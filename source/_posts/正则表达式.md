---
title: 正则表达式
date: 2020-04-12 18:57:32
categories: 
- 常用知识笔记
---



## 正则表达式

### 元字符

**请注意:元字符就只是一个字符而已,代表的字符含义不确定而已**

- **"^"** ：^会匹配行或者字符串的==起始位置==，有时还会匹配整个文档的==起始位置。==
- **"$"** ：$会匹配行或字符串的==结尾==, 例如 `\d$` , 匹配以数字结尾的字符串
-  **"\d"**: 匹配==数字==，
- **"."**：匹配**除了换行符(\n)以外**的任何字符 ==(相当于 \w和 \s的结合)==
- **"\w"**：匹配字母，数字，下划线(==即大多数语言的标识符合法规则==).
- **"\s"**：匹配==空格(space)== 
- **"[abc]"**: 字符组  ==匹配包含括号内元素的字符==, 还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了，
- **“\b”**: 代表==单词边界的意思==, 例如`en\b`代表匹配单词末尾的“en” , `\ben`代表匹配单词开头的“en”字符



### 反义

写法很简单改成大写就行了，意思与原来的相反，这里就不举例子了

 "**\W**”  匹配任意不是字母，数字，下划线 的字符

  **"\S"**  匹配任意不是空白符的字符

　**"\D"** 匹配任意非数字的字符

  **"\B"** 匹配不是单词开头或结束的位置

“ **[\^abc\]** “ 匹配除了abc以外的任意字符



### 量词

#### 量词符号

 **"\*"(贪婪)**  重复零次或更多  ==(0到无穷未知个)==

　　　  例如"aaaaaaaa" 匹配字符串中所有的a  正则： "a*"  会出到所有的字符"a"

   **"+"(懒惰)**  重复一次或更多次  ==(1到无穷未知个)==

　　   例如"aaaaaaaa" 匹配字符串中所有的a  正则： "a+"  会取到字符中所有的a字符，  **"a+"与"a\**"不同在于"a+"至少是一次而"a*\*" 可以是0次，**

   **"?"(占有)**  重复零次或一次 ==(只有0或1个)==

　　   例如"aaaaaaaa" 匹配字符串中的a 正则 ： "a?" 只会匹配一次，也就是结果只是单个字符a

　  **"{n}"** 重复n次  ==(出现n次, 次数是明确的)==

　　   例如从"aaaaaaaa" 匹配字符串的a 并重复3次 正则：  "a{3}"  结果就是取到3个a字符  "aaa";

　  **"{n,m}"** 重复n到m次   ==(出现n-m次,次数是明确的)==

　　   例如正则 "a{3,4}" 将a重复匹配3次或者4次 所以供匹配的字符可以是三个"aaa"也可以是四个"aaaa" 正则都可以匹配到

   **"{n,}"** 重复n次或更多次

 　   **与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则"a{3,}" a至少要重复3次**

例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123 而通常只能是3位或者4位，

正则: "^0\d{2,3}-\d{7}"



####  **懒惰限定符**

先解释关于量词所涉及到的重要的三个概念

-   贪婪(贪心) 如"*"字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定**尽可能多的内容，如果 失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。**相比下面两种贪婪量词对资源的消耗是最大的，


-   懒惰(勉强) 如 "?"  懒惰量词使用另一种方式匹配，它从**目标的起始位置开始尝试匹配，每次检查一个字符，**并寻找它要匹配的内容，如此循环直到字符结尾处。


-   占有  如"+" 占有量词会覆盖事个目标字符串，然后尝试寻找匹配内容 ，但**它只尝试一次，不会回溯，**就好比先抓一把石头，然后从石头中挑出黄金


------

　　**"\*?"**  重复任意次，但**尽可能少重复** 

　　   如 "acbacb"  正则  "a.*?b" 只会取到第一个"acb" 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而"acbacb"最少字符的结果就是"acb" 

　　**"+?"** 重复1次或更多次，但**尽可能少重复**

　　  与上面一样，只是至少要重复1次

　　**"??"** 重复0次或1次，但**尽可能少重复**

　　   如 "aaacb" 正则 "a.??b" 只会取到最后的三个字符"acb"

　　**"{n,m}?"** 重复n到m次，但**尽可能少重复**

​     如 "aaaaaaaa"  正则 "a{0,m}" 因为最少是0次所以取到结果为空

　　**"{n,}?"**   重复n次以上，但尽可能少重复

​     如 "aaaaaaa"  正则 "a{1,}" 最少是1次所以取到结果为 "a"

------



### 分组匹配

正则表达式可以**通过`()`和`|`配合可以进行分组和优先运算以及组内或逻辑运算**, 例如:匹配日期:

```sh
str_date = "\d{4}-(0[1-9]|1[0-2])-([0-2]\d|[3][0-1])"
```



### 分组调用与别名引用

正则表达式可以`\分组索引分组值`来引用分组实现复用分组  **注: 索引值以1 开始** 

```python
str = r"<title>This is python3</title>"  #需要匹配的字符串
regex = r"<(\w+)>([\w\W]*)</\1>"     #其中的 \1 代表引用了第一个分组 (\w+)
```

还可以通过`(?P<分组名>)`给分组起别名, 通过别名引用分组`(?P=分组名)` 

```python
str = r"<title>This is python3</title>"  
regex = r"<(?P<tag>\w+)>([\w\W]*)</(?P=tag)>"   
```





## 常用的字符串处理函数(java)

#### 获得位置:

-  **int indexOf(int ch)**:返回的是ch在字符串中第一次出现的位置。不存在返回 -1
- **int indexOf(int ch,int fromIndex):**从fromIndex指定位置开始，获取ch在字符串中出现的位置。
- int indexOf(String str):返回的是str在字符串中第一次出现的位置。
-  int indexOf(String str，int fromIndex):从fromIndex指定位置开始，获取str在字符串中出现的位置。

#### 替换

-  **String replace(oldchar,newchar);**

#### 分割

-  **String[] split(regex);**    regex可以是正则表达式

#### 截取

-  **String subString(int begin);**  
-  **String subString(int begin,int end)**    //begin,end都是实际的位置坐标((从0开始),**到end结束不包括end,也可以将end理解为从begin开始截取多少个字符**

#### 去两端的空格

-  **String trim()**



