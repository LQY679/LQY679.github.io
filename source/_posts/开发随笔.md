---
title: 开发随笔
date: 2020-01-01 08:00:00
updated: {{date}}
categories:
  - 踩坑记录
---

# 关于mysql存储时间类型数据只精确到秒

最近在对自己编写的接口进行单元测试时, 发现一个问题: 

**将Java的Date对象存入mysql时, 在通过Data对象来查询,发现查询不到!**

代码如下:  

实体类结构

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    public static final String BeIng = "Be_Ing";
    public static final String WaitPay = "Wait_Pay";
    public static final String Finished = "Finished";
    public static final String Close = "Close";

//    订单编号, 由用户id,车辆编号和时间戳三者用 - 连接
    private String order_id;
//    第三方交易号
    private String trade_no;
//   交易类型
    private String trade_type;
    private double amount;
    private String order_status;
    private Date start_time;
    private Date end_time;
}
```

通过如下方法进行插入数据:

```java
	@Autowired
    OrderMapper orderMapper;
    @Test
    public void testAdd(){
        for (int i=1; i<5; i++){
            Date date = new Date();
            String s = "" + i;
            Order order = new Order(
                    "u100"+s+"-b100"+s+"-"+date.getTime(),
                    "888888",
                    Order.AliPay,
                    0,
                    Order.BeIng,
                    date,
                    date
            );
            orderMapper.addOrder(order);
        }
    }
```

上述方法向数据库中插入数据, `order_id`同时也记录了时间戳信息, **注意: `order_id`后缀的时间戳,是和`start_time`表示的时间对应的时间戳应该是一致的** 这时我尝试测试根据`start_time`查询数据

```java
@Test
    public void test_getOrderByStart_time(){
        // 参数的时间戳 是我从数据表中找了一个 order_id后缀的时间戳
        List<Order> list = orderMapper.getOrderByStart_time(new Date(1677138162002L));
        if (list.isEmpty()){
            System.err.println("查询为空!!!");
        }
        else {
            for (Order order : list) {
                System.out.println(order);
            }
        }
    }
```

**运行之后发现居然查询不到**, 这让我表示很困惑, 明明是一样的时间戳存入的时间类型数据, 居然找不到

## 解决与总结:

后来我询问老师, 经过讲解后知道 **mysql在存入时间类型数据时,只会精确到秒(时间戳是按毫秒算的)**



## 实践检验

我们尝试通过`order_id`来查询到该数据的`start_time`,并将其转换成时间戳来与`order_id`后缀时间戳来进行对比

```java
@Test
    public void test_getOrderByOrder_id(){
        System.out.println(orderMapper.getOrderByOrder_id("u1001-b1001-1677138162002").getStart_time().getTime());
    }
```

运行后发现打印结果为:

```sh
1677138162000
```

**果然,后面全是0,说明是将毫秒数去除了,只会将时间精确到秒**





# Maven模块引入依赖问题

## 被引入模块的依赖没有传递引入

**问题描述: ** 在模块`heima-leadnews-article`中引入了另一个模块`heima-file-starter`, 但是`heima-file-starter`的依赖项没有引入到模块 `heima-leadnews-article`中如图所示: 

![image-20230909222713242](%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/image-20230909222713242.png)

**解决方案: **

**将该模块使用maven插件install一下或者使用maven命令`mvn install` 进行安装打包**

 解释: 在**新创建一个模块并且需要将该模块引入到其他模块时, 需要进行一次install 打包**



## 被引入模块的Bean无法注入

**问题描述:**在引入模块`heima-file-starter`后, 需要注入该模块的Bean进行使用, 发现报错:

*org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'com.heima.article.test.ArticleFreemarkerTest': Unsatisfied dependency expressed through field 'fileStorageService'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.heima.file.service.FileStorageService' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}*

如图: 

![image-20230909224344473](%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/image-20230909224344473.png)

**解决方案: **

将`heima-file-starter`模块的`pom.xml`文件打包方式进行修改: 

```xml
<!--    使用pom打包方式会导致bean无法注入, 不写默认是jar方式进行打包-->
<!--    <packaging>pom</packaging>-->
```

**解释 来自文心一言AI模型:** 

> `<packaging>pom</packaging>`指定了项目的打包类型为"pom"。**这种打包类型通常用于父项目或继承项目**，它不会构建实际的Java应用程序，而是提供了一组依赖项和插件的声明，供其他项目继承和使用。**

由于POM打包方式不会构建Java程序创建SpringBoot环境, 所以无法将该模块的Bean进行注入

