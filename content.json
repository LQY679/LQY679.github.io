{"meta":{"title":"南城记录倌","subtitle":"往昔皆为过眼云烟,一切尽随风而逝;此刻之行终将化未来的救赎之刃","description":"清醒,知趣 明得失,知进退","author":"Luo Qianyou","url":"https://lqy679.github.io","root":"/"},"pages":[{"title":"标签","date":"2020-04-12T10:20:21.000Z","updated":"2023-02-14T03:54:21.349Z","comments":false,"path":"tags/index.html","permalink":"https://lqy679.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-12T10:23:16.000Z","updated":"2023-02-14T03:56:08.396Z","comments":false,"path":"about/index.html","permalink":"https://lqy679.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-02-14T10:20:14.000Z","updated":"2023-02-14T03:53:53.379Z","comments":false,"path":"categories/index.html","permalink":"https://lqy679.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo搭配github白嫖域名搭建md个人博客","slug":"hexo搭配github白嫖域名搭建md个人博客","date":"2020-01-02T10:57:32.000Z","updated":"2023-02-22T07:03:31.396Z","comments":true,"path":"2020/01/02/hexo搭配github白嫖域名搭建md个人博客/","link":"","permalink":"https://lqy679.github.io/2020/01/02/hexo%E6%90%AD%E9%85%8Dgithub%E7%99%BD%E5%AB%96%E5%9F%9F%E5%90%8D%E6%90%AD%E5%BB%BAmd%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"hexo搭配github白嫖域名搭建md个人博客前置环境: git, node,更多具体参考Hexo官方文档, 有一个GitHub账号 Hexo建站,本地部署 参考官方文档快速上手:文档 | Hexo","text":"hexo搭配github白嫖域名搭建md个人博客前置环境: git, node,更多具体参考Hexo官方文档, 有一个GitHub账号 Hexo建站,本地部署 参考官方文档快速上手:文档 | Hexo 想要快速上述可以参考这篇文章搭配官方文档食用,第一次使用Hexo搭建个人博客网站 - 简书 (jianshu.com), 根据自己的理解简单讲一下Hexo是什么, 这就是一个能够快速搭建博客的框架, 他可以把md文件(也就是markdown文件,一般我们写笔记都是用这个的) 转换成一个博客网站, 原理呢也很好理解, 就是把md文件解析转换成html+ css + js然后生成一个博客网站 也就是说Hexo会把你放在source目录的东西(例如图片,md文档等),解析打包到public目录下生成一个只含html css js的网站 ==特别说明: 有关hexo的命令无特殊情况都需要在站点的根目录下执行,否则无法生效== 然后想记录一下自己遇到的几个坑和问题: 图片无法加载这里我的解决办法是设置Hexo的这个配置项: 12# _config.ymlpost_asset_folder: true 然后还有一点要注意: 我们可以命令hexo new 文章名 来创建一篇文章,也可以直接把md文件复制粘贴到博客根目录\\source\\_posts目录下, 这样都可以创建文章,但是请注意: 如果你的文章名是带有中文的最好使用命令来创建一个和你想要创建的文件重名的,然后再把md文件复制过去覆盖掉用命令创建的文件 ,反正我这样亲测可用,但是还有一个问题就是: 即使是这样,首页展示的文章依旧无法加载图片(点击阅读更多进去还是正常显示没问题) 通过插件解决参考: 自动生成文章摘要很多主题可以设置主页不展示整篇文章,而是展示很多文章,每篇文章只显示部分内容(比如摘要), 然后有个阅读阅读更多的功能 ,这种方式非常美观 例如Next主题, 相关设置文档在这里:Post Settings | NexT (theme-next.js.org) 因为我呢是有很多现成的md笔记的,但是我没有摘要的习惯, 但我又希望主页能够美观一点,就想着能不能根据文章开头自动生成摘要呢, 果然办法还是有的, 这里是原文: 解决Hexo博客的Next主题中阅读全文没有auto_excerpt的问题-阿里云开发者社区 (aliyun.com) 安装: npm install hexo-excerpt --save 在站点根目录的配置文件_config.yml添加配置: 12345excerpt: depth: 5 excerpt_excludes: [] more_excludes: [] hideWholePostExcerpts: true 常用命令:部署与调试启动服务,进行调试 1hexo server 这个是在本地启动服务器, 可以通过http://localhost:4000来访问hexo帮你生成的网站,这个命令一般是用来预览和调试效果,据官方文档所说这个是热启动 官网原话: Hexo 会监视文件变动并自动更新，您无须重启服务器。,但是有时候发现自己修改配置文件后发现自己没错确实又没效果可以尝试重启试试 打包, 部署 1hexo g -d 这个是简写形式,这个命令主要用于后面讲的github pages 一键部署, 这个命令会检测所有文件, 发现有修改就会重新打包source目录重新生成public文件, 如果修改一些配置后发现没效果也可以试试这个命令 设置主题(看个人喜好)主题的设置参考主题的官方文档即可, 根据自己喜欢进行相应设置, 也可以去找别的主题 : Hexo主题中心 Next主题官方文档 github pages 上线发布github pages 是github为我们的仓库提供了一个可以部署静态网站的功能,并且还能白嫖一个三级域名:用户名.github.io例如我的个人博客: https://lqy679.github.io/ , lqy679就是github的用户名 github设置 参考文章: 使用 GitHub Pages 搭建个人博客 - tfel-ypoc - 博客园 (cnblogs.com) 首先你要创建一个 GitHub 仓库, 仓库名应为: &lt;当前github用户名&gt;.github.io 仓库的可见性, 官方文档没做说明, 所以我选择了默认的 Public 注: 每个用户只能有一个名为&lt;当前github用户名&gt;.github.io的仓库,因为我们只能白嫖一个域名 创建完毕后别忘了进行仓库设置,打开pages功能 配置一键部署 参考: 部署 | Hexo 然后在Hexo站点目录执行: 12# 安装 hexo git 一键部署插件npm install hexo-deployer-git --save 编辑Hexo的配置文件,修改如下配置 1234567891011deploy:#### type: git, 使用git部署固定该值# repo: 填入你的博客仓库地址, 就是之前提到的 &lt;当前github用户名&gt;.github.io# branch: 指定部署用的分支, 你可以不用 GitHub 上的 main 或者 master 分支来部署, 自行建立一个分支用于博客# message: 可选项, 它用来在部署时自动填上 git 的 commit 备注### type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 最后,执行如下命令一键部署! 1hexo g -d 插件本人博客用到的比较复杂的插件如下, 还有一些用到插件,例如搜素功能,但是在Next主题的官方文档中已经写得很清楚了就不再赘述 看板娘(卡哇伊小人)通过我的不断探索,最终找到了两种设置看板娘的方法如下: 建议只选择一种即可,尽量不要两种都使用避免冲突 看板娘 Live 2D插件(配置简单) 插件官方文档-项目地址, live2d-widget源项目地址 安装安装模块: npm install --save hexo-helper-live2d 配置在Hexo的 _config.yml 文件或主题的 _config.yml 文件中添加配置.更多配置请参考官方文档 123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true react: opacity: 0.7 下载并配置模型使用 npm install 模型的包名 来安装,然后修改之前添加的配置文件将包名输入位于 _config.yml 的 model.use 中. 保存后重新运行部署即可生效 现有的模型: live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru) live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru) live2d-widget-model-haruto live2d-widget-model-hibiki live2d-widget-model-hijiki live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzsche live2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 看板娘模型预览Live 2D所有模型展示图，看板娘图形合集 - 腾讯云开发者社区-腾讯云 (tencent.com) 会动的看板娘 (交互性强) 参考: 给你的hexo添加live2D看板娘 - 知乎 (zhihu.com) 上述的使用官方插件中心的看板娘没有交互性,使用参考文章配置的可以个性化设置看板娘 注意一下, 如果你的主题是用npm下载的, 那么主题文件夹将不会在/themes/下,而是位于/node_modules/hexo-thems-主题名的目录下,自己适当替换一下参考文章中的目录, 1.下载:下载 stevenjoezhang的项目，解压到本地博客目录的主题文件夹/source下，修改文件夹名为 live2d-widget（部署时记得把li ve2d-widget目录的.git删了），修改项目中的 autoload.js 文件: 12// const live2d_path = &quot;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/&quot;;const live2d_path = &quot;/live2d-widget/&quot;; 注: 如果你的hexo加了URL前缀，就将前缀加入live2d_path 2.修改api (被墙一定要修改)同样是修改autoload.js文件,替换修改一下注释即可, 123456initWidget(&#123; waifuPath: live2d_path + &quot;waifu-tips.json&quot;, // apiPath: &quot;https://live2d.fghrsh.net/api/&quot;, // 被墙 apiPath: &quot;https://api.zsq.im/live2d&quot;, // 需要国内方位请使用这个配置 // cdnPath: &quot;https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/&quot;, // 被墙&#125;); 3.引入:每个主题引入不一样，具体请查询自己的主题文档，我用的是Next主题: 在主题文件夹/layout/_layout.njk文件,这其实是一个布局好的html文件, 引入一下js 1&lt;script src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 4.启用Linve 2D在**博客根目录的_config.yml**或者主题根目录的_config.主题名.yml添加如下: 12live2d: enable: true 更多配置:参考stevenjoezhang的仓库阅读REAME.md文件有详细的配置项 , 传送门 非Next主题或没有主题怎么使用这里简述一下我的认为可行的解决方案: 将上述步骤中有关主题文件夹的操作,替换到博客根目录即可, 因为主题是基于Hexo结构拓展开发的,例如 直接下载到博客根目录的source, 引入操作在博客根目录的布局文件都是一样的 Meting-JS 音乐播放器 项目地址: metowolf/MetingJS: A powerful plugin connect APlayer and Meting (github.com) 由于Hexo插件中心的插件是通过文章内容插件标签来使用的, 无法全局使用,所以这里我采用了全局脚本生成, 通过Hexo配置的注入器实现 首先: 在Hexo的工作目录(也就是站点目录)下, 新建script目录, 随后在此目录新建js文件Meting.js内容如下: 设置播放器生效页面如果不想让播放器在每个页面都生效, 请参考注入器（Injector） | Hexo , 自定进行相应的修改 123456789101112131415161718192021222324252627282930const css = hexo.extend.helper.get(&#x27;css&#x27;).bind(hexo);const js = hexo.extend.helper.get(&#x27;js&#x27;).bind(hexo);hexo.extend.injector.register(&#x27;head_end&#x27;, () =&gt; &#123; return css(&#x27;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&#x27;);&#125;, &#x27;default&#x27;);hexo.extend.injector.register(&#x27;body_end&#x27;, js(&#x27;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&#x27;), &#x27;default&#x27;);hexo.extend.injector.register(&#x27;body_end&#x27;, js(&#x27;https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js&#x27;), &#x27;default&#x27;);hexo.extend.injector.register(&#x27;body_end&#x27;,()=&gt;&#123; str = &#x27;&lt;meting-js &#x27;+ &#x27;server=&quot;tencent&quot; &#x27;+ &#x27;type=&quot;playlist&quot; &#x27;+ &#x27;id=&quot;8388941837&quot; &#x27;+ &#x27;fixed=&quot;true&quot; &#x27;+ &#x27;autoplay=&quot;false&quot; &#x27;+ &#x27;loop=&quot;all&quot; &#x27;+ &#x27;order=&quot;list&quot; &#x27;+ &#x27;list-folded=&quot;ture&quot; &#x27;+ &#x27;list-max-height=&quot;500px&quot; &#x27;+ &#x27;&gt;&#x27; console.log(str); return str&#125;, &#x27;default&#x27;); 播放器参数设置上述代码就是在每个页面加载完毕后, 添加如下的dom元素, 播放器是依靠引入这些元素实现的,如果需要修改播放器相关参数请参考如下表所示, 或者官方文档: metowolf/MetingJS: A powerful plugin connect APlayer and Meting (github.com), 对Meting.js文件15行的str变量做相应的修改 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启迷你模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto theme #ad7a86 播放器风格色彩设置 12345678910111213141516&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;meting-js server=&quot;tencent&quot; type=&quot;playlist&quot; id=&quot;8388941837&quot; fixed=&quot;true&quot; autoplay=&quot;false&quot; loop=&quot;all&quot; order=&quot;list&quot; list-folded=&quot;ture&quot; list-max-height=&quot;500px&quot;&gt;&lt;/meting-js&gt; 网站连通本地笔记预览:解决图片本地或线上无法显示 参考自: Hexo 图片插入无法显示的问题 - 知乎 (zhihu.com) 上文已经解决了大部分问题, 但是还有一个小问题还有待改进, 就是图片无法实现在本地编辑器和生成的网站同时显示图片,这是因为Hexo解析生成网站路径的原因,参考自知乎大佬的文章,记录一下解决方案: 设置开启资源文件夹首先,修改一下Hexo的配置文件,开启资源文件夹,官方文档具体描述: 资源文件夹 | Hexo _config.yml文件, 修改为如下所示 1post_asset_folder: true 下载插件:进入你博客的根目录, 或者使用命令行切换到博客根目录, 执行npm install hexo-asset-image --save 下载失败尝试用管理员身份, ==注意!!! 由于这个插件年久失修,所以需要修改一下源码:== 进入你博客的根目录，然后下面顺序找到index.js:node_modules –&gt; hexo-asset-image –&gt; index.js 用VS Code 或者 记事本打开 index.js 在第 58 行，可以找到这么一行代码： 1$(this).attr(&#x27;src&#x27;, config.root + link + src); 修改为: 1$(this).attr(&#x27;src&#x27;, src); 至此,配置相关的工作就算是做完了 图片路径怎么写?由于我们设置了资源文件夹配置, post_asset_folder: true , 所以在文章的存放目录下会有和你md文件重名的文件夹, 我们在那个文件夹下放图片即可, 当然,我们在写md的时候一般都会用一些比较只能的编辑器比如typora , 下面我就以这个软件举例: typora进行图片粘贴设置打开typora的偏好设置 (快捷键: ctrl + 逗号) 这样, 我们就可以在typora中直接ctrl + v 直接粘贴图片,而且会把图片自动存储到与md文件同名的文件夹中 至此,问题完全解决,即可在typora上看到图片,发布到网站上的笔记又不会导致网页笔记图片丢失","categories":[{"name":"时记杂谈","slug":"时记杂谈","permalink":"https://lqy679.github.io/categories/%E6%97%B6%E8%AE%B0%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"MyBatis-Plus","slug":"mybatis-puls","date":"2020-01-02T10:57:32.000Z","updated":"2023-05-05T06:53:41.187Z","comments":true,"path":"2020/01/02/mybatis-puls/","link":"","permalink":"https://lqy679.github.io/2020/01/02/mybatis-puls/","excerpt":"MyBatis-PlusMyBatis-Plus简介注: 本文是在SpringBoot中演示使用Mybatis-Puls 1 、简介","text":"MyBatis-PlusMyBatis-Plus简介注: 本文是在SpringBoot中演示使用Mybatis-Puls 1 、简介MyBatis-Plus （简称 MP）是一个 MyBatis的增强工具 ，在 MyBatis 的基础上 只做增强不做改变 ，为简化开发、提高效率而生 。 2 、特性 无侵入 ：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小 ：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作 ：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用 ：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成 ：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由 配置，完美解决主键问题 支持 ActiveRecord 模式 ：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强 大的 CRUD 操作 支持自定义全局通用操作 ：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器 ：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件 ：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等 同于普通 List 查询 分页插件支持多种数据库 ：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、 Postgre、SQLServer 等多种数据库 内置性能分析插件 ：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件 ：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 3 、支持数据库任何能使用MyBatis进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下 MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb 达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库 4 、代码及文档地址 官方地址: http://mp.baomidou.com 代码发布地址: Github: https://github.com/baomidou/mybatis-plus Gitee: https://gitee.com/baomidou/mybatis-plus 文档发布地址: https://baomidou.com/pages/24112f 入门案例依赖: 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 在application.yaml中配置好JDBC连接信息 a&gt;创建表 123456789CREATE DATABASE `mybatis_plus` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;use `mybatis_plus`;CREATE TABLE `user` (`id` bigint(20) NOT NULL COMMENT &#x27;主键ID&#x27;,`name` varchar(30) DEFAULT NULL COMMENT &#x27;姓名&#x27;,`age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;,`email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; b&gt;添加数据 123456INSERT INTO user (id, name, age, email) VALUES(1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;),(2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;),(3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;),(4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;),(5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;); c&gt;添加实体 1234567@Data //lombok注解public class User &#123; private Long id; private String name; private Integer age; private String email;&#125; d&gt;添加mapper BaseMapper是MyBatis-Plus提供的模板mapper，其中包含了基本的CRUD方法，泛型为操作的 实体类型 123public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; e&gt;测试 1234567891011@SpringBootTestpublic class MybatisPlusTest &#123; @Autowired private UserMapper userMapper; @Test public void testSelectList()&#123; //selectList()根据MP内置的条件构造器查询一个list集合，null表示没有条件，即查询所有 userMapper.selectList(null).forEach(System.out::println); &#125;&#125; 显示日志与关闭在application.yml中配置mp的sql执行日志 1234## 配置MyBatis日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl tips: 再开发测试时,还可以将Mybatis和SpringBoot的banner以及debug日志关闭, 避免影响干扰结果: 在application.yaml中: 123456mybatis-plus: banner: false spring: main: banner-mode: off 基本CRUD1 、BaseMapperMyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，我们可以直接使用，通过观察BaseMapper中的方法，大多方法中都有Wrapper类型的形参，此为条件构造器，可针 对于SQL语句设置不同的条件，若没有条件，则可以为该形参赋值null，即查询（删除/修改）所有, 数据接口如 下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt; &#123; /*** 插入一条记录* @param entity 实体对象*/ int insert(T entity);/*** 根据 ID 删除* @param id 主键ID*/ int deleteById(Serializable id); /*** 根据 columnMap 条件，删除记录* @param columnMap 表字段 map 对象*/ int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); /*** 根据 entity 条件，删除记录* @param queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where语句）*/ int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /*** 删除（根据ID 批量删除）* @param idList 主键ID列表(不能为 null 以及 empty)*/ int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); /*** 根据 ID 修改* @param entity 实体对象*/int updateById(@Param(Constants.ENTITY) T entity); /*** 根据 whereEntity 条件，更新记录* @param entity 实体对象 (set 条件值,可以为 null)* @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成where 语句）*/int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER)Wrapper&lt;T&gt; updateWrapper); /*** 根据 ID 查询* @param id 主键ID*/T selectById(Serializable id); /*** 查询（根据ID 批量查询）* @param idList 主键ID列表(不能为 null 以及 empty)*/List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); /*** 查询（根据 columnMap 条件）* @param columnMap 表字段 map 对象*/List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt;columnMap);/* 根据 entity 条件，查询一条记录* 查询一条记录，例如 qw.last(&quot;limit 1&quot;) 限制取一条记录, 注意：多条数据会报异常* @param queryWrapper 实体对象封装操作类（可以为 null）*/default T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper) &#123; List&lt;T&gt; ts = this.selectList(queryWrapper); if (CollectionUtils.isNotEmpty(ts)) &#123; if (ts.size() != 1) &#123; throw ExceptionUtils.mpe(&quot;One record is expected, but the query result is multiple records&quot;); &#125; return ts.get(0); &#125; return null;&#125; /*** 根据 Wrapper 条件，查询总记录数* @param queryWrapper 实体对象封装操作类（可以为 null）*/Long selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /*** 根据 entity 条件，查询全部记录* @param queryWrapper 实体对象封装操作类（可以为 null）*/List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /*** 根据 Wrapper 条件，查询全部记录* @param queryWrapper 实体对象封装操作类（可以为 null）*/List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER), Wrapper&lt;T&gt;queryWrapper); /*** 根据 Wrapper 条件，查询全部记录* &lt;p&gt;注意： 只返回第一个字段的值&lt;/p&gt;* @param queryWrapper 实体对象封装操作类（可以为 null）*/List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /*** 根据 entity 条件，查询全部记录（并翻页）* @param page 分页查询条件（可以为 RowBounds.DEFAULT）* @param queryWrapper 实体对象封装操作类（可以为 null）*/&lt;P extends IPage&lt;T&gt;&gt; P selectPage(P page, @Param(Constants.WRAPPER)Wrapper&lt;T&gt; queryWrapper); /*** 根据 Wrapper 条件，查询全部记录（并翻页）* @param page 分页查询条件* @param queryWrapper 实体对象封装操作类*/&lt;P extends IPage&lt;Map&lt;String, Object&gt;&gt;&gt; P selectMapsPage(P page,@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); 2、插入12345678910@Testpublic void testInsert()&#123;User user = new User(null, &quot;张三&quot;, 23, &quot;zhangsan@atguigu.com&quot;);//INSERT INTO user ( id, name, age, email ) VALUES ( ?, ?, ?, ? ) int result = userMapper.insert(user); System.out.println(&quot;受影响行数：&quot;+result); //1475754982694199298 System.out.println(&quot;id自动获取：&quot;+user.getId());&#125; 最终执行的结果，所获取的id为1475754982694199298, 这是因为MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id 3、删除通过id删除记录 1234567@Testpublic void testDeleteById()&#123;//通过id删除用户信息//DELETE FROM user WHERE id=? int result = userMapper.deleteById(1475754982694199298L); System.out.println(&quot;受影响行数：&quot;+result);&#125; 通过id批量删除记录 12345678@Testpublic void testDeleteBatchIds()&#123;//通过多个id批量删除//DELETE FROM user WHERE id IN ( ? , ? , ? ) List&lt;Long&gt; idList = Arrays.asList(1L, 2L, 3L); int result = userMapper.deleteBatchIds(idList); System.out.println(&quot;受影响行数：&quot;+result);&#125; 通过map条件删除记录 12345678910@Testpublic void testDeleteByMap()&#123;//根据map集合中所设置的条件删除记录//DELETE FROM user WHERE name = ? AND age = ? Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;age&quot;, 23); map.put(&quot;name&quot;, &quot;张三&quot;); int result = userMapper.deleteByMap(map); System.out.println(&quot;受影响行数：&quot;+result);&#125; 4、修改1234567@Testpublic void testUpdateById()&#123;User user = new User(4L, &quot;admin&quot;, 22, null);//UPDATE user SET name=?, age=? WHERE id=? int result = userMapper.updateById(user); System.out.println(&quot;受影响行数：&quot;+result);&#125; 5、查询根据id查询用户信息 1234567@Testpublic void testSelectById()&#123;//根据id查询用户信息//SELECT id,name,age,email FROM user WHERE id=? User user = userMapper.selectById(4L); System.out.println(user);&#125; 根据多个id查询多个用户信息 12345678@Testpublic void testSelectBatchIds()&#123;//根据多个id查询多个用户信息//SELECT id,name,age,email FROM user WHERE id IN ( ? , ? ) List&lt;Long&gt; idList = Arrays.asList(4L, 5L); List&lt;User&gt; list = userMapper.selectBatchIds(idList); list.forEach(System.out::println);&#125; 通过map条件查询用户信息 12345678910@Testpublic void testSelectByMap()&#123;//通过map条件查询用户信息//SELECT id,name,age,email FROM user WHERE name = ? AND age = ?Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;age&quot;, 22);map.put(&quot;name&quot;, &quot;admin&quot;);List&lt;User&gt; list = userMapper.selectByMap(map);list.forEach(System.out::println);&#125; 查询所有数据 1234567@Testpublic void testSelectList()&#123;//查询所有用户信息//SELECT id,name,age,email FROM user List&lt;User&gt; list = userMapper.selectList(null); list.forEach(System.out::println);&#125; 6、通用Service通用 Service CRUD 封装Service接口，进一步封装 CRUD 采用 get 查询单行 remove 删除 list 查询集合 page 分页 前缀命名方式区分 Mapper 层避免混淆 泛型 T 为任意实体对象 建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类 api细节请参考官网: CRUD 接口 | MyBatis-Plus (baomidou.com) IServiceMyBatis-Plus中有一个接口 IService和其实现类 ServiceImpl，封装了常见的业务层逻辑 创建Service接口 12345/*** UserService继承IService模板提供的基础功能*/public interface UserService extends IService&lt;User&gt; &#123;&#125; Service实现类 1234567/*** ServiceImpl实现了IService，提供了IService中基础功能的实现* 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现*/@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;&#125; 测试实例:测试查询记录数 1234567@Autowiredprivate UserService userService;@Testpublic void testGetCount()&#123; long count = userService.count(); System.out.println(&quot;总记录数：&quot; + count);&#125; 测试批量插入 1234567891011121314151617@Autowiredprivate UserService userService;@Testpublic void testSaveBatch()&#123;// SQL长度有限制，海量数据插入单条SQL无法实行，// 因此MP将批量插入放在了通用Service中实现，而不是通用Mapper ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; User user = new User(); user.setName(&quot;ybc&quot; + i); user.setAge(20 + i); users.add(user); &#125;//SQL:INSERT INTO t_user ( username, age ) VALUES ( ?, ? ) userService.saveBatch(users);&#125; 常用注解1 、@TableName此注解主要是用来解决实体类与数据库的数据表名称不一致的情况, 通过在实体类上加上该注解即可解决该问题 1234@TableName(&quot;t_user&quot;)public class User&#123; ....&#125; 此外,如果数据表有规定的前缀, 我们还可以通过配置文件applcation.yaml设置数据表的全局前缀: 12345678mybatis-plus: configuration: ## 配置MyBatis日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: ## 配置MyBatis-Plus操作表的默认前缀 table-prefix: t_ 2、@TableIdMyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id, 若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus不会自动识别uid为主键, 我们可以通过在实体类中uid属性上通过@TableId将其标为主键解决该问题 实体类主属性名与数据表主键字段名不一致解决方案: 若实体类中主键对应的属性为id，而表中表示主键的字段为uid，此时若只在属性id上添加注解 @TableId，则抛出异常Unknown column ‘id’ in ‘field list’，即MyBatis-Plus仍然会将id作为表的 主键操作，而表中表示主键的是字段uid 此时需要通过@TableId注解的value属性，指定表中的主键字段，@TableId(“uid”)或 @TableId(value=”uid”) 主键策略:@TableId的type属性用来定义主键策略: 值 描述 IdType.ASSIGN_ID（默 认） 基于雪花算法的策略生成数据id，与数据库id是否设置自增无关 IdType.AUTO 使用数据库的自增策略，注意，该类型请确保数据库设置了id自增， 否则无效 此外,还可以通过配置文件application.yaml全局配置主键策略: 12345678910mybatis-plus: configuration:## 配置MyBatis日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config:## 配置MyBatis-Plus操作表的默认前缀 table-prefix: t_## 配置MyBatis-Plus的主键策略为自增 id-type: auto ######## 拓展-雪花算法: 需要选择合适的方案去应对数据规模的增长，以应对逐渐增长的访问压力和数据量。 数据库的扩展方式主要包括：业务分库、主从复制，数据库分表。 数据库分表: 将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据， 如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进 行拆分。 单表数据拆分有两种方式：垂直分表和水平分表。示意图如下： 垂直分表 垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。例如，前面示意图中的 nickname 和 description 字段，假设我们是一个婚恋网站，用户在筛选其他用户的时候，主要是用 age 和 sex 两个字段进行查询，而 nickname 和 description 两个字段主要用于展示，一般不会在业务查询中用到。description 本身又比较长，因此我们可以将这两个字段独立到另外 一张表中，这样在查询 age 和 sex 时，就能带来一定的性能提升。 水平分表 水平分表适合表行数特别大的表，有的公司要求单表行数超过 5000 万就必须进行分表，这个数字可以作为参考，但并不是绝对标准，关键还是要看表的访问性能。对于一些比较复杂的表，可能超过 1000 万就要分表了；而对于一些简单的表，即使存储数据超过 1 亿行，也可以不分表。 但不管怎样，当看到表的数据量达到千万级别时，作为架构师就要警觉起来，因为这很可能是架构的性能瓶颈或者隐患。 水平分表相比垂直分表，会引入更多的复杂性，例如要求全局唯一的数据id该如何处理, 如下是一些常见的处理策略: 主键自增 ①以最常见的用户 ID 为例，可以按照 1000000 的范围大小进行分段，1 ~ 999999 放到表 1中， 1000000 ~ 1999999 放到表2中，以此类推。 ②复杂点：分段大小的选取。分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会 导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适 的分段大小。 ③优点：可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万， 只需要增加新的表就可以了，原有的数据不需要动。 ④缺点：分布不均匀。假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1 条，而 另外一个分段实际存储的数据量有 1000 万条。 取模 ①同样以用户 ID 为例，假如我们一开始就规划了 10 个数据库表，可以简单地用 user_id % 10 的值来 表示数据所属的数据库表编号，ID 为 985 的用户放到编号为 5 的子表中，ID 为 10086 的用户放到编号 为 6 的子表中。 ②复杂点：初始表数量的确定。表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。 ③优点：表分布比较均匀。 ④缺点：扩充新的表很麻烦，所有数据都要重分布。 雪花算法 雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的 主键的有序性。 ①核心思想： 长度共64bit（一个long型）。首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负 数是1，所以id一般是正数，最高位是0。41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。 10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。 12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。 ②优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。 3、@TableField若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格 例如实体类属性userName，表中字段user_name 此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格 相当于在MyBatis中配置进行了大驼峰转下划线配置, 但如果实体类属性与数据表字段名无法进行大驼峰转下划线映射时, 就需要通过在实体类字段上添加@TableField(&quot;数据库字段名&quot;)来解决映射字段名不一致的问题, 例如: 实体类属性name，表中字段username 12345678public class User&#123;//@TableId(type IdType.ASSIGN_ID) private Long id; @TableField(&quot;username&quot;) private string name; private Integer age; private string email;&#125; 4、@TableLogic引入一个逻辑删除的概念: 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库 中仍旧能看到此条数据记录, 常用与可能需要进行数据恢复的场景 mybatis提供的@TableLogic注解可以为我们实现逻辑删除功能提供遍历. @TableLogic 支持所有数据类型（推荐使用 Integer、Boolean、LocalDateTime）如果数据库字段使用 datetime，字符串 null，另一个值支持配置为函数来获取值如now() 附录： （1）逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。 （2）如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。 **该注解有两个属性值: ** value: 用来指定逻辑未删除值，默认为空字符串 delval: 用来指定逻辑删除值，默认为空字符串。 ==注意，该注解只对自动注入的 sql 起效== @TableLogic 对于 CIUD 的限制 插入（insert） 不作限制 查找（select） @TableLogic 注解将会在 select 语句的 where 条件添加条件，自动过滤掉已删除数据, 且使用 wrapper.entity 生成的 where 条件会忽略该字段,例如: 1SELECT user_id,name,sex,age,deleted FROM user WHERE user_id=1 AND deleted=&#x27;0&#x27; 更新（update） @TableLogic 注解将会在 update 语句的 where 条件后追加条件，防止更新到已删除数据, 且使用 wrapper.entity 生成的 where条件会忽略该字段,例如: 1update user set deleted=1 where id = 1 and deleted=0 删除（delete） @TableLogic 注解会将 delete 语句转变为 update 语句,例如: 1update user set deleted=1 where id = 1 and deleted=0 测试实例:添加表字段sql: 123-- 添加一个 deleted 字段，实现逻辑删除ALTER TABLE `user`ADD COLUMN `deleted` varchar(1) NULL DEFAULT 0 COMMENT &#x27;是否删除（1-删除；0-未删除）&#x27;; 实体类: 12345678910111213141516171819@TableName(value = &quot;user&quot;)public class AnnotationUser7Bean &#123; @TableId(value = &quot;user_id&quot;, type = IdType.AUTO) private int userId; @TableField(&quot;name&quot;) private String name; @TableField(&quot;sex&quot;) private String sex; @TableField(&quot;age&quot;) private Integer age; // 也可以不指定属性值,那将按照默认的规则进行判断(Integer-&gt;0,1 Boolean-&gt;true,false, 其他的null为假,具体可以查阅资料) @TableLogic(value = &quot;0&quot;, delval = &quot;1&quot;), private String deleted; // getter,setter....&#125; 全局配置逻辑删除当然，你也可以不在 @TableLogic 注解中指定 value 和 delval 属性的值。使用全局逻辑删除配置信息，配置如下： 1234567891011## application.ymlmybatis-plus: global-config: db-config: ## 全局逻辑删除的实体字段名 (since 3.3.0, 配置后可以忽略 @TableLogic 中的配置) logic-delete-field: flag ## 逻辑已删除值(默认为 1) logic-delete-value: 1 ## 逻辑未删除值(默认为 0) logic-not-delete-value: 0 条件构造器和常用接口1 、wapper介绍 Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 QueryWrapper ： 查询条件封装 UpdateWrapper ： Update 条件封装 AbstractLambdaWrapper ： 使用Lambda 语法 LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper 2 、QueryWrapper模糊匹配12345LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();//模糊匹配 likelqw.likeLeft(User::getName, &quot;J&quot;); // likeLeft 表示通配符 % 在左边(默认), 也可以设置到右边List&lt;User&gt; userList = userDao.selectList(lqw);System.out.println(userList); 组装查询条件123456789@Testpublic void test01()&#123;//查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;username&quot;, &quot;a&quot;).between(&quot;age&quot;, 20, 30).isNotNull(&quot;email&quot;); List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println);&#125; 组装排序条件123456789@Testpublic void test02()&#123;//按年龄降序查询用户，如果年龄相同则按id升序排列//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.orderByDesc(&quot;age&quot;).orderByAsc(&quot;id&quot;); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println);&#125; 组装删除条件12345678910@Testpublic void test03()&#123;//删除email为空的用户//DELETE FROM t_user WHERE (email IS NULL) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.isNull(&quot;email&quot;); //条件构造器也可以构建删除语句的条件 int result = userMapper.delete(queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; 条件的优先级123456789101112@Testpublic void test04() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改 //UPDATE t_user SET age=?, email=? WHERE (username LIKE ? AND age &gt; ? OR email IS NULL) queryWrapper.like(&quot;username&quot;, &quot;a&quot;).gt(&quot;age&quot;, 20).or().isNull(&quot;email&quot;); User user = new User(); user.setAge(18); user.setEmail(&quot;user@atguigu.com&quot;); int result = userMapper.update(user, queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; Lambda表达式的逻辑最优先进行运算,如: 12345678910111213@Testpublic void test04() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改//UPDATE t_user SET age=?, email=? WHERE (username LIKE ? AND (age &gt; ? OR email IS NULL))//lambda表达式内的逻辑优先运算queryWrapper.like(&quot;username&quot;, &quot;a&quot;).and(i -&gt; i.gt(&quot;age&quot;, 20).or().isNull(&quot;email&quot;)); User user = new User(); user.setAge(18); user.setEmail(&quot;user@atguigu.com&quot;); int result = userMapper.update(user, queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; 组装select子句12345678910@Testpublic void test05() &#123;//查询用户信息的username和age字段//SELECT username,age FROM t_user QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select(&quot;username&quot;, &quot;age&quot;); //selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper); maps.forEach(System.out::println);&#125; 实现子查询123456789@Testpublic void test06() &#123;//查询id小于等于3的用户信息//SELECT * FROM t_user WHERE (id IN (select id from t_user where id &lt;= 3)) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.inSql(&quot;id&quot;, &quot;select id from t_user where id &lt;= 3&quot;); List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println);&#125; 3、UpdateWrapper1234567891011121314151617181920@Testpublic void test07() &#123;//将（年龄大于20或邮箱为null）并且用户名中包含有a的用户信息修改//组装set子句以及修改条件 UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();//lambda表达式内的逻辑优先运算 updateWrapper .set(&quot;age&quot;, 18) .set(&quot;email&quot;, &quot;user@atguigu.com&quot;) .like(&quot;username&quot;, &quot;a&quot;) .and(i -&gt; i.gt(&quot;age&quot;, 20).or().isNull(&quot;email&quot;));//这里必须要创建User对象，否则无法应用自动填充。如果没有自动填充，可以设置为null //UPDATE t_user SET username=?, age=?,email=? WHERE (username LIKE ? AND (age &gt; ? OR email IS NULL)) //User user = new User(); //user.setName(&quot;张三&quot;); //int result = userMapper.update(user, updateWrapper); //UPDATE t_user SET age=?,email=? WHERE (username LIKE ? AND (age &gt; ? OR email IS NULL)) int result = userMapper.update(null, updateWrapper); System.out.println(result);&#125; 4、condition在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因 此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择(结果为null)则一定不能组装，以免影响SQL执行的结果 123456789101112131415161718192021@Testpublic void test08() &#123; //定义查询条件，有可能为null（用户未输入或未选择） String username = null; Integer ageBegin = 10; Integer ageEnd = 24; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();//StringUtils.isNotBlank()判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成 if(StringUtils.isNotBlank(username))&#123; queryWrapper.like(&quot;username&quot;,&quot;a&quot;); &#125; if(ageBegin != null)&#123; queryWrapper.ge(&quot;age&quot;, ageBegin); &#125; if(ageEnd != null)&#123; queryWrapper.le(&quot;age&quot;, ageEnd); &#125;//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (age &gt;= ? AND age &lt;= ?) List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println);&#125; 上面的实现方案虽然没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查 询条件，简化代码的编写 12345678910111213141516@Testpublic void test08UseCondition() &#123;//定义查询条件，有可能为null（用户未输入或未选择） String username = null; Integer ageBegin = 10; Integer ageEnd = 24; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //StringUtils.isNotBlank()判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成 queryWrapper .like(StringUtils.isNotBlank(username), &quot;username&quot;, &quot;a&quot;) .ge(ageBegin != null, &quot;age&quot;, ageBegin) .le(ageEnd != null, &quot;age&quot;, ageEnd);//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (age &gt;= ? AND age &lt;= ?) List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println);&#125; 5、LambdaQueryWrapper12345678910111213141516@Testpublic void test09() &#123;//定义查询条件，有可能为null（用户未输入） String username = &quot;a&quot;; Integer ageBegin = 10; Integer ageEnd = 24; LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();//避免使用字符串表示字段，防止运行时错误 /* 查询username含有a字符,年龄小于ageBegin,大于的ageEnd的所有用户信息 */ queryWrapper .like(StringUtils.isNotBlank(username), User::getName, username) .ge(ageBegin != null, User::getAge, ageBegin) .le(ageEnd != null, User::getAge, ageEnd); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println);&#125; 6、LambdaUpdateWrapper12345678910111213@Testpublic void test10() &#123; //组装set子句 LambdaUpdateWrapper&lt;User&gt; updateWrapper = new LambdaUpdateWrapper&lt;&gt;(); updateWrapper .set(User::getAge, 18) .set(User::getEmail, &quot;user@atguigu.com&quot;) .like(User::getName, &quot;a&quot;) .and(i -&gt; i.lt(User::getAge, 24).or().isNull(User::getEmail)); //lambda表达式内的逻辑优先运算 User user = new User(); int result = userMapper.update(user, updateWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; 投影,聚合,分组投影: 1234567/*LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;();lqw.select(User::getId, User::getName, User::getAge);*///或者QueryWrapper&lt;User&gt; lqw = new QueryWrapper&lt;User&gt;();lqw.select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;, &quot;tel&quot;);List&lt;User&gt; userList = userDao.selectList(lqw);System.out.println(userList); 聚合: 12345QueryWrapper&lt;User&gt; lqw = new QueryWrapper&lt;User&gt;();lqw.select(&quot;count(*) as count, tel&quot;);lqw.groupBy(&quot;tel&quot;);List&lt;Map&lt;String, Object&gt;&gt; userList = userDao.selectMaps(lqw);System.out.println(userList); 分组: 12345QueryWrapper&lt;User&gt; qw = new QueryWrapper&lt;User&gt;();qw.select(&quot;gender&quot;,&quot;count(*) as nums&quot;);qw.groupBy(&quot;gender&quot;);List&lt;Map&lt;String, Object&gt;&gt; maps = userDao.selectMaps(qw);System.out.println(maps); mp插件(拦截器)1 、分页插件MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能,使用步骤如下: 1.添加配置类 12345678910@Configuration@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;) //可以将主类中的注解移到此处public class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 2.测试 123456789101112131415@Testpublic void testPage()&#123; //设置分页参数 Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); userMapper.selectPage(page, null); //获取分页数据 List&lt;User&gt; list = page.getRecords(); list.forEach(System.out::println); System.out.println(&quot;当前页：&quot;+page.getCurrent()); System.out.println(&quot;每页显示的条数：&quot;+page.getSize()); System.out.println(&quot;总记录数：&quot;+page.getTotal()); System.out.println(&quot;总页数：&quot;+page.getPages()); System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious()); System.out.println(&quot;是否有下一页：&quot;+page.hasNext());&#125; 2 、xml自定义分页UserMapper中定义接口方法 1234567/*** 根据年龄查询用户列表，分页显示* @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位* @param age 年龄* @return*/IPage&lt;User&gt; selectPageVo(@Param(&quot;page&quot;) Page&lt;User&gt; page, @Param(&quot;age&quot;)Integer age); UserMapper.xml中编写SQL 123456&lt;!--SQL片段，记录基础字段--&gt;&lt;sql id=&quot;BaseColumns&quot;&gt;id,username,age,email&lt;/sql&gt; &lt;!--IPage&lt;User&gt; selectPageVo(Page&lt;User&gt; page, Integer age);--&gt; &lt;select id=&quot;selectPageVo&quot; resultType=&quot;User&quot;&gt; SELECT &lt;include refid=&quot;BaseColumns&quot;&gt;&lt;/include&gt; FROM t_user WHERE age &gt; ##&#123;age&#125; &lt;/select 测试: 123456789101112131415@Testpublic void testSelectPageVo()&#123;//设置分页参数 Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); userMapper.selectPageVo(page, 20);//获取分页数据 List&lt;User&gt; list = page.getRecords(); list.forEach(System.out::println); System.out.println(&quot;当前页：&quot;+page.getCurrent()); System.out.println(&quot;每页显示的条数：&quot;+page.getSize()); System.out.println(&quot;总记录数：&quot;+page.getTotal()); System.out.println(&quot;总页数：&quot;+page.getPages()); System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious()); System.out.println(&quot;是否有下一页：&quot;+page.hasNext());&#125; 3 、乐观锁假设有这么一个场景: 一件商品，成本价是 80 元，售价是 100 元。老板先是通知小李，说你去把商品价格增加 50 元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到 150 元，价格太高，可能会影响销量。又通知小王，你把商品价格降低 30 元。此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格 100 元；小王也在操作，取出的商品价格也是 100 元。小李将价格加了 50 元，并将100+50=150元存入了数据库；小王将商品减了 30 元，并将100-30=70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。现在商品价格是 70 元，比成本价低 10 元。几分钟后，这个商品很快出售了 1 千多件商品，老板亏 1万多。 如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。 如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证 最终的价格是120元。 下面的例子将模拟模拟修改冲突 数据库中增加商品表 123456789CREATE TABLE t_product( id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;, NAME VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;商品名称&#x27;, price INT(11) DEFAULT 0 COMMENT &#x27;价格&#x27;, VERSION INT(11) DEFAULT 0 COMMENT &#x27;乐观锁版本号&#x27;, PRIMARY KEY (id)); 添加数据: 1INSERT INTO t_product (id, NAME, price) VALUES (1, &#x27;外星人笔记本&#x27;, 100); 实体类: 1234567@Datapublic class Product &#123; private Long id; private String name; private Integer price; private Integer version;&#125; dao层mapper 12public interface ProductMapper extends BaseMapper&lt;Product&gt; &#123;&#125; 测试: 123456789101112131415161718192021@Testpublic void testConcurrentUpdate() &#123; //1、小李 Product p1 = productMapper.selectById(1L); System.out.println(&quot;小李取出的价格：&quot; + p1.getPrice()); //2、小王 Product p2 = productMapper.selectById(1L); System.out.println(&quot;小王取出的价格：&quot; + p2.getPrice()); //3、小李将价格加了50元，存入了数据库 p1.setPrice(p1.getPrice() + 50); int result1 = productMapper.updateById(p1); System.out.println(&quot;小李修改结果：&quot; + result1); //4、小王将商品减了30元，存入了数据库 p2.setPrice(p2.getPrice() - 30); int result2 = productMapper.updateById(p2); System.out.println(&quot;小王修改结果：&quot; + result2); //最后的结果 Product p3 = productMapper.selectById(1L); //价格覆盖，最后的结果：70 System.out.println(&quot;最后的结果：&quot; + p3.getPrice());&#125; 乐观锁实现######## 实现思路: **数据库中添加version字段 取出记录时，获取当前version ** 1SELECT id,`name`,price,`version` FROM product WHERE id=1 更新时，version + 1，如果where语句中的version版本不对，则更新失败 1UPDATE product SET price=price+50, `version`=`version` + 1 WHERE id=1 AND `version`=1 ######## Mybatis-puls实现: 修改实体类,添加版本属性字段 123456789@Data public class Product &#123; private Long id; private String name; private Integer price; // Mybatis-puls 版本字段注解 @Version private Integer version;&#125; 添加乐观锁插件配置, 并且注入到Spring管理, 最后在Mybatis-puls配置类里注入,方便管理 12345678910111213@Configuration@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;) //可以将主类中的注解移到此处public class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //添加分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); //添加乐观锁插件 interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor; &#125;&#125; 预期效果: 小李查询商品信息： SELECT id,name,price,version FROM t_product WHERE id=? 小王查询商品信息： SELECT id,name,price,version FROM t_product WHERE id=? 小李修改商品价格，自动将version+1 UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=? Parameters: 外星人笔记本(String), 150(Integer), 1(Integer), 1(Long), 0(Integer) 小王修改商品价格，此时version已更新，条件不成立，修改失败 UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=? Parameters: 外星人笔记本(String), 70(Integer), 1(Integer), 1(Long), 0(Integer) 最终，小王修改失败， 查询价格：150 SELECT id,name,price,version FROM t_product WHERE id=? 代码实现: 123456789101112131415161718192021222324252627282930@Testpublic void testConcurrentVersionUpdate() &#123; //小李取数据 Product p1 = productMapper.selectById(1L); //小王取数据 Product p2 = productMapper.selectById(1L); //小李修改 + 50 p1.setPrice(p1.getPrice() + 50); int result1 = productMapper.updateById(p1); System.out.println(&quot;小李修改的结果：&quot; + result1); //小王修改 - 30 p2.setPrice(p2.getPrice() - 30); int result2 = productMapper.updateById(p2); System.out.println(&quot;小王修改的结果：&quot; + result2); if(result2 == 0)&#123; //失败重试，重新获取version并更新 p2 = productMapper.selectById(1L); p2.setPrice(p2.getPrice() - 30); result2 = productMapper.updateById(p2); &#125; System.out.println(&quot;小王修改重试的结果：&quot; + result2); //老板看价格 Product p3 = productMapper.selectById(1L); System.out.println(&quot;老板看价格：&quot; + p3.getPrice());&#125; 通用枚举表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举类型来实现,(其实也可以通过MySQL数据库约束实现) 如下案例将演示使用mybatis-puls的通用枚举类型: 实体类创建通用枚举类型 123456789101112@Getterpublic enum SexEnum &#123; MALE(1, &quot;男&quot;), FEMALE(2, &quot;女&quot;); @EnumValue private Integer sex; private String sexName; SexEnum(Integer sex, String sexName) &#123; this.sex = sex; this.sexName = sexName; &#125;&#125; 在application.yaml中配置扫描通用枚举 123456789101112mybatis-plus: configuration:## 配置MyBatis日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config:## 配置MyBatis-Plus操作表的默认前缀 table-prefix: t_## 配置MyBatis-Plus的主键策略 id-type: auto## 配置扫描通用枚举 type-enums-package: com.atguigu.mybatisplus.enums 测试: 1234567891011@Testpublic void testSexEnum()&#123; User user = new User(); user.setName(&quot;Enum&quot;); user.setAge(20); //设置性别信息为枚举项，会将@EnumValue注解所标识的属性值存储到数据库 user.setSex(SexEnum.MALE); //INSERT INTO t_user ( username, age, sex ) VALUES ( ?, ?, ? ) // Parameters: Enum(String), 20(Integer), 1(Integer) userMapper.insert(user);&#125; 代码生成器Mybatis-Puls为了更高效快速的进行CURD操作,还提供了代码生成器,能够根据数据库中的数据表快速生成实体类和Dao层代码 引入依赖: 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt;&lt;!--默认使用velocity模板引擎--&gt;&lt;!--&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt;--&gt; 代码生成器类: 12345678910111213141516public class Generator &#123; public static void main(String[] args) &#123; //1. 创建代码生成器对象，执行生成代码操作 AutoGenerator autoGenerator = new AutoGenerator(); //2. 数据源相关配置：读取数据库中的信息，根据数据库表结构生成代码 DataSourceConfig dataSource = new DataSourceConfig(); dataSource.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); autoGenerator.setDataSource(dataSource); /* 这里可以根据需要对生成器类进行一些配置... */ //3. 执行生成操作 autoGenerator.execute(); &#125;&#125; 自定义配置下面是对生成器的配置的一些补充: 设置全局配置12345678910//设置全局配置GlobalConfig globalConfig = new GlobalConfig();globalConfig.setOutputDir(System.getProperty(&quot;user.dir&quot;)+&quot;/mybatisplus_04_generator/src/main/java&quot;); //设置代码生成位置globalConfig.setOpen(false); //设置生成完毕后是否打开生成代码所在的目录globalConfig.setAuthor(&quot;程序员&quot;); //设置作者globalConfig.setFileOverride(true); //设置是否覆盖原始生成的文件globalConfig.setMapperName(&quot;%sDao&quot;); //设置数据层接口名，%s为占位符，指代模块名称globalConfig.setIdType(IdType.ASSIGN_ID); //设置Id生成策略autoGenerator.setGlobalConfig(globalConfig); 设置包名相关配置1234567//设置包名相关配置PackageConfig packageInfo = new PackageConfig();packageInfo.setParent(&quot;com.aaa&quot;); //设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径packageInfo.setEntity(&quot;domain&quot;); //设置实体类包名packageInfo.setMapper(&quot;dao&quot;); //设置数据层包名autoGenerator.setPackageInfo(packageInfo); 策略设置12345678910//策略设置StrategyConfig strategyConfig = new StrategyConfig();strategyConfig.setInclude(&quot;tbl_user&quot;); //设置当前参与生成的表名，参数为可变参数strategyConfig.setTablePrefix(&quot;tbl_&quot;); //设置数据库表的前缀名称，模块名 = 数据库表名 - 前缀名 例如： User = tbl_user - tbl_strategyConfig.setRestControllerStyle(true); //设置是否启用Rest风格strategyConfig.setVersionFieldName(&quot;version&quot;); //设置乐观锁字段名strategyConfig.setLogicDeleteFieldName(&quot;deleted&quot;); //设置逻辑删除字段名strategyConfig.setEntityLombokModel(true); //设置是否启用lombokautoGenerator.setStrategy(strategyConfig); 多数据源多数据源适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等 目前我们就来模拟一个纯粹多库的一个场景，其他场景类似 场景说明： 我们创建两个库，分别为：mybatis_plus（以前的库不动）与mybatis_plus_1（新建），将 mybatis_plus库的product表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例 分别获取用户数据与商品数据，如果获取到说明多库模拟成功 创建数据库mybatis_plus_1和表product 123456789101112131415-- 建库建表CREATE DATABASE `mybatis_plus_1` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;use `mybatis_plus_1`;CREATE TABLE product( id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;, name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;商品名称&#x27;, price INT(11) DEFAULT 0 COMMENT &#x27;价格&#x27;, version INT(11) DEFAULT 0 COMMENT &#x27;乐观锁版本号&#x27;, PRIMARY KEY (id));INSERT INTO product (id, NAME, price) VALUES (1, &#x27;外星人笔记本&#x27;, 100);use mybatis_plus;DROP TABLE IF EXISTS product; 引入依赖: 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 在application.yaml中配置多数据源 12345678910111213141516171819spring: ## 配置数据源信息datasource: dynamic: ## 设置默认的数据源或者数据源组,默认值即为master primary: master ## 严格匹配数据源,默认为false, 为true时未匹配到指定数据源时抛异常,false使用默认数据源 strict: false datasource: master: url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 slave_1: url: jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 创建用户Service 12public interface UserService extends IService&lt;User&gt; &#123;&#125; 实现类: 12345@DS(&quot;master&quot;) //指定所操作的数据源@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implementsUserService &#123;&#125; 创建商品service 12public interface ProductService extends IService&lt;Product&gt; &#123;&#125; 实现类: 1234@DS(&quot;slave_1&quot;)@Servicepublic class ProductServiceImpl extends ServiceImpl&lt;ProductMapper, Product&gt;implements ProductService &#123;&#125; 测试: 123456789@Autowiredprivate UserService userService;@Autowiredprivate ProductService productService;@Testpublic void testDynamicDataSource()&#123; System.out.println(userService.getById(1L)); System.out.println(productService.getById(1L));&#125; 结果：1、都能顺利获取对象，则测试成功2、如果我们实现读写分离，将写操作方法加上主库数据源，读操作方法加上从库数据源，自动切换，是不是就能实现读写分离？ MyBatisX插件MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率, 但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件 MyBatisX插件用法参考官方文档：https://baomidou.com/pages/ba5b24/","categories":[{"name":"Java系列","slug":"Java系列","permalink":"https://lqy679.github.io/categories/Java%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"运维常识简记","slug":"运维常识简记","date":"2020-01-02T00:00:00.000Z","updated":"2023-04-13T11:55:38.191Z","comments":true,"path":"2020/01/02/运维常识简记/","link":"","permalink":"https://lqy679.github.io/2020/01/02/%E8%BF%90%E7%BB%B4%E5%B8%B8%E8%AF%86%E7%AE%80%E8%AE%B0/","excerpt":"本人根据作者已经掌握知识查缺补漏 域名, ip 一个域名只能对应一个ip地址吗 (west.cn) 一般来说, 一个域名只能对应一个(公网)ip, 网络主机, 而是一个ip 是可以绑定多个域名的. 不过，为了获得更好的体验,一般会做负载均衡.比如: 成都用户和杭州的用户都同时访问 www.abc.com ,假如该站点做了负载均衡, 两人虽然都是访问的同一个域名，但访问的对应IP地址却可能是不同的。 这是因为: 在一开始, 两人确实都访问到了 www.abc.com 域名对应的主机, 但是该主机是一个做了负载均衡服的反向代理务器, 该服务器将根据各地的访问IP，到达域名IP中路由跳数最小的那个IP地址作为访问的域名IP地址。这样能保证一个域名被访问时，能最大限度提供高速稳定的访问体验。","text":"本人根据作者已经掌握知识查缺补漏 域名, ip 一个域名只能对应一个ip地址吗 (west.cn) 一般来说, 一个域名只能对应一个(公网)ip, 网络主机, 而是一个ip 是可以绑定多个域名的. 不过，为了获得更好的体验,一般会做负载均衡.比如: 成都用户和杭州的用户都同时访问 www.abc.com ,假如该站点做了负载均衡, 两人虽然都是访问的同一个域名，但访问的对应IP地址却可能是不同的。 这是因为: 在一开始, 两人确实都访问到了 www.abc.com 域名对应的主机, 但是该主机是一个做了负载均衡服的反向代理务器, 该服务器将根据各地的访问IP，到达域名IP中路由跳数最小的那个IP地址作为访问的域名IP地址。这样能保证一个域名被访问时，能最大限度提供高速稳定的访问体验。 此外，一般大型网站都有多个备选IP，当其中一个出现问题时，可以实现故障自动切换，提高业务可用性，并提高资源利用率。 相关问题:国内服务器是使用国外注册的域名需要备案吗 需要 , 凡是想通过域名服务器, 都需要进行备案, 换句话说, ==国内服务器( 香港的除外 )绑定域名都需要备案==, 但是只购买使用国内服务器, 通过ip访问是不需要备案的 Http, Https这两个是tcp 网络协议, 常用于web服务访问, Http采用明文传输, 不安全, Https采用密文传输,相对安全. Http 采用80端口, 一般也是浏览器方位的默认端口(在浏览器地址栏输入IP地址,默认方位的就是该主机的80端口), 不过目前现代主流浏览器都在主推Https, 微信小程序接口服务也是默认Https 服务的. Https 未来将会是主流. 并且, 由于安全策略的限制, 不支持https服务的web应用无法通过浏览器调用摄像头, 具体定位等功能 相关问题如何让web应用或者说服务器支持Https ? 通过相关机构购买ssl数字证书即可, 证书有付费的, 有免费的.一般来说ssl 是颁发绑定到域名的. 中国大陆大部分是这样, 也就是说想要支持Https协议, 基本上都是要有域名进行绑定的 参考链接: 如何进行域名购买，获取免费ssl证书，使用springboot绑定ssl证书_https域名购买_ 通过云厂商如阿里云,腾讯云, 购买证书 (有免费的, 但是需要绑定域名) JDK能自带生成ssl证书","categories":[{"name":"运维","slug":"运维","permalink":"https://lqy679.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[]},{"title":"Docker","slug":"Docker","date":"2020-01-01T10:57:32.000Z","updated":"2023-04-28T03:23:48.812Z","comments":true,"path":"2020/01/01/Docker/","link":"","permalink":"https://lqy679.github.io/2020/01/01/Docker/","excerpt":"Docker 参考文档:💻 Docker 快速安装软件 - Docker 快速入门 - 易文档 (easydoc.net) 官方文档:Docker Documentation 官网:Docker 常见问题解决: (61条消息) 【已解决】Error: Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist_ReadThroughLife的博客-CSDN博客 或:(61条消息) CentOSyum安装报错“Error: Failed to download metadata for repo ‘AppStream‘: xxxx”_Indra_ran的博客-CSDN博客","text":"Docker 参考文档:💻 Docker 快速安装软件 - Docker 快速入门 - 易文档 (easydoc.net) 官方文档:Docker Documentation 官网:Docker 常见问题解决: (61条消息) 【已解决】Error: Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist_ReadThroughLife的博客-CSDN博客 或:(61条消息) CentOSyum安装报错“Error: Failed to download metadata for repo ‘AppStream‘: xxxx”_Indra_ran的博客-CSDN博客 1234567891011121314# 容器 bash 没有 clear命令dnf install ncurses -y# 查看容器CentOS 系统版本cat /etc/redhat-release# 无法下载东西,容器需要配置镜像源cd /etc/yum.repos.d/sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*yum makecache # 建立yum缓存# an&#x27;zhungyum update -yyum -y install vimyum -y install net-tools 也可以通过Dockerfile打包镜像,Dockerfile内容如下: 1234567891011121314FROM centosENV mypath /tmpWORKDIR $mypathRUN cd /etc/yum.repos.d/RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*RUN yum makecacheRUN yum update -yRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo &#x27;to be not success running&#x27;CMD echo &#x27;success------ok&#x27;CMD /bin/bash 简介Docker 是什么 Docker 是一个应用打包、分发、部署的工具你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。 跟普通虚拟机的对比 特性 普通虚拟机 Docker 跨平台 通常只能在桌面级系统运行，例如 Windows/Mac，无法在不带图形界面的服务器上运行 支持的系统非常多，各类 windows 和 Linux 都支持 性能 性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了 性能好，只虚拟软件所需运行环境，最大化减少没用的配置 自动化 需要手动安装所有东西 一个命令就可以自动部署好所需环境 稳定性 稳定性不高，不同系统差异大 稳定性好，不同系统都一样部署方式 打包、分发、部署打包：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包分发：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装部署：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows/Mac/Linux。 部署的优势常规应用开发部署方式：自己在 Windows 上开发、测试 –&gt; 到 Linux 服务器配置运行环境部署。 问题：我机器上跑都没问题，怎么到服务器就各种问题了 用 Docker 开发部署流程：自己在 Windows 上开发、测试 –&gt; 打包为 Docker 镜像（可以理解为软件安装包） –&gt; 各种服务器上只需要一个命令部署好 优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。 例如 易文档，SVNBucket 的私有化部署就是用 Docker，轻松应对客户的各种服务器。 通常用来做什么 应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用 快速安装测试/学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK 多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0 Windows 上体验/学习各种 Linux 系统 重要概念：镜像、容器镜像：可以理解为软件安装包，可以方便的进行传播和安装。容器：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。 原理以及架构(待学)Docker的三个概念 镜像（Image）：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。 容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。 仓库（Repository）：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。 安装在Window中安装桌面版：https://www.docker.com/products/docker-desktop服务器版：https://docs.docker.com/engine/install/#server 配置镜像加速源 镜像加速器 镜像加速器地址 Docker 中国官方镜像 https://registry.docker-cn.com DaoCloud 镜像站 http://f1361db2.m.daocloud.io Azure 中国镜像 https://dockerhub.azk8s.cn 科大镜像站 https://docker.mirrors.ustc.edu.cn 阿里云 https://.mirror.aliyuncs.com 七牛云 https://reg-mirror.qiniu.com 网易云 https://hub-mirror.c.163.com 腾讯云 https://mirror.ccs.tencentyun.com 在Linux中安装(重点): 视频教程:哔哩哔哩_bilibili 官方文档: https://docs.docker.com/engine/install/centos/ 准备工作:关闭防火墙:123456#关闭防火墙(临时关闭)systemctl stop firewalld#永久关闭防火墙systemctl disable firewalld#查看防火墙状态systemctl status firewalld 关闭Selinux:123#打开配置文件:vim /etc/selinux/config#找到设置项并设置为: SELINUX=disable 安装wgetwget命令是Linux系统用于从Web下载文件的命令行工具，支持 HTTP、HTTPS及FTP协议下载文而且wget还提供了很多选项，例如下载多个文件、后台下载，使用代理等等，使用非常方便。 1yum install wget -y 更换yum镜像源1234567891011#进入下载源配置目录cd /etc/yum.repos.d/#创建一个备份文件夹mkdir repo-bk#将原来的配置源文件移动到备份文件夹中mv *.repo repo-bk/#下载镜像源wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo#清空并重新更新一下缓存yum clean allyum makecache fast 安装一些工具12345678#(按需安装) 安装vim编辑器和查询网卡的工具yum install -y vim net-tools.x86_64yum -y install gccyum -y install gcc-c++#工具包yum install -y yum-utils#更新缓存yum makecache fast 设置stable镜像仓库需要设置是因为yum软件源是没有docker 12345#docker官网(不推荐)yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo#推荐使用阿里云镜像yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache fast #更新软件源索引 安装docker1234567891011#安装dockeryum -y install docker-ce docker-ce-cli containerd.io#启动systemctl start docker#设置开机自启systemctl enable docker #测试docker是否安装成功docker version #查看版本与信息docker info#测试(第一次过程需要从仓库拉取有些慢,需要耐心等待)docker run hello-world 普通用户免root运行docker 12345678910#在普通用户在su #切换到root用户#添加组groupadd docker#修改普通用户所属组usermod -aG docker 普通用户名#重启dockersystemctl restart docker#重启使用修改生效reboot 配置阿里云镜像加速 容器镜像服务 (aliyun.com) 需要到阿里云登陆账号: 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://eh05r18s.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 镜像命令 常用命令:注: [options] 表示可选命令参数, tag代表镜像的版本 可以通过hub.docker 查看详细的镜像以及版本号 123456789docker images #查看本地镜像列表docker search [options] 镜像名 #查找仓库中镜像,命令参数: -limit n 指定列出的镜像数,默认25docker pull 镜像名[:tag] #从仓库中下载镜像到本地,可以在镜像名后追加标签号指定版本,不加是最新版docker push 镜像名 #上传镜像到仓库docker rmi [options] 镜像名或镜像id #删除指定的镜像,添加命令参数-f,可以通过镜像id删除或者删除多个#删除多个: docker rmi 镜像id 镜像id#删除全部镜像:docker rmi `docker images -q`# 重命名镜像docker image tag fb583c3ac45d my_docker/test:latest 容器命令 注意: 以下所说的容器名其实写容器id也可以,不过多赘述 有镜像才能创建容器,这是前提 以下例子 用Nginx和CentOS演示: 12docker pull nginx #从仓库下载一个Nginx镜像docker pull centos 创建容器与配置docker run [OPTIONS] image [COMMAND] [ARG...] OPTIONS说明（常用）：有些是一个减号，有些是两个减号: -i：以交互模式运行容器，通常与 -t 同时使用； -t：为容器重新分配一个伪输入终端 上面两个一般配合使用,并且大部分情况下是必须的 -d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行),在大多数情况下,我们是希望Docker服务后台运行的 --name “容器名字” 给容器定义个名字,不写则随机生成 -p: 指定端口映射，小写p -P: 随机端口映射，大写P 例子: 1234#前台启动Nginx,开启端口映射docker run -it --name nginxContainer -p 8080:80 nginx#在Docker中启动一个CentOS虚拟机docker run -it --name centosContainer centos tips: -v命令参数涉及到容器卷的概念: 容器卷即将容器内部的文件路径与宿主机文件路径进行关联,(即每当容器或者宿主机关联的文件进行关联,修改其中一个,另一个也会改变) 我们将其操作称之为容器卷挂载 1docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名 查看数据卷是否挂载成功,通过docker inspect 容器ID查看容器细节 补充: 读写映射规则设置: 12345#默认rwdocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw#容器实例内部被限制，只能读取不能写docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名 卷的继承和共享: 实现: docker run -it --privileged=true --volumes-from 父类容器 --name 容器名 镜像 参数说明: --privileged=true 用于解决文件权限问题 --volumes-from指定继承的父类容器 容器交互命令退出容器==当使用run进入容器后:== 使用快捷键:ctrl+p+q 或 ctrl +p ctrl q退出，容器不停止 输入命令: exit退出，容器停止 进入后台容器12docker exec -it 容器ID bash #推荐使用docker attach 容器ID 上述两者的区别: exec 是在容器中打开新的终端，并且可以启动新的进程,用exit退出，不会导致容器的停止 attach 直接进入容器启动命令的终端，不会启动新的进程,用exit退出，会导致容器的停止。 容器与宿主机通信容器-&gt;宿主机 docker cp 容器ID:容器内路径 目的主机路径 宿主机-&gt;容器 docker cp 宿主机路径 容器ID:容器内路径 更多命令123456789101112docker ps [options] #查看正在运行的容器#options命令参数: -a 查看所有的参数, -q 只查看容器iddocker start 容器ID或者容器名 #启动已停止的容器docker restart 容器ID或者容器名 #重启容器docker stop 容器ID或者容器名 #停止容器docker kill 容器ID或容器名 # 强制停止容器docker rm 容器ID #删除已经停止的容器#补充: 删除全部容器docker rm `docker ps -a -q`docker logs 容器ID #查看容器的日志docker top 容器ID #查看容器运行的进程docker inspect 容器ID #查看容器内部细节 容器导出与导入:我们可以将自己的容器打包成一个镜像了,也可引入打包好的容器文件为作为一个镜像(包含被包的容器的所有数据) docker export 容器ID &gt; 文件名.tar docker import 文件名.tar 镜像名:镜像版本号 部署常用软件 搜索镜像:https://hub.docker.com/ 总体分二步: 搜索拉取镜像 创建容器 安装mysql 参考:mysql - Official Image | Docker Hub 拉取好镜像后,启动mysql服务 1docker run -itd --name some-mysql -e MYSQL_ROOT_PASSWORD=设置的密码 -p 3306:3306 mysql:tag 不过上述方案存在一个问题:即删除容器会导致数据丢失 实战部署通过挂载mysql容器卷来实现数据解决上述问题 1docker run -d -p 3306:3306 --privileged=true -v /opt/mysql/log:/var/log/mysql -v /opt/mysql/data:/var/lib/mysql -v /opt/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:5.7 安装Tomcat跟上述同理,不过最新版有个bug,无法正常进入首页,把webapps..dist目录命名为webapps即可 安装Redis注: Redis的配置文件可以从网上下载到,例如github:https://github.com/redis/redis/blob/6.0.8/redis.conf, 切换到对应版本即可 首先,创建一个存放配置文件的目录: mkdir -p /opt/redis redis.conf文件用xftp传输到/opt/redis目录下 /opt/redis目录下修改redis.conf文件 最后挂载容器卷创建运行容器 1docker run -p 6379:6379 --name redis --privileged=true -v /opt/redis/redis.conf:/etc/redis/redis.conf -v /opt/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf DockerfileDockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。 构建:三个步骤: 1.编写Dockerfile文件 2.docker build命令构建镜像 3.docker run依镜像运行容器实例 构建过程解析每条保留字指令都必须为大写字母且后面要跟随至少一个参数 指令按照从上到下，顺序执行 #表示注释 每条指令都会创建一个新的镜像层并对镜像进行提交 常用保留字 案例:下面的案例将构建一个带有Java环境和ifconfig命令的CentOS系统 准备好需要打包的文件即jdk , 注意jdk需要放到与Dockerfile文件同级目录下 1234#创建一个存放构建镜像的目录mkdir /opt/centos#新建并编写一个Dockerfile文件, 注意D一定要是大写 (内容在后面)vim Dockerfile Dockerfile文件内容 1234567891011121314151617181920212223242526272829303132#基础镜像,即从什么镜像开始构建FROM centos:latest#设置最新yum镜像仓库地址RUN cd /etc/yum.repos.d/RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*RUN yum makecache#设置镜像默认工作路径,即进入容器后会默认来到这个目录 WORKDIR /usr/local#安装ifconfig网络工具RUN yum -y install net-tools#安装 Java8依赖库RUN yum -y install glibc.i686#创建java的路径RUN mkdir /usr/local/java#将java安装包添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java#设置Java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATHCMD echo &quot;success......ok&quot;CMD /bin/bash 打包构建在准备好文件和Dockerfile后就可以使用命令打包了 1234docker build -t 镜像名:TAG(版本号) . #注意后面有个. 千万不能漏,代表当前目录#可以查看镜像的构建历史日志docker history 镜像名 随后用此镜像创建运行centos容器就可以执行ifconfig 和java相关的命令 微服务部署假设已经有开发好的SpringBoot应用jar包 我们需要打包构建一个镜像,并用如下的Dockerfile脚本进行构建镜像 123456789101112131415#根据java8构建镜像FROM java:8#默认工作目录WORKDIR /opt/java#添加jar包ADD docker-springboot-1.0-SNAPSHOT.jar /opt/java#暴露端口EXPOSE 6002#执行命令(不会被覆盖)ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]CMD [&quot;/opt/java/docker-springboot-1.0-SNAPSHOT.jar&quot;] #当执行docker run 时的 bash默认参数,可被命令参数覆盖,即不写默认执行:#docker run -itd --name 容器名 java -jar /opt/java/docker-springboot-1.0-SNAPSHOT.jar#写了就会将其替换为:#docker run -itd --name 容器名 java -jar 自己写的参数 随后构建微服务的镜像: 1docker build -t 镜像名:TAG(版本号) . 然后docker run ... 即可启动服务 Docker-ComposeDocker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。 1234#安装yum install -y docker-compose-plugin#检查是否安装成功docker compose version Compose使用的三个步骤 编写Dockerfile定义各个微服务应用并构建出对应的镜像文件 使用 docker-compose.yml，定义一个完整业务单元，安排好整体应用中的各个容器服务执行顺序。 最后，执行docker compose up命令 来启动并运行整个应用程序，完成一键部署上线 案例下面将演示一个简单的SpringBoot应用依赖于MySQL和redisf服务的部署过程 即 要先启动MySQL 和 redis 服务后,再启动Springboot服务 首先编写Dockerfile定义各个微服务应用并构建出对应的镜像文件 Dockerfile内容 12345678910FROM java:8WORKDIR /opt/javaADD docker-springboot-1.0-SNAPSHOT.jar /opt/javaEXPOSE 6002ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]CMD [&quot;/opt/java/docker-springboot-1.0-SNAPSHOT.jar&quot;] 随后构建镜像: docker build -t 镜像名:版本号 yaml文件语法: yaml语法 然后编写docker-compose.yml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#compose版本version: &quot;3&quot;#compose需要组合编排的服务: springboot应用,mysql,redisservices: #springboot服务的相关配置 docker-springboot: image: docker-springboot:latest #用哪个镜像docker run容器 container_name: docker-springboot #定义创建的容器名 ports: #暴漏端口: 相当于 docker run -p 6001:6001 - &quot;6001:6001&quot; networks: #所属compose创建的局域网 - ptu202180 depends_on: #依赖的服务,即只有依赖的服务启动后,才会启动该服务 - redis - mysql #redis服务的相关配置 redis: image: redis:6.0.8 ports: - &quot;6379:6379&quot; volumes: #相当于 docker run -v 的挂载容器卷 - /opt/redis/redis.conf:/etc/redis/redis.conf - /opt/redis/data:/data networks: - ptu202180 #使用配置文件启动redis命令 command: redis-server /etc/redis/redis.conf mysql: image: mysql:5.7 #设置mysql登陆密码,数据库等 environment: MYSQL_ROOT_PASSWORD: &#x27;123456&#x27; MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27; MYSQL_DATABASE: &#x27;ptu&#x27; ports: - &quot;3306:3306&quot; volumes: - /opt/mysql/data:/var/lib/mysql - /opt/mysql/conf/my.cnf:/etc/my.cnf - /opt/mysql/init:/docker-entrypoint-initdb.d - /opt/mysql/log:/var/log/mysql networks: - ptu202180 command: --default-authentication-plugin=mysql_native_password #解决外部无法访问#组件局域网,名为ptu202180 networks: ptu202180: 最后组合创建并执行排编好的微服务,注意执行 docker compose up命令目录必须与docker-compose.yml一致 也可以使用 -d 命令参数后台运行 补充:docker-compose.yml文件中的networks配置项用于在一个compose编排的微服务中构建一个内部共享的局域网,即:其内部的各个服务(springboot,mysql,redis)处于同一局域网下可以互相访问 (注: 详细原理请看docker 网络的自定义网络) 那么我们的springboot的mysql等数据库的连接配置就不必写成: jdbc:mysql://IP地址:3306/bike_db?serverTimezone=Asia/Shanghai 而是可以用服务名代替,即: jdbc:mysql://服务名(本例中是:mysql):3306/bike_db?serverTimezone=Asia/Shanghai Compose常用命令:1234567docker compose up # 启动所有docker-compose服务docker compose up -d # 启动所有docker-compose服务并后台运行docker compose down # 停止并删除容器、网络、卷、镜像。docker compose stop # 停止服务docker compose restart # 重启服务docker compose start # 启动服务docker compose -h #查看帮助 Docker网络总体介绍: 网络模式 介绍 bridge模式**(默认模式)** 使用--network bridge指定，默认使用docker0 host模式 使用--network host指定 container模式： 使用--network container:NAME或者容器ID指定 none模式 使用--network none指定 Bridge模式Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样==容器之间就能够通过容器的Container-IP直接通信==。 docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址 网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）； 每个容器实例内部也有一块网卡，每个接口叫eth0； docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。 Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让宿主机和容器之间可以通过网桥相互通信。 1234# 查看 bridge 网络的详细信息，并通过 grep 获取名称项docker network inspect bridge | grep name#查看网卡信息ifconfig 案例:结论: IP地址随容器顺序递增且动态分配 1 先启动两个ubuntu容器实例 2 docker inspect 容器ID or 容器名字 3 关闭u2实例 4 新建u3，查看ip变化 host模式直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。 容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。 问题： docke启动时总是遇见标题中的警告 原因： docker启动时指定--network host或-net=host，如果还指定了-p映射端口，那这个时候就会有此警告， 并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。 解决: 解决的办法就是使用docker的其他网络模式，例如--network=bridge，这样就可以解决问题，或者直接无视。 none模式在none模式下，并**不为Docker容器进行任何网络配置(禁用网络功能)**。 也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo 需要我们自己为Docker容器添加网卡、配置IP等。 1docker run -d -p 8084:8080 --network none --name 容器名 镜像名 container模式新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。 12# 创建容器2,并且与已经存在的容器1共享网卡,同时也无法与宿主机进行端口映射docker run -it --network container:容器1 --name 容器2 镜像名 bash 自定义网络我们可以通过docker network create 网络名自定义创建一个局部网来实现容器名(服务名)与其容器的IP地址绑定,即可以使用服务名来代表该服务容器的ip地址,自定义网络默认使用的是桥接(Bridge)模式 相关命令:12docker network ls #查看所有的网络(列表)docker network create 网络名 #创建网络 案例: Harbor私有镜像仓库搭建硬件要求: 安装Harbor1.在opt下创建文件夹harbor 2.上传安装包到harbor文件夹下 3.上传安装包到harbor文件夹下 123#在/opt/harbor目录下执行!cp harbor.yml.tmpl harbor.ymlmkdir -p /opt/harbor/data #用于存放harbor的持久化数据 修改配置文件harbor.yml配置文件主要修改参数如下： 设置内容: 123456789101112131415161718#设置主机地址，可以使用ip、域名，不可以设置为127.0.0.1或localhost。默认情况下，harbor使用的端口是80hostname: 192.168.0.8#http配置http:# port for http, default is 80. If https enabled, this port will redirect to https portport: 9999#https配置（如不需要可不配置,注释掉）# https related config#https:# https port for harbor, default is 443 #port: 443# The path of cert and key files for nginx #certificate: /your/certificate/path #private_key: /your/private/key/path#external_url: https://reg.mydomain.com:8433 //如果要启用外部代理,比如外层的NGINX、LB等，请取消注释external_url,当它启用时，hostname将不再使用。 数据库配置: 123456789#数据库配置database:# The password for the root user of Harbor DB. Change this before any production use.password: root123# The maximum number of connections in the idle connection pool. If it &lt;=0, no idle connections are retained.max_idle_conns: 50# The maximum number of open connections to the database. If it &lt;= 0, then there is no limit on the number of open connections.# Note: the default number of connections is 100 for postgres.max_open_conns: 100 持久化数据目录: 1data_volume: /opt/harbor/data 执行安装脚本:在/opt/harbor/目录下,执行 ./install.sh 网页可视化访问: 新建项目 本地镜像推送harbordocker登录到harbor1docker login ip地址:harbor端口 可能出现错误: 原因：Docker自从1.3.X之后docker registry交互默认使用的是HTTPS，但是我们搭建私有镜像默认使用的是HTTP服务，所以与私有镜像交时出现以上错误。 解决方案： 修改docker配置文件 vim /etc/docker/daemon.json 添加行：&quot;insecure-registries&quot;:[&quot;IP地址:harbor端口&quot;] 随后执行命令: 12345678910#重新加载docker配置systemctl daemon-reload#重启dockersystemctl restart docker#重新启动harborcd /opt/harbor/harbordocker-compose downdocker-compose up -d 重新利用docker登录到harbor，显示登录成功： 对本地镜像进行重新命名，命名要求参考harbor指示： 比如我们想把hello-world镜像推到harbor，具体过程如下： (1)首先确认镜像存在1docker images (2)重命名镜像按harbor命名要求重新给hello-world命名 1dokcer tag hello-world 仓库IP地址:harbor端口/项目名/推送的镜像名:版本 (3)推送到harbor上1docker pull 按规范命名好的镜像名 网页上刷新确认 拉取harbor镜像(1)利用docker登录到harbor(2)在网页上点击要拉取的镜像 随后到终端运行复制的命令即可 docker可视化web工具Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。 安装步骤1234#拉取镜像docker pull portainer/portainer#创建文件夹并且开放文件夹权限mkdir -p /opt/portainer &amp;&amp; chmod 777 -R portainer 创建配置文件docker-compose.yml 12#在/opt/portainer下:vim docker-compose.yml docker-compose.yml文件内容 12345678910111213141516version: &quot;3.6&quot;services: portainer: container_name: portainer image: portainer/portainer:latest restart: always ports: - &quot;9000:9000&quot; - &quot;8000:8000&quot; volumes: - /var/run/docker.sock:/var/run/docker.sock:rw - /opt/portainer/data:/data:rw logging: driver: &quot;json-file&quot; options: max-size: &quot;10m&quot; 启动: 1docker compose up -d 访问测试 选择docker类型: 主界面 单个部署创建局域网对应命令: dicker network create 网络名 部署mysql 部署redis在Home页面进入 Container-&gt; Add Container 堆积部署1.创建堆叠容器 2.命名 3.编写配置文件相当于编写docker-compose.yml文件 4.启动部署","categories":[{"name":"运维","slug":"运维","permalink":"https://lqy679.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[]},{"title":"CSS3新增知识","slug":"CSS3新增知识","date":"2020-01-01T10:57:32.000Z","updated":"2023-03-30T06:58:21.432Z","comments":true,"path":"2020/01/01/CSS3新增知识/","link":"","permalink":"https://lqy679.github.io/2020/01/01/CSS3%E6%96%B0%E5%A2%9E%E7%9F%A5%E8%AF%86/","excerpt":"CSS3新增知识1.1、CSS3的概念和优势 CSS3是css技术的升级版本, CSS3语言开发是朝着模块化发展的。以前的规范作为一个模块实在是太庞大而且比较复杂,所以,把它分解为-些小的模块，更多新的模块也被加入进来。这些模块包括:盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等。 css3的优点: CSS3将完全向后兼容，所以没有必要修改现在的设计来让它们继续运作。网络浏览器也还将继续支持CSS2.对我们来说，CSS3主要的影响是将可以使用新的可用的选择器和属性,这些会允许实现新的设计效果(譬如动态和渐变) ,而且可以很简单的设计出现在的设计效果(比如说使用分栏) 1.2、渐进增强和优雅降级","text":"CSS3新增知识1.1、CSS3的概念和优势 CSS3是css技术的升级版本, CSS3语言开发是朝着模块化发展的。以前的规范作为一个模块实在是太庞大而且比较复杂,所以,把它分解为-些小的模块，更多新的模块也被加入进来。这些模块包括:盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等。 css3的优点: CSS3将完全向后兼容，所以没有必要修改现在的设计来让它们继续运作。网络浏览器也还将继续支持CSS2.对我们来说，CSS3主要的影响是将可以使用新的可用的选择器和属性,这些会允许实现新的设计效果(譬如动态和渐变) ,而且可以很简单的设计出现在的设计效果(比如说使用分栏) 1.2、渐进增强和优雅降级 渐进增强progressive enhancement:针对低版本浏览器进行构建页面，保证最基本的功能,然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级graceful degradation: .一开始就构建完整的功能， 然后再针对低版本浏览器进行兼容. 区别:优雅降级是从复杂的现状开始,并试图减少用户体验的供给,而渐进增强则是从-个非常基础的,能够起作用的版本开始，并不断打充,以适应未来环境的需要。降级(功能衰减)意味着往回看;而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 一、选择器1.3、层级选择器( &gt; + ~) [重点掌握] E**&gt;**F子选择器选择匹配的F元素，匹配的F元素所匹配的E元素的子元素 (子代选择器,区别于空格的后代选择器) E**+** F相邻兄弟选择器选择匹配的F元素，且匹配的F元素紧位于匹配的元素的后面 (兄弟选择器) E~F通用选择器选择匹配的F元素，且位于匹配的E元素后的所有匹配的F元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 子代选择器 */ .box&gt;li &#123; border:1px solid red; &#125; /* + 当前元素的后面第一个兄弟 */ /* .child+li&#123; background:yellow; &#125; */ /* ~ 当前元素的后面所有的亲兄弟 */ .child~li&#123; background:yellow; &#125; .container~p&#123; background:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;box&quot;&gt; &lt;li&gt;1111 &lt;ul&gt; &lt;li&gt;111-111&lt;/li&gt; &lt;li&gt;111-222&lt;/li&gt; &lt;li&gt;111-333&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;child&quot;&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;li&gt;5555&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;container&quot;&gt;div-111111&lt;/div&gt; &lt;p&gt;p-1111&lt;/p&gt; &lt;p&gt;p-2222&lt;/p&gt; &lt;div&gt; &lt;p&gt;p-3333333&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1.4、属性选择器 ( [属性名]) [重点掌握] E[attr]: 只使用属性名,但没有确定任何属性值; E[attr= “value”]:指定属性名,并指定了该属性的属性值; E[attr= “value”]:指定属性名，并且具有属性值，此属性值是一个词列表， 并且以空格隔开,其中词列表中包含了一个value词，而且等号前面的“”不能不写. 扩展知识（了解） E[attr^= “value”]:指定了属性名,并且有属性值，属性值是以value开头的; E[attr$=”value”]: 指定了属性名,并且有属性值,且属性值是以value结束的 Eattr*= “value”]:指定了属性名，并且有属性值，而且属值中包含了value; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 属性选择器 [class,,] */ div[class]&#123; background:yellow; &#125; p[class]&#123; background:red; &#125; /* div .box1 &#123; &#125; */ /* 完全匹配 */ /* div[class=box1]&#123; border:1px solid blue; &#125; */ /* 包含就匹配 */ div[class~=box1]&#123; border:1px solid blue; &#125; input[name]&#123; background:yellow; &#125; input[type=email]&#123; background:red; &#125; /* 模糊匹配 class^=b 以这个开头的 class$=b 以这个结尾 class*=b 包含某个字符 */ div[class*=&quot;1&quot;],p[class*=&quot;1&quot;]&#123; color:green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;div-11111&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;div-22222&lt;/div&gt; &lt;div &gt;div-33333&lt;/div&gt; &lt;div class=&quot;box1&quot;&gt;div-44444&lt;/div&gt; &lt;div class=&quot;box1 box3&quot;&gt;div-555555555555555&lt;/div&gt; &lt;p class=&quot;p1&quot;&gt;p-11111&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;p-22222&lt;/p&gt; &lt;p &gt;p-33333&lt;/p&gt; &lt;div&gt; &lt;h1&gt;注册页面&lt;/h1&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 年龄&lt;input type=&quot;number&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱&lt;input type=&quot;email&quot;&gt;&lt;br&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1.5、伪类选择器 ( : 表示) [重点掌握]1.5.1、结构伪类选择器 X:first- child匹配子集的第一个元素。IE7就可以支持 X:last- child匹配父元素中最后一个X元素 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 940px; height: 100px; margin:0 auto; background:yellow; &#125; .box div&#123; float:left; width: 300px; height: 100px; background: red; margin-right: 20px; &#125; .box div:last-child&#123; margin-right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 通过某种结构关系查找页面元素. 比如： 匹配某元素第一个子元素 匹配某元素最后一个子元素 --&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; X:nth-child(n)用于匹配索引值为n的子元素。索引值从1开始 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* ul li:first-child&#123; background:yellow; &#125; ul li:last-child&#123; background:red; &#125; */ /* 第几个 */ /* li:nth-child(2)&#123; background:blue; &#125; */ /* 第几个， 偶数2n(even) 奇数 2n+1 2n-1(odd) */ li:nth-child(odd)&#123; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;li&gt;55555&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; X:only- child这个伪类一般用的比较少， 比如上述代码匹配的是div下的有且仅有-个的p，也就是说，如果div内有多个p,将不匹配。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; border:1px solid black; &#125; div p:only-child &#123; background:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;1111&lt;/p&gt; &lt;p&gt;2222&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;1111&lt;/p&gt; &lt;p&gt;2222&lt;/p&gt; &lt;p&gt;3333&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;11111&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; X:root匹配文档的根元素。在HTML (标准通用标记语言下的一个应用)中,根元素永远是HTML 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* html,body&#123; height: 100%; width: 100%; background: red; &#125; */ /* 以下代码可以实现相同效果 */ :root,body&#123; width: 100%; height: 100%; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; X:empty匹配没有任何子元素(包括包含文本)的元素X 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; height: 100px; width: 100px; &#125; div:empty&#123; background: darksalmon; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 注意：空格，换行等不等于空 --&gt; &lt;div&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结构伪类汇总: X:first- child匹配子集的第一个元素。IE7就可以支持 X:last- child匹配父元素中最后-个X元素 X:nth-child(n)用于匹配索引值为n的子元素。索引值从1开始 X:root匹配文档的根元素。在HTML (标准通用标记语言下的一个应用)中,根元素永远是HTML 1.5.2、目标伪类选择器 ==E:target==选择匹配E的所有元素，且匹配元素被相关URL指向 锚点案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0 &#125; ul&#123; list-style: none; position: fixed; right: 0px; top:100px; &#125; li&#123; width: 100px; height: 50px; line-height: 50px; text-align: center; border:1px solid black; &#125; div&#123; height: 600px; border:1px solid #ccc; /* background:yellow; */ &#125; div:target&#123; background: yellow; &#125; /* 锚点作用：页面不同区域的跳转， 使用a链接。 &lt;a href=&quot;#锚点名字&quot;&gt;&lt;/a&gt; &lt;div id=&quot;锚点名字&quot;&gt;&lt;/div&gt; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#a&quot;&gt;京东秒杀&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#b&quot;&gt;双11&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#c&quot;&gt;频道优选&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#d&quot;&gt;特色广场&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;a&quot;&gt; 京东秒杀 &lt;/div&gt; &lt;div id=&quot;b&quot;&gt; 双11 &lt;/div&gt; &lt;div id=&quot;c&quot;&gt; 频道优选 &lt;/div&gt; &lt;div id=&quot;d&quot;&gt; 特色广场 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 手风琴案例： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div.content&#123; /* 两者区别:display:block会从文档流消失,而visibility: hidden ,相当于彻底透明,但是本身还在文档流用占用空间*/ /* display: none; */ display: none; &#125; div.content:target&#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=&quot;#aaa&quot;&gt;aaa&lt;/a&gt; &lt;div id=&quot;aaa&quot; class=&quot;content&quot;&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Fuga odio eos natus cupiditate distinctio sequi, dolorum, obcaecati vel facilis velit provident deleniti inventore tempora iste, aut optio magnam asperiores non? &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;#bbb&quot;&gt;bbb&lt;/a&gt; &lt;div id=&quot;bbb&quot; class=&quot;content&quot;&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Fuga odio eos natus cupiditate distinctio sequi, dolorum, obcaecati vel facilis velit provident deleniti inventore tempora iste, aut optio magnam asperiores non? &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;#ccc&quot;&gt;ccc&lt;/a&gt; &lt;div id=&quot;ccc&quot; class=&quot;content&quot;&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Fuga odio eos natus cupiditate distinctio sequi, dolorum, obcaecati vel facilis velit provident deleniti inventore tempora iste, aut optio magnam asperiores non? &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1.5.3、UI元素状态伪类选择器 E:==enabled==匹配所有用户界面(form表单)中处于==可用状态==的E元素 E:==disabled==匹配所有用户界面(form表单) 中处于==不可用状态==的E元素 E:==checked==匹配所有用户界面(form表单) 中处于==选中状态==的元素E E==::====selection==匹配E元素中被用户==选中或处于高亮状态==的部分 E:==focus== 匹配E元素==获得焦点==的时候 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; input:enabled&#123; background: red; &#125; input:disabled&#123; background:yellow; &#125; /* 焦点 会匹配此选择器 */ input:focus&#123; /* background: blue; */ &#125; input[type=checkbox]&#123; /* 去掉默认样式 */ appearance: none; width: 20px; height: 20px; border:1px solid black; &#125; input:checked&#123; /* 去除默认样式后不再生效 */ background:red; &#125; div::selection&#123; background:yellow; color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot;&gt; 用户名&lt;input type=&quot;text&quot;&gt; &lt;br&gt; 密码&lt;input type=&quot;password&quot;&gt; &lt;br&gt; 记住用户名 &lt;input type=&quot;checkbox&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; disabled&gt; &lt;/form&gt; &lt;div&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Aliquid perferendis adipisci nihil repudiandae, maiores vero et, inventore facilis dolor eius consequatur nemo eaque. Dolorem, corrupti? Dolore molestiae dolorem esse laborum! &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1.5.4、否定伪类选择器 E:not(s) (IE6-8浏览器不支持:not(选择器。 )匹配所有不匹配简单选择符s的元素E 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul&#123; list-style: none; &#125; li:not(:first-child)&#123; background: yellow; &#125; li:not(:nth-child(even))&#123; color: red; &#125; div&#123; height: 100px; width: 100px; border: 1px solid greenyellow; &#125; div:not(:empty)&#123; background: hotpink; &#125; input:active&#123; background: red; &#125; a:hover&#123; background: seagreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;1111&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; &lt;br&gt; &lt;a href=&quot;&quot;&gt;sssss&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 1.5.5、动态伪类选择器 ==E:link==链接伪类选择器==选择匹配的E玩素，而且匹配元素被定义了超链接==并未被访问过。常用于链接描点上 ==E:visited==链接伪类选择器选择匹配的E元素，而且匹配元素被定义了超链接并==已被访问过。==常用于链接描点上 ==E:active==用户行为选择器选择匹配的E玩素，且==匹配元素被激活(如链接被点击时)==。常用于链接描点和按钮上 ==E:hover==用户行为选择器选择匹配的E元素，且==用户鼠标停留在元素E上==。IE6及以下浏览器仅支持a:hover 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul&#123; list-style: none; &#125; li:not(:first-child)&#123; background: yellow; &#125; li:not(:nth-child(even))&#123; color: red; &#125; div&#123; height: 100px; width: 100px; border: 1px solid greenyellow; &#125; div:not(:empty)&#123; background: hotpink; &#125; input:active&#123; background: red; &#125; a:hover&#123; background: seagreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;1111&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; &lt;br&gt; &lt;a href=&quot;&quot;&gt;sssss&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 二、阴影2.1、文本阴影 text-shadow:水平偏移位置 垂直偏移位置 阴影模糊距离 阴影颜色 ; 注意：==水平、垂直阴影的位置允许负值，并可进行多阴影设置（中间逗号隔开）== 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; text-shadow: 0px -10px 1px red, 0px 10px 1px yellow; /* text-shadow: 0px 10px 1px yellow; */ &#125; /* 10px 水平方向位移 10px 垂直方向的位移 1px 模糊程度 red 阴影颜色 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;大家好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.2、盒子阴影 box-shadow 属性值： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background:yellow; margin:0 auto; /* box-shadow: -10px -10px 10px 10px red,10px 10px 10px blue; */ box-shadow: 10px 10px 10px blue inset; /* inset内阴影 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 三、圆角3.1、圆角边框123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; background:green; margin:0 auto; /* border-radius: 10px 50px 70px 100px; */ /* px 或者 百分比 v1 , 四个角一样 v1,v2, 左上右下， 左下右上 一致 v1,v2,v3 左上， 左下右上 右下 v1,v2,v3,v4 顺时针 */ border-top-left-radius:10px; border-top-right-radius:30px; border-bottom-left-radius:60px; border-bottom-right-radius:100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.2、圆形案例123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; background:green; margin:0 auto; padding:20px; border:20px solid red; /* border-radius: 30px/60px; */ /* 30px/60px 水平/垂直 支持border-radius*/ /* border-top-left-radius: 30px/60px; 不支持的*/ /* border-radius: 10px 20px 30px 40px/50px 60px 70px 80px; */ border-radius: 50%; /* 一半===盒子的一半 50%*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3.3、长方形案例123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 500px; height: 200px; background:green; margin:0 auto; /* border-radius: 10%; */ border-radius: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.4、半圆案例1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 50px; background:green; margin:0 auto; border-radius: 50px 50px 0 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.5、扇形案例1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; background: green; margin:0 auto; border-radius: 0 0 0 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.6、圆角和阴影综合案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;圆角案例&lt;/title&gt; &lt;style&gt; *&#123; padding: 0px; margin: 0px; &#125; input&#123; outline: none; box-shadow: ; &#125; div&#123; height: 120px; line-height: 120px; width: 936px; text-align: center; margin: 20px auto; background: #f5f5f5; border: 1px solid #dedede; border-radius: 15px; box-shadow: 4px 11px 7px #c0c0c0, -4px 11px 7px #c0c0c0; /* position: relative; */ &#125; [type=text]&#123; height: 86px; width: 683px; margin: 0px auto; border: 3px solid #cccccc; border-radius: 3px; /* 缩进 */ text-indent: 11px; font-size: 24px; color: #a9a9aa; &#125; [type=submit]&#123; width: 200px; height: 88px; font-size: 22px; color: #fff; border-radius: 3px; background: url(&quot;img/btn.png&quot;)repeat; margin-left: 18px; /* position: relative; top: 1px; */ border: 1px solid #00748e; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Serach for CSS3,HTML5,jQuery...&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;GO&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 四、字体引入4.1、@font- face @font- face是CSS3中的一个模块,他主要是把自己2定义的Web字体嵌入到你的网页中,随着@font-face模块的出现,我们在Web的开发中使用字体不怕只能使用Web安全字体(@font face这个功能早在IE4就支持) @font-face的语法规则: 123456@font-face &#123; font- family: YourWebFontName; . src: 相对路径/绝对路径; font-weight: 字体大小 ; font-style: 字体;&#125; @font- face语法说明:1、YourWebFontName:此值指的就是你自定义的字体名称,最好是使用你下载的默认字体,他将被引用到你的Web元素中的font-family。如”font-family:”YourWebFontName’”;”2、source:此值指的是你自定义的字体的存放路径,可以是相对路径也可以是绝路径; 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @font-face&#123; font-family: kerwin; src:url(font/ygyxsziti2.0.ttf); &#125; div&#123; font-family: kerwin; font-size: 50px; color:red; text-shadow: 5px 0px 0px green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;赵钱孙李&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 五、怪异盒模型5.1、标准盒模型(内边距会撑大盒子模型) 含义:更改原有布局盒子模型的计算方式通过box-sizing属性的取值进行更改 属性: box-sizing：==box-sizing属性允许您以特定的方式定义匹配某个区域的特定元素。== 属性值: content-box这是由CSS2.1规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 5.2、怪异盒模型(盒子大小固定,内边距和边框不会撑大) 设置 box-sizing: border-box 为元素设定的宽度和高度决定了元素的边框盒。 就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 5.3、案例12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; background:green; padding: 30px; border:10px solid black; box-sizing: content-box; /* 标准盒模型 */ &#125; .box2&#123; width: 200px; height: 200px; background:red; margin-top:100px; padding: 30px; border:10px solid black; box-sizing: border-box; /* 怪异盒模型 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5.4、使用场景1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 900px; height: 300px; background:yellow; margin:0 auto; &#125; .box div&#123; width: 300px; height: 300px; float: left; text-align: center; padding: 10px; border:10px solid red; box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Eligendi voluptate nam obcaecati sequi blanditiis illum! Animi illo omnis ullam exercitationem quibusdam, suscipit, labore molestiae impedit corporis iste facere? Vitae, vero. &lt;/div&gt; &lt;div&gt;Lorem ipsum, dolor sit amet consectetur adipisicing elit. Repudiandae totam voluptatem distinctio in omnis sequi ut voluptatum, fuga nulla. Qui cumque voluptatum consequatur libero? Eos omnis illum harum corporis facilis?&lt;/div&gt; &lt;div&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Nostrum nam facere dicta praesentium animi perferendis harum neque similique rem laboriosam et magni, numquam tenetur veniam voluptatem. Nostrum esse pariatur dolorum.&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 六、弹性盒6.1、基本概念 弹性盒是CSS3中新增的一种布局方式：特别适合移动端布局 将一个盒子display属性设置为：flex，则表示为弹性盒 弹性盒对子元素产生的影响： 使子元素默认横向排列 行内元素变成行内块元素 (inline-block) 只有一个元素的时候，margin:auto–将自动水平垂直方向居中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; height: 400px; width: 400px; margin: 200px auto; border: 2px solid black; display: flex; &#125; /* .box div&#123; width: 50px; height: 50px; border: 1px dotted red; &#125; */ .box span&#123; width: 50px; height: 50px; border: 1px dotted red; /* 设置弹性盒子元素居中 */ margin: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 弹性盒是CSS3中新增的一种布局方式：特别适合移动端布局 --&gt; &lt;!--将父级盒子display属性设置为：flex则表示为弹性盒 弹性盒对子元素产生的影响 1.使子元素默认横向排列 2.行内元素变成块级元素 3.只有一个元素的时候，margin:auto--将自动水平垂直方向居中 --&gt; &lt;div class=&quot;box&quot;&gt; &lt;!-- &lt;div&gt;1111&lt;/div&gt; &lt;div&gt;2222&lt;/div&gt; &lt;div&gt;3333&lt;/div&gt; &lt;div&gt;4444&lt;/div&gt; --&gt; &lt;span&gt;1111&lt;/span&gt; &lt;!-- &lt;span&gt;2222&lt;/span&gt; &lt;span&gt;3333&lt;/span&gt; &lt;span&gt;4444&lt;/span&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.2、修改主轴方向6.2.1、概念引入 弹性盒子元素的排布方式可以有横向排布和纵向排布： 可以将子元素所在的方向称为主轴 另一个方向称为侧轴 6.2.2、flex-direction ==flex-direction==可以修改主轴方向 row：横向排列-默认方式 Colum-纵向排列； column-reverse:纵向反向排列 row-reverse-横向反向排列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; height: 400px; width: 400px; margin: 200px auto; border: 2px solid black; display: flex; /* 设置弹性盒内部布局方式： Colum-纵向排列； column-reverse:纵向反向排列 row-横向排列 row-reverse-横向反向排列 */ flex-direction: row; &#125; /* .box div&#123; width: 50px; height: 50px; border: 1px dotted red; &#125; */ .box span&#123; width: 50px; height: 50px; border: 1px dotted red; /* 设置弹性盒子元素居中 */ /* margin: auto; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;!-- &lt;div&gt;1111&lt;/div&gt; &lt;div&gt;2222&lt;/div&gt; &lt;div&gt;3333&lt;/div&gt; &lt;div&gt;4444&lt;/div&gt; --&gt; &lt;span&gt;1111&lt;/span&gt; &lt;span&gt;2222&lt;/span&gt; &lt;span&gt;3333&lt;/span&gt; &lt;span&gt;4444&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.3、主侧轴对齐方式 默认情况下：弹性盒内部元素是沿着主侧轴方向起点排布的 6.3.1、修改主轴对齐方式 ==justify-content==: 修改主轴方向元素对齐方式 属性值有： 默认左（上）对齐：flex-start 右（下）对齐：flex-end 两端对齐：space-between 环绕对齐：space-around 居中对齐：center 6.3.2、修改侧轴对齐方式 ==align-items:==修改侧轴方向元素对齐方式 属性值有: 默认左（上）对齐：flex-start 右（下）对齐：flex-end 居中对齐：center 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; height: 400px; width: 400px; margin: 200px auto; border: 2px solid black; display: flex; /* 设置弹性盒内部布局方式： Colum-纵向排列； column-reverse:纵向反向排列 row-横向排列 row-reverse-横向反向排列 概念引入： 将子元素所在的排列方向称之为主轴，另一方向称之为侧轴 如：子元素横向排列，则水平方向为主轴，垂直方向为侧轴 */ flex-direction: column; /* 调整主轴对齐方式： 默认左（上）对齐：flex-start 右（下）对齐：flex-end 两端对齐：space-between 环绕对齐：space-around 居中对齐：center */ justify-content: center; /* 调整侧轴对齐方式 默认左（上）对齐：flex-start 右（下）对齐：flex-end 居中对齐：center */ align-items: center; &#125; /* .box div&#123; width: 50px; height: 50px; border: 1px dotted red; &#125; */ .box span&#123; width: 50px; height: 50px; border: 1px dotted red; /* 设置弹性盒子元素居中 */ /* margin: auto; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;span&gt;1111&lt;/span&gt; &lt;span&gt;2222&lt;/span&gt; &lt;span&gt;3333&lt;/span&gt; &lt;span&gt;4444&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.4、折行与行间距6.4.1、折行 默认情况下：弹性盒不会发生折行，即一行内所有子元素全部挤下 通过flex-wrap: wrap;可以实现折行，具体属性值有： 值 描述 nowrap 默认值。规定灵活的项目不拆行或不拆列。 wrap 规定灵活的项目在必要的时候拆行或拆列。 wrap-reverse 规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。 initial 设置该属性为它的默认值。 inherit 从父元素继承该属性。 注意：==实现折行后，行距是等间距的== 6.4.2、行间距align-content属性用于修改 flex-wrap 属性的行为。与 align-items 相似，但它不对齐弹性项目，而是对齐 flex 线。 (注: css的gap属性可以直接设置行间距固定值) 折行之后的间距可以使用align-content改变间距方式 align-content的属性值有： 值 描述 stretch 默认值。行拉伸以占据剩余空间。 center 朝着弹性容器的中央对行打包。 flex-start 朝着弹性容器的开头对行打包。 flex-end 朝着弹性容器的结尾对行打包。 space-between 行均匀分布在弹性容器中。 space-around 行均匀分布在弹性容器中，两端各占一半。 initial 将此属性设置为其默认值。参阅 initial。 inherit 从其父元素继承此属性。参阅 inherit。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; height: 400px; width: 400px; margin: 200px auto; border: 2px solid black; display: flex; /* flex-direction: column; */ /* 折行 折行之后行间距是等间距的 */ flex-wrap:unset; /* 折行之后的间距可以使用align-content改变间距 */ align-content: flex-end; &#125; .box div&#123; width: 100px; height: 100px; border: 1px dotted red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;1111&lt;/div&gt; &lt;div&gt;2222&lt;/div&gt; &lt;div&gt;3333&lt;/div&gt; &lt;div&gt;4444&lt;/div&gt; &lt;div&gt;5555&lt;/div&gt; &lt;div&gt;6666&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.5、项目6.5.1、概念 在弹性盒概念中，我们称用flex修饰的盒子为容器，而容器里边的小盒子称为项目 6.5.2、项目-对齐方式 align-self可以设置每一个项目的对齐方式 其属性值有： 值 描述 auto 默认。元素继承其父容器的 align-items 属性，如果没有父容器，则为 “stretch”。 stretch 定位元素以适合容器。 center 元素位于容器的中央。 flex-start 元素位于容器的开头。 flex-end 元素位于容器的末端。 baseline 元素被定位到容器的基线。（和flex-start效果相同） initial 将此属性设置为其默认值。参阅 initial。 inherit 从其父元素继承此属性。参阅 inherit。 主轴在水平方向的案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; height: 500px; width: 500px; margin: 100px auto; border: 1px solid black; display: flex; box-sizing: border-box; &#125; .box div&#123; /* height: 100px; */ width: 100px; border: 1px dotted red; &#125; .d1&#123; height: 100px; align-self: flex-start; &#125; .d2&#123; height: 100px; align-self: flex-end; &#125; .d3&#123; height: 100px; align-self: center; &#125; .d4&#123; height: 100px; align-self: baseline; &#125; .d5&#123; /* 拉伸：不设置高度情况下有效，而且这个是默认效果 */ align-self: stretch; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;d1&quot;&gt;1111&lt;/div&gt; &lt;div class=&quot;d2&quot;&gt;2222&lt;/div&gt; &lt;div class=&quot;d3&quot;&gt;3333&lt;/div&gt; &lt;div class=&quot;d4&quot;&gt;4444&lt;/div&gt; &lt;div class=&quot;d5&quot;&gt;5555&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 主轴在垂直方向的案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; height: 500px; width: 500px; margin: 100px auto; border: 1px solid black; display: flex; box-sizing: border-box; flex-direction: column; &#125; .box div&#123; height: 100px; /* width: 100px; */ border: 1px dotted red; &#125; .d1&#123; width: 100px; align-self: flex-start; &#125; .d2&#123; width: 100px; align-self: flex-end; &#125; .d3&#123; width: 100px; align-self: center; &#125; .d4&#123; width: 100px; align-self: baseline; &#125; .d5&#123; /* 拉伸：不设置宽度情况下有效，而且这个是默认效果 */ align-self: stretch; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;d1&quot;&gt;1111&lt;/div&gt; &lt;div class=&quot;d2&quot;&gt;2222&lt;/div&gt; &lt;div class=&quot;d3&quot;&gt;3333&lt;/div&gt; &lt;div class=&quot;d4&quot;&gt;4444&lt;/div&gt; &lt;div class=&quot;d5&quot;&gt;5555&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.5.3、项目-顺序调整 order属性可以设置项目的顺序，其默认值为0 order的属性值其实是一个权重，如果某两个或多个项目的权重一样，则还是按照实际顺序排列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; height: 500px; width: 500px; margin: 100px auto; border: 1px solid black; display: flex; box-sizing: border-box; flex-direction: row-reverse; &#125; .box div&#123; height: 100px; width: 100px; border: 1px dotted red; &#125; .d1&#123; /* 默认值为0，不会发生变化 */ order: 0; &#125; .d2&#123; order: 0; &#125; .d3&#123; order: 1; &#125; .d4&#123; order: 1; &#125; .d5&#123; order: -1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;d1&quot;&gt;1111&lt;/div&gt; &lt;div class=&quot;d2&quot;&gt;2222&lt;/div&gt; &lt;div class=&quot;d3&quot;&gt;3333&lt;/div&gt; &lt;div class=&quot;d4&quot;&gt;4444&lt;/div&gt; &lt;div class=&quot;d5&quot;&gt;5555&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.5.4、项目-剩余宽高 使用flex属性可以快速实现多栏布局 剩余宽度案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 500px; height: 300px; border: 1px solid black; display: flex; margin: 100px auto; &#125; .box div:first-child&#123; width: 100px; height: 100px; border: 1px dotted red; flex: 1; &#125; .box div:nth-child(2)&#123; /* width: 300px; */ flex: 1; height: 100px; border: 1px dotted red; &#125; .box div:last-child&#123; width: 100px; height: 100px; border: 1px dotted red; flex: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 剩余高度案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 500px; height: 300px; border: 1px solid black; display: flex; margin: 100px auto; flex-direction: column; &#125; .box div:first-child&#123; width: 100px; height: 100px; border: 1px dotted red; flex: 1; &#125; .box div:nth-child(2)&#123; width: 100px; flex: 1; height: 100px; border: 1px dotted red; &#125; .box div:last-child&#123; width: 100px; height: 100px; border: 1px dotted red; flex: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 三栏布局案例： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; html,body&#123; height: 100%; &#125; body&#123; display: flex; &#125; .d1,.d3&#123; width: 100px; background: gray; &#125; .d2&#123; flex: 1; background: greenyellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;d1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;d2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;d3&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 相应式布局案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;* &#123; box-sizing: border-box;&#125;.flex-container &#123; display: flex; flex-wrap: wrap; font-size: 30px; text-align: center;&#125; /* 两列布局 */.flex-item-left &#123; background-color: #f1f1f1; padding: 10px; flex: 50%;&#125;.flex-item-right &#123; background-color: dodgerblue; padding: 10px; flex: 50%;&#125;/* 响应式布局 - 制作一列布局而不是两列布局, 当浏览器宽度小于等于800时,使用如下样式 */@media (max-width: 800px) &#123; .flex-item-right, .flex-item-left &#123; flex: 100%; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;响应式弹性框&lt;/h1&gt;&lt;p&gt;在此例中，我们修改了 flex 的百分比，以针对不同的屏幕尺寸创建不同的布局。&lt;/p&gt;&lt;p&gt;&lt;b&gt;请调整浏览器窗口的大小，来查看小于或等于 800 像素时的方向改变。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;flex-container&quot;&gt; &lt;div class=&quot;flex-item-left&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;flex-item-right&quot;&gt;2&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"大前端","slug":"大前端","permalink":"https://lqy679.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"HTML5新增知识","slug":"HTML5新增知识","date":"2020-01-01T10:57:32.000Z","updated":"2023-03-08T15:56:02.438Z","comments":true,"path":"2020/01/01/HTML5新增知识/","link":"","permalink":"https://lqy679.github.io/2020/01/01/HTML5%E6%96%B0%E5%A2%9E%E7%9F%A5%E8%AF%86/","excerpt":"HTM5新增知识一、HTML发展史 HTML5草案的前身名为Web Applications 1.0, 于2004年被WHATWG提出，于2007年被W3C接纳，并成立了新的HTML工作团队。HTML 5的第一份正式草案已于2008年1月22日公布。HTML5仍处于完善之中。然而，大部分现代浏览器已经具备了某些HTML5支持。 2012年12月17日，万维网联盟(W3C)正式宣布凝结了大量网络工作者心血的HTML5规范已经正式定稿。根据W3C的发言稿称: “HTML5是开放的Web网络平台的奠基石。” 2013年5月6日， HTML 5.1正式草案公布。该规范定义了第五次重大版本，第一次要修订万维网的核心语言:超文本标记语言(HTML) 。在这个版本中，新功能不断推出，以帮助Web应用程序的作者，努力提高新元素互操作性。 本次草案的发布，从2012年12月27日至今,进行了多达近百项的修改，包括HTML和XHTML的标签, 相关的API、Canvas等, 同时HTML 5的图像img标签及svg也进行了改进，性能得到进一 步提升。 二、HTML5的浏览器兼容问题","text":"HTM5新增知识一、HTML发展史 HTML5草案的前身名为Web Applications 1.0, 于2004年被WHATWG提出，于2007年被W3C接纳，并成立了新的HTML工作团队。HTML 5的第一份正式草案已于2008年1月22日公布。HTML5仍处于完善之中。然而，大部分现代浏览器已经具备了某些HTML5支持。 2012年12月17日，万维网联盟(W3C)正式宣布凝结了大量网络工作者心血的HTML5规范已经正式定稿。根据W3C的发言稿称: “HTML5是开放的Web网络平台的奠基石。” 2013年5月6日， HTML 5.1正式草案公布。该规范定义了第五次重大版本，第一次要修订万维网的核心语言:超文本标记语言(HTML) 。在这个版本中，新功能不断推出，以帮助Web应用程序的作者，努力提高新元素互操作性。 本次草案的发布，从2012年12月27日至今,进行了多达近百项的修改，包括HTML和XHTML的标签, 相关的API、Canvas等, 同时HTML 5的图像img标签及svg也进行了改进，性能得到进一 步提升。 二、HTML5的浏览器兼容问题 支持HtmI5的浏览器包括Firefox (火狐浏览器)，IE9及其更高版本, Chrome (谷歌浏览器)，Safari, Opera等; 国内的遨游浏览器(Maxthon) ,以及基于IE或Chromium (Chrome的工程版或称实验版)所推出的360浏览器、搜狗浏览器、 QQ浏览器、猎豹浏览器等国产浏览器同样具备支持HTML5的能力。常用的五大浏览器有: lE,chrome,firefox,safari,opera 三、HTML5语法 内容类型(ContentType)HTML 5的文件扩展符与内容类型保持不变,仍然为” .html”或” .htm”. DOCTYPE声明不区分大小写 指定字符集编码meta charset=”UTF-8” 可省略标记的元素不允许写结束标记的元素: br. col. embed、hr. img、 input. 、link. meta可以省略结束标记的元素: li、dt、 dd、p. option. colgroup、 thead. tbody、 tfoot. tr. td. th可以省略全部标记的元素: html. head、 body. colgroup、 tbody 省略引号属性值可以使用双引号,也可以使用单引号。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 语义化标签 增强型表单 canvas svg 音频视频 本地存储和离线存储 --&gt; &lt;input type=&quot;text&quot; value=&quot;aaaaa&quot;/&gt; &lt;input type=&quot;text&quot; value=&#x27;bbbbb&#x27;&gt; &lt;ul&gt; &lt;li&gt;1111 &lt;li&gt;2222 &lt;li&gt;33333 &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 四、HTML5新增语义化标签4.1、语义化案例 section元素表示页面中的- -个内容区块 article元素表示一块与上下文无关的独立的内容 aside元素在article之外的，与article内容相关的辅助信息 header元素表示页面中-个内容区块或整个页面的标题 footer元素表示页面中一个内容区块或整个页面的脚注 nav元素表示页面中导航链接部分 figure元素表示- -段独立的流内容，使用figcaption元素为其添加标题(第-个或最后- 个子元素的位置) main元素表示页面中的主要的内容(ie不兼容) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; html,body&#123; height: 100%; &#125; header,footer&#123; height: 80px; line-height: 80px; background: #f47d31; font-size: 40px; font-weight: bolder; text-align: center; color: #fff; &#125; section&#123; /* 注意：‘-’两边留好空格 */ height: calc(100% - 160px); /* background: chocolate; */ &#125; nav,aside&#123; float: left; width: 200px; height: 100%; background: #ccc; &#125; nav ul&#123; margin: 10px; &#125; nav ul&gt;li&#123; color: #f47d31; text-indent: 10px; padding-bottom: 10px; border-bottom: 2px solid #fff; &#125; figure&#123; color: white; font-size: 20px; text-align: center; &#125; main&#123; float: left; width: calc(100% - 400px); height: 100%; &#125; article header&#123; margin: 5px; &#125; .article1&#123; height: 60%; &#125; .article2&#123; height: 40%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; header &lt;/header&gt; &lt;section&gt; &lt;nav&gt; &lt;ul&gt; &lt;figure&gt;nav&lt;/figure&gt; &lt;li&gt;Link1&lt;/li&gt; &lt;li&gt;Link2&lt;/li&gt; &lt;li&gt;Link3&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;main&gt; &lt;article class=&quot;article1&quot;&gt; &lt;header&gt;article-header&lt;/header&gt; &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Fugiat minus amet ratione cumque quae expedita maxime ducimus eum quam sunt aliquam, odit temporibus voluptates totam illo doloremque corrupti alias incidunt! Lorem ipsum dolor sit amet consectetur adipisicing elit. &lt;/p&gt; &lt;footer&gt;article-footer&lt;/footer&gt; &lt;/article&gt; &lt;article class=&quot;article2&quot;&gt; &lt;header&gt;article-header&lt;/header&gt; &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Fugiat minus amet ratione cumque quae expedita maxime ducimus eum quam sunt aliquam, odit temporibus voluptates totam illo doloremque corrupti alias incidunt! Lorem ipsum dolor sit amet consectetur adipisicing elit. &lt;/p&gt; &lt;footer&gt;article-footer&lt;/footer&gt; &lt;/article&gt; &lt;/main&gt; &lt;aside&gt; &lt;figure&gt;aside&lt;/figure&gt; &lt;p class=&quot;aside_p&quot;&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Quis culpa quae repudiandae necessitatibus nam non, atque pariatur nihil voluptate magni deserunt voluptates corrupti assumenda facilis maxime alias minima dicta a? &lt;/p&gt; &lt;/aside&gt; &lt;/section&gt; &lt;footer&gt;footer&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 五、Video和audio的应用 video元素定义视频 控制栏：controls 循环播放：loop 自动播放：autoplay（多数浏览器已屏蔽） 静音：muted 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 之前的霸主flash, 由于安全性、计算资源使用效率低,被抛弃了 &lt;/p&gt; &lt;h1&gt;音频&lt;/h1&gt; &lt;audio src=&quot;./jiejie.wav&quot; controls loop autoplay muted&gt;&lt;/audio&gt; &lt;!-- controls 控制栏 loop : 循环 autoplay :自动播放 muted:静音 --&gt;&lt;/body&gt;&lt;/html&gt; video元素定义音频 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; video&#123; width: 300px; height: 300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;video src=&quot;./movie.mp4&quot; controls loop autoplay muted&gt;&lt;/video&gt; --&gt; &lt;video src=&quot;./movie.mp4&quot; controls loop poster=&quot;./poster.jpg&quot; &gt;&lt;/video&gt; &lt;!-- controls 控制栏 loop 循环 autoplay 自动播放 muted 静音 poster 属性海报 width height --&gt;&lt;/body&gt;&lt;/html&gt; 下面属性都是布尔值 ==controls属性:如果出现该属性,则向用户显示控件,比如播放按钮。== autoplay属性:如果出现该属性,则视频在就绪后马.上播放。 loop属性:重复播放属性。 muted属性:静音属性。 **poster属性:**规定视频正在下载时显示的图像，直到用户点击播放按钮。==(即封面)== 六、增强表单input的类型(type)多样 Type= “color” 生成一个颜色选择的表单 Type= “tel” 唤起拨号盘表单（手机专用） Type= “search” 产生一个搜索意义的表单 Type= “range” 产生- 个滑动条表单 Type= “number” 产生一个数值表单 (只能选择指定范围的类型) Type= “email” 限制用户必须输入email类型 ==Type= “url” 限制用户必须输入url类型 (规则:协议命://路径)== Type= “date” 限制用户必须输入日期 Type= “month” 限制用户必须输入月类型 (火狐可能不支持) Type= “week”限制用户必须输入周类型 (火狐可能不支持) Type= “time” 限制用户必须输入时间类型 (火狐可能不支持) ==Type= “datetime-local” 限制输入时间格式== (火狐可能不支持) 注意:数值(number)框和range框可设置步长(step),最大值和最小值属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 颜色选择 --&gt; &lt;form action=&quot;&quot;&gt; &lt;div&gt; &lt;!-- 颜色选择:&lt;input type=&quot;color&quot; name=&quot;color&quot;&gt; --&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- 邮箱: &lt;input type=&quot;email&quot; name=&quot;myemail&quot;&gt; --&gt; &lt;/div&gt; &lt;div&gt; url地址(完整地址) : &lt;input type=&quot;url&quot;&gt; &lt;/div&gt; &lt;div&gt; 电话号码: &lt;input type=&quot;tel&quot;&gt; &lt;/div&gt; &lt;div&gt; 滑块效果: &lt;input type=&quot;range&quot; name=&quot;range&quot; min=&quot;100&quot; max=&quot;200&quot; value=&quot;100&quot; step=&quot;10&quot;&gt; &lt;!-- step步长 --&gt; &lt;/div&gt; &lt;div&gt; 数字类型: &lt;input type=&quot;number&quot; min=&quot;0&quot; max=&quot;10&quot; value=&quot;4&quot; step=&quot;2&quot; name=&quot;age&quot;&gt; &lt;/div&gt; &lt;div&gt; 搜索: &lt;input type=&quot;search&quot;&gt; &lt;/div&gt; &lt;div&gt; 日期选择 &lt;input type=&quot;date&quot;&gt; 月份选择 &lt;input type=&quot;month&quot;&gt; 周数选择 &lt;input type=&quot;week&quot;&gt; &lt;input type=&quot;datetime-local&quot; name=&quot;datetime&quot;&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 增强表单之属性 autofocus属性:给文本框、选择框、或者按钮控件加上该属性,==当打开页面时，该控件自动获得国标焦点，一个页面只能有一 个==。 required属性: 验证输入不能为空 Multiple: 可以输入一个或多个值，每个值之间用逗号分开例: &lt;input type= &quot;email&quot; multiple/&gt;还可以应用于file pattern: (定制验证格式)将属性值设为某个格式的正则表达式，在提交时会检查其内容是否符合给定格式。例: &lt;input pattern= “[0-9][A-Z]{3}” title= “输入内容: -个数与三个大写字母” placeholder=输入内容: 一个数与三个大写字母’&gt; placeholder: 提示内容,但不会提交,与value有区别 list: 选项列表,详见选项列表 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot;&gt; &lt;div&gt; 用户名: &lt;input type=&quot;text&quot; autofocus required pattern=&quot;[0-9][A-Z]&#123;3&#125;&quot;&gt; &lt;!-- autofocus 获取焦点 --&gt; &lt;/div&gt; &lt;div&gt; 邮箱:&lt;input type=&quot;email&quot; name=&quot;email&quot; required multiple&gt; &lt;!-- required 必填项, 不能为空 --&gt; &lt;!-- multiple, 支持多个地址, 用逗号隔开 --&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 七、Datalist :选项列表例: 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;uri&quot; list=&quot;mylist&quot;&gt; &lt;datalist id=&quot;mylist&quot;&gt; &lt;option value=&quot;手机&quot;&gt;&lt;/option&gt; &lt;option value=&quot;手表&quot;&gt;&lt;/option&gt; &lt;option value=&quot;手环&quot;&gt;&lt;/option&gt; &lt;option value=&quot;手镯&quot;&gt;&lt;/option&gt; &lt;/datalist&gt;&lt;/body&gt;&lt;/html&gt; 提示: ==option 元素永远都要设置value属性。==","categories":[{"name":"大前端","slug":"大前端","permalink":"https://lqy679.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"git","slug":"Git基础","date":"2020-01-01T10:57:32.000Z","updated":"2023-04-25T09:34:15.614Z","comments":true,"path":"2020/01/01/Git基础/","link":"","permalink":"https://lqy679.github.io/2020/01/01/Git%E5%9F%BA%E7%A1%80/","excerpt":"Git分布式版本控制系统, 此外还有 SVN (集中式版本控制系统) 下载地址(阿里云镜像) :CNPM Binaries Mirror (npmmirror.com) Git Bash : Linux命令行风格 (推荐使用)","text":"Git分布式版本控制系统, 此外还有 SVN (集中式版本控制系统) 下载地址(阿里云镜像) :CNPM Binaries Mirror (npmmirror.com) Git Bash : Linux命令行风格 (推荐使用) Git CMD: window命令行风格 Git UID : 图形界面 工具使用技巧: 命令行切换目录麻烦,可以在直接打开该目录,再鼠标右击进入Git Bash 配置使用Git必须配置用户名和邮箱(不需要是真实的邮箱) 1234git config --global --list # 查看全局配置,即用户配置git config --system --list # 查看系统配置git config --global user.name &quot;名字&quot;git config --global user.email 318482536@qq.com Git配置文件系统配置文件在: 安装路径\\Git\\etc\\gitconfig 用户配置文件 C:\\Users\\当前用户名.gitconfig Git基本原理(理论) 工作区域 Git 在本地有三个工作区域:, ==工作目录(Working Directory) , 暂存区(Stage/index) , 资源库(Git Directory或Repsoitory),== 远程的Git仓库如GItHub或Gitee码云(Remole Directory)共四个工作区域,转换关系如下: ​ (图片来自狂神说) 工作目录 add =&gt; 添加到暂存区 , commit =&gt; 提交到本地仓库 ,push =&gt; 推送到远程仓库 到达工作目录 checkout &lt;= 存放到暂存区 , reset &lt;= 下载到本地仓库 ,pull &lt;= 远程仓库 工作区: 平时项目代码存放的地方,是真实的目录 暂存区: 用于临时存代码的改动,实际上只是一个文件,记录了即将提交到文件列表的信息,并不是真实目录 本地仓库: 安全存放数据的位置(实际上存在于.git目录中),存有所有版本的数据,其中HEAD文件指向最新放入仓库的版本 **远程仓库:**相当于网盘 注: HEAD文件在仓库目录的隐藏文件.git文件中,此文件记录了分支数以及分支指向, 基本流程 在工作目录添加,修改文件; ==相当于我们日常Coding的项目文件目录== 将需要进行版本管理的文件放入暂存区 ==对应命令 git add== 将暂存区的文件提交到本地仓库 ==对应命令 git commit== (可选) 提交到远程仓库 ==对应命令 git add push== git管理的文件状态:是否跟踪(untrack,track): 文件在工作目录且未被git管理就是属于未跟踪,并且是属于未暂存的, 是否暂存 (unstage,stage): 当文件已经被添加到暂存区后,就属于暂存状态了,但是git管理的文件被修改后,又会变成未暂存状态 已修改(modfiied):顾名思义,也就是当暂存区的文件被修改后,文件会变成已经修改状态,并且属于未状态,不过请注意,未跟踪的文件由于是未被git管理,故未跟踪的文件即使被修改也还是未跟踪状态 已提交(commited):顾名思义,也就是被提交到本地仓库的文件,此外,请注意本地仓库在隐藏目录.git中,并且只保存一些修改记录信息,所以并不能在本地仓库中真实的查看到代码或文件内容 ,咱们能正常查看到的文件是属于工作区的(这也就意味着我们修改文件后,并不能直接查看到原来的文件内容) 命令(速查)1234567891011121314151617181920212223242526272829git init # 在当前目录初始化git项目git clone url #克隆一个远程仓库项目到本地,url是项目链接; 克隆会初始化本地库,拉去代码,起一个默认别名git status [文件名]# 查看仓库(文件)状态git add 文件名 # 添加文件到暂存区git rm --cached 文件名 # 将文件从暂存区移除,相当于标记为未跟踪,不删除本地文件git commit -m &quot;日志信息&quot; 文件名 # 提交到本地仓库git reflog # 查看历代版本信息git log # 查看详细版本git reset --hard 版本号 # 回滚,即切换版本,会删除提交git revert -n 版本号 # 不会删除commit 的huigit push 远程库的别名或url 分支名 #将本地库推送到远程库git pull 远程库的别名或url 分支名 #将本地库拉取到远程库# 以下不常用git restore 文件名 #恢复,这个命令针对已修改但还未添加到暂存区的文件,撤销本次修改操作,文件将恢复成未修改之前的样子git restore --staged 文件名 #恢复暂存的文件,这个命令针对已修改并且已经添加到暂存区的文件,相当于撤销本次添加到暂存区操作git checkout . # 直接回滚当前目录一下的所有working tree内的修改，会递归扫描当前目录下的所有子目录# 分支管理命令git branch 分支名 # 创建分支git branch -v + # 查看分支git checkout 分支名 # 切换分支git merge 分支名 # 把指定的分支合并到当前分支下# 别名管理命令git remote -v #查看所有远程链接别名git remote add 别名 远程地址url #添加别名git remote remove 别名 #删除别名 分支为了提高开发效率,开建立多个分支进行协同开发,分支可简单理解为一个单独的副本(底层是指针的引用), 基本开发流程 ​ ( 图片来自尚硅谷 ) 分支协同开发 ​ ( 图片来自尚硅谷 ) master分支:代表项目上线正式版本 hot-fix 分支: 项目热维护分支,不需要将部署的项目停止运行 feature-bule: 开发分支 feature-game: 开发分支 分支操作(命令)123456git branch 分支名 # 创建分支git branch -v # 查看分支git checkout # 切换分支git merge 分支名 # 把指定的分支合并到当前分支下，合并要人工处理冲突，改动较多推荐用强制覆盖git push origin test:master -f # 将test分支强制（-f）推送到主分支master 还有一种强制覆盖分支的办法：假设 123git checkout master //将当前分支切换到主分支git reset --hard test //将主分支重置为test分支git push origin master -f //将重置后的master分支强制推送到远程仓库 团队协作团队内协作 ​ (图片来自尚硅谷) 跨团队协作 ​ (图片来自尚硅谷) 远程仓库相关命令12345git remote -v #查看所有远程链接别名git remote add 别名 远程地址url #添加别名git push 远程库别名或url # 将本地框推送至远程库git pull 远程库别名或url # 将远程库拉取到本地git remote remove 别名 #删除别名 权限以下针对Gitee来说,GitHub同理 仓库的团队内成员(以下简称团队成员,实际上还细分开发者,观察者等不做讨论,并且均当作拥有开发者及以上的权限) push的时候,输入的登陆信息尽量选择邮箱名或手机号作为用户名,输入gitee用户名可能会失败 团队成员在push到远程库的时候,无需管理员同意,并且分支也是同步的,也就是说团队的成员在哪个分支下进行的推送,远程也只有那个分支下进行改变 团队外成员无法直接Push,可以在Gitee通过fork叉入生成自己远程库,随后在克隆到到自己本地,修改完后push到自己的远程库,然后在Gitee上通过发起Pull Resquest到团队的远程库,随后管理员会看到申请,决定是否合并 样例:以下所有案例都是连续的操作 初次提交有如下案例,在testGit项目中存在一个hello.txt文件,从未追踪到提交到本地库生成版本信息如下: 后续修改如下代码赋值终端信息为了方便观看,接上面的案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ ls -lh # 查看当前所有文件信息total 1.0K-rw-r--r-- 1 Lenovo 197609 12 Feb 11 22:55 hello.txt # 当前目录存在一个hello.txt文件Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ cat hello.txt # 查看文件内容,内容为: \\n hello javahello javaLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ echo &quot;hello javaweb!!!&quot; &gt;&gt; hello.txt # Linux命令(通过管道)向hello.txt文件追加内容,模拟修改代码echo &quot;hello javawebcat hello.txt !&quot; &gt;&gt; hello.txtLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ cat hello.txt # 再次查看文件内容 文件内容为: \\n hello javahello javawebcat hello.txt !hello javahello javawebcat hello.txt !Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git status # 查看状态,可发现文件被修改后又变成了未暂存状态On branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: hello.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git add hello.txt # 添加文件到暂存区warning: LF will be replaced by CRLF in hello.txt.The file will have its original line endings in your working directoryLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git status # 再次查看状态,和第一提交差不多,文件已经在暂存区中,但还未提交On branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: hello.txtLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git commit -m &quot;second commit&quot; hello.txt # 将修改后的文件提交到本地仓库warning: LF will be replaced by CRLF in hello.txt. # 这里的警告是说window和linux换行符不同的原因,不用在意The file will have its original line endings in your working directory[master 1db21ac] second commit # 提交成功后,又有一个版本号,以及提交者编写的信息 1 file changed, 1 insertion(+), 1 deletion(-)Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git reflog # 查看日志1db21ac (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: second commit63c7412 HEAD@&#123;1&#125;: commit (initial): frist commit #(HEAD -&gt; master)所在的版本号表示master分支的当前版本(指向) Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git log # 查看详细日志commit 1db21ac75f97fdd8bc9dfed2e57eb430c3153b5b (HEAD -&gt; master) Author: lqy &lt;318482536@qq.com&gt;Date: Sat Feb 12 00:00:04 2022 +0800 second commitcommit 63c7412ca2d0c639542c5a4a6a4cd1770e1e75a7Author: lqy &lt;318482536@qq.com&gt;Date: Fri Feb 11 23:20:39 2022 +0800 frist commitLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ 版本穿梭,代码回滚接上面两个案例,将版本切换为初代版本 版本切换会将造成本地工作区的文件内容修改,但本质是git在操作HEAD指针 123456789101112Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git reflog # 查看历代版本1db21ac (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: second commit63c7412 HEAD@&#123;1&#125;: commit (initial): frist commitLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git reset --hard 63c7412 # 切换版本HEAD is now at 63c7412 frist commit # 提示HEAD指针现在指向第一个版本Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ 查看创建分支,多分支提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git branch -v # 查看分支,目录名后面的括号代表了当前所处分支.即现在在master分支下* master 1db21ac second commitLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git branch hot-fix #创建分支Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git branch -v # 查看分支 hot-fix 1db21ac second commit* master 1db21ac second commitLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git checkout hot-fix # 切换到hot-fix分支,模拟热维护Switched to branch &#x27;hot-fix&#x27;Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix) #切换后,目录后面的括号内容发生改变$ ls -lhtotal 1.0K-rw-r--r-- 1 Lenovo 197609 42 Feb 12 10:45 hello.txtLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ cat hello.txt # 查看文件内容hello javahello javawebcat hello.txt !Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ echo &quot;\\n hello Git! and Java yyds&quot; &gt;&gt; hello.txt # 追加文件内容Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ cat hello.txt # 再次查看文件内容,检查是添加成功,发现已经添加hello javahello javawebcat hello.txt !\\n hello Git! and Java yydsLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ git status .On branch hot-fixChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: hello.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ git add .warning: LF will be replaced by CRLF in hello.txt.The file will have its original line endings in your working directoryLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ git statusOn branch hot-fixChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: hello.txtLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ git commit -m &quot;hot-fix frist commit&quot; . # hot-fix分支,添加,提交到本地仓库成功warning: LF will be replaced by CRLF in hello.txt.The file will have its original line endings in your working directory[hot-fix f804008] hot-fix frist commit 1 file changed, 1 insertion(+)Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ git checkout master # 切换回 master分支Switched to branch &#x27;master&#x27;Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ cat hello.txt # 查看 master 分支下的文件内容(查看在别的分支下修改文件是否会受到影响) #发现和切换到 hot-fix分支之前的文件内容一样,说明每个分支修改都是独立的hello javahello javawebcat hello.txt !Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git reflog # 下面都是查看历史版本和日志1db21ac (HEAD -&gt; master, checkout) HEAD@&#123;0&#125;: checkout: moving from hot-fix to masterf804008 (hot-fix) HEAD@&#123;1&#125;: commit: hot-fix frist commit1db21ac (HEAD -&gt; master, checkout) HEAD@&#123;2&#125;: checkout: moving from master to hot-fix1db21ac (HEAD -&gt; master, checkout) HEAD@&#123;3&#125;: reset: moving to 1db21ac63c7412 HEAD@&#123;4&#125;: reset: moving to 63c74121db21ac (HEAD -&gt; master, checkout) HEAD@&#123;5&#125;: commit: second commit63c7412 HEAD@&#123;6&#125;: commit (initial): frist commitLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git logcommit 1db21ac75f97fdd8bc9dfed2e57eb430c3153b5b (HEAD -&gt; master, checkout)Author: lqy &lt;318482536@qq.com&gt;Date: Sat Feb 12 00:00:04 2022 +0800 second commitcommit 63c7412ca2d0c639542c5a4a6a4cd1770e1e75a7Author: lqy &lt;318482536@qq.com&gt;Date: Fri Feb 11 23:20:39 2022 +0800 frist commitLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git checkout hot-fix # 再次切换回 hot-fix分支Switched to branch &#x27;hot-fix&#x27;Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ cat hello.txt # 查看文件还是 之前自己(hot-fix分支)修改提交后的样子hello javahello javawebcat hello.txt !\\n hello Git! and Java yyds 分支合并(无冲突)接上面的例子,将hot-fix修改的内容合并到master分支上,并且两者是没有修改到重复的地方(也就是无冲突) 1234567891011121314151617181920Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ git checkout master # 切换回master分支,因为我们要将 hot-fix 合并到当前的分支(也就是master)下Switched to branch &#x27;master&#x27;Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git merge hot-fix # 合并Updating 1db21ac..f804008Fast-forward hello.txt | 1 + #共一行受到影响,添加了内容(之前hot-fix分支添加了\\n hello Git! and Java yyds) 1 file changed, 1 insertion(+)Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ cat hello.txt # 查看文件,注意:此时在master分支下,查看的是master的文件,发现已经合并了hello javahello javawebcat hello.txt !\\n hello Git! and Java yydsLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ 合并冲突出现的原因: 多个分支同时修改了==同一个文件的同一个位置==,这时git不会自动处理(仅仅把冲突标记),需要人为修改 下面例子演示了hot-fex分支和master同时在hello.txt最后一行添加数据合并的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ cat hello.txt # 查看原来的文件,请注意最后一行hello javahello javawebcat hello.txt !\\n hello Git! and Java yydsLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ cat hello.txt #在最后一行添加内容,修改过程已省略,需要注意的是修改后需要commithello javahello javawebcat hello.txt !\\n hello Git! and Java yydshot-fix testLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ git add .Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ git commit -m &quot;2&quot; . # 需要提交,不提交合并的还是之前的版本[hot-fix 2d3540a] 2 1 file changed, 1 insertion(+)Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ git checkout master # 切换回 master 分支,除了合并,其他操作与 hot-fix分支一致,文件修改内容不一样罢了Switched to branch &#x27;master&#x27;Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ cat hello.txthello javahello javawebcat hello.txt !\\n hello Git! and Java yydsLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ cat hello.txthello javahello javawebcat hello.txt !\\n hello Git! and Java yydsmaster testLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git add .Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git commit -m &quot;2&quot; .[master 73cb316] 2 1 file changed, 1 insertion(+)Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git merge hot-fix # 进行合并Auto-merging hello.txtCONFLICT (content): Merge conflict in hello.txt #提示我们发现了(内容)冲突,发生在hello.txt文件Automatic merge failed; fix conflicts and then commit the result.# 自动合并失败,让我们修复冲突然后进行提交, 注意,之后的提交命令接文件名Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master|MERGING)$ git status # 查看状态On branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: hello.txt # 提示都修改no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 然后我们打开文件观看发现 注意!!!我们修改后的提交命令也不能带文件名了,因为如果携带文件名他就不知道该提交哪个 123456789101112Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master|MERGING)$ git add hello.txtLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master|MERGING)$ git commit -m &quot;merge test&quot; hello.txtfatal: cannot do a partial commit during a merge. # 提交失败,致命(错误),合并过程中不能部分提交Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master|MERGING)$ git commit -m &quot;merge test&quot; # 提交成功,又生成了一个新的版本号[master d74e6d6] merge test 不过,合并只会改变被合并的分支,不会改变拿来合并的分支,如下所示,切换到hot-fix分支文件内容依然没变 12345678910111213141516171819Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ cat hello.txthello javahello javawebcat hello.txt !\\n hello Git! and Java yydsmaster testLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git checkout hot-fixSwitched to branch &#x27;hot-fix&#x27;Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ cat hello.txthello javahello javawebcat hello.txt !\\n hello Git! and Java yydshot-fix testLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (hot-fix)$ 创建别名远程库链接太长,为了方便管理,我们通常会给远程库起一个别名替代远程库链接 如下演示:我们在码云创建一个仓库,并且起一个别名,在上面的本地仓库进行 1234567891011121314Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git remote -v # 查看别名,发现没有Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git remote add testGit https://gitee.com/LQY679/test-git.git #从gitee获得链接,并且起一个别名testGitLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git remote -v # 发现有两个,因为需要拉去和推送,实际上是同一个仓库testGit https://gitee.com/LQY679/test-git.git (fetch)testGit https://gitee.com/LQY679/test-git.git (push)Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ 推送和拉取远程库请注意:无论是push 远程库还是pull 远程库时,都==需要指定分支==, 并且在push可能因为远程库被修改过了(如远程库比本地库多了些本地库没有的文件),会导致push失败,==所以在push失败时可以先尝试pull在push== 1234567891011121314151617181920212223242526272829303132Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git push testGit master #将本地仓库推送至远程库的master分支,出现下面信息代表成功Enumerating objects: 37, done.Counting objects: 100% (37/37), done.Delta compression using up to 12 threadsCompressing objects: 100% (24/24), done.Writing objects: 100% (37/37), 3.10 KiB | 528.00 KiB/s, done.Total 37 (delta 7), reused 0 (delta 0), pack-reused 0remote: Powered by GITEE.COM [GNK-6.2]To https://gitee.com/LQY679/test-git.git * [new branch] master -&gt; masterLenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ git pull testGit master # 将远程库拉取到本地库的master,出现下面信息代表成功From https://gitee.com/LQY679/test-git * branch master -&gt; FETCH_HEADUpdating d74e6d6..d9ec34fFast-forward hello.txt | 1 + 1 file changed, 1 insertion(+)Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ cat hello.txt # 查看文件发现发现了在gitee上的修改hello javahello javawebcat hello.txt !\\n hello Git! and Java yydsmaster test 在gitee上做的修改Lenovo@DESKTOP-2U25RBA MINGW64 /e/Code/gitCode/testGit (master)$ SSH公钥免密登陆gitee和gitHub都支持使用ssh公钥免密登陆,我们在自己电脑绑定公钥后以后进行Git操作就不需要频繁输入密码了 生成公钥命令 1ssh-keygen -t rsa -C 自己之前的邮箱 # 使用真实邮箱,rsa是一种加密算法, 注意 -C选项的C 是大小 生成并且查看公钥 生成的公钥在用户目录中,用户目录即 C:\\Users\\自己电脑的登陆名,由于我还未生生成,故是没有的, 在此目录下右击鼠标打开Git命令行工具,随后输入命令 随后进入.ssh目录,会有两个文件 id_rsa ,这个文件内容是私钥, id_rsa.pub 文件的内容是公钥, 复制公钥在平台(Gitee或GitHub)里绑定 登陆Gitee或租GitHub,在个人信息找到相关设置将id_rsa.pub 文件的内容复制后.粘贴到对应平台所需要填写的公钥即可 Git结合IDE使用忽略项配置文件,建议命名成 git.ignore,文件名随意,但后缀名务必为ignore 123456789101112131415161718192021222324252627# Compiled class file*.class# Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rarhs_err_pid*.classpath.project.settingstarget.idea*.iml 复制上面的内容创建忽略项配置文件,其实放哪都行,但是为了方便~/git.config使用,一般也放在 ~/目录下 (注: 学过Linux的应该知道,~代表用户家目录,window则是C盘下的用户目录下自己的用户命目录**) 随后打开在用户家目录下的git.config文件,文件内容中添加如下配置 12[core] excludesfile = 刚才的git.ignore文件地址 # 注意: 使用正斜线 &quot;/&quot; ,不要用反斜线 &quot;\\&quot; 在idea使用Git插件在Gitee上分享项目创建远程库的时候,会遇到如下对话框","categories":[{"name":"运维","slug":"运维","permalink":"https://lqy679.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[]},{"title":"JSON","slug":"JSON","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T05:00:19.188Z","comments":true,"path":"2020/01/01/JSON/","link":"","permalink":"https://lqy679.github.io/2020/01/01/JSON/","excerpt":"JSON 参考自菜鸟教程:Java 中 JSON 的使用 | 菜鸟教程 (runoob.com) JSON 简介JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。","text":"JSON 参考自菜鸟教程:Java 中 JSON 的使用 | 菜鸟教程 (runoob.com) JSON 简介JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在javaScrip 一切皆为对象,任何js支持的类型,都可以用JSON来表示 JSON 格式 都以键值对的形式表示, 即 key: value 对象都用 {} 形式为: &#123;&quot;属性1&quot;:属性1的值,&quot;属性2&quot;:属性2的值,&quot;属性3&quot;:属性3的值&#125; 数组(即使包含了多个对象)都用 [] , 形式为: [&#123;&quot;对象1的属性1&quot;:对象1的属性1的值,&quot;对象1的属性2&quot;:对象1的属性2的值&#125;,&#123;&quot;对象2的属性1&quot;:对象2的属性1的值,&quot;对象2的属性2&quot;:对象2的属性2的值&#125;] JSON 转换在JavaScript中:12345678// 假如定义了一个对象 let user = &#123; name:&#x27;mm&#x27;, sex : &#x27;女&#x27; ,age : 19 &#125;; /* JSON转换成字符串 */JSON.stringify(user); //返回一个字符串,内容为: &#123;&quot;name&quot;:&quot;mm&quot; ,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;女&quot;&#125;/* 字符串转换成JSON */let user_text = &#x27;&#123;&quot;name&quot;:&quot;mm&quot; ,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#x27;;JSON.parse(user2_text); //返回一个对象 在Java第三方JSON处理库:Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。 下面是几个常用的 JSON 解析类库： Gson: 谷歌开发的 JSON 库，功能十分全面。 FastJson: 阿里巴巴开发的 JSON 库，性能十分优秀。 Jackson: 社区十分活跃且更新速度很快。 本人强烈推荐Jackson , 因为FastJson存在很多安全漏洞,并且线程不安全 Jackson 参考: 史上最全的Jackson框架使用教程_程序员资源社区的博客-CSDN博客 依赖导入1234567&lt;!--Jackson的Maven依赖--&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.14.1&lt;/version&gt;&lt;/dependency&gt; 快速入门Jackson 最常用的 API 就是基于”对象绑定” 的 ObjectMapper。下面是一个 ObjectMapper 的使用的简单示例。 准备一个实体类Person, 注意: Jackson的反序列化依赖于无参构造,所以实体类一定要有无参构造 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Date;public class Person &#123; // 正常case private String name; // 空对象case private Integer age; // 日期转换case private Date date; // 默认值case private int height; public Person(String name, Integer age, Date date, int height) &#123; this.name = name; this.age = age; this.date = date; this.height = height; &#125; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; public int getHeight() &#123; return height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, date=&quot; + date + &quot;, height=&quot; + height + &#x27;&#125;&#x27;; &#125;&#125; 进行单元测试: 123456789101112131415161718192021222324 ObjectMapper mapper = new ObjectMapper(); // 造数据 Person person = new Person(&quot;Tom&quot;, 40, new Date(), 170); System.out.println(&quot;序列化...&quot;); String jsonString = null; try &#123; // writerWithDefaultPrettyPrinter() 会将序列化的json进行格式化美化// jsonString = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(person); jsonString = mapper.writeValueAsString(person); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; System.out.println(jsonString); System.out.println(&quot;反序列化...&quot;); Person deserializedPerson = null; try &#123; deserializedPerson = mapper.readValue(jsonString, Person.class); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; System.out.println(deserializedPerson); &#125; 打印结果: 1234序列化...&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:40,&quot;date&quot;:1676962157783,&quot;height&quot;:170&#125;反序列化...Person&#123;name=&#x27;Tom&#x27;, age=40, date=Tue Feb 21 14:49:17 CST 2023, height=170&#125; 总结:ObjectMapper 通过 writeValue 系列方法将 java 对象序列化为 json，并将 json 存储成不同的格式，String（writeValueAsString），Byte Array（writeValueAsString），Writer， File，OutStream 和 DataOutput。 ObjectMapper 通过 readValue 系列方法从不同的数据源像 String ， Byte Array， Reader，File，URL， InputStream 将 json 反序列化为 java 对象。 统一配置在调用 writeValue 或调用 readValue 方法之前，往往需要设置 ObjectMapper 的相关配置信息。这些配置信息应用 java 对象的所有属性上。示例如下： 12345678910//在反序列化时忽略在 json 中存在但 Java 对象不存在的属性mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);//在序列化时日期格式是否设置为时间戳,默认为ture, 设置为false变成: yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ,mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);//在序列化时自定义时间日期格式mapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));//在序列化时忽略值为 null 的属性mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);//在序列化时忽略值为默认值的属性mapper.setDefaultPropertyInclusion(JsonInclude.Include.NON_DEFAULT); 更多配置信息可以查看 Jackson 的 DeserializationFeature，SerializationFeature 和 Include。 注解个性化处理Jackson 根据它的默认方式序列化和反序列化 java 对象，若根据实际需要，灵活的调整它的默认方式，可以使用 Jackson 的注解。常用的注解及用法如下。 注解 用法 @JsonProperty 用于属性，把属性的名称序列化时转换为另外一个名称。示例：@JsonProperty(“birth_date”) private Date birthDate @JsonIgnore 可用于字段、getter/setter、构造函数参数上，作用相同，都会对相应的字段产生影响。使相应字段不参与序列化和反序列化。 @JsonIgnoreProperties 该注解是类注解。该注解在Java类和JSON不完全匹配的时候使用。 @JsonNaming 类注解。序列化的时候该注解可将驼峰命名的字段名转换为下划线分隔的小写字母命名方式。反序列化的时候可以将下划线分隔的小写字母转换为驼峰命名的字段名。示例：@JsonNaming(PropertyNamingStrategy.SnakeCaseStrategy.class) @JsonFormat 用于属性或者方法，把属性的格式序列化时转换成指定的格式。示例：@JsonFormat(timezone = “GMT+8”, pattern = “yyyy-MM-dd HH:mm”) public Date getBirthDate() @JsonRootName 类注解。需开启mapper.enable(SerializationFeature.WRAP_ROOT_VALUE)，用于序列化时输出带有根属性名称的 JSON 串，形式如 {“root_name”:{“id”:1,”name”:”zhangsan”}}。但不支持该 JSON 串反序列化。 @JsonPropertyOrder 用于类， 和 @JsonProperty 的index属性类似，指定属性在序列化时 json 中的顺序 ， 示例：@JsonPropertyOrder({ “birth_Date”, “name” }) public class Person @JsonCreator 用于构造方法，和 @JsonProperty 配合使用，适用有参数的构造方法。示例：@JsonCreator public Person(@JsonProperty(“name”)String name) {…} @JsonAnySetter 用于属性或者方法，设置未反序列化的属性名和值作为键值存储到 map 中 @JsonAnySetter public void set(String key, Object value) { map.put(key, value); } @JsonAnyGetter 用于方法 ，获取所有未序列化的属性 public Map&lt;String, Object&gt; any() { return map; } 属性可视化JackSon 默认不是所有的属性都可以被序列化和反序列化。默认的属性可视化的规则如下： 若该属性修饰符是 public，该属性可序列化和反序列化。 若属性的修饰符不是 public，但是它的 getter 方法和 setter 方法是 public，该属性可序列化和反序列化。因为 getter 方法用于序列化， 而 setter 方法用于反序列化。 若属性只有 public 的 setter 方法，而无 public 的 getter 方 法，该属性只能用于反序列化。 若想更改默认的属性可视化的规则，需要调用 ObjectMapper 的方法 setVisibility。 下面的示例使修饰符为 protected 的属性 name 也可以序列化和反序列化。 12345678910111213141516171819202122public static class People &#123; public int age; protected String name;&#125; @Testpublic void test7() throws IOException &#123; ObjectMapper mapper = new ObjectMapper(); // PropertyAccessor 支持的类型有 ALL,CREATOR,FIELD,GETTER,IS_GETTER,NONE,SETTER // Visibility 支持的类型有 ANY,DEFAULT,NON_PRIVATE,NONE,PROTECTED_AND_PUBLIC,PUBLIC_ONLY mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY); // 造数据 People people = new People(); people.name = &quot;Tom&quot;; people.age = 40; System.out.println(&quot;序列化&quot;); String jsonString = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(people); System.out.println(jsonString); System.out.println(&quot;反序列化&quot;); People deserializedPerson = mapper.readValue(jsonString, People.class); System.out.println(deserializedPerson);&#125; 属性过滤在将 Java 对象序列化为 json 时 ，有些属性需要过滤掉，不显示在 json 中 ，除了使用 @JsonIgnore 过滤单个属性或用 @JsonIgnoreProperties 过滤多个属性之外， Jackson 还有通过代码控制的方式。 自定编写一个属性过滤器: 12345678910111213141516171819202122232425262728293031323334@JsonFilter(&quot;myFilter&quot;)public interface MyFilter &#123;&#125; @Testpublic void test8() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //设置 addMixIn mapper.addMixIn(Person.class, MyFilter.class); //调用 SimpleBeanPropertyFilter 的 serializeAllExcept 方法,过滤age属性 SimpleBeanPropertyFilter newFilter = SimpleBeanPropertyFilter.serializeAllExcept(&quot;age&quot;); //或重写 SimpleBeanPropertyFilter 的 serializeAsField 方法 SimpleBeanPropertyFilter newFilter2 = new SimpleBeanPropertyFilter() &#123; @Override public void serializeAsField(Object pojo, JsonGenerator jgen, SerializerProvider provider, PropertyWriter writer) throws Exception &#123; if (!writer.getName().equals(&quot;age&quot;)) &#123; writer.serializeAsField(pojo, jgen, provider); &#125; &#125; &#125;; //设置 FilterProvider FilterProvider filterProvider = new SimpleFilterProvider().addFilter(&quot;myFilter&quot;, newFilter); // 造数据 Person person = new Person(); person.setName(&quot;Tom&quot;); person.setAge(40); // 该属性将被忽略 person.setDate(new Date()); // 序列化 String jsonString = mapper.setFilterProvider(filterProvider).writeValueAsString(person); System.out.println(jsonString);&#125; 运行结果: 1&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;date&quot;:1595780842754&#125; 日期处理不同类型的日期类型，JackSon 的处理方式也不同。 普通日期对于日期类型为 java.util.Calendar, java.util.GregorianCalendar, java.sql.Date, java.util.Date, java.sql.Timestamp，若不指定格式，在 json 文件中将序列化为 long 类型的数据。显然这种默认格式，可读性差，转换格式是必要的。 JackSon 有很多方式转换日期格式。 注解方式，使用 @JsonFormat 注解指定日期格式。 ObjectMapper 方式，调用 ObjectMapper 的方法 setDateFormat，将序列化为指定格式的 string 类型的数据。 Local日期对于日期类型为 java.time.LocalDate, java.time.LocalDateTime，还需要添加代码 mapper.registerModule(new JavaTimeModule())，同时添加相应的依赖 jar 包。 导入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt; &lt;/dependency&gt; 对于 Jackson 2.5 以下版本，需要添加代码 mapper.registerModule(new JSR310Module ())。使用示例： 1234567891011121314151617181920212223242526272829303132333435363738@Datapublic static class Student &#123; // 正常case private String name; // 日期转换case private LocalDateTime date;&#125; @Testpublic void test4() throws IOException &#123; ObjectMapper mapper = new ObjectMapper(); // 必须添加对LocalDate的支持 mapper.registerModule(JavaTimeModule()); // 造数据 Student student = new Student(); student.setName(&quot;Tom&quot;); student.setDate(LocalDateTime.now()); System.out.println(&quot;序列化&quot;); String jsonString = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(student); System.out.println(jsonString); System.out.println(&quot;反序列化&quot;); Student deserializedPerson = mapper.readValue(jsonString, Student.class); System.out.println(deserializedPerson);&#125; private Module JavaTimeModule() &#123; JavaTimeModule module = new JavaTimeModule(); String DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; String DATE_FORMAT = &quot;yyyy-MM-dd&quot;; String TIME_FORMAT = &quot;HH:mm:ss&quot;; module.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DATE_TIME_FORMAT))); module.addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DATE_FORMAT))); module.addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern((TIME_FORMAT)))); module.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DATE_TIME_FORMAT))); module.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DATE_FORMAT))); module.addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(TIME_FORMAT))); return module;&#125; Joda日期对于日期类型为 org.joda.time.DateTime，还需要添加代码 mapper.registerModule(new JodaModule())，同时添加相应的依赖 jar 包 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt; &lt;/dependency&gt; 对象集合Jackson 对泛型反序列化也提供很好的支持 List对于 List 类型 ，可以调用 constructCollectionType 方法来序列化，也可以构造 TypeReference 来序列化。 使用示例： 构造mapper和数据: 12345678910ObjectMapper mapper = new ObjectMapper(); // 造数据 List&lt;Person&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; Person person = new Person(); person.setName(&quot;Tom&quot;); person.setAge(new Random().nextInt(100)); person.setDate(new Date()); list.add(person); &#125; 序列化 123System.out.println(&quot;序列化...&quot;);String jsonInString = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(list);System.out.println(jsonInString); 通过调用 constructCollectionType 方法来反序列化 1234System.out.println(&quot;反序列化：使用 javaType&quot;);CollectionType javaType = mapper.getTypeFactory().constructCollectionType(List.class, Person.class);List&lt;Person&gt; personList = mapper.readValue(jsonInString, javaType);System.out.println(personList); 构造 TypeReference 来反序列化 123System.out.println(&quot;反序列化：使用 TypeReference&quot;);List&lt;Person&gt; personList2 = mapper.readValue(jsonInString, new TypeReference&lt;List&lt;Person&gt;&gt;() &#123;&#125;);System.out.println(personList2); 运行结果: 123456789101112131415161718192021序列化...[ &#123; &quot;name&quot; : &quot;Tom&quot;, &quot;age&quot; : 94, &quot;date&quot; : 1676964663518, &quot;height&quot; : 0&#125;, &#123; &quot;name&quot; : &quot;Tom&quot;, &quot;age&quot; : 5, &quot;date&quot; : 1676964663518, &quot;height&quot; : 0&#125;, &#123; &quot;name&quot; : &quot;Tom&quot;, &quot;age&quot; : 60, &quot;date&quot; : 1676964663518, &quot;height&quot; : 0&#125; ]反序列化：使用 javaType[Person&#123;name=&#x27;Tom&#x27;, age=94, date=Tue Feb 21 15:31:03 CST 2023, height=0&#125;, Person&#123;name=&#x27;Tom&#x27;, age=5, date=Tue Feb 21 15:31:03 CST 2023, height=0&#125;, Person&#123;name=&#x27;Tom&#x27;, age=60, date=Tue Feb 21 15:31:03 CST 2023, height=0&#125;]反序列化：使用 TypeReference[Person&#123;name=&#x27;Tom&#x27;, age=94, date=Tue Feb 21 15:31:03 CST 2023, height=0&#125;, Person&#123;name=&#x27;Tom&#x27;, age=5, date=Tue Feb 21 15:31:03 CST 2023, height=0&#125;, Person&#123;name=&#x27;Tom&#x27;, age=60, date=Tue Feb 21 15:31:03 CST 2023, height=0&#125;] Map对于 map 类型， 与 List 的实现方式相似。 构建ObjectMaper, 造数据 12345678910ObjectMapper mapper = new ObjectMapper(); // 造数据 Map&lt;String, Person&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; Person person = new Person(); person.setName(&quot;Tom&quot;); person.setAge(new Random().nextInt(100)); person.setDate(new Date()); map.put(&quot;key&quot; + i, person); &#125; 序列化基本一致 1String jsonInString = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(map); 通过调用 constructCollectionType 方法来反序列化 12345System.out.println(&quot;反序列化: 使用 javaType&quot;);//第二参数是 map 的 key 的类型，第三参数是 map 的 value 的类型MapType javaType = mapper.getTypeFactory().constructMapType(HashMap.class, String.class, Person.class);Map&lt;String, Person&gt; personMap = mapper.readValue(jsonInString, javaType);System.out.println(personMap); 构造 TypeReference 来反序列化 123System.out.println(&quot;反序列化: 使用 TypeReference&quot;);Map&lt;String, Person&gt; personMap2 = mapper.readValue(jsonInString, new TypeReference&lt;Map&lt;String, Person&gt;&gt;() &#123;&#125;);System.out.println(personMap2); 运行结果: 12345678910111213141516171819202122232425序列化...&#123; &quot;key1&quot; : &#123; &quot;name&quot; : &quot;Tom&quot;, &quot;age&quot; : 57, &quot;date&quot; : 1676964964761, &quot;height&quot; : 0 &#125;, &quot;key2&quot; : &#123; &quot;name&quot; : &quot;Tom&quot;, &quot;age&quot; : 76, &quot;date&quot; : 1676964964761, &quot;height&quot; : 0 &#125;, &quot;key0&quot; : &#123; &quot;name&quot; : &quot;Tom&quot;, &quot;age&quot; : 80, &quot;date&quot; : 1676964964760, &quot;height&quot; : 0 &#125;&#125;反序列化: 使用 javaType&#123;key1=Person&#123;name=&#x27;Tom&#x27;, age=57, date=Tue Feb 21 15:36:04 CST 2023, height=0&#125;, key2=Person&#123;name=&#x27;Tom&#x27;, age=76, date=Tue Feb 21 15:36:04 CST 2023, height=0&#125;, key0=Person&#123;name=&#x27;Tom&#x27;, age=80, date=Tue Feb 21 15:36:04 CST 2023, height=0&#125;&#125;反序列化: 使用 TypeReference&#123;key1=Person&#123;name=&#x27;Tom&#x27;, age=57, date=Tue Feb 21 15:36:04 CST 2023, height=0&#125;, key2=Person&#123;name=&#x27;Tom&#x27;, age=76, date=Tue Feb 21 15:36:04 CST 2023, height=0&#125;, key0=Person&#123;name=&#x27;Tom&#x27;, age=80, date=Tue Feb 21 15:36:04 CST 2023, height=0&#125;&#125; Array 和 Collection 的处理与 List，Map 相似，这里不再赘述。 树模型处理Jackson 也提供了树模型(tree model)来生成和解析 json。若想修改或访问 json 部分属性，树模型是不错的选择。树模型由 JsonNode 节点组成。程序中常常使用 ObjectNode，ObjectNode 继承于 JsonNode，示例如下： 12345678910111213141516171819202122232425262728ObjectMapper mapper = new ObjectMapper(); //构建 ObjectNode ObjectNode personNode = mapper.createObjectNode(); //添加/更改属性 personNode.put(&quot;name&quot;, &quot;Tom&quot;); personNode.put(&quot;age&quot;, 40); ObjectNode addressNode = mapper.createObjectNode(); addressNode.put(&quot;zip&quot;, &quot;000000&quot;); addressNode.put(&quot;street&quot;, &quot;Road NanJing&quot;); //设置子节点 personNode.set(&quot;address&quot;, addressNode); System.out.println(&quot;构建 ObjectNode:\\n&quot; + personNode.toString()); //通过 path 查找节点 JsonNode searchNode = personNode.path(&quot;name&quot;); System.out.println(&quot;查找子节点 name:\\n&quot; + searchNode.asText()); //删除属性 ((ObjectNode) personNode).remove(&quot;address&quot;); System.out.println(&quot;删除后的 ObjectNode:\\n&quot; + personNode.toString()); //读取 json JsonNode rootNode = mapper.readTree(personNode.toString()); System.out.println(&quot;Json 转 JsonNode:\\n&quot; + rootNode); //JsonNode 转换成 java 对象 Person person = mapper.treeToValue(personNode, Person.class); System.out.println(&quot;JsonNode 转对象:\\n&quot; + person); //java 对象转换成 JsonNode JsonNode node = mapper.valueToTree(person); System.out.println(&quot;对象转 JsonNode:\\n&quot; + node); 自定义序列类(不常用)当 Jackson 默认序列化和反序列化的类不能满足实际需要，可以自定义新的序列化和反序列化的类。 自定义序列化类：自定义的序列化类需要直接或间接继承 StdSerializer 或 JsonSerializer，同时需要利用 JsonGenerator 生成 json，重写方法 serialize()， 示例如下： 1234567891011121314public static class CustomSerializer extends StdSerializer&lt;Person&gt; &#123; protected CustomSerializer() &#123; super(Person.class); &#125; @Override public void serialize(Person person, JsonGenerator jgen, SerializerProvider provider) throws IOException &#123; jgen.writeStartObject(); jgen.writeNumberField(&quot;age&quot;, person.getAge()); jgen.writeStringField(&quot;name&quot;, person.getName()); jgen.writeStringField(&quot;msg&quot;, &quot;已被自定义序列化&quot;); jgen.writeEndObject(); &#125;&#125; JsonGenerator 有多种 write 方法以支持生成复杂的类型的 json，比如 writeArray，writeTree 等 。若想单独创建 JsonGenerator，可以通过 JsonFactory() 的 createGenerator。 自定义反序列化类：自定义的反序列化类需要直接或间接继承 StdDeserializer 或 StdDeserializer，同时需要利用 JsonParser 读取 json，重写方法 deserialize，示例如下： 1234567891011121314151617public static class CustomDeserializer extends StdDeserializer&lt;Person&gt; &#123; protected CustomDeserializer() &#123; super(Person.class); &#125; @Override public Person deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException &#123; JsonNode node = jp.getCodec().readTree(jp); Person person = new Person(); int age = (Integer) ((IntNode) node.get(&quot;age&quot;)).numberValue(); String name = node.get(&quot;name&quot;).asText(); person.setAge(age); person.setName(name); return person; &#125;&#125; JsonParser 提供很多方法来读取 json 信息， 如 isClosed(), nextToken(), getValueAsString()等。若想单独创建 JsonParser，可以通过 JsonFactory() 的 createParser。 使用自定义序列类定义好自定义序列化类和自定义反序列化类，若==想在程序中调用它们，还需要注册到 ObjectMapper 的 Module，==示例如下: 123456789101112131415161718ObjectMapper mapper = new ObjectMapper(); // 生成 module SimpleModule module = new SimpleModule(&quot;myModule&quot;); module.addSerializer(new CustomSerializer()); module.addDeserializer(Person.class, new CustomDeserializer()); // 注册 module mapper.registerModule(module); Person person = new Person(); person.setName(&quot;Tom&quot;); person.setAge(40); person.setDate(new Date()); System.out.println(&quot;序列化&quot;); String jsonString = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(person); System.out.println(jsonString); System.out.println(&quot;反序列化&quot;); Person deserializedPerson = mapper.readValue(jsonString, Person.class); 封装工具类根据上述知识点,我们可以对Jackson进行再次封装成一个工具类,方便我们进行使用: 本工具类拥有mapperFactory系列方法用于生成mapper对象, 可以进行自定义的配置, 同时, 工具类还提供了很多简便的转换json的方法 JsonUtility.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.node.ObjectNode;import java.text.SimpleDateFormat;import java.util.Collection;/** * 基于Jackson封装的JSON工具类, * 封装掉复杂的操作,只暴漏简单易用的方法 */public class JsonUtility &#123; private static final String failJsonInfo = &quot;&#123;\\&quot;code\\&quot;:\\&quot;500\\&quot;, \\&quot;msg\\&quot;: \\&quot;Conversion failure\\&quot;&#125;&quot;; private void serializationConfig(ObjectMapper mapper)&#123; this.serializationConfig(mapper,&quot;yyyy-MM-dd HH:mm:ss&quot;, false, false); &#125; private void serializationConfig(ObjectMapper mapper, String dataFormat)&#123; this.serializationConfig(mapper,dataFormat, false, false); &#125; private void serializationConfig(ObjectMapper mapper, boolean isIgnoreNull, boolean isIgnoreDefault)&#123; this.serializationConfig(mapper,&quot;yyyy-MM-dd HH:mm:ss&quot;, isIgnoreNull, isIgnoreDefault); &#125; /** * serializationConfig() * 设置序列化的一些配置 * @param dataFormat: 指定序列化的格式,默认格式为 yyyy-MM-dd HH:mm:ss * @param isIgnoreNull: 设置序列化时是否忽略属性为null的值, 默认为 false, 不忽略 * @param isIgnoreDefault: 设置序列化时是否忽略属性值为默认值的值, 默认为 false, 不忽略 */ private void serializationConfig(ObjectMapper mapper, String dataFormat, boolean isIgnoreNull, boolean isIgnoreDefault)&#123; mapper.setDateFormat(new SimpleDateFormat(dataFormat)); if (isIgnoreNull) &#123; mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); &#125; if (isIgnoreDefault)&#123; mapper.setDefaultPropertyInclusion(JsonInclude.Include.NON_DEFAULT); &#125; &#125; /** * 对反序列化进行一些配置, * @param isIgnoreUnknownProperty: 反序列化时是否忽略在 json 中存在但 Java 对象不存在的属性,默认为true,忽略 */ private void deSerializationConfig(ObjectMapper mapper, boolean isIgnoreUnknownProperty)&#123; if (isIgnoreUnknownProperty)&#123; mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); &#125; else &#123; mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true); &#125; &#125; // 返回一个默认配置的 mapper public ObjectMapper mapperFactory()&#123; ObjectMapper mapper = new ObjectMapper(); this.serializationConfig(mapper); return mapper; &#125; public ObjectMapper mapperFactory(String dataFormat)&#123; ObjectMapper mapper = new ObjectMapper(); this.serializationConfig(mapper, dataFormat); return mapper; &#125; public ObjectMapper mapperFactory(boolean isIgnoreNull,boolean isIgnoreDefault)&#123; ObjectMapper mapper = this.mapperFactory(&quot;yyyy-MM-dd HH:mm:ss&quot;, isIgnoreNull, isIgnoreDefault, true); return mapper; &#125; public ObjectMapper mapperFactory(String dataFormat,boolean isIgnoreNull,boolean isIgnoreDefault)&#123; ObjectMapper mapper = this.mapperFactory(dataFormat, isIgnoreNull, isIgnoreDefault, true); return mapper; &#125; // 返回自定义配置的mapper public ObjectMapper mapperFactory(String dataFormat,boolean isIgnoreNull,boolean isIgnoreDefault,boolean isIgnoreUnknownProperty)&#123; ObjectMapper mapper = new ObjectMapper(); this.serializationConfig(mapper, dataFormat, isIgnoreNull, isIgnoreDefault); this.deSerializationConfig(mapper, isIgnoreUnknownProperty); return mapper; &#125; // 将Java对象转换成没有格式化的JSON字符串 public String jsonParser_ByObject(ObjectMapper mapper, Object object)&#123; return this.jsonParser_ByObject(mapper, object,false); &#125; /** * 将Java对象转换成一个JSON字符串 * @param mapper 根据传入的mapper对象的进行转换 * @param object 需要转换成JSON的Java对象,可以是集合,如List,Map * @param isFormat 是否返回一个经过格式化美化的JSON,默认为 false 不美化 * @return String:返回一个JSON字符串 */ public String jsonParser_ByObject(ObjectMapper mapper, Object object, boolean isFormat)&#123; String jsonString = JsonUtility.failJsonInfo; try &#123; if (isFormat)&#123; jsonString = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(object); &#125; else&#123; jsonString = mapper.writeValueAsString(object); &#125; &#125; catch (JsonProcessingException e) &#123; System.err.println(object+&quot;转换json失败!&quot;); e.printStackTrace(); &#125; return jsonString; &#125; /** * 将 JSON字符串解析成 Java对象 * @param mapper 根据传入的mapper对象的进行转换 * @param jsonString 需要解析JSON字符串 * @param aClass 根据 Class 推导 Java对象的类型1 * @return 返回解析好的 Java对象 */ public Object objectParser_ByJSON(ObjectMapper mapper, String jsonString, Class aClass)&#123; Object o = null; try &#123; o = mapper.readValue(jsonString, aClass); &#125; catch (JsonProcessingException e) &#123; System.err.println(jsonString+&quot;解析失败!&quot;); e.printStackTrace(); &#125; return o; &#125; /** * * @param mapper 根据传入的mapper对象的配置信息进行转换 * @param jsonString 需要解析的json字符串 * @param type 提供一个类型引用实例, 例如 new TypeReference&lt;Map&lt;String, Object&gt;&gt;()&#123;&#125; 或 new TypeReference&lt;List&lt;Objectr&gt;&gt;&#123;&#125; * @param &lt;E&gt; 类型参数, 即使 集合元素类型 * @return 返回解析好的 集合对象 */ public &lt;E&gt; Collection collectionParser_ByJSON(ObjectMapper mapper, String jsonString, TypeReference&lt;E&gt; type)&#123; Collection collection = null; try &#123; collection = (Collection) mapper.readValue(jsonString, type); &#125; catch (JsonProcessingException e) &#123; System.err.println(jsonString+&quot;解析失败!指定解析的类型为:&quot;+type); e.printStackTrace(); &#125; return collection; &#125; /** * 根据传入的 mapper对象的映射规则将 json字符串解析成 JSON节点树形对象 * @param mapper * @param jsonString 需要的解析json对象 * @return 返回的 JSON节点树形对象 */ public JsonNode readJsonToNode(ObjectMapper mapper, String jsonString)&#123; JsonNode jsonNode = null; try &#123; jsonNode = mapper.readTree(jsonString); &#125; catch (JsonProcessingException e) &#123; System.err.println(jsonString+&quot;解析失败!&quot;); e.printStackTrace(); &#125; return jsonNode; &#125; /** * 将json节点对象转换成 Java对象 * @param mapper 映射器对象 * @param jsonNode 需要转换的 json节点对象 * @param aClass 转换后的Java对象的Class * @return 返回转换好的 对象 */ public Object readNodeToObject(ObjectMapper mapper, JsonNode jsonNode, Class aClass)&#123; Object object = null; try &#123; object = mapper.treeToValue(jsonNode, aClass); &#125; catch (JsonProcessingException e) &#123; System.err.println(jsonNode+&quot;节点转换失败!&quot;); e.printStackTrace(); &#125; return object; &#125; /** * 为 指定的 objectNode 添加基本属性(不包括对象类型的属性),相当于为json对象添加或者设置属性 * @param node 需要添加或者修改属性值的 对象节点, 即使json对象 * @param key 属性名, 不存在则添加该属性,存在则修改该属性 * @param value 属性值, 需要添加或者修改的属性值 * @throws Exception 当时 传入的 value 类型 不是 int ,double, boolean, String 任意一个时,会抛出异常 */ public void setAttribute(ObjectNode node, String key, Object value) throws Exception &#123; String type = null; type = value instanceof String ? &quot;String&quot; : type; type = value instanceof Integer ? &quot;int&quot; : type; type = value instanceof Double ? &quot;double&quot; : type; type = value instanceof Boolean ? &quot;boolean&quot; : type; if (type == null)&#123; throw new Exception(&quot;value 不能为 null !&quot;); &#125; switch (type)&#123; case &quot;String&quot;: &#123; node.put(key, (String) value); break; &#125; case &quot;int&quot;: &#123; node.put(key, (Integer) value); break; &#125; case &quot;double&quot;: &#123; node.put(key, (Double) value); break; &#125; case &quot;boolean&quot;: &#123; node.put(key, (Boolean) value); break; &#125; default: &#123; throw new Exception(&quot;value参数类型错误!只能为int, double, String, boolean&quot;); &#125; &#125; &#125; /** * 给指定节点添加对象属性 * @param node 指定节点 * @param key 属性名,存在则修改,不存在则新建 * @param value 对象属性 */ public void setNodeAttribute(ObjectNode node, String key, ObjectNode value)&#123; node.set(key, value); &#125; // 删除指定节点的指定属性 public void removeAttribute(ObjectNode objectNode, String key)&#123; objectNode.remove(key); &#125; // 查找指定节点 public JsonNode findNode(JsonNode jsonNode, String key)&#123; return jsonNode.path(key); &#125;&#125; FastJson依赖导入123456&lt;!--FastJson的Maven依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; 流程说明:java变量 &lt;--&gt; JSON对象 &lt;--&gt; 字符串 将java变量转换为JSON12345678910111213141516public void testJson() &#123; JSONObject object = new JSONObject(); //string object.put(&quot;string&quot;,&quot;string&quot;); //int object.put(&quot;int&quot;,2); //boolean object.put(&quot;boolean&quot;,true); //array List&lt;Integer&gt; integers = Arrays.asList(1,2,3); object.put(&quot;list&quot;,integers); //null object.put(&quot;null&quot;,null); System.out.println(object);//打印结果: &#123;&quot;boolean&quot;:true,&quot;string&quot;:&quot;string&quot;,&quot;list&quot;:[1,2,3],&quot;int&quot;:2&#125; &#125; 将JSON转换为java变量12345678910111213141516171819202122232425262728public void testJson2() &#123; JSONObject object = JSONObject .parseObject(&quot;&#123;\\&quot;boolean\\&quot;:true,\\&quot;string\\&quot;:\\&quot;string\\&quot;,\\&quot;list\\&quot;:[1,2,3],\\&quot;int\\&quot;:2&#125;&quot;); //string String s = object.getString(&quot;string&quot;); System.out.println(s); //int int i = object.getIntValue(&quot;int&quot;); System.out.println(i); //boolean boolean b = object.getBooleanValue(&quot;boolean&quot;); System.out.println(b); //list List&lt;Integer&gt; integers = JSON.parseArray(object.getJSONArray(&quot;list&quot;).toJSONString(),Integer.class); integers.forEach(System.out::println); //null System.out.println(object.getString(&quot;null&quot;));&#125;/* 打印结果:string2true123null*/ 方法使用 方法 作用 JSON.parseObject(String) 将字符串解析为 JSON 对象 JSON.parseArray(String) 将从字符串解析为 JSON 数组 JSON.toJSONString(obj/array) 将 JSON 对象或 JSON 数组转化为字符串 实例: 12345678//将字符串解析为JSON对象JSONObject obj = JSON.parseObject(&quot;&#123;\\&quot;runoob\\&quot;:\\&quot;菜鸟教程\\&quot;&#125;&quot;);//从字符串解析为JSON数组JSONArray arr = JSON.parseArray(&quot;[\\&quot;菜鸟教程\\&quot;,\\&quot;RUNOOB\\&quot;]\\n&quot;);//将JSON对象转化为字符串String objStr = JSON.toJSONString(obj);//将JSON数组转化为字符串String arrStr = JSON.toJSONString(arr);","categories":[{"name":"常用知识笔记","slug":"常用知识笔记","permalink":"https://lqy679.github.io/categories/%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Linux快速入门","slug":"Linux常用命令","date":"2020-01-01T10:57:32.000Z","updated":"2023-04-04T08:33:19.247Z","comments":true,"path":"2020/01/01/Linux常用命令/","link":"","permalink":"https://lqy679.github.io/2020/01/01/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"Linux 快速入门可以通过 tab键来补全提示命令或者目录,终端命令的格式: 命令 [-选项,多个选项可以结合写] [参数] , 大多数情况可以通过 ctrl c 退出命令 磁盘管理123456789101112131415161718192021222324252627282930313233343536373839404142pwd # 查看当前所在目录 即:print wrok directoryls [-[l][,h][,a]] [目录] # 查看目录下的所有文件和目录,默认查看当前目录下的 即:list# 选项 l 代表以列表形式展现,a即 all,显示所有文件包括隐藏的,隐藏文件的特征是文件命名最前面有一个点 .# ls 命令可配合通配符(即正则表达式)使用# 通配符 : * 代表任意个字符 ? 代表任意一个字符 [] 代表字符组中的任意一个(即范围)(如[abc]代表有abc中任意一个,[a-z]代表任意一个小写字母)tree [目录名] # 以树状图的形式列出文件目录cd 目录名 #切换目录# 目录名可以使用相对路径和绝对路径 相对路径中: . 代表当前目录, .. 代表上一级目录 即:change directory# cd ~ 切换到该用户的Home目录mkdir 目录名 # 创建目录 即:make directory 选项: -p可以创建多级目录 touch 文件名 # 创建文件 如果不存在则新建文件,存在则修改文件末次修改时间 rm 文件名 #删除(不经过回收站),也可结合通配符使用 即: remove 选项 -r 则删除目录, 默认删除文件 -f 不提示删除clear #清屏 cp 原文件 目标文件 #即: copy,拷贝文件 mv 原文件 目标文件 #即: move 移动文件或者重命名文件# cp和mv均有命令选项 -i , 覆盖前提示, 默认不提示, -r 操作目录#查看文件内容cat 文件名 #即:concatenate, 查看文件内容,创建文件,合并文件,追加文件内容等功能 #选项: -n 对所有行进行编号(行号) , -b 对非空行进行编号more 文件名 #以分页模式查看,按空格键下一页,回车下一行, b 回滚前一页,f前滚一页, /word 即可搜索word字符串#查找文件find [路径] -name &quot;查找内容&quot; # 查找文件,可结合正则表达式使用,不写目录默认在当前目录查找,#选项-name,代表根据文件名查找 , 如 find -name &quot;.txt&quot; 查找当前目录下后缀名为txt的文件grep 搜索内容(如果有空格,用引号包裹) 文件 #即:搜索指定文件的内容,可结合正则表达式使用#选项: -n 显示匹配的行及行号, -i 忽略大小写 , -v显示不包括匹配文本的所有行(相当于求反)#命令参数: ^string 行首匹配,如 grep ^string a.txt 搜索以stirng开头的行; str$ 行尾匹配,搜索str结尾的行echo 参数(可以是文本或者执行命令后的结果) #输出参数,默认输出到终端,通常配合重定向使用;#重定向 &gt; 和 &gt;&gt; # &gt; 文件 代表将文件内容重写,不存在则新建文件, &gt;&gt; 文件 代表向文件追加内容#如 echo hello &gt; a.txt 则会向a.txt中内容重写为 hello , ls &gt; a.txt 则向文件中输出 ls命令的结果内容管道 | # 即: 将一个命令的输出可以通过管道作为另一个命令的输出# 如 ls -lha ~ | more 将用户home目录分页显示, ls -lha ~ | grep -n root 查找用户home目录中带有root的记录","text":"Linux 快速入门可以通过 tab键来补全提示命令或者目录,终端命令的格式: 命令 [-选项,多个选项可以结合写] [参数] , 大多数情况可以通过 ctrl c 退出命令 磁盘管理123456789101112131415161718192021222324252627282930313233343536373839404142pwd # 查看当前所在目录 即:print wrok directoryls [-[l][,h][,a]] [目录] # 查看目录下的所有文件和目录,默认查看当前目录下的 即:list# 选项 l 代表以列表形式展现,a即 all,显示所有文件包括隐藏的,隐藏文件的特征是文件命名最前面有一个点 .# ls 命令可配合通配符(即正则表达式)使用# 通配符 : * 代表任意个字符 ? 代表任意一个字符 [] 代表字符组中的任意一个(即范围)(如[abc]代表有abc中任意一个,[a-z]代表任意一个小写字母)tree [目录名] # 以树状图的形式列出文件目录cd 目录名 #切换目录# 目录名可以使用相对路径和绝对路径 相对路径中: . 代表当前目录, .. 代表上一级目录 即:change directory# cd ~ 切换到该用户的Home目录mkdir 目录名 # 创建目录 即:make directory 选项: -p可以创建多级目录 touch 文件名 # 创建文件 如果不存在则新建文件,存在则修改文件末次修改时间 rm 文件名 #删除(不经过回收站),也可结合通配符使用 即: remove 选项 -r 则删除目录, 默认删除文件 -f 不提示删除clear #清屏 cp 原文件 目标文件 #即: copy,拷贝文件 mv 原文件 目标文件 #即: move 移动文件或者重命名文件# cp和mv均有命令选项 -i , 覆盖前提示, 默认不提示, -r 操作目录#查看文件内容cat 文件名 #即:concatenate, 查看文件内容,创建文件,合并文件,追加文件内容等功能 #选项: -n 对所有行进行编号(行号) , -b 对非空行进行编号more 文件名 #以分页模式查看,按空格键下一页,回车下一行, b 回滚前一页,f前滚一页, /word 即可搜索word字符串#查找文件find [路径] -name &quot;查找内容&quot; # 查找文件,可结合正则表达式使用,不写目录默认在当前目录查找,#选项-name,代表根据文件名查找 , 如 find -name &quot;.txt&quot; 查找当前目录下后缀名为txt的文件grep 搜索内容(如果有空格,用引号包裹) 文件 #即:搜索指定文件的内容,可结合正则表达式使用#选项: -n 显示匹配的行及行号, -i 忽略大小写 , -v显示不包括匹配文本的所有行(相当于求反)#命令参数: ^string 行首匹配,如 grep ^string a.txt 搜索以stirng开头的行; str$ 行尾匹配,搜索str结尾的行echo 参数(可以是文本或者执行命令后的结果) #输出参数,默认输出到终端,通常配合重定向使用;#重定向 &gt; 和 &gt;&gt; # &gt; 文件 代表将文件内容重写,不存在则新建文件, &gt;&gt; 文件 代表向文件追加内容#如 echo hello &gt; a.txt 则会向a.txt中内容重写为 hello , ls &gt; a.txt 则向文件中输出 ls命令的结果内容管道 | # 即: 将一个命令的输出可以通过管道作为另一个命令的输出# 如 ls -lha ~ | more 将用户home目录分页显示, ls -lha ~ | grep -n root 查找用户home目录中带有root的记录 系统与设备信息123456789101112131415161718192021222324#关机/重启shutdown [选项] [时间] #不写选项默认是关机, 不写时间默认一分钟后#选项: -r 重启 -c 取消执行计划 时间: now 现在执行, 20:00 今天晚上8点执行, +10 10分钟后执行#查看或配置网卡信息ping ip地址 #即:访问ip, 按 CTRL C 退出命令ifconfig #即: configure a network interface , 查看网卡配置信息#使用SSH命令远程控制ssh [-p port] user@remote #不设置选项默认为ssh默认端口22, remote可以是IP地址,域名,或者别名date #显示系统时间cal # 显示系统日历, calendar 的缩写df -h # disk free 显示磁盘剩余量, 选项 -h 显示得更人性化 du -h [目录名] # 显示目录的文件大小, 不写目录名默认是当前目录, 选项 -h 显示更加人性化# 进程信息ps aux # process status 查看进程详细情况,参数 a 代表 所有用户的进程, u显示详细状态, x显示没用控制终端的进程 ,top #动态显示运行的进程并且排序 , 退出直接输入 q kill [-9] 进程id # 结束进程, 选项 -9 代表强行终止#查看端口占用情况(查看占用端口的PID)sudo netstat -nultp #查看所有得端口占用情况,状态为listen则表示为占用sudo netstat -anp |grep 端口号 #查看指定端口的PID 权限与用户组使用 ls 命令查看文件列表时, 可以看到文件所属的用户和组,以及相关权限 在/etc/passwd文件中,保存了用户的信息 权限管理命令123456789101112131415161718192021222324252627282930313233# 权限管理chmod +或- 权限(rwx均可) #文件或者目录 即: 增加(+) 或减少(-) 权限 ,#针对目录而言, x即可执行权限决定目录是否能打开或执行命令, #目录的可读权限决定目录能否查看目录里的内容,#可写权限决定是否能修改目录的内容(比如增减文件)#并且可指定用户的权限 , u (代表user) , g(代表group), o(代表other)#例如: chmod o-rwx file 代表其他人不能读写执行此文件, chomd u+rw file 代表文件所属用户可以读写文件chmod 权限(数字表示) 文件或目录名 # 修改权限 , 选项 -R 递归修改子目录#拓展: chmod 命令的权限用数字表示, 单个权限数字表示: r 对应 4, w 对应 2 , x 对应 1 ,#多个权限将权限数字加起来 如 rwx 权限为 7, rw- 权限为 6, r-w为 5, -wx 为3, 无任何权限为0#例如: chmod 763 文件或目录 # 这样即为数字表示,其中763依次代表 文件拥有者, 所属组, 其他用户 所对应的权限sudo 命令 #借用root用户权限执行命令,管理组只能由超级用户root权限执行 su 即 substitute user 的缩写# 管理组chgrp 组名 文件或目录 # 修改组,选项 -R 递归修改子目录groupadd 组名 #即: 添加组groupdel 组名 #即: 删除组chgrp 组名 文件或目录 #即: 修改文件或目录的所属组, 选项 -R 递归的修改目录所属组(即该目录以及所有子目录都修改所属组)#用户管理su 用户名 # 切换用户, 选项 -l 切换的同时切换home目录chown 用户名 文件名或目录名 # 修改文件所属者useradd 用户名 #即 添加用户, 但是这样添加的用户默认是没有管理员权限,无法使用 sudo命令, # 选项: -m 自动创建用户home目录,默认不创建, -g 指定所在的组,默认在创建一个同名的组加入userdel 用户名 #即 删除用户, 选项 -r 删除该用户的 home目录,默认不删除home目录passwd 新密码 #即修改当前用户密码id [用户名] #即 : 查询用户的id和所属的组的id, 不指定用户名则查询当前用户who #即 查询当前主机登陆了哪些用户usermod [-g或-G] 组 用户名 # 设置用户的主组或者附加组,设置后需要重新登陆,选项 -g 设置主组, -G设置附加组, -s 设置登陆shell# 主组,即用户所属的组, 附加组为用户附加的权限,常见的附加组有: sudo ,adm,cdrom等which 命令(如ls, passwd等命令) # 查看命令程序文件所在的目录位置 文件打包压缩与软件安装管理12345678910111213141516#打包压缩tar 命令只打包不压缩tar -cvf 要打包文件名.tar 被打包的文件 # 打包 ,选项带 -ctar -xvf 包文件名.tar # 打开被打包的文件, 选择带 -x#gzip压缩#压缩要使用到gzip 命令,压缩包的后缀是 xxx.tar.gz,但可在tar命令添加选项 -z自动调用压缩命令tar -zcvf 压缩包文件名.tar.gz #被压缩的文件,多个文件用空格隔开 # 压缩文件tar -zxvf 压缩包文件名.tar.gz [-C 目标路径] # 解压文件, 其中 -C 选项可以指定解压路径bzip2(读two)压缩与gzip 压缩差不多, 区别是在 tar命令第一个命令选项将z替换成 j#软件安装卸载/更新(需使用root 权限),需说明一下,Linux分两大类,ubuntu这种通常用apt-get, CentOS通常用yum,dapt install 软件名 #安装, 其中apt 是 Advanced Package Toolapt remove 软件名 #卸载apt upgrade #检查更新软件 常见软件环境安装12345#sshsudo apt-get install openssh-server #安装sshsudo service ssh start #启动sshsudo ps -e |grep ssh #查看ssh服务是否启动 vim编辑器使用vim 有三种模式: 只读模式(打开默认进入) 可写模式(在只读模式下按a键或i键可切换) ,在此模式下按 Esc 可以退出可写模式重新回到只读模式 命令行模式(按shift + ; 或者大写模式下的 :) , 1vim 文件名 #使用vim 打开文件(文件不存在则新建) 保存或者退出: 在命令行模式下, 输入: ==q!== 强制退出不保存 , ==wq== 保存退出 显示/隐藏行号: 在命令行模式下, 输入: set nu / set nonu 搜索关键字: 在命令行模式下 , 输入 : ==/ 搜索的内容== 撤回: 在命令行模式下 ,输入: u 取消撤回: 在只读模式下 , 按 Ctrl 和 r 删除行和转换至某行: 在只读模式下 , 按 dd 删除某行 , 按 n 和 shift 跳转到某行 软连接和硬链接在Linux中,文件名与文件数据是分开存储的 软连接相当于window系统的快捷方式 软连接与硬链接的区别是被链接的源文件删除后,软连接就会失效,但硬链接依然不受影响 Shellshell基本概念:什么是shell ?shell(外壳) 是一个用c语言编写的程序 , 它是用户使用linux的桥梁, shell 既是一种命令语言 , 又是一种程序设计语言 shell 是指一种应用程序, 这个应用程序提供了一个界面, 用户通过这个界面访问操作系统内核的服务 什么是脚本?脚本简单说就是一条条的文字命令 , 这些命令是可以看到的(可以用文本编辑器编辑) , 常见的脚本: JavaScript , VBscript , ASP , JSP, PHP , Shell , python ,Ruby , JavaFx Shell 种类在linux中有很多类型的shell , 不同的shell 具备不同的功能 ,shell还决定了脚本中函数的语法, linux中默认的shell 是 ==/bin/bash== , 流行的shell 有 : ash , bash , ksh , csh , zsh shell 入门编写一个hello.sh , 内容如下: 1echo &quot;hello world&quot; ; 随后使用chmod hello.sh +rwx 给文件添加权限 , 最后运行命令 ./hello.sh , **注意: 即使在当前目录下也不能使用hello.sh**去运行 , 因为这样系统会去寻找Path(即系统环境变量)下的路径,而Path里只有: /bin , /sbin , /user/sbin 等路径 Shell变量12345#定义变量:变量名=值 #注意:变量后的等号前后不能空格#使用变量: $变量echo $变量名 #打印变量 ==注意事项:== 变量命名规范与大多数C语言类似,不支持中文汉字,并且在变量名后面的等号不能有空格 ,不可使用关键字(可用help命令查询) 反引号引用自带命令123456#内置显示时间命令data +&quot;%F %T&quot; #显示当前时间,格式为 年-月-日 00:00:00#shell内容mg=`data +&#x27;%F %T&#x27;` ;echo $mg ; 接受用户输入语法格式; 1read -p &quot;提示信息&quot; 变量名 如下例子演示接受用户输入的文件路径然后根据此字符串创建文件 1234read -p &quot;Enter the path name of the file you want to create!&quot; filePath ;touch $filePath ;echo the file created! ; #打印提示信息ls -lh $filePath #显示文件信息 扩展:只读变量(常量): 语法格式: 1readonly 变量名 #此变量会被修饰被常量 扩展:删除变量: 语法格式: 1unset 变量名 条件判断语句 参考:Shell 流程控制 | 菜鸟教程 (runoob.com) shell 中貌似没有 switch 语句, 与大多数编程语言不同: 没有{} ,而是采用了then , if语句最后结束要加个 fi , 条件内容不需要加括号 , else if 写成了 elif 注意!!! 条件表达式 想使用 &lt;, &gt; , =&lt;, &gt;= 等符号 表达式格式为: (( 条件 )) 123456789101112131415161718192021222324#语法1:if 条件then 语句(块)fi#语法2:if 条件then 语句(块)else 语句(块)fi#语法3;if 条件3then 语句(块)elif 条件then 语句(块)else 语句(块)fi 运算符**原生bash不支持简单的数学运算 ,但是可以通过其他命令来实现,例如 awk , expr(最常用) , ==注意:除了赋值等号之间不能用空格隔开,其大多数都必须用空格隔开== ** expr是一款表达式计算工具, 如可以在终端中使用命令expr 2 + 2 , 需要注意的是: ==表达式中的运算数和运算符之间要有空格隔开,这里与大多数编程语言不同== 由于expr也是一个原生命令 , 故在shell中使用时需要用 反引号包裹 例如: 12val=`expr 2 + 2` ; echo &quot;$val&quot; ; 算术运算符 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：==条件表达式要放在方括号之间，并且要有空格==，例如: [$a==$b] 是错误的，必须写成 **[ $a == $b ]**。 例: 12345678910a=10 ;b=20 ;echo &quot;a=$a,b=$b&quot;echo &quot;a+b=&quot; `expr $a + $b`echo &quot;a-b=&quot; `expr $a - $b`echo &quot;a*b=&quot; `expr $a \\* $b` # 注意:*原指的 通配符 , 所以乘法需要转义 \\*echo &quot;a/b=&quot; `expr $a / $b`echo &quot;a%b=&quot; `expr $a % $b` 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。**(equal)** [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 (not equal ) [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。**(相当于 &gt; , greater than)** [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。**(相当于 &lt; , less than)** [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。**( &gt;= ,greater than equal)** [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。**(&lt;= , less than equal)** [ $a -le $b ] 返回 true。 逻辑(布尔)运算符下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 注意: 使用下面的逻辑运算符需要 用两个 方括号d 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false || 逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true 字符串运算符下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否不相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否不为 0，不为 0 返回 true。 [ -n “$a” ] 返回 true。 $ 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 文件测试运算符d 操作符 说明 举例 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -b file 检测文件是否是块设备文件(如u盘之类的)，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 shell脚本附带参数选项自定义的shell 脚本其实也可以设置命令选项, 接收选项的方式通过 $1 $2 $3 $4 等去接受, 分别代表了第一个选项,第二个选项第三个选型 … 1234#讲命令选型打印出来 , $0表示脚本文件自身echo $1echo $2echo $3 案例:自定义命令user -add 用户名 添加用户, user -del 用户名 删除用户 , 编写shell文件, 123456789if [$1 = &quot;-add&quot;]then useradd $2 ; elif [$1 = -del]then userdel -r $2 ;else echo &quot;命令有误!&quot;if 随后定义别名 , 在~/.bashrc文件中添加如下内容: 1alias user=&#x27;shell文件路径及文件名.sh&#x27; 别名(alias)Linux允许我们给脚本文件或者内置命令自定义别名 , 别名配置信息都存储在~/.bashrc,文件, 1alias -p #查看已经设置的别名 ==注意:添加别名后需要切换一下用户才能生效== SSH远程链接 安装SSH 根据主机ip进行链接 CentOS 命令补充防火墙放行 1234567891011firewall-cmd --permanent --add-service=dnsfirewall-cmd --permanent --add-service=ftpfirewall-cmd --permanent --add-service=httpfirewall-cmd --reload # 查看放行的服务: firewall-cmd --list-services# 关闭SELinux,重启后失效setenforce 0# 查看是否SELinx关闭成功, 成功提示 Permissivegetenforce 网卡相关配置 12345678910# 查看网卡信息nmcli device# 添加连接nmcli connection add con-name 连接名 ifname 网卡名 type ethernet# 修改ip地址nmcli connection modify 连接名 ipv4.method manual ipv4.addresses IP地址/网络位# 激活连接nmcli connection up 连接名#查看所有链接nmcli connection show","categories":[{"name":"运维","slug":"运维","permalink":"https://lqy679.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[]},{"title":"Maven课程教案","slug":"Maven课程教案","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T07:51:25.078Z","comments":true,"path":"2020/01/01/Maven课程教案/","link":"","permalink":"https://lqy679.github.io/2020/01/01/Maven%E8%AF%BE%E7%A8%8B%E6%95%99%E6%A1%88/","excerpt":"Maven课程教案课程介绍 课程目录 课程目标 01. 知识点 - Maven 概述 认识 Maven 02. 实操 - Maven 下载与安装 完成 Maven的下载与安装 03. 知识点 - Maven 结构与配置 了解 Maven的结构与配置 04. 知识点 - Maven 仓库与坐标 认识 Maven的仓库与坐标 05. 知识点 - Maven 项目的结构 认识 约定结构与pom文件 06. 实操 - 手动创建 Maven项目 完成 第一个项目的创建 07. 实操 - 模板创建 Maven项目 认识 模板创建的方法 08. 实操 - Idea创建 Maven项目 完成 Idea集成Maven 09. 知识点 - Maven 生命周期 认识 Maven的生命周期 10. 实操 - 常用构建命令 11. 知识点 - Maven 插件介绍 了解 Maven插件的作用 12. 实操 - 生成项目站点 13. 知识点 - Maven 依赖管理 掌握 Maven的依赖管理 14. 知识点 - 项目模块化开发 了解 项目的模块化开发 15. 实操 - Maven 项目继承与聚合 掌握 项目继承配置 16. 实操 - 测试项目的代码编写 测试以上配置 重点难点","text":"Maven课程教案课程介绍 课程目录 课程目标 01. 知识点 - Maven 概述 认识 Maven 02. 实操 - Maven 下载与安装 完成 Maven的下载与安装 03. 知识点 - Maven 结构与配置 了解 Maven的结构与配置 04. 知识点 - Maven 仓库与坐标 认识 Maven的仓库与坐标 05. 知识点 - Maven 项目的结构 认识 约定结构与pom文件 06. 实操 - 手动创建 Maven项目 完成 第一个项目的创建 07. 实操 - 模板创建 Maven项目 认识 模板创建的方法 08. 实操 - Idea创建 Maven项目 完成 Idea集成Maven 09. 知识点 - Maven 生命周期 认识 Maven的生命周期 10. 实操 - 常用构建命令 11. 知识点 - Maven 插件介绍 了解 Maven插件的作用 12. 实操 - 生成项目站点 13. 知识点 - Maven 依赖管理 掌握 Maven的依赖管理 14. 知识点 - 项目模块化开发 了解 项目的模块化开发 15. 实操 - Maven 项目继承与聚合 掌握 项目继承配置 16. 实操 - 测试项目的代码编写 测试以上配置 重点难点 难点用高亮标识 01. Maven是什么 02. Maven有什么用 03. Maven项目结构 04. Maven生命周期 05. ==Maven依赖管理== 06. ==Maven模块化开发== 01. 知识点 - Maven 概述1.目标 了解Maven是什么 了解Maven有什么用 2.路径 Maven 的简介 Maven 的作用 3.讲解3.1 Maven 的简介 ​ Apache Maven是一个强大的、服务于 Java 平台的项目管理工具。 ​ Maven 是一个可以用于构建和管理任何基于Java的项目的工具，它可以使Java开发人员的日常工作变得更轻松，并且通常有助于理解任何基于Java的项目。 ​ Maven是使用Java语言开发的 ，可以对Java项目进行构建、依赖管理。当然Maven也可以被用于构建和管理各种项目，例如C#，Ruby，Scala和其他语言编写的项目。 3.2 Maven 的作用3.2.1 使用Maven 可以实现项目的自动化构建 ​ Maven 使用标准的目录结构和默认构建生命周期，我们可以使用它自动完成项目的基础工具建设。 3.2.2 使用Maven 可以自动管理项目的依赖 ​ Maven 提供了强大的中央仓库，能够帮助我们自动下载依赖。 3.2.3 使用Maven 可以自动生成项目报告 ​ Maven 提供了有用的项目信息，可以生成项目站点与文档。 4.小结 Maven是什么 ​ 管理项目的软件 Maven有什么用 ​ 构建项目，管理依赖，生成报告 02. 实操 - Maven 下载与安装1.目标 完成Maven的下载 完成Maven的安装 2.路径 使用前说明 Maven下载 Maven安装 3.讲解3.1 使用前说明 ​ Maven本身就是基于Java写的，所以在安装配置Maven之前，有必要将Java的运行环境安装配置好。 ​ 需要注意Maven版本依赖的JDK版本。 3.2 Maven下载 ​ Maven官网：http://maven.apache.org ​ 下载步骤：登录官网，进入下载页面，选择对应环境与版本。 3.3 Maven安装 ​ 下载完成解压后即可完成安装 ​ 通过调用bin目录下命令使用，全局使用则需要配置环境变量 ​ 注意：解压路径建议 无空格，无中文 4.小结 安装前注意 安装Java环境 下载时注意 选择版本 安装后注意 配置环境变量 配置后注意 测试 03. 知识点 - Maven 结构与配置1.目标 了解Maven软件的结构 了解Maven软件的配置 2.路径 Maven软件结构 Maven配置概述 配置本地仓库位置 配置阿里云镜像地址 3.讲解3.1 Maven软件结构 ​ Maven软件解压后的文件结构如下 目录 介绍 bin 该目录中包含了 mvn 的运行脚本。 boot 该目录只有一个类加载器Jar，对于一般的Maven用户来说，不必关心该文件。 conf 该目录中包含了Maven配置文件，配置Maven行为。 lib 该目录中包含了所有 Maven 运行时需要的 Java 类库。 LICENSE 记录了 Maven 使用的软件许可证。 NOTICE 记录了 Maven 包含的第三方软件。 README.txt 说明了 Maven 的简要介绍以及安装需求以及如何安装的简单指令等。 3.2 Maven配置概述 ​ ==conf/settings.xml文件==，配置全局范围的 Maven 行为。 ​ 配置文件主要包含以下元素： 顶级标签 配置内容 默认值 &lt;localRepository&gt; 本地仓库的目录 用户目录下面的.m2/repository目录 &lt;interactiveMode&gt; 是否启用交互模式 true &lt;offline&gt; 是否启用离线模式 false &lt;mirrors&gt; 定义远程仓库镜像 &lt;proxies&gt; 定义代理连接 &lt;profiles&gt; 定义开发环境 &lt;servers&gt; 连接远程服务时需要的验证 3.3 配置本地仓库位置 ​ 配置改变默认的仓库目录 1&lt;localRepository&gt;你指定的文件夹&lt;/localRepository&gt; 3.4 配置阿里云镜像地址 ​ 配置阿里云镜像地址 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 4.小结 安装完成后建议配置阿里云镜像，提高依赖下载速度。 04. 知识点 - Maven 仓库与坐标1.目标 了解Maven的仓库结构 了解Maven的坐标 2.路径 Maven 仓库介绍 Maven 坐标介绍 3.讲解3.1 Maven 仓库介绍 ​ Maven 的仓库就是用来存储依赖的地方 ​ Maven 仓库分为本地仓库与远程仓库 3.1.1 Maven 本地仓库 ​ 本地仓库就是 Maven 在本地存储依赖的仓库，默认是在用户的 .m2/repository/ 目录下 3.1.2 Maven 远程仓库 ​ 远程仓库就是 Maven 在远程存储构建的仓库，软件默认链接中心仓库 ​ 远程仓库可以分为中央仓库和私服 ​ 中央仓库：就是 Maven 提供所提供的远程仓库，其地址为：http://repo.maven.apache.org/maven2 ，该仓库包含了绝大多数流行的开源 Java 构件，以及源码、作者信息、SCM 信息、许可证信息等。据统计，每个月中央仓库大概会接受全世界 Java 程序员大概 1 亿次访问，其重要性不言而喻。 ​ 私服：公司、私人搭建的远程仓库。 3.4 Maven 的坐标 ​ Maven 坐标是 Maven 定义的一组规则：其目的是为了给世界上任一构件创建一个唯一标识。 ​ 主要元素包括：GroupID、ArtifactID、Version 元素标签 建议内容 &lt;GroupID&gt; 当前 Maven 项目隶属，一般与公司域名相对应，比如 com.taobao。 &lt;ArtifactID&gt; 实际项目中的一个模块。 &lt;Version&gt; 表示当前模块的版本。 4.小结 本地仓库–&gt;私服【如果存在】–&gt;中心仓库 Maven规定的的坐标规则是GAV，用来保证模块唯一 05. 知识点 - Maven 项目的结构1.目标 了解Maven项目是什么 了解Maven项目的结构 认识pom.xml文件 2.路径 Maven项目是什么 Maven项目的结构 pom.xml文件简介 3.讲解3.1 Maven项目是什么 ​ 有pom.xml描述文件的项目，就是一个Maven项目。 ​ 需要遵循Maven约定目录结构。 3.2 Maven项目的结构 ​ Maven 对于项目目录结构有着既定的规则，只要遵循了这些成熟的规则，用户在项目中切换的时候就免去了额外的学习成本，也就是约定优于配置。 项目根目录 结构意义 src 源文件 src/main 项目主源文件 ==src/main/java== 代码 src/main/resources 配置 src/main/webapp 页面资源【如果为Web项目】 src/test 项目测试源文件 src/test/java 测试代码 src/test/resources 测试配置 target 打包目录 ==pom.xml== ==项目描述文件== 3.3 pom.xml文件简介 ​ POM(project object model)是Maven对一个单一项目的描述 ​ pom.xml就是对该项目的描述文件 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 默认写法：pom文件的版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 项目的坐标--&gt; &lt;groupId&gt;com.aepvale&lt;/groupId&gt; &lt;artifactId&gt;demo230221&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 项目打包类型：不设置默认为Jar--&gt; &lt;packaging&gt;jar&lt;/packaging&gt;&lt;/project&gt; 4.小结 遵循项目的约定结构：约定大于配置 pom.xml文件是项目的描述文件，非常重要。 06. 实操 - 手动创建 Maven项目1.目标 创建一个简单Maven工程 2.路径 创建项目文件夹 创建约定目录结构 创建pom.xml文件 创建测试用文件 执行mvn命令测试 3.讲解3.1 创建项目文件夹 创建一个空的项目文件夹 3.2 创建约定目录结构 3.3 创建pom.xml文件 maven项目的描述文件 - 配置文件 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 默认写法：pom文件的版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;himvn&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt;&lt;/project&gt; 3.4 创建测试用文件 src/main/java/HelloMaven.java 12345public class HelloMaven&#123; public static void main(String args[])&#123; System.out.println(&quot;Hello Maven！&quot;); &#125;&#125; 3.5 执行mvn命令测试 mvn compile [执行编译] 4.小结 理解符合约定结构的项目，就叫做Maven项目 07. 实操 - 模板创建 Maven项目1.目标 使用插件创建Maven工程 2.路径 创建空文件夹 使用模板命令创建 查看结果 3.讲解3.1 创建空文件夹 3.2 使用模板命令创建3.2.1 使用命令 mvn archetype:generate 3.2.2 选择将要创建的模板1# 选择模板，本次测试选择 maven-archetype-quickstart 模板 3.2.3 输入项目坐标G,A,V 3.3 查看结果 4.小结 使用模板命令，省去了手动创建 08. 实操 - Idea创建 Maven项目1.目标 使用 Idea 集成并创建Maven项目 2.路径 Idea配置Maven环境 创建Maven项目 3.讲解3.1 Idea配置Maven环境 3.3 创建Maven项目 4.小结 注意正式版Idea包含默认Maven，需要配置自己的 三种方式创建结果其实没有什么不同 09. 知识点 - Maven 生命周期1.目标 了解Maven 的生命周期 2.路径 生命周期概述 Clean 生命周期 Site 生命周期 Default 生命周期 3.讲解3.1 生命周期概述 ​ Maven 的生命周期是对所有的构建过程进行的抽象和统一 ​ 为此 Maven 提供了三套独立的生命周期：clean、site 和 default 3.2 Clean 生命周期[天天用] ​ clean 生命周期的目的是清理项目，删除之前的构建结果 ​ 它包含以下三个阶段： 生命周期阶段 阶段介绍 pre-clean 执行一些清理前需要完成的工作 clean 清理上一次构建生成的文件 post-clean 执行一些清理后需要完成的工作 3.3 Site 生命周期 [不常用 / 基本不用] ​ site 生命周期的目的是建立和发布项目站点，方便团队交流和发布项目信息 ​ 它包含以下四个阶段： 生命周期阶段 阶段介绍 pre-site 执行生成项目站点文档前需要完成的工作 site 生成项目站点文档 post-site 执行生成项目站点文档后需要完成的工作 site-deploy 将生成的项目站点发布到服务器上 3.4 Default 生命周期 ​ Default 生命周期是最重要的一个，绝大部分工作都发生在这个生命周期中。 ​ 它定义了真正构建项目中需要执行的所有步骤。 ​ 它包含以下23个阶段： 生命周期阶段 阶段介绍 validate 验证 initialize 初始化 generate-sources 生成所有需要包含在编译过程中的源代码 process-sources 处理源代码 generate-resources 生成所有需要包含在打包过程中的资源文件 process-resources 复制并处理资源文件至目标目录 compile 编译项目源代码 process-classes 流程类 generate-test-sources process-test-sources generate-test-resources process-test-resources test-compile 编译测试源代码 process-test-classes test 使用单元测试框架运行测试 prepare-package 在打包之前执行 package 项目打包 pre-integration-test 执行一些在集成测试运行之前需要的动作 integration-test 处理包并发布至集成测试可以运行的环境 post-integration-test 集成测试运行之后需要的动作 verify 安装前验证 install 将包安装至本地仓库 deploy 复制提交至到远程的仓库 4.小结 Maven三个生命周期过程是相互独立的 10. 实操 - 常用构建命令1.目标 了解Maven 命令 掌握Maven 常用命令 2.路径 Maven命令介绍 常用的构建命令 3.讲解3.1 Maven命令介绍 ​ 输入【mvn + 生命周期阶段名称】即可执行相关构建操作 ​ 比如：mvn complie 就会执行编译源代码 ​ 注意：执行某一周期，其实执行的是从头到此的完整阶段 ​ 比如：mvn test实际执行阶段是从validate到test的所有阶段 3.2 常用的构建命令 命令 描述 mvn clean 执行清理 mvn compile 编译源代码 mvn test-compile 项目打包 mvn test 执行测试 mvn package 项目打包 mvn install 将项目安装进本地仓库 4.小结 mvn＋生命周期名即可执行该生命周期 执行某一周期其实执行的是该周期从头到此周期的完整阶段 11. 知识点 - Maven 插件介绍1.目标 了解Maven 的插件机制 了解插件的目标 了解自定义插件绑定 2.路径 Maven 插件概述 关于插件的目标 自定义绑定插件 3.讲解3.1 Maven 插件概述 ​ 其实Maven 生命周期的各个阶段都是抽象的概念，真正干活的是一个个的插件。插件是以独立的构件形式存在，Maven 的生命周期的各个阶段与 Maven 的插件进行了绑定。当我们执行 mvn 命令其实就是在指挥着一个个的插件在干活。 ​ Maven本质上是一个插件框架，它并不执行任何具体的构建任务，把所有这些任务都交给插件来完成。 ​ 但是为了方便用户使用，Maven为生命周期默认绑定了一套插件。 3.2 关于插件的目标 ​ Maven 的插件以独立的构件形式存在，为了能够复用代码，使得一个插件可以完成多个任务，我们定义了插件目标（Plugin Goal），每一个目标都可以完成不同的功能。 ​ 比如：compile和test-compile就使用的同一个插件，但是是不同的目标。 ​ 事例： 生命周期阶段 插件 目标 执行任务 process-resources maven-resources-plugin resources 复制项目资源 - 至输出目录 ==compile== maven-compile-plugin compile 编译代码 - 至输出目录 process-test-resources maven-resources-plugin testResources 复制测试资源 - 至输出目录 ==test-compile== maven-compile-plugin testCompile 编译测试代码 - 至输出目录 test maven-surefire-plugin test 执行测试用例 package maven-jar-plugin jar 创建项目Jar包 install maven-install-plugin install 将项目安装到本地仓库 deploy maven-deploy-plugin deploy 将项目部署到远程仓库 3.3 自定义绑定插件 ​ 除了Maven默认的绑定之外，可以选择指定为某个阶段绑定某个插件，更自由的构建项目。 ​ 在项目的pom文件中单独指定： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;himvn&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!-- 将clean插件替换成3.1.0版本--&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;!-- 将compile插件目标替换成3.8.0版本--&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;compiler&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 4.小结 插件才是真正干活的东西 Maven默认绑定了一套插件，也可以自主绑定 12. 实操 - 生成项目站点1.目标 使用mvn命令生成项目站点 2.路径 配置site插件 执行mvn site命令 3.讲解3.1 配置site插件 ​ 需要配置最新的版本的site插件 ​ 或者配置它所需要的依赖 1234567891011121314151617&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;configuration&gt; &lt;locales&gt;zh_CN&lt;/locales&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 3.2 执行mvn site命令 4.小结 实操辅助理解插件机制 13. 知识点 - Maven 依赖管理1.目标 [ ] 了解Maven依赖的原则 [ ] 了解Maven依赖的仓库网站 [ ] 掌握Maven依赖的管理 2.路径 依赖的配置 依赖的查找网站 依赖的范围 依赖的传递性 依赖传递的原则 依赖的排除 依赖的归类 3.讲解3.1 依赖的配置 ​ Maven用坐标一一对应地描述了构件，并且保存在仓库中 ​ 在项目需要这些构件时，直接指定该坐标，就可以集成到项目中了 ​ 所以：项目的依赖是配置在项目pom.xml文件中的 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;himvn&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- 在项目中引入mysql-connector-java-5.2.36的Jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.36&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.2 依赖的查找网站 ​ 网站一： https://mvnrepository.com/ ​ 网站二：https://repository.sonatype.org/ ​ 查找流程：搜索项目依赖，选择对应的依赖，选择需要的版本，复制到pom文件 3.3 依赖的范围 ​ 在引入依赖的时候，Maven提供了五种依赖的选择范围 ​ 用以区别编译，执行，测试，等不同时期的依赖 ​ 在依赖的&lt;scope&gt;标签指定，例如： 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 范围的选项 描述 ==compile== 编译依赖【默认值】 ==test== 测试依赖 ==provided== 已提供依赖 runtime 运行时依赖 system 系统依赖 依赖范围 编译有效 测试有效 运行有效 compile YES YES YES test YES YES NO provided YES YES NO runtime NO YES YES system YES YES NO 3.4 依赖的传递性 ​ 有的依赖构件，又依赖其他的第三方构件，比如Junit依赖Hamcrest ​ Maven通过自动解析引入项目的依赖信息，并将间接依赖导入 ​ 传递依赖在将间接依赖引入项目的过程中也有它自己的规则和范围 传递性规则【注】 compile test provided runtime compile compile - - runtime provided provided - - provided runtime runtime - - runtime test test - - test 3.5 依赖传递的原则 ​ 当前项目对同一个构件，有多个直接或间接的依赖，版本可能不同，Maven该如何抉择 3.3.1 路径优先原则 ​ 对同一构件，Maven优先选择路径最近者 3.3.2 声明优先原则 ​ 对同一构件，路径相同时，Maven优先选择声明时&lt;dependency&gt;靠后的 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;himvn&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- 声明在上者优先 --&gt; &lt;dependency&gt; &lt;groupId&gt;test.maven&lt;/groupId&gt; &lt;artifactId&gt;One&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;test.maven&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.6 依赖的排除 ​ Maven除了依赖传递的原则之外，还提供了手动排除依赖的配置方式 ​ 使用：&lt;exclusion&gt;标签排除依赖 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;himvn&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- 声明在上者优先 --&gt; &lt;dependency&gt; &lt;groupId&gt;test.maven&lt;/groupId&gt; &lt;artifactId&gt;One&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;com.Utils&lt;/artifactId&gt; &lt;groupId&gt;utils&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;test.maven&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.7 依赖的归类 ​ 在引入依赖的时候，很多情况需要引入一个构件的多个模块，这些模块都应该是相同的版本 ​ 比如Spring框架下开发应用，就需要引入：spring-core、spring-context、spring-beans等等模块，他们都应该是同一版本 ​ 对此，Maven 可以声明变量统一管理版本 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;himvn&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 声明统一管理版本号 --&gt; &lt;properties&gt; &lt;!-- 自定义标签名称 --&gt; &lt;spring.version&gt;5.0.0.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!--导入Spring相关依赖包--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;!-- 统一管理版本号 --&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4.小结 依赖配置注意GAV坐标和Scope范围 依赖传递管理有两原则、一操作：路径优先，声明优先，依赖排除 我们可以通过统一管理版本号，来管理依赖归类 14. 知识点 - Maven 模块化开发1.目标 [ ] 了解模块化是什么 [ ] 了解Maven项目的模块化 2.路径 模块化简介 Maven 模块化介绍 3.讲解3.1 模块化开发简介 ​ 模块化其实是一个程序设计方法。 ​ 进行程序设计时将一个大程序按照功能划分为若干小程序模块，每个小程序模块完成一个确定的功能，并相对独立。 ​ 通过对这些模块之间建立必要的联系，按需引用，互相协作完成项目功能。 3.2 Maven 模块化介绍 ​ 在实际的项目中，我们往往需要建立多个模块协同开发，所以Maven提供了继承与聚合两个方式。 3.2.1 Maven 模块的继承 ​ 回顾： ​ 设计Java类的时候，当我们发现类有公共行为和特征的话，会很自然地将这些公共特征和行为提炼到一个类中，这个类叫父类 ​ 只要继承一个父类，就不用重复定义行为和特征了，解决了代码重复编写的问题，从而简化了子类的代码 ​ 同样的： ​ Maven项目里经常需要在pom.xml中配置很多信息，随着Maven项目的模块化，很多内容都是重复的 ​ 所以Maven借鉴了面向对象的思想，支持继承 ​ 例如： ​ 如果有多个项目模块要用的配置，单独用一个公共的父项目编写Maven配置项，然后用子项目继承，即可完成配置复用 3.2.1 Maven 模块的聚合 ​ 项目开发时是分模块开发的，但是开发完成进行编译和运行时，是整个项目多模块一起运行的 ​ 所以，为了能够使用统一进行项目管理，Maven提供了聚合方法能够帮助把项目的各个模块聚合在一起构建 ​ 通过配置，可以方便项目的整体构建 4.小结 模块化开发 是一种程序设计方法 继承 可以实现pom配置的复用 聚合 方便了整体的项目构建 通常来说 继承 和 聚合 是同时使用的 聚合模块知道它聚合了哪些模块，但是被聚合的模块不知道聚合模块的存在。 父模块不知道子模块的存在，但是子模块都必须知道自己的父模块是谁。 15. 实操 - Maven 项目继承与聚合1.目标 [ ] 配置完成模块的继承 [ ] 了解继承需要注意的内容 2.路径 创建新项目 创建项目模块 被继承的属性 父项目pom.xml的编写 子项目pom.xml的编写 3.讲解3.1 创建新项目 ​ 本测试项目为SSM集成框架测试 ​ 注意：父项目只留pom.xml文件，且==打包方式为pom== 3.2 创建项目模块 ​ 测试项目分层4个模块：分别是util，pojo，dao，service，controller ​ 继承：子模块通过&lt;parent&gt;标签继承父项目 ​ 聚合：父项目通过&lt;module&gt;标签聚合子模块 子模块pom展示 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;test-parent&lt;/artifactId&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;test-controller&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 父项目pom展示 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;test-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;test-pojo&lt;/module&gt; &lt;module&gt;test-dao&lt;/module&gt; &lt;module&gt;test-service&lt;/module&gt; &lt;module&gt;test-controller&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 3.3 被继承的配置 ​ 子模块继承了父项目，以下配置项被继承 ​ 注意 dependencies 和 dependencyManagement ​ dependencyManagement ：其中配置的依赖，子模块并不直接引入，它只是为子模块提供依赖选择 Pom元素 介绍 GroupID 项目坐标——项目组ID Version 项目坐标——项目版本 properties 自定义的 Maven 属性 ==dependencies== 项目的依赖配置 ==dependencyManagement== 项目的依赖管理配置 build 项目的构建配置 —- 入门课程以下看看即可 —- description 项目的描述信息 organization 项目的组织信息 inceptionYear 项目的创始年份 url 项目的 URL 地址 developers 项目的开发者信息 contributors 项目的贡献者信息 distributionManagement 项目的部署配置 issueManagement 项目的问题管理系统 ciManagement 项目的持续集成信息 scm 项目的版本控制代码库 malilingLists 项目的邮件列表信息 repositories 项目的仓库配置 reporting 项目的报告输出配置 3.4 父项目pom.xml的编写 ​ 测试项目构建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;test-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;test-dao&lt;/module&gt; &lt;module&gt;test-service&lt;/module&gt; &lt;module&gt;test-util&lt;/module&gt; &lt;module&gt;test-controller&lt;/module&gt; &lt;module&gt;test-pojo&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;aspectjweaver.version&gt;1.6.8&lt;/aspectjweaver.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt; &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;mybatis-spring.version&gt;1.3.0&lt;/mybatis-spring.version&gt; &lt;druid.version&gt;1.0.9&lt;/druid.version&gt; &lt;!--文件的编码格式--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;!-- jar包管理 dependencyManagement:并非导入依赖，而只是管理依赖（这样子工程可供选择） --&gt; &lt;dependencyManagement&gt; &lt;!--引入依赖--&gt; &lt;dependencies&gt; &lt;!-- spring（切面） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;$&#123;aspectjweaver.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring（aop） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring包（核心）--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--用于SpringMVC--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--用于数据库源相关操作--&gt; &lt;!-- spring（整合jdbc） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring（事务） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet相关API（可以使用Request、Response）--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jsp-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jstl标签--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- log日志 start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--MyBatis集成Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 3.5 子模块pom.xml的编写 ​ 子模块配置依赖时，继承了父项目版本号以及依赖范围 ​ 注意controller打包方式是war，其他均为jar 3.4.1 pojo模块123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;test-parent&lt;/artifactId&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;test-pojo&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt;&lt;/project&gt; 3.4.2 dao模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;test-parent&lt;/artifactId&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;test-dao&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--引入依赖--&gt; &lt;dependencies&gt; &lt;!--pojo的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;test-pojo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--MyBatis集成Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--MySQL数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--SpringJdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.4.3 service模块123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;test-parent&lt;/artifactId&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;test-service&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--依赖--&gt; &lt;dependencies&gt; &lt;!--依赖dao--&gt; &lt;dependency&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;test-dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.4.4 controller模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;test-parent&lt;/artifactId&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;test-controller&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!--依赖引入--&gt; &lt;dependencies&gt; &lt;!--依赖service--&gt; &lt;dependency&gt; &lt;groupId&gt;com.daojie&lt;/groupId&gt; &lt;artifactId&gt;test-service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入springmvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--servletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jstl表达式 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4.小结 Idea的模块创建，自动配置了继承与聚合 dependencyManagement 管理配置项，子模块不会直接引入 16. 实操 - 测试项目的代码编写1.目标 [ ] 完成测试项目的代码 2.路径 创建项目数据库 创建数据实体对象 创建测试用页面 写入框架配置文件 完成dao层 完成service层 完成controller层 测试效果 3.讲解3.1 创建项目数据库1234567891011121314151617181920212223SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `items`-- ----------------------------DROP TABLE IF EXISTS `items`;CREATE TABLE `items` ( `id` int(10) NOT NULL auto_increment, `name` varchar(20) default NULL, `price` float(10,0) default NULL, `pic` varchar(40) default NULL, `createtime` datetime default NULL, `detail` varchar(200) default NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;-- ------------------------------ Records of items-- ----------------------------INSERT INTO `items` VALUES (&#x27;1&#x27;, &#x27;智酷道捷&#x27;, &#x27;1000&#x27;, null, &#x27;2018-03-13 09:29:30&#x27;, &#x27;带我走上人生巅峰&#x27;);INSERT INTO `items` VALUES (&#x27;2&#x27;, &#x27;道捷实训云&#x27;, null, null, &#x27;2018-03-28 10:05:52&#x27;, &#x27;值得学习和拥有&#x27;);INSERT INTO `items` VALUES (&#x27;3&#x27;, &#x27;道捷风云录&#x27;, &#x27;199&#x27;, null, &#x27;2018-03-07 10:08:04&#x27;, &#x27;小人物，大智慧&#x27;);INSERT INTO `items` VALUES (&#x27;7&#x27;, &#x27;道捷英雄&#x27;, null, null, null, null);INSERT INTO `items` VALUES (&#x27;8&#x27;, &#x27;道捷飞车&#x27;, null, null, null, null); 3.2 创建数据实体对象1234567891011121314151617package com.daojie.test.pojo;import java.util.Date;/** * @author dancinghorse * @version v0.0.1 */public class Items &#123; private Integer id; private String name; private Float price; private String pic; private Date createtime; private String detail; // 省略，get..set..&#125; 3.3 创建测试用页面 ​ 创建 index.jsp 和 /WEB-INF/pages/success.jsp index.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;/list&quot;&gt;点击查询列表&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; success.jsp 123456789101112131415161718192021222324252627282930&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;查询结果&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;hr&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;name&lt;/td&gt; &lt;td&gt;price&lt;/td&gt; &lt;td&gt;pic&lt;/td&gt; &lt;td&gt;createTime&lt;/td&gt; &lt;td&gt;detail&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;items&#125;&quot; var=&quot;item&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;item.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.pic&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.createtime&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.detail&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 3.4 写入框架配置文件3.4.1 dao层 ​ 配置mybatis和spring applicationContext-mybatis.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 1：数据源配置 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/bean&gt; &lt;!-- 2：创建SqlSessionFactoryBean --&gt; &lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--指定数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!--指定别名配置--&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.daojie.test.pojo&quot; /&gt; &lt;/bean&gt; &lt;!--3：Dao层接口扫描，让Dao被spring管理--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--指定Dao接口的包--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.daojie.test.dao&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 3.4.2 service层 ​ 配置事务相关代码 applicationContext-service.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--1：创建一个事务管理器--&gt; &lt;bean id=&quot;txtManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--指定数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--2：配置通知，配置事务的传播特性，对切入点方法的细化--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txtManager&quot;&gt; &lt;!--配置传播特性属性--&gt; &lt;tx:attributes&gt; &lt;!--对应方法参与事务并且在事务下执行，事务隔离剂别使用默认隔离级别,发生异常需要事务回滚--&gt; &lt;tx:method name=&quot;add*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;java.lang.Exception&quot;/&gt; &lt;tx:method name=&quot;insert*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;java.lang.Exception&quot;/&gt; &lt;tx:method name=&quot;save*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;java.lang.Exception&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;java.lang.Exception&quot;/&gt; &lt;tx:method name=&quot;update*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;java.lang.Exception&quot;/&gt; &lt;tx:method name=&quot;edit*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;java.lang.Exception&quot;/&gt; &lt;!--除了以上操作，其余方法为只读操作--&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--3：配置AOP，AOP声明式事务配置（配置切入点，让通知关联切入点）--&gt; &lt;aop:config&gt; &lt;!--切点指点--&gt; &lt;aop:pointcut id=&quot;tranpointcut&quot; expression=&quot;execution(* com.daojie.test.service..*.*(..))&quot;/&gt; &lt;!--配置通知--&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;tranpointcut&quot;/&gt; &lt;/aop:config&gt; &lt;!--引入spring-mybatis.xml--&gt; &lt;import resource=&quot;classpath:applicationContext-mybatis.xml&quot;/&gt;&lt;/beans&gt; 3.4.3 controller层 ​ 配置springmvc以及web.xml spring-mvc.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--1：包扫描--&gt; &lt;context:component-scan base-package=&quot;com.daojie&quot; /&gt; &lt;!--2：视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!--3：springmvc注解驱动，自动配置mvc的处理器适配器和处理映射器--&gt; &lt;mvc:annotation-driven /&gt; &lt;!--4：静态资源不过滤--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--5：导入applicationContext-service.xml--&gt; &lt;import resource=&quot;applicationContext-service.xml&quot; /&gt;&lt;/beans&gt; web.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!--1:配置编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!--拦截映射--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--2:springmvc前端核心控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--指定映射拦截，/表示所有请求--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.5 完成dao层 ItemsDao.java 123456789101112package com.daojie.test.dao;import com.daojie.test.pojo.Items;import java.util.List;/** * @author dancinghorse * @version v0.0.1 */public interface ItemsDao &#123; List&lt;Items&gt; selectAll();&#125; ItemsDao.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.daojie.test.dao.ItemsDao&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;Items&quot;&gt; SELECT * FROM items &lt;/select&gt;&lt;/mapper&gt; 3.6 完成service层 ItemsService.java 1234567891011package com.daojie.test.service;import com.daojie.test.pojo.Items;import java.util.List;/** * @author dancinghorse * @version v0.0.1 */public interface ItemsService &#123; List&lt;Items&gt; selectAll();&#125; ItemsServiceImpl.java 12345678910111213141516171819202122package com.daojie.test.service.Impl;import com.daojie.test.dao.ItemsDao;import com.daojie.test.pojo.Items;import com.daojie.test.service.ItemsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * @author dancinghorse * @version v0.0.1 */@Service(&quot;itemsService&quot;)public class ItemsServiceImpl implements ItemsService &#123; @Autowired private ItemsDao itemsDao; @Override public List&lt;Items&gt; selectAll() &#123; return itemsDao.selectAll(); &#125;&#125; 3.7 完成controller层 ItemsController.java 12345678910111213141516171819202122232425package com.daojie.test.controller;import com.daojie.test.pojo.Items;import com.daojie.test.service.ItemsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;/** * @author dancinghorse * @version v0.0.1 */@Controllerpublic class ItemsController &#123; @Autowired private ItemsService itemsService; @RequestMapping(value = &quot;/list&quot;) public String list(Model model)&#123; List&lt;Items&gt; items = itemsService.selectAll(); model.addAttribute(&quot;items&quot;,items); return &quot;success&quot;; &#125;&#125; 3.8 测试效果 ​ 配置tomcat并启动 4.小结 测试代码编写，知识点回顾，没有难度","categories":[{"name":"Java系列","slug":"Java系列","permalink":"https://lqy679.github.io/categories/Java%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"Nginx","slug":"Nginx","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T04:59:52.612Z","comments":true,"path":"2020/01/01/Nginx/","link":"","permalink":"https://lqy679.github.io/2020/01/01/Nginx/","excerpt":"Nginx简介:Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。 其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。","text":"Nginx简介:Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。 其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。 Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。 Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。 Nginx产生一个公司的项目刚刚上线的时候，并发量小，用户使用的少，所以在低并发的情况下，一个 jar 包启动应用就够了，然后内部 tomcat 返回内容给用户 慢慢的，使用平台的用户越来越多了，并发量慢慢增大了，这时候一台服务器满足不了我们的需求了 于是我们横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求。 我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验！所以我们使用了Nginx。 作用Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。 代理分为正向代理和反向代理: 正向代理：代理客户端 反向代理 ：代理服务端 所以用户是无感知的，比如，百度的服务器是在不同的服务器上，我们只需要搜索 baidu.com 就行。 负载均衡策略Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，ip hash。扩展策略,即自定义策略 内置策略:**轮询: **每个请求按时间顺序分配到不同的后端服务器，如果服务器down掉，能自动剔除 加权轮询:通过给服务增加权重来决定具体请求服务器 ip Hash:对客户端请求的 ip 进行 hash 操作，然后根据 hash 结果决定请求分发给哪一台服务器进行处理，可以解决 session 不共享的问题(只要客户端IP不变,每次请求的都是同一个台服务器) fair(第三方):按后端服务器的响应时间来分配请求，响应时间短的优先分配 动静分离:Nginx可以将我们的请求的资源根据静态资源(图片,js,css等资源)还是动态资源(后端接口)进行区分: 静态资源直接请求Nginx, 动态资源再请求服务器 Nginx安装windos下:直接下载安装即可 Linux发行版: CentOS 7 参考:https://www.yuque.com/wukong-zorrm/cql6cz 准备工作: 1234567891011121314151617181920# 关闭并精用防火墙sudo systemctl stop firewalldsudo systemctl disable firewalld#修改/etc/selinux/config，设置SELINUX=disabled （永久有效，需重启）#安装网络工具包,有就不用了sudo yum install yum-utils net-tools# 添加Nginx下载源cat &gt; /etc/yum.repos.d/nginx.repo &lt;&lt; EOF[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/\\$releasever/\\$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=trueEOF#安装Nginxsudo yum install nginx Nginx相关命令12345678910111213141516171819202122232425whereis nginx # 查找安装路径# 使用nginx必须进入sbin目录，需要先找到nginx的安装目录 进入sbin目录执行以下命令./nginx #启动./nginx -v #查看版本号./nginx -s stop./nginx -s quit./nginx -s reload# ./nginx -s quit:此方式停止步骤是待nginx进程处理任务完毕进行停止。# ./nginx -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。#重新加载配置文件，相当于 systemctl reload nginxnginx -s reload#将日志写入一个新的文件nginx -s reopen#测试配置文件nginx -t# 查看nginx状态systemctl status nginx#产看日志journalctl -xe#配置开机启动systemctl enable nginx 配置文件Linux版本的配置文件: /etc/nginx/nginx.conf 默认配置信息: /etc/nginx/conf.d/default.conf 配置文件详解由三部分组成 全局块从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行Nginx服务器的用户组，允许生成的worker process数，进程PID存放路径，日志存放路径和类型以及配置文件的引入等 第二部分 events块events块涉及的指令主要影响Nginx服务器与用户的网络连接，这部分的配置对Nginx的性能影响较大，在实际中应该灵活配置 第三部分 http块Nginx服务器配置中最频繁的部分，http块也可以包括http全局块、server块 http全局块:http全局块配置的指令包括文件引入、MIME-TYPE定义，日志自定义，连接超时时间、单链接请求数上限等 server块:这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本 每个http块可以包括多个srever块，而每个server块就相当于一个虚拟主机，而每个server也分为全局server块以及可以同时包含多个location块 全局server块:最常见的配置时本虚拟机主机的监听配置和本虚拟机主机的名称或IP配置 location块: 一个server块可以配置多个location块，这块的作用是基于nginx服务器接收到的请求字符串，对虚拟注解名称之外的字符串进行匹配，对特定的请求进行处理，地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行 文件内容1234567891011121314151617181920212223242526272829303132user nginx;#worker_processes越大，可以支持的并发处理数量也越多，但是会受到硬件，软件等设备的制约worker_processes auto;#错误日志error_log /var/log/nginx/error.log notice;pid /var/run/nginx.pid;events &#123; #表示每个work process支持的最大连接数为1024 worker_connections 1024;&#125;http &#123; # 引入/etc/nginx/mime.types文件的内容,包含了可以处理的资源类型 include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #日志 access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on, 引入了/etc/nginx/conf.d/*.conf文件,包含了监听端口,代理配置等信息 include /etc/nginx/conf.d/*.conf;&#125; 默认情况下,/etc/nginx/conf.d/*.conf只有一个默认配置文件default.conf,内容如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647server &#123; # 默认监听 localhost的 80端口 listen 80; listen [::]:80; server_name localhost; #主机名(即ip地址) #access_log /var/log/nginx/host.access.log main; location / &#123; #页面文件根目录,类似tomcat的webapps/Root目录 root /usr/share/nginx/html; #首页 index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 配置实例配置实例-反向代理 案例一: 实现效果：打开浏览器，在浏览器地址栏输入地址www.123.com，跳转Linux系统tomcat主页面中 准备工作：在linux中安装tomcat, 并启动tomcat 具体实现：在windows的host文件中加入 装有nginx虚拟机ip www.123.com nginx也修改配置文件添加配置: 12345678910111213141516http &#123; # ... server &#123; listen 80; # localhost指:nginx主机ip,根据实际情况来 server_name localhost ; # 资源映射 location / &#123; root html index index,html index.htm # 代理配置: 访问nginx服务器的 / 目录就会转发到 127.0.0.1:8080 proxy_pass http://127.0.0.1:8080 &#125; &#125; &#125; 案例二: 实现效果：使用nginx反向代理，根据访问的路径跳转到不同端口的服务中，nginx监听端口为9001 访问 http://127.0.0.1:9001/edu/ 直接跳转到127.0.0.1:8080 访问 http://127.0.0.1:9001/vod/ 直接跳转到127.0.0.1:8081 具体实现:弄两个tomcat并修改它们的配置文件中的监听端口号分别为: 8080, 8081 之后启动两个tomcat并进行测试 在8080端口的tomcat的安装目录的/webapps/Root/下创建edu文件夹并创建a.html文件 在8081端口的tomcat的安装目录的/webapps/Root/下创建vod文件夹并创建a.html文件 修改nginx的配置文件: 12345678910111213141516http&#123; # ... server &#123; listen 9001; server_name localhost; # 匹配映射 location ~ /edu/ &#123; proxy_pass http:localhost:8080; &#125; location ~ /vod/ &#123; proxy_pass http:localhost:8081; &#125; &#125; &#125; 补充: ==注意: 如果location 映射路径中包含正则表达式,则必须要有 ~ 或 ~*标识== ~:用于 uri 包含正则表达式且区分大小写 ~*:用于 uri 包含正则表达式且不区分大小写 = : 用于不含正则表达式的 uri 前, 要求请求字符串与 uri严格匹配,匹配成功,就停止向下搜索并立即处理 ^~: 用于不含正则表达式前,匹配到与 uri 匹配度最高的location后立即使用该location处理请求,不再匹配后续location中 uri 的正则表示式 配置实例-负载均衡实现效果： 浏览器地址栏输入地址 http://10.10.10.129/edu/a.html 负载均衡效果，将请求平均分发到8080和8081端口中 需要在nginx的配置文件中进行负载均衡的配置 在http块中进行如下配置: nginx.conf 1234567891011121314151617181920212223242526http &#123; #... # 定义名为 myserver 负载均衡所分配的服务, upstream myserver &#123; #这里可以设置负载均衡策略,默认是轮询策略 #ip_hash server 127.0.0.1:8080; server 127.0.0.1:8081; #或 设置权重 #server 127.0.0.1:8080 weight=5; #server 127.0.0.1:8081 weight=10; &#125; server &#123; listen 80; server_name 127.0.0.1; location / &#123; root html; index index.html index.htm ; proxy_pass http://myserver; &#125; &#125; &#125; 之后访问地址之后进行刷新，**每次刷新之后显示的内容都不一样(同一个请求会每次请求会被分发到不同的服务器)**，表示已经实现了负载均衡 配置实例-动静分离准备工作：准备一些静态资源，用于进行访问 在nginx配置文件中进行配置: 123456789101112131415http &#123; server &#123; listen 80; server_name localhost; &#125; location /www/&#123; root /data/; index index.html index.htm; &#125; location /image/&#123; root /data/; # autoindex on 代表访问该目录时,会将该目录的资源以列表的形式展示 autoindex on; &#125;&#125; autoindex on 效果 配置实例-主从配置所有的服务器都有宕机的可能性，所以当我们只有一台服务器的时候就不能保证程序的正常运行，这个时候我们就需要使用多台服务器来保证服务器的正常运行，其中会有一台主服务器和多台备用服务器。 一般都是先发送到主服务器，如果主服务器宕机那么就会使用备份服务器进行转发 理解高可用问题引出: 解决: Nginx高可用 实现: 技术实现: Keepalived_百度百科 (baidu.com) 实际上这已经跟nginx关系不大了, 主从配置主要是靠 keepalived实现的 测试环境: 两台装有Nginx和keepalived 的服务器 准备工作: 使用 yum 命令进行安装yum install keepalived –y安装之后，使用命令rpm -q -a keepalived查看是否安装成功 配置 修改keepalived 的配置文件: /etc/keepalived/keepalivec.conf 主服务器配置: 1234567891011121314151617181920212223242526272829303132global_defs &#123; notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.17.129 #主服务器ip smtp_connect_timeout 30 router_id LVS_DEVEL #主服务器的本地ip域名,可在 系统 host文件中看到&#125;vrrp_script chk_http_port &#123; script &quot;/usr/local/src/nginx_check.sh&quot; # 检测主服务器是否挂掉的脚本 interval 2 #（检测脚本执行的间隔） weight 2 &#125;vrrp_instance VI_1 &#123; state MASTER # 备份服务器上将 MASTER 改为 BACKUP interface ens33 #本地网卡名称（用ifconfig命令查看） virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同 priority 100 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.17.50 # 虚拟ip地址,可随便设置,但是主从服务器要一致,并且是内网IP地址 &#125;&#125; 从服务器配置keepalived 配置: 1234567891011121314151617181920212223242526272829303132global_defs &#123; notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.17.131 #从服务器ip smtp_connect_timeout 30 router_id LVS_DEVEL #从服务器的本地ip域名,可在 系统 host文件中看到&#125;vrrp_script chk_http_port &#123; script &quot;/usr/local/src/nginx_check.sh&quot; # 检测主服务器是否挂掉的脚本 interval 2 #（检测脚本执行的间隔） weight 2 &#125;vrrp_instance VI_1 &#123; state BACKUP # 备份服务器上将 MASTER 改为 BACKUP interface ens33 #本地网卡名称（用ifconfig命令查看） virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同 priority 100 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.17.50 # 虚拟ip地址,可随便设置,但是主从服务器要一致,并且是内网IP地址 &#125;&#125; 检测脚本/usr/local/src/nginx_check.sh&quot;,主从服务器都一致 12345678910#!/bin/bashA=`ps -C nginx – no-header |wc -l`if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx sleep 2 if [ `ps -C nginx --no-header |wc -l` -eq 0 ]; then killall keepalived fifi 把两台服务器上 Nginx 和 keepalived 启动 12./nginx # !在nginx安装目录的 sbin/目录执行systemctl start keepalived.service 测试: 在浏览器地址栏输入 虚拟 ip 地址 192.168.17.50把主服务器（192.168.17.129） Nginx 和 keepalived 停止，再输入 192.168.17.50","categories":[{"name":"运维","slug":"运维","permalink":"https://lqy679.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[]},{"title":"JavaScript","slug":"JavaScript","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T05:00:28.685Z","comments":true,"path":"2020/01/01/JavaScript/","link":"","permalink":"https://lqy679.github.io/2020/01/01/JavaScript/","excerpt":"1、初识JavaScript在网页中: html表示网页的结构 CSS表示网页的样式 JavaScript表示网页的行为 三大核心","text":"1、初识JavaScript在网页中: html表示网页的结构 CSS表示网页的样式 JavaScript表示网页的行为 三大核心(1)ECMAScript:javaSript的标准语法(2)BOM(Browser Object Model):一整套操作浏览器的属性和方法(3)DOM(Document Object Model):一整套操作文档流的属性和方法 -&gt;通过JS语法让页面发生变换,让文档变换 书写位置 行内式(1) a标签(本身有行为) -&gt; 因为a标签,本身有动作行为出现,需要区分你是跳转还是执行JS代码 -&gt; 如果不是跳转在href属性里写一个JavaScript声明:Js代码;(2) 非a标签 内嵌式-&gt;在html文件的任意标签内书写一个script标签,在此标签中书写JS代码-&gt;推荐在head标签或者body标签的末尾 123&lt;script type = &quot;text/javascript&quot;&gt;js代码&lt;/script&gt; 外链式 -&gt;**在script标签的src属性中引用JS文件,JS代码书写在JS文件中-&gt;注意:使用外链式之后,再在script标签中书写JS代码没意义(哪怕只写了src属性,无法使用内嵌式) 123&lt;script src = &quot;js文件路径&quot;&gt; &lt;/script&gt; 示例: 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert(&#x27;我是内嵌式js代码&#x27;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 行内式 --&gt; &lt;h1&gt;alter()方法&lt;/h1&gt; &lt;a href=&quot;javascript: alert(&#x27;helloword!&#x27;);&quot;&gt;点击试试&lt;/a&gt; &lt;a href=&quot;alert(&#x27;hell!&#x27;);&quot;&gt;不加javascript再点击试试&lt;/a&gt; &lt;div onclick=&quot;alert(&#x27;hello&#x27;)&quot;&gt; div点击试试 &lt;/div&gt; &lt;!-- 内嵌式 --&gt; &lt;!-- 外联式 --&gt; &lt;!-- &lt;script src=&quot;helloword.js&quot;&gt; --&gt; &lt;/body&gt;&lt;/html&gt; 输出语法1.alert():-&gt; 以浏览器弹出层形式展示内容,堵塞后面的代码执行-&gt; 只要不是纯数字,单双引号无所谓 2.console():-&gt;在浏览器控制台输出,方便调试,不影响页面展示,不会堵塞后面的代码执行 3.document.write()=&gt;直接在html页面显示 特殊: -&gt;由于是直接输出到文档流,故可以解析标签 2、变量与数据类型2.1定义变量=&gt;声明变量格式: var 变量名 (标识符规则和规范与java类似)=&gt;不使用var 关键字也可以声明一个变量(不推荐) 2.2数据类型Number 数值 包括一切数字(浮点数,任意进制数如0x十六进制,0八进制) NaN: Not a Number, 即是一个数值类型,但不是数字 科学计数法(如:2e5) Undefined 空(未定义) undefined Null 空 null String 字符串用单或者双引号或者反引号(`)包裹表示 模板字符串:12let name = &quot;lili&quot;; //模板字符串let yourName = &quot;你的名字:$&#123;name&#125;&quot; //使用$&#123;name&#125;引用了name的内容; 常用方法:substring 截取字符串123//[) 含头不含尾substring(1); //从第一个截取到最后一个;substirng(1,3); //从第一个截取到第三个; Boolean 布尔值==0 /0.0 / null / undefined / NaN 这些都视为fasle ,其他一律为真(true)== true 在计算机存储的时候是1 false 在计算机存储的时候是0 引用数据类型ObjectFunctiontypeof检测数据类型关键字typeof(以String类型返回)用法一: typeof 变量 1var n2 = typeof n1 ; //将n1的数据类型以字符串的形式返回给n2 用法二: typeof(),相较于用法一没有局限性 数据类型转换Number类型1. Number() 语法: Number(要转换的数据) 返回值: 转换好的数据,转换不了(如含有字符串),则返回NaN 2. parseInt() 取整,依次转换 语法:parseInt(转换的的数据) 特点: 一位一位的转换,每识别到一个数字就返回一个,直到遇到非数字(包括小数点)就不往下看了,第一位是非数字直接返回NaN 12parseInt(&quot;2a5&quot;) ; // 返回 2parseInt(&quot;123.456&quot;) //返回 123 3.parseFloat() 比parseFloat()多认识一个小数点4. 非加法数学运算 a-0 a*1 a/1 String类型1. Stirng() 语法: String(转换的数据) 特点: 任意的数据都能转 2. toString() 语法: 转换的数据.toString() 特点: Undefined和null不能转换 3. + 与java同样的字符串链接符Boolean 类型Boolean() 语法:Boolean(转换的数据) 特点: **只有这五个是false,分别是: 空字符串&#39;&#39; NaN,null , Undefined ,,0 **其他全是true 注意!:即使[] ==&#39;&#39; 的结果为true,Boolean([])的结果也还是true 3、运算符号1.数学运算符与java基本一致,比java多个幂运算符号如: 122**10 //结果为1024 ,2的10次方3**2 //结果为9.即3的2 次方 2.比较运算符号与java不同或者新增的是: == : 只比较值,不管数据类型 === :既比较值又比较数据类型 12345console.log(1==&#x27;1&#x27;); //trueconsole.log(1==true); //trueconsole.log(null==undefined); //trueconsole.log(NaN==NaN); //false,因为NaN的值不确定console.log(NaN===NaN); //false !===即三等于的的取反,值不一样就算true** !==,即双等于的取反,数据类型和值都不一样才是true** 3.逻辑运算符号与java一致 4.if语句与java一致,注意:条件位置处，必须Boolean的值 / 表达式 / 变量，如果不是Boolean类型的话，JS会自动进行转换 例如这些 ==if（0 /0.0 / null / undefined / NaN）{ } 这些 if 都会认为是false。==因为*0/0.0/null/undefined/NaN* 这些值转换为布尔值都是 false， ==除此以外一律为真。== 5.switch语句与java基本一致,只能判断===其他语句也基本与java一致 4、函数 一种引用数据类型 对一段代码的封装 4.1 定义函数声明式定义: 语法: function 函数名(){} 赋值式定义: 语法: var 函数名 = function(){} 4.2 函数调用声明式定义函数和赋值式定义的调用的区别 声明式函数:可以在声明前后调用 赋值式函数: 只==能在赋值后调用== 4.3 函数参数实参和形参不对应的情况也不会报错 形参多: 多的形参为undefined 实参多: 形参不接受 4.4 arguments(参数数组) 函数自带的变量 表示所有实参的集合(伪数组) arguments的属性: length表示参数的个数 1.预解析是指在代码之前做的准备工作,类似C语言的预处理,JS代码的一种运行机制 1.1 var 声明变量实际上在代码的执行时,会*预先解析var声明的变量 注: 用var声明的变量是全局变量,而在ES6标准后可使用 let 来声明局部变量 1let 局部变量 ; 1.2 定义函数 声明式定义函数 :在预计解析时将函数准备好(不建议多用,因为全局可用太乱了) 赋值式定义函数:预计解析时只是声明有这么一个变量 2.当预解析时函数与变量同名2.1 预解析的最高级与其他编程语言有所不同 只要有JS代码中可以预解析的内容,无论要解析的语句在会先进行解析(哪怕是return或者if语句判断为false) 12345console.log(num); //不会报错if(false)&#123; var num = 100; //(1) 代码最执行执行预解析,var num,if语句只判断是否赋值&#125;console.log(num); 2.2 优先级在JS中函数是一等公民,在预解析时只解析函数如: 1234567fn(); //(2)按代码顺序执行,打印var fn;fn = 100; //将fn赋值为100fn () ; //报错!!因为此时fn已经不是一个函数function fn ()&#123; //(1)最先执行,将fn解析为一个函数,然后再解析var fn console.log(&quot;我是一个函数&quot;);&#125; (建议:(1)变量尽量以名词命名,尽可能用到两三个单词;(2)函数名尽量以功能区分) 3. 作用域用来限制变量的使用范围 3.1 全局作用域全局可用,叫做window 3.2 局部作用域(也叫私有域)函数体里面的作用域,只有该函数内可用 3.3 变量的三个机制 定义机制:只能在自己的作用域和子级作用域有效 使用机制: 越明确越优先,即先在自己的作用域找,找不到以次往f父作用域上找(全局也找到不到报错) 赋值机制:优先在自己作用域内查找,找不到就往父作用域上找还不到也不会报错 ,因为由于两种定义变量的方式存在(如定义变量可以 a = 10 这样定义) ,将会在全局作用域(windows)定义一个变量 3.4 作用域的预解析 全局下先预解析 局部的预解析只有在调用的时候才会预解析(由于函数是单独进行预解析,因此是*参数传递在前,预解析在后)* 事件常见的事件 click 点击事件 当用户点击了html元素得时候,会触发该事件 mouseover 鼠标覆盖事件 当鼠标移动到元素上面时 mouseout 鼠标离开事件 当鼠标从元素上离开时 focus 获得焦点事件 当获得焦点时触发 blur 失去焦点事件 失去焦点事件 load 加载事件 当元素被加载时触发, 如js中可用浏览器对象 window.onload 函数和元素结合: 函数还可以当作一个页面元素的事件处理函数 当页面的某个元素触发行为时,执行某个函数 语法:元素.onclick = 函数名或元素.onclick = function (){} 页面元素的简单操作 在一个页面里,标签的id名(只有id可以),可以直接当成一个变量来使用 这个元素就代表这个标签 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;!-- 函数还可以当作一个页面元素的事件处理函数 当页面的某个元素触发行为时,执行某个函数页面元素的简单操作 在一个页面里,标签的id名(只有id可以),可以直接当成一个变量来使用 这个元素就代表这个标签 --&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; 点击试试 &lt;/div&gt; &lt;input id=&quot;frist&quot;/&gt; + &lt;input id=&quot;second&quot; /&gt; &lt;button id=&quot;but&quot;&gt;=&lt;/button&gt; &lt;input id=&quot;res&quot; disabled=&quot;disabled&quot;/&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; console.log(box); box.onclick = function()&#123; console.log(&#x27;我是一个事件处理函数&#x27;); &#125; but.onclick = function()&#123; var resule; resule = (Number(frist.value)+Number(second.value)) ; //注意:从页面拿出来的都是字符串类型 console.log(resule) res.value = resule; &#125; &lt;/script&gt;&lt;/html&gt; 6、引用数据类型详解 对象:承载一堆数据的盒子 函数:承载了一段代码的盒子 1 创建对象的方式 字面量创建 注: ==成员以 key:value 的形式==表示,并且多个成员用逗号隔开 12345var o1 = &#123; //创建对象 o1 num:100, //成员 num 的值为 100 str:&quot;字符串&quot;, //成员 str 的值为 &quot;字符串&quot; function f1()&#123; console.log(&quot;我是对象o1的方法&quot;)&#125;; //o1的一个方法&#125; 内置构造方法创建 1var o = new Object(); 区别:(1)字面量创建可以直接在里面添加数据,数据以键值对key:value的形式出现,key表示数据名字,value表示值用(,)分隔 2.操作对象语法增: 向对象添加成员点语法格式:对象名.成员名 = 值数组关联语法:对象名[“成员名”] = 成员名] = 值 删:删除对象的成员点语法格式:==delete== 对象名.成员名数组关联语法:==delete== 对象名[“成员名”] 改:修改对象的成员点语法格式:对象名.成员名 = 值数组关联语法:对象名[“成员名”] = 成员名] = 值 查:获取对象的成员点语法格式:对象名.成员名数组关联语法:对象名[“成员名”]如果没有此成员,则为undefined 点语法和数组关联语法的区别数组关联语法成员名可以使用变量和拼接字符串点语法成员名不能使用变量和拼接字符串**注意:*在控制台打印对象时-&gt;不展开时是当前的样子-&gt;展开后是最终的样子解决方案: (1)使用对象名.成员名直接获取 (2)使用console.table()的方式打印对象,就会得到当前的值 3. for in循环遍历对象的属性类似java的增强for 即forearch 12345678910var o1 = &#123; num:100, str:&quot;字符串&quot;, fn :function() &#123; console.log(&quot;我是对象o1的方法&quot;)&#125;&#125;for(var key in o1)&#123; // console.log(o1[key]); //遍历value console.log(key); //默认为string类型&#125; 4. in关键字:判断一个成员判断是否在对象里语法: “成员名” in 对象名 内置对象:Date1234567891011121314151617181920new Date()Sun Nov 21 2021 00:30:16 GMT+0800 (中国标准时间)new Date().getFullYear()2021//获得月份,注意,月份从0算起new Date().getMonth() 10//date代表日期new Date().getDate()21//day代表星期几new Date().getDay()0//获得时间戳, 全世界统一, 从1970年1月1日 00:00:00 开始到现在的毫秒数new Date().getTime()1637425919212//获得本地时间new Date().toLocaleString()&#x27;2021/11/21 00:39:40&#x27; JSON 参考自菜鸟教程:Java 中 JSON 的使用 | 菜鸟教程 (runoob.com) JSON 简介JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在javaScrip 一切皆为对象,任何js支持的类型,都可以用JSON来表示 JSON 格式 都以键值对的形式表示, 即 key: value 对象都用 {} 形式为: &#123;&quot;属性1&quot;:属性1的值,&quot;属性2&quot;:属性2的值,&quot;属性3&quot;:属性3的值&#125; 数组(即使包含了多个对象)都用 [] , 形式为: [&#123;&quot;对象1的属性1&quot;:对象1的属性1的值,&quot;对象1的属性2&quot;:对象1的属性2的值&#125;,&#123;&quot;对象2的属性1&quot;:对象2的属性1的值,&quot;对象2的属性2&quot;:对象2的属性2的值&#125;] JSON 转换在JavaScript中:12345678// 假如定义了一个对象 let user = &#123; name:&#x27;mm&#x27;, sex : &#x27;女&#x27; ,age : 19 &#125;; /* JSON转换成字符串 */JSON.stringify(user); //返回一个字符串,内容为: &#123;&quot;name&quot;:&quot;mm&quot; ,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;女&quot;&#125;/* 字符串转换成JSON */let user_text = &#x27;&#123;&quot;name&quot;:&quot;mm&quot; ,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#x27;;JSON.parse(user2_text); //返回一个对象 在Java中:Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。 下面是几个常用的 JSON 解析类库： Gson: 谷歌开发的 JSON 库，功能十分全面。 FastJson: 阿里巴巴开发的 JSON 库，性能十分优秀。 Jackson: 社区十分活跃且更新速度很快。 注:本文以阿里的 FastJson为例说明 依赖导入123456&lt;!--FastJson的Maven依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; 流程说明:java变量 &lt;--&gt; JSON对象 &lt;--&gt; 字符串 将java变量转换为JSON12345678910111213141516public void testJson() &#123; JSONObject object = new JSONObject(); //string object.put(&quot;string&quot;,&quot;string&quot;); //int object.put(&quot;int&quot;,2); //boolean object.put(&quot;boolean&quot;,true); //array List&lt;Integer&gt; integers = Arrays.asList(1,2,3); object.put(&quot;list&quot;,integers); //null object.put(&quot;null&quot;,null); System.out.println(object);//打印结果: &#123;&quot;boolean&quot;:true,&quot;string&quot;:&quot;string&quot;,&quot;list&quot;:[1,2,3],&quot;int&quot;:2&#125; &#125; 将JSON转换为java变量12345678910111213141516171819202122232425262728public void testJson2() &#123; JSONObject object = JSONObject .parseObject(&quot;&#123;\\&quot;boolean\\&quot;:true,\\&quot;string\\&quot;:\\&quot;string\\&quot;,\\&quot;list\\&quot;:[1,2,3],\\&quot;int\\&quot;:2&#125;&quot;); //string String s = object.getString(&quot;string&quot;); System.out.println(s); //int int i = object.getIntValue(&quot;int&quot;); System.out.println(i); //boolean boolean b = object.getBooleanValue(&quot;boolean&quot;); System.out.println(b); //list List&lt;Integer&gt; integers = JSON.parseArray(object.getJSONArray(&quot;list&quot;).toJSONString(),Integer.class); integers.forEach(System.out::println); //null System.out.println(object.getString(&quot;null&quot;));&#125;/* 打印结果:string2true123null*/ 方法使用 方法 作用 JSON.parseObject(String) 将字符串解析为 JSON 对象 JSON.parseArray(String) 将从字符串解析为 JSON 数组 JSON.toJSONString(obj/array) 将 JSON 对象或 JSON 数组转化为字符串 实例: 12345678//将字符串解析为JSON对象JSONObject obj = JSON.parseObject(&quot;&#123;\\&quot;runoob\\&quot;:\\&quot;菜鸟教程\\&quot;&#125;&quot;);//从字符串解析为JSON数组JSONArray arr = JSON.parseArray(&quot;[\\&quot;菜鸟教程\\&quot;,\\&quot;RUNOOB\\&quot;]\\n&quot;);//将JSON对象转化为字符串String objStr = JSON.toJSONString(obj);//将JSON数组转化为字符串String arrStr = JSON.toJSONString(arr); 操作BOM对象(重点)B: 浏览器 , BOM浏览器模型 浏览器(内核)介绍 IE Chrome FireFox Safair 常用的BOM对象 window对象 代表浏览器窗口 screen 代表屏幕尺寸 location 代表当前页面的URL信息 12345host: &quot;www.baidu.com&quot; href: &quot;https://www.baidu.com/&quot; portocol: &quot;https&quot; //协议reload:f reload() //刷新页面location.assign(&quot;www.jd.com&quot;) //重定向 doucument 代表当前的页面,HTML,DOM文档树 12document.title //获取当前页面的标题document.cookie history 12history.back //回退history.forward //前进 操作DOM对象(重点)网页就是一个Dom树形结构! 获得dom节点 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;操作dom对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;h1&gt;标题1&lt;/h1&gt; &lt;p id=&quot;p1&quot;&gt;p1&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; //对应CSS的选择器 var h1 = document.getElementsByTagName(&quot;h1&quot;); //根据标签名 var p1 = document.getElementById(&quot;p1&quot;); var p2 = document.getElementsByClassName(&quot;p2&quot;) ; var father = document.getElementById(&quot;father&quot;) ; //获取所有子节点 var childrens = father.children; &lt;/script&gt;&lt;/html&gt; 更新dom节点 12345678&lt;div id = &quot;id1&quot;&gt;&lt;/div&gt;&lt;script&gt;var id1 = document.getElementById(&quot;id1&quot;); //首先获得节点 id1.innerText = “文本内容” ; // 修改文本的值,会把之前的文本内容清除,不可解析html标签id1.innerHTML = “文本内容” ; // 修改文本的值,与上面的唯一区别是可以解析html标签&lt;/script&gt; remove 删除节点 由于指针不能指向自己,所以要删除一个节点,必须要先获得父节点,再通过父结点来删除 ==注意:删除结点是动态的==(即当删除第一个子节点的时候,原来的第二个子节点就变成了现在的第一个子结点) 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;删除结点&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;father1&quot;&gt; &lt;h6 id=&quot;ch1&quot;&gt;子结点&lt;/h6&gt; &lt;h6 id=&quot;ch2&quot;&gt;子结点&lt;/h6&gt; &lt;h6 id=&quot;ch3&quot;&gt;子结点&lt;/h6&gt; &lt;h6 id=&quot;ch4&quot;&gt;子结点&lt;/h6&gt; &lt;/div&gt; &lt;!-- JS --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var f = document.getElementById(&quot;ch1&quot;).parentElement; // 以下操作是错误的,动态删除 f.removeChild(f.children[0]) ; f.removeChild(f.children[1]) ; f.removeChild(f.children[2]) ; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; append 追加结点 在document结点后面添加结点 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;h4 id =&quot;java&quot;&gt;java&lt;/h4&gt; &lt;p id=&quot;se&quot;&gt;javaSE&lt;/p&gt; &lt;p id=&quot;ee&quot;&gt;JavaEE&lt;/p&gt; &lt;p id=&quot;me&quot;&gt;javaME&lt;/p&gt; &lt;/div&gt; &lt;!-- JS --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var new_p = document.createElement(&#x27;p&#x27;) ; //获得p标签结点 new_p.id = &#x27;new_p&#x27;; //设置属性值 new_p.innerText = &quot;hello java!&quot;; father.append(new_p); var body = document.getElementsByTagName(&quot;body&quot;) ; var style = document.createElement(&quot;style&quot;) ; //style.setAttribute(&quot;type&quot;,&quot;text/css&quot;) ; //设置属性值,其中参数 key,vaule,也可以用下面的方式 style.type = &#x27;text/css&#x27; style.innerHTML = &#x27;body&#123;background-color:pink &#125;&#x27; ; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(style); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; insert 插入结点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;h4 id =&quot;java&quot;&gt;java&lt;/h4&gt; &lt;p id=&quot;se&quot;&gt;javaSE&lt;/p&gt; &lt;p id=&quot;ee&quot;&gt;JavaEE&lt;/p&gt; &lt;p id=&quot;me&quot;&gt;javaME&lt;/p&gt; &lt;button type=&quot;button&quot; onclick=&quot;apend_p&quot;&gt;追加元素&lt;/button&gt; &lt;button type=&quot;button&quot; onclick=&quot;apend_style&quot;&gt;追加样式&lt;/button&gt; &lt;button type=&quot;button&quot; onclick=&quot;insert_java&quot;&gt;插入元素&lt;/button&gt; &lt;/div&gt; &lt;!-- JS --&gt; &lt;script type=&quot;text/javascript&quot;&gt; function apend_p()&#123;// 追加p元素 alert(&quot;nihao!&quot;) ; var new_p = document.createElement(&#x27;p&#x27;) ; new_p.id = &#x27;new_p&#x27;; new_p.innerText = &quot;hello java!&quot;; father.append(new_p); &#125; function apend_style()&#123; //追击style元素 var body = document.getElementsByTagName(&quot;body&quot;) ; var style = document.createElement(&quot;style&quot;) ; //style.setAttribute(&quot;type&quot;,&quot;text/css&quot;) ; //设置属性值 style.type = &#x27;text/css&#x27; style.innerHTML = &#x27;body&#123;background-color:pink &#125;&#x27; ; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(style); &#125; function insert_java()&#123; // 插入p元素 var java = document.getElementById(&quot;java&quot;) ; var js = document.createElement(&quot;p&quot;) ; js.id = &#x27;js&#x27; ; js.innerText = &quot;javaScript&quot; ; var father = document.getElementById(&quot;father&quot;) ; father.insertBefore(js,java) ; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 当拿到结点document结点(id也能直接进行操作)后,我们可以进行一下操作 操作文本id1.innerText = “文本内容” ; 修改文本的值,==会把之前的文本内容清除,不可解析html标签== id1.innerHTML = “文本内容” ; 修改文本的值,==与上面的唯一区别是可以解析html标签== 操作CSS(更改样式)12p1.style.color = &quot;red&quot; ; //修改颜色p1.style.fontSize = 12em ; //修改字体大小 操作表单(验证表单)注:可以通过添加 required 属性使文本框变为必填项,不填写就提交会有提示==,表单里的input标签,一定要有name属性才能发送到后台== 获得表单的值1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS操作表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;!--&gt;可以通过添加 required 属性使文本框变为必填项,不填写就提交会有提示&lt;--&gt; 用户名: &lt;input type=&quot;text&quot; id=&quot;uid&quot; required/&gt; &lt;br&gt; 密码: &lt;input type=&quot;password&quot; id=&quot;pwd&quot; name=&quot;pwd&quot; required/&gt; &lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex_m&quot; value=&quot;男&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex_w&quot; value=&quot;女&quot; /&gt;女 &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;确定&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var uid = document.getElementById(&quot;uid&quot;) ; var pwd = document.getElementById(&quot;pwd&quot;) ; var sex_m = document.getElementById(&quot;sex_m&quot;); var sex_w = document.getElementById(&quot;sex_w&quot;) ; //可通过 uid.value 获得文本框的值,同理也可以通过这种方式修改值 //单选框 可通过 sex_m.checked = true 则表示被选中,否则就是没选中来判断 &lt;/script&gt;&lt;/html&gt; 表单数据加密(md5)以及提交验证==表单中的onsubmit 属性:用于提交验证,如果事件函数返回true,则提交,反之不提交,注意还要写一个return,并且默认为true== ==此外,在提交表单时容易被人抓包发现表单的数据,==,因此我们需要对表单数据进行加密 如下代码对表单进行了加密 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;提交表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入md5.js 工具包 --&gt; &lt;script src=&quot;MD5_js/md5.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;!-- onsubmit 属性:表单提交验证,如果事件函数返回true,则提交,反之不提交,注意还要写一个return,并且默认为true --&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot; onsubmit=&quot;return ff2()&quot;&gt; &lt;p&gt; 用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; value=&quot;&quot; /&gt; &lt;/p&gt; &lt;p&gt; 密码: &lt;input type=&quot;password&quot; id=&quot;pwd&quot; name=&quot;password&quot; /&gt; &lt;/p&gt; &lt;!-- 通过按钮绑定事件 --&gt; &lt;!-- &lt;button type=&quot;button&quot; onclick=&quot;ff()&quot;&gt;提交&lt;/button&gt; --&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;ok&quot; /&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; function ff()&#123; var uid = document.getElementById(&quot;username&quot;) ; var pwd = document.getElementById(&quot;pwd&quot;) ; console.log(uid.value); console.log(pwd.value); &#125; function ff2()&#123; alert(&quot;2&quot;) var uid = document.getElementById(&quot;username&quot;) ; var pwd = document.getElementById(&quot;pwd&quot;) ; //md5加密 pwd.value = hex_md5(pwd.value) ; return true ; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ==由于直接对密码框进行密文赋值,会导致密码框在提交的一瞬间变长,不能提升用户体验,所以我们可以采用一个隐藏密码框来进行赋值传输== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;提交表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入md5.js 工具包 --&gt; &lt;script src=&quot;MD5_js/md5.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;!-- onsubmit 属性:表单提交验证,如果事件函数返回true,则提交,反之不提交 --&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot; onsubmit=&quot;return ff2()&quot;&gt; &lt;p&gt; 用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; value=&quot;&quot; /&gt; &lt;/p&gt; &lt;p&gt; 密码: &lt;input type=&quot;password&quot; id=&quot;input_pwd&quot; name=&quot;input_pwd&quot; /&gt; &lt;/p&gt; &lt;!-- 隐藏密码框 --&gt; &lt;div id =&quot;hidden_pwd&quot; &gt; &lt;input type=&quot;password&quot; hidden=&quot;hidden&quot; id=&quot;pwd&quot; name=&quot;password&quot;/&gt; &lt;/div&gt; &lt;!-- 通过按钮绑定事件 --&gt; &lt;!-- &lt;button type=&quot;button&quot; onclick=&quot;ff()&quot;&gt;提交&lt;/button&gt; --&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;ok&quot; /&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; function ff()&#123; var uid = document.getElementById(&quot;username&quot;) ; var pwd = document.getElementById(&quot;pwd&quot;) ; console.log(uid.value); console.log(pwd.value); &#125; function ff2()&#123; alert(&quot;2&quot;) var uid = document.getElementById(&quot;username&quot;) ; // 明文密码框 var input_pwd = document.getElementById(&quot;input_pwd&quot;) ; // 获得隐藏密码框结点 var pwd = document.getElementById(&quot;pwd&quot;) ; //md5加密 pwd.value = hex_md5(input_pwd.value) ; input_pwd.value = &quot; &quot; ; return true ; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; jQueryjQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程。 jQuery 很容易学习。 简述初识jQuery 库位于一个 JavaScript 文件中，其中包含了所有的 jQuery 函数。==请注意，&lt;script&gt; 标签应该位于页面的 &lt;head&gt; 部分。== 1234&lt;head&gt; &lt;!-- 引入jQuery文件,文件可用网上资源(CDN)或者下载到本地 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 谷歌CDN:1234&lt;head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 微软CDN:1234&lt;head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.microsoft.com/ajax/jquery/jquery-1.4.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 基础 jQuery 实例下面的例子演示了 jQuery 的 hide() 函数，隐藏了 HTML 文档中所有的 元素。 123456789101112131415161718192021222324&lt;html&gt;&lt;!-- 点击按钮让p标签消失 --&gt;&lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function () &#123; // 选中 按钮,绑定点击事件函数 $(&quot;button&quot;).click(function () &#123; // 选中 p 标签,调用 hide() 函数 $(&quot;p&quot;).hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;This is a heading&lt;/h2&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt; &lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery语法:通过 jQuery，您可以选取（查询，query） HTML 元素，并对它们执行“操作”（actions）。 ==基础语法是：*$(selector).action()*== 美元符号定义 jQuery 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作 示例: $(this).hide() - 隐藏当前元素 $(“p”).hide() - 隐藏所有段落 (标签选择器) $(“.test”).hide() - 隐藏所有 class=”test” 的所有元素 (类选择器,注意加引号) $(“#test”).hide() - 隐藏所有 id=”test” 的元素 (id选择器,注意加引号) 提示：jQuery 使用的语法是 ==XPath 与 CSS 选择器语法的组合。== 文档就绪函数您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中： 12345$(document).ready(function()&#123;--- jQuery functions go here ----&#125;); 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。 如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子： 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 jQuery选择器jQuery选择器与CSS的选择器基本一致 注意:选择器表示时需要用引号表示,特别的 id 可以之间写在括号内或者用CSS选择表示(加引号) 123//设有一个带有 &lt;p id=&quot;id&quot;&gt;&lt;/p&gt;$(id).aciton();$(&quot;id&quot;).action(); 语法 描述 $(this) 当前 HTML 元素 $(“p”) 所有 元素 $(“p.intro”) 所有 class=”intro” 的 元素 $(“.intro”) 所有 class=”intro” 的元素 $(“#intro”) id=”intro” 的元素 $(“ul li:first”) 每个 的第一个 元素 $(“[href$=’.jpg’]”) 所有带有以 “.jpg” 结尾的属性值的 href 属性 $(“div#intro .head”) id=”intro” 的 元素中的所有 class=”head” 的元素 jQuery事件jQuery 事件处理方法是 jQuery 中的核心函数。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。术语由事件“触发”（或“激发”）经常会被使用。 通常会把 jQuery 代码放到 部分的事件处理方法中： 常见事件: $(document).ready(function) 将函数绑定到文档的就绪事件（当文档完成加载时） $(selector).click(function) 触发或将函数绑定到被选元素的点击事件 $(selector).dblclick(function) 触发或将函数绑定到被选元素的双击事件 $(selector).focus(function) 触发或将函数绑定到被选元素的获得焦点事件 $(selector).mouseover(function) 触发或将函数绑定到被选元素的鼠标悬停事件 jQuery 名称冲突:jQuery 使用 $ 符号作为 jQuery 的简介方式。 某些其他 JavaScript 库中的函数（比如 Prototype）同样使用 $ 符号。 jQuery 使用名为 noConflict() 的方法来解决该问题。 ==*var jq=jQuery.noConflict()*，帮助您使用自己的名称（比如 jq）来代替 $ 符号。== 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=&quot;/jquery/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //这里用将jQuery 用来替换 $ 符号$.noConflict(); jQuery(document).ready(function()&#123; jQuery(&quot;button&quot;).click(function()&#123; jQuery(&quot;p&quot;).text(&quot;jQuery 仍在运行！&quot;); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;button&gt;测试 jQuery&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 总结:由于 jQuery 是为处理 HTML 事件而特别设计的，那么当您遵循以下原则时，您的代码会更恰当且更易维护： 把所有 jQuery 代码置于事件处理函数中 把所有事件处理函数置于文档就绪事件处理器中 把 jQuery 代码置于单独的 .js 文件中 如果存在名称冲突，则重命名 jQuery 库 jQuery效果隐藏、显示、切换，滑动，淡入淡出，以及动画，哇哦！ 隐藏与显示函数: hide((speed,callback)) 隐藏 show((speed,callback)) 显示 toglgle((speed,callback)) 切换 语法： 1$(selector).toggle(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是 toggle() 方法完成后所执行的函数名称。(即回调函数) ==注意:参数类型必须是字符串== 淡入谈出:123fadeIn(speed,callback); // 淡入fadeOut(speed,callback); // 淡出fadeToggle(speed,callback); //切换淡入淡出 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是 fading 完成后所执行的函数名称。 AjaxAjax即Asynchronous Javascript And XML（异步JavaScript和XML）在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML 或 XHTML, CSS, JavaScript, DOM, XML, XSLT, 以及最重要的XMLHttpRequest。 [3] 使用Ajax技术网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面，这使得程序能够更快地回应用户的操作。 Ajax如何工作: 网页中发生一个事件（页面加载、按钮点击） 由 JavaScript 创建 XMLHttpRequest 对象 XMLHttpRequest 对象向 web 服务器发送请求 服务器处理该请求 服务器将响应发送回网页 由 JavaScript 读取响应 由 JavaScript 执行正确的动作（比如更新页面） 样例: html页面: 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h2&gt;让 AJAX 更改这段文本&lt;/h2&gt; &lt;button type=&quot;button&quot; onclick=&quot;loadDoc()&quot;&gt;更改文本&lt;/button&gt; &lt;!-- js点击事件触发函数 loadDoc() --&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; js代码: 1234567891011121314151617181920Function loadDoc()/* 定义函数 */function loadDoc() &#123; var xhttp = new XMLHttpRequest(); //创建响应对象 /* 事件句柄事件绑定事件函数 每次 readyState 属性改变的时候调用的事件句柄函数。当 readyState 为 3 时，它也可能调用多次。 readyState为http请求状态当一个 XMLHttpRequest 初次创建时，这个属性的值从 0 开始， 直到接收到完整的 HTTP 响应，这个值增加到 4。 */ xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; //响应成功后 document.getElementById(&quot;demo&quot;).innerHTML = this.responseText; &#125; &#125;; //初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求。 xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, true); //发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体 xhttp.send();&#125; XMLHttpRequestAjax 的核心是 XMLHttpRequest 对象。 XMLHttpRequest 对象用于同服务器交换数据。 所有现代浏览器都支持 XMLHttpRequest 对象。XMLHttpRequest 对象用于同幕后服务器交换数据。这意味着可以更新网页的部分，而不需要重新加载整个页面。 创建XMLHttpRequest 对象1234567var xhttp;if (window.XMLHttpRequest) &#123; xhttp = new XMLHttpRequest(); &#125; else &#123; // code for IE6, IE5, 老版本浏览器可能只支持ActiveX对象 xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125; XMLHttpRequest 对象方法 new XMLHttpRequest() 创建新的 XMLHttpRequest 对象 abort() 取消当前请求 getAllResponseHeaders() 返回头部信息 getResponseHeader() 返回特定的头部信息 open(method, url, async, user, psw) 规定请求 method：请求类型 GET 或 POST url：文件位置 async：true（异步）或 false（同步） user：可选的用户名称 psw：可选的密码 send() 将请求发送到服务器，用于 GET 请求 send(string) 将请求发送到服务器，用于 POST 请求 setRequestHeader() 向要发送的报头添加标签/值对 GET 还是 POST？GET 比 POST 更简单更快，可用于大多数情况下。不过，请在以下情况始终使用 POST： 缓存文件不是选项（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 无大小限制） 发送用户输入（可包含未知字符），POST 比 GET 更强大更安全 XMLHttpRequest 对象属性 属性 描述 onreadystatechange 定义当 readyState 属性发生变化时被调用的函数 readyState 保存 XMLHttpRequest 的状态。 0：请求未初始化 1：服务器连接已建立 2：请求已收到 3：正在处理请求 4：请求已完成且响应已就绪 responseText 以字符串返回响应数据 responseXML 以 XML 数据返回响应数据 status 返回请求的状态号 200: “OK” 403: “Forbidden” 404: “Not Found” 如需完整列表请访问 Http 消息参考手册 statusText 返回状态文本（比如 “OK” 或 “Not Found”） onreadystatechange 属性通过 XMLHttpRequest 对象，您可以定义当请求接收到应答时所执行的函数。 这个函数是在 XMLHttpResponse 对象的 onreadystatechange 属性中定义的： 1234567xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(&quot;demo&quot;).innerHTML = this.responseText; &#125;&#125;;xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, true);xhttp.send(); 使用回调函数回调函数是一种作为参数被传递到另一个函数的函数。 如果您的网站中有多个 AJAX 任务，那么您应该创建一个执行 XMLHttpRequest 对象的函数，以及一个供每个 AJAX 任务的回调函数。 该函数应当包含 URL 以及当响应就绪时调用的函数。 123456789101112131415161718192021222324loadDoc(&quot;url-1&quot;, myFunction1); // (1)loadDoc(&quot;url-2&quot;, myFunction2);//声明函数,第一个参数是url ,第二个参数类型是函数(即回调函数)function loadDoc(url, cFunction) &#123; var xhttp; xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; cFunction(this); //使用自己(xhttp)作为参数传入下面的函数作为参数执行 &#125; &#125;; xhttp.open(&quot;GET&quot;, url, true); xhttp.send();&#125;function myFunction1(xhttp) &#123; // 回调函数1 // action goes here &#125; function myFunction2(xhttp) &#123; //回调函数2 // action goes here &#125; responseText 属性responseText 属性以 JavaScript 字符串的形式返回服务器响应，因此您可以这样使用它： 1document.getElementById(&quot;demo&quot;).innerHTML = xhttp.responseText; responseXML 属性XML HttpRequest 对象有一个內建的 XML 解析器。 ResponseXML 属性以 XML DOM 对象返回服务器响应。 使用此属性，您可以把响应解析为 XML DOM 对象： Ajax 获取XML文件AJAX 可用于同 XML 文件进行交互式通信。 实例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt;table,th,td &#123; border : 1px solid black; border-collapse: collapse;&#125;th,td &#123; padding: 5px;&#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;XMLHttpRequest 对象&lt;/h1&gt;&lt;button type=&quot;button&quot; onclick=&quot;loadDoc()&quot;&gt;获取我的音乐列表&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;table id=&quot;demo&quot;&gt;&lt;/table&gt;&lt;script&gt;function loadDoc() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myFunction(this); //this 是指??? xhttp??? &#125; &#125;; xhttp.open(&quot;GET&quot;, &quot;/demo/music_list.xml&quot;, true); xhttp.send();&#125;function myFunction(xml) &#123; var i; var xmlDoc = xml.responseXML; //获得响应件对象 var table=&quot;&lt;tr&gt;&lt;th&gt;艺术家&lt;/th&gt;&lt;th&gt;曲目&lt;/th&gt;&lt;/tr&gt;&quot;; var x = xmlDoc.getElementsByTagName(&quot;TRACK&quot;); for (i = 0; i &lt;x.length; i++) &#123; table += &quot;&lt;tr&gt;&lt;td&gt;&quot; + x[i].getElementsByTagName(&quot;ARTIST&quot;)[0].childNodes[0].nodeValue + &quot;&lt;/td&gt;&lt;td&gt;&quot; + x[i].getElementsByTagName(&quot;TITLE&quot;)[0].childNodes[0].nodeValue + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; document.getElementById(&quot;demo&quot;).innerHTML = table;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Jquery封装好的Ajax网络请求(get和post)基础知识:在get请求中 , 请求的发送的==数据和参数会直接暴露在url中== , 格式为: url?参数1=value&amp;参数2value&amp;参数3=value ,即用问号分隔url和参数列表, 参数列表中的多个参数用 &amp; 分隔 如图所示: 在百度搜索 “你好世界” ,观察url (即 : https://www.baidu.com/baidu?tn=monline_3_dg&amp;ie=utf-8&amp;wd=你好世界), 可发现发送请求时携带了三个参数 (即 tn , ie , wd) ,他们的值分别为: monline_3_d , utf-8 , 你好世界 load() 方法 12345语法:$(selector).load(URL,data,callback); // 必需的 URL 参数规定您希望加载的 URL。// 可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。// 可选的 callback 参数是 load() 方法完成后所执行的函数名称。 get()方法 123456789$.get(URL,callback);// 必需的 URL 参数规定您希望请求的 URL。// 可选的 callback 参数是请求成功后所执行的函数名。//例子:$(&quot;button&quot;).click(function()&#123; $.get(&quot;demo_test.asp&quot;,function(data,status)&#123; alert(&quot;Data: &quot; + data + &quot;\\nStatus: &quot; + status); &#125;);&#125;); post方法 1234567891011121314$.post(URL,data,callback);//必需的 URL 参数规定您希望请求的 URL。//可选的 data 参数规定连同请求发送的数据。//可选的 callback 参数是请求成功后所执行的函数名。$(&quot;button&quot;).click(function()&#123; $.post(&quot;demo_test_post.asp&quot;, &#123; name:&quot;Donald Duck&quot;, city:&quot;Duckburg&quot; &#125;, function(data,status)&#123; alert(&quot;Data: &quot; + data + &quot;\\nStatus: &quot; + status); &#125;);&#125;); 可异步的Ajax方法:1jQuery.ajax([settings]) ; //其中settings是配置请求选项的键值对 setting参数: url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。 **type:**要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。 async: 要求为Boolean类型的参数，==默认设置为true，所有请求均为异步请求==。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。 **data:**要求为Object或String类型的参数，发送到服务器的数据。==如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换==，可以查看processData选项。==对象必须为key/value格式==，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。==如果是数组，JQuery将自动为不同值对应同一个名称==。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。 dataType:==要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。==可用的类型如下： xml：返回XML文档，可用JQuery处理。 html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。 text：返回纯文本字符串。 script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。 json：返回JSON数据。 jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。 **contentType:**要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。 success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。(1)由服务器返回，并根据dataType参数进行处理后的数据。(2)描述状态的字符串。 1234function(data, textStatus)&#123;//data可能是xmlDoc、jsonObj、html、text等等this; //调用本次ajax请求时传递的options参数&#125; **error:**要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下： 1234function(XMLHttpRequest, textStatus, errorThrown)&#123;//通常情况下textStatus和errorThrown只有其中一个包含信息this; //调用本次ajax请求时传递的options参数&#125; **cache:**要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。 **timeout:**要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。 案例: 1234567891011121314151617181920$(function()&#123; $(&#x27;#send&#x27;).click(function()&#123; $.ajax(&#123; type: &quot;GET&quot;, url: &quot;test.json&quot;, data: &#123;username:$(&quot;#username&quot;).val(), content:$(&quot;#content&quot;).val()&#125;, dataType: &quot;json&quot;, success: function(data)&#123; $(&#x27;#resText&#x27;).empty(); //清空resText里面的所有内容 var html = &#x27;&#x27;; $.each(data, function(commentIndex, comment)&#123; html += &#x27;&lt;div class=&quot;comment&quot;&gt;&lt;h6&gt;&#x27; + comment[&#x27;username&#x27;] + &#x27;:&lt;/h6&gt;&lt;p class=&quot;para&quot;&#x27; + comment[&#x27;content&#x27;] + &#x27;&lt;/p&gt;&lt;/div&gt;&#x27;; &#125;); $(&#x27;#resText&#x27;).html(html); &#125; &#125;); &#125;);&#125;); axious 在线引入CDN axios官方CDN服务 12345&lt;!-- 完整版 --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/axios/0.26.1/axios.js&quot;&gt;&lt;/script&gt;&lt;!-- 精简版: --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/axios/0.26.1/axios.min.js&quot;&gt;&lt;/script&gt; npm 安装(推荐) npm i axious 浅谈axious与ajax1.区别:axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。axios是ajax (一部分), ajax不止axios。 **扩展:**Promise是异步编程的一种解决方案，可以替代传统的解决方案–回调函数和事件。ES6统一了用法，并原生提供了Promise对象。作为对象，Promise有一下两个特点： （1）对象的状态不受外界影响。 （2）一旦状态改变了就不会在变，也就是说任何时候Promise都只有一种状态。 2.优缺点:ajax：本身是针对MVC的编程,不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务axios：从 node.js 创建 http 请求支持 Promise API客户端支持防止CSRF提供了一些并发请求的接口（重要，方便了很多的操作） 拓展:Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 ajax和axios、fetch的区别 3.实现对比:12345678910111213141516171819202122232425262728 // jquery封装的ajax$.ajax(&#123; url: &#x27;/getUsers&#x27;, type: &#x27;get&#x27;, dataType: &#x27;json&#x27;, data: &#123; //&#x27;a&#x27;: 1, //&#x27;b&#x27;: 2, &#125;, success: function (response) &#123; console.log(response)； &#125; &#125;)//axious封装的ajaxaxios(&#123; url: &#x27;/getUsers&#x27;, method: &#x27;get&#x27;, responseType: &#x27;json&#x27;, // 默认的 data: &#123; //&#x27;a&#x27;: 1, //&#x27;b&#x27;: 2, &#125; &#125;).then(function (response) &#123; console.log(response); console.log(response.data); &#125;).catch(function (error) &#123; console.log(error); &#125;） 4.axious使用:注: axious请求默认都是异步请求 发送get请求: 123456789101112131415161718192021// 为给定 ID 的 user 创建请求axios.get(&#x27;/user?ID=12345&#x27;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 上面的请求也可以这样做axios.get(&#x27;/user&#x27;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 发送post请求: 12345678910axios.post(&#x27;/user&#x27;, &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 并发多个请求: 12345678910function getUserAccount() &#123; return axios.get(&#x27;/user/12345&#x27;);&#125;function getUserPermissions() &#123; return axios.get(&#x27;/user/12345/permissions&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); 请求配置: 这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 详情请查询:axios中文网 123456789101112131415161718192021// 发送 POST 请求axios(&#123; method: &#x27;post&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;);// 获取远端图片axios(&#123; method:&#x27;get&#x27;, url:&#x27;http://bit.ly/2mTM3nY&#x27;, responseType:&#x27;stream&#x27;&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream(&#x27;ada_lovelace.jpg&#x27;))&#125;) .catch(function (error) &#123; console.log(error);&#125;); 配置项有: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&#123; // `url` 是用于请求的服务器 URL url: &#x27;/user&#x27;, // `method` 是创建请求时使用的方法 method: &#x27;get&#x27;, // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &#x27;https://some-domain.com/api/&#x27;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `responseType` 表示服务器响应的数据类型，可以是 &#x27;arraybuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27; responseType: &#x27;json&#x27;, // default // `responseEncoding` indicates encoding to use for decoding responses // Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests responseEncoding: &#x27;utf8&#x27;, // default // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: &#x27;janedoe&#x27;, password: &#x27;s00pers3cret&#x27; &#125;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: &#x27;Fred&#x27; &#125;, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // default // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` defines a UNIX Socket to be used in node.js. // e.g. &#x27;/var/run/docker.sock&#x27; to send requests to the docker daemon. // Only either `socketPath` or `proxy` can be specified. // If both are specified, `socketPath` is used. socketPath: null, // default // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // &#x27;proxy&#x27; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: &#x27;127.0.0.1&#x27;, port: 9000, auth: &#123; username: &#x27;mikeymike&#x27;, password: &#x27;rapunz3l&#x27; &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; Vue 简记MVVM模型每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例。 1.M: 模型(Model):对应data中的数据 2.V:视图(View):模型 3.VM:视图模型(ViewModel): Vue实例对象 回顾 Object.defineProperty()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; let person = &#123; // 声明定义的对象属性: //默认可以 : 枚举,删除,修改 name: &quot;张三&quot;, sex: &quot;男&quot; &#125;; // Object.defineProperty(对象, 属性 ,引用类型的配置项) //添加(定义)属性 age //这样添加的属性是不可枚举的,也就是无法通过增强for遍历到 Object.defineProperty(person, &quot;age1&quot;, &#123; value: 18 &#125;) // 遍历不到 console.log(Object.keys(person)); for (let key in person) &#123; console.log(key); &#125; Object.defineProperty(person, &quot;age2&quot;, &#123; value: 18, enumerable:true, //控制属性是否可枚举 ,默认为false writable:true, //控制属性是否可修改,默认为false configurable: true //控制属性是否可以被删除 &#125;) console.log(Object.keys(person)); /**********************简单的数据代理小demo*****************************************//******使用 变量 a 代理了 属性job********/ let a =&quot;律师&quot;; Object.defineProperty(person,&quot;job&quot;,&#123; enumerable:true, configurable:true, // 使用getter后不能再指定属性为 riteable为true和指定value get()&#123; //当读取属性时触发 //此时请注意,当每次获取job时都会从执行如下函数,也就是说即使执行了 person.job = &quot;值&quot;,只要a没变,那么person.job也是不会变的 console.log(&quot;读取了job&quot;); return a; &#125;, set(set_value)&#123; //当修改属性时触发 console.log(&quot;修改了job,修改的值是:&quot;,set_value); a = set_value; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; vue中的数据代理与监测12345678910&lt;!-- Vue 数据代理: 在页面中&#123;&#123;name&#125;&#125; 实际上获取到的值,应该是 data()&#123; return &#123;school:&quot;广科师&quot;,major:&quot;软件工程&quot;&#125;; &#125; 原理: 在new 一个Vue实例时, 我们将构造器Vue(&#123;对象&#125;)中的参数对象称为 opintion , 其中参数对象的 data属性 会成为 vue实例的生成一个名为 _data的属性(此时依然没有 涉及到数据代理,属于赋值的关系),即实际上js整个作用域中真实存在的只有 _data属性(这个属性的类型是对象) 随后为了编码方便,vue实例又生成代理_data对象的属性值的属性 --&gt; 示意图 模拟一个数据监测123456789101112131415161718192021222324252627282930let data = &#123; //用这个模拟,Vue里我们配置的data name :&quot;Vue&quot;, address :&quot;神奈川&quot;&#125;;// 创建一个代理对象let obs = new Observe(data);console.log(obs);// 代理对象的构造方法function Observe(obj)&#123; // 拿到参数的 所有属性 let keys = Object.keys(obj); keys.forEach((k)=&gt;&#123; // k 是每次变量的临时值 /* 下面的意思是: 当读取或者修改Observer的实例的属性时, 将用参数 obj的属性值替换, 也就是将Observer实例与参数 obj双向绑定 */ Object.defineProperty(this,k,&#123; //这里的 this 指向 Observer创建的实例对象 get()&#123; // 这里用方括号不用 . 是因为 k 是变量 return obj[k]; &#125;, set(val)&#123; obj[k] = val; &#125; &#125;); &#125;);&#125;;let vm = &#123;&#125;;vm._data = data = obs; Vue2实例的属性添加问题如果不借助api,在Vue2中, vue实例是不允许添加数据的 但是可借助Vue.set()方法在**已有的数据对象(即这个对象必须是响应式的)**中添加属性 Vue2监测数组问题在vue监测的数据中,如果数据是数组,只有数组是通过调用如下方法改变才能被监测到,(vue底层对起进行了封装) push() 从尾部添加一个数据 pop() 从尾部移除一个数据 shift() 从头部移除一个数据 unshift() 从头部添加一个数据 splice(int start,int count,data) 替换数组中的数据, 参数start代表从哪个开始(第一个是0),count代表替换数据个数 sort() 升序排序 reverse() 反转 数据监测小总结: 列表渲染循环列表的key原理(key使用id而不使用index) Vue在修改dom时,==会复用dom==,所以在上面的例子中,==vue根据 key对比==,由于key是索引,导致复用了之前的文本框 故: ==推荐使用唯一标识数据项的属性(如id)来绑定 key== ,如渲染的列表仅作为展示不修改,则两者无所谓 列表过滤(分别使用computed和watch实现) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;列表过滤(watch实现)&lt;/h3&gt; 模糊搜索:&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; placeholder=&quot;请输入名字&quot;/&gt; &lt;br&gt; &lt;li v-for=&quot;(p,index) of filterPersons&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125; - &#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;h3&gt;列表过滤(computed实现)&lt;/h3&gt; 模糊搜索:&lt;input type=&quot;text&quot; v-model=&quot;keyword2&quot; placeholder=&quot;请输入名字&quot;/&gt; &lt;br&gt; &lt;li v-for=&quot;(p,index) of key_person&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125; - &#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: root, data:&#123; persons:[ &#123;id:&quot;001&quot;,name:&quot;马冬梅&quot;,age:32&#125;, &#123;id:&quot;002&quot;,name:&quot;周冬雨&quot;,age:18&#125;, &#123;id:&quot;003&quot;,name:&quot;周杰伦&quot;,age:26&#125;, &#123;id:&quot;004&quot;,name:&quot;温兆伦&quot;,age:27&#125; ], // 搜索关键字 keyword:&quot;&quot;, // 过滤后的数据 filterPersons:[], persons2:[ &#123;id:&quot;01&quot;,name:&quot;马冬梅&quot;,age:32&#125;, &#123;id:&quot;02&quot;,name:&quot;周冬雨&quot;,age:18&#125;, &#123;id:&quot;03&quot;,name:&quot;周杰伦&quot;,age:26&#125;, &#123;id:&quot;04&quot;,name:&quot;温兆伦&quot;,age:27&#125; ], // 搜索关键字 keyword2:&quot;&quot;, &#125;, methods:&#123; &#125;, computed:&#123; key_person()&#123; return this.persons2.filter((p)=&gt;&#123; return p.name.indexOf(this.keyword2) !== -1 &#125;) &#125; &#125;, watch:&#123; keyword:&#123; immediate:true, handler(newValue)&#123; /* Array.filter() 用法 它创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意：filter()不会对空数组进行检测、不会改变原始数组 语法:Array.filter(function(currentValue, indedx, arr), thisValue) 其中，函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留； 函数的第一个参数 currentValue 也为必须，代表当前元素的值。 */ return this.filterPersons = this.persons.filter((p)=&gt;&#123; // indexOf() 判断一个字符串是否包含参数字符串,返回匹配值的首字符索引,不存在返回 -1 // 并且每个数组都包含空串 // console.log(&quot;过滤器的this是:&quot;,this); //this 因为是箭头函数指向父级上下问,即 vm return p.name.indexOf(newValue) !== -1; &#125;) &#125; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 表单数据收集 生命周期 注: 生命周期钩子函数共有4对,8个,即: beforeCreate Created beforeMount Mounted beforeUpate Updated beforeDestory Destoryed 组件化编程组件:用来实现局部特定功能效果的代码集合 Vue与VueComponent之间的关系VueComponent是组件的构造函数,下面将组件实例对象称为vc 实际上,组件就是继承自Vue,只不过组件没有el配置属性,其他vue该有的它都有 此外,请注意,在组件中的配置项(如methods中定义的函数)它们的this应该是指向vc的 vue脚手架(CLI)CLI即command line Interface,命令行接口,在使用单文件组件的时候会用到 安装脚手架注意:使用的命令行尽量都使用管理员权限的命令行 脚手架的安装需要node.js环境 node.js安装与配置由于 Node.js 中默认安装了 npm，所以不用额外配置就能在全局命令中使用 npm命令，如果要使用自己安装的 npm 时，如 cnpm ，那么就需要像上面一样添加相应的环境变量然后在cmd或者shell中测试一下是否安装成功了：输入 node -v 与 npm -v node.js修改默认下载地址在node.js下新建两个文件夹如下所示 随后输入命令修改配置: 12npm config set prefix &quot;D:\\node安装目录\\node_global&quot; 注意:目录自行替换 npm config set cache &quot;D:\\node安装目录\\node_cache&quot; 将来全局安装的东西就会跑到这个文件夹的node_modules文件夹里面去了。 配置npm镜像源输入如下命令: 1npm --registry https://registry.npm.taobao.org install express -g 配置环境变量增加系统环境变量NODE_PATH 内容是：D:\\node安装目录\\node安装目录\\node_modules 最后编辑用户变量里的Path，将相应npm的路径改为：D:\\node安装目录\\node_global(以自己路径为主) 至此node.js环境就配置好了 下载脚手架CLI命令 :npm install -g @vue/cli 使用脚手架切换到需要创建项目的目录 创建项目: vue create 项目名 运行项目: npm run serve 项目结构 基本的html页面相关说明 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 兼容IE --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- 开启移动端最理想视图 --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;!-- 引入图标, &lt;%= BASE_URL %&gt;表示脚手架配置处理的路径 --&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;!-- 引入配置的网页标题 --&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- noscript标签当浏览器不支持js的时候才会渲染 --&gt; &lt;noscript&gt; &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 配置修改vue.config.js配置文件在项目的根目录下(没有可以在自己新建) 随后来到vue官网的CLI配置栏目进行查找: 配置参考 | Vue CLI (vuejs.org)","categories":[{"name":"大前端","slug":"大前端","permalink":"https://lqy679.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"Mybatis","slug":"Mybatis","date":"2020-01-01T10:57:32.000Z","updated":"2023-03-31T08:37:17.790Z","comments":true,"path":"2020/01/01/Mybatis/","link":"","permalink":"https://lqy679.github.io/2020/01/01/Mybatis/","excerpt":"Mybatis简介 官网地址:mybatis – MyBatis 3 | 简介 MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。MyBatis本是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了[google code](https://baike.baidu.com/item/google code/2346604)，并且改名为MyBatis。2013年11月迁移到Github。","text":"Mybatis简介 官网地址:mybatis – MyBatis 3 | 简介 MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。MyBatis本是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了[google code](https://baike.baidu.com/item/google code/2346604)，并且改名为MyBatis。2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）。 导入mybatis: maven 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt; 优点: 简化了JDBC的操作 入门案例 需要的依赖包有: mybatis依赖, 数据库驱动依赖包 如下所示使用maven导入: 123456789101112131415161718192021&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql链接驱动,注意,请选高一点的版本--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt;&lt;/dependency&gt;&lt;!-- maven的测试工具--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 编写核心配置文件 在resoures文件夹下创建配置文件mybatis-config.xml内容如下(来自官网): 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;&lt;!--注意: 由于xml中无法直接使用 &amp; ,所以需要使用 转义字符 &amp;amp; , 此外高版本的mysql驱动还需要设置时区--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 注意:这里的路径下一级用 / 表示,可以注册多个映射器 --&gt; &lt;mapper resource=&quot;dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写获取SqlSession的mybatis工具类 123456789101112131415161718192021222324import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtiles &#123; static SqlSessionFactory sqlSessionFactory; static &#123; String resource = &quot;mybatis-config.xml&quot;; // mybatis核心配置文件名 InputStream inputStream = null; try &#123; inputStream = Resources.getResourceAsStream(resource); // 从 resources &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 使用SqlSession工常构造器构建 SqlSession工厂 sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 编写持久层接口, 并且还有实体类, 以及对应的映射配置文件 持久层接口 UserDao.java 123456789package dao;import pojo.User;import java.util.LinkedList;public interface UserDao &#123; LinkedList&lt;User&gt; getUser();&#125; 实体类:User.java 1234567891011121314151617181920212223242526272829303132333435363738394041package pojo;public class User &#123; private int uid; private String name; private String pwd; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;uid=&quot; + uid + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 对应的映射文件: UserMapper.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--命名空间作用是绑定 Dao/Mapper接口,相当于编写了一个类实现了该接口--&gt;&lt;mapper namespace=&quot;UserDao&quot;&gt; &lt;!-- id就当于Dao/Mapper接口的方法,相当于实现了接口重写了接口里的方法,方法体内容就是sql, 返回类型和参数类型应该与重写的方法保持一致--&gt; &lt;select id=&quot;getUser&quot; resultType=&quot;dao.UserDao&quot; &gt; select * from mytatistest.user; &lt;/select&gt;&lt;/mapper&gt; 使用maven的测试工具测试123456789101112131415161718192021222324import dao.UserDao;import org.apache.ibatis.session.SqlSession;import pojo.User;import utlis.MybatisUtiles;import java.util.LinkedList;public class Test &#123; @org.junit.Test public void test()&#123; SqlSession sqlSession = MybatisUtiles.getSqlSession(); UserDao userDao = sqlSession.getMapper(UserDao.class); LinkedList&lt;User&gt; list = userDao.getUser(); for (User user:list) &#123; System.out.println(user); &#125; sqlSession.close(); &#125;&#125; 增删改查注意点: ==增删改操作需要(sqlSession.commit())提交事务,不然无法生效== ==sql需要用到参数的时候, 参数用占位符#{字段名或参数名}表示 , 此外如果参数类型是对象,则可以直接使用对象的属性(字段)== mybatis的核心配置文件(注意! 如果涉及到多个映射器,就需要在核心配置文件中配置) 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;&lt;!-- 注意: 由于xml中无法直接使用 &amp; ,所以需要使用 转义字符 &amp;amp; , 此外高版本的mysql驱动还需要设置时区--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 注意:这里的路径下一级用 / 表示 --&gt; &lt;mapper resource=&quot;dao/UserMapper.xml&quot;/&gt; &lt;mapper resource=&quot;dao/UserDao.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 实体类与入门案例一样 持久层接口 12345678910111213141516package dao;import pojo.User;import java.util.LinkedList;public interface UserMapper &#123;// 根据id 获取用户 LinkedList&lt;User&gt; getUser(int id); int addUser(User user); int updateUser(User user); int deleteUser(int id);&#125; 映射器Mapper配置文件 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.UserMapper&quot;&gt;&lt;!-- 注意,当参数类型是对象后, 对象的字段可以直接使用--&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;pojo.User&quot;&gt; insert into `user` values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) ; &lt;/insert&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from `user` where id = #&#123;id&#125; &lt;/delete&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;pojo.User&quot;&gt; update `user` set `name` = #&#123;name&#125; , pwd = #&#123;pwd&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 标签的id属性相当于绑定了对应接口的方法名, 用#&#123;&#125;表示参数占位符, 参数名要和方法名一致 --&gt; &lt;select id=&quot;getUser&quot; resultType=&quot;pojo.User&quot; parameterType=&quot;int&quot;&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 使用maven工具进行测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import dao.UserDao;import dao.UserMapper;import org.apache.ibatis.session.SqlSession;import pojo.User;import utlis.MybatisUtiles;import java.util.LinkedList;public class Test &#123; //根据 id 查询用户 @org.junit.Test public void getUserById()&#123;// 获取 sql会话 SqlSession sqlSession = MybatisUtiles.getSqlSession();// 获取 持久层接口的映射 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); LinkedList&lt;User&gt; link = userMapper.getUser(2); for (User user:link) &#123; System.out.println(user); &#125; &#125; // 添加用户 @org.junit.Test public void addUser()&#123; SqlSession sqlSession = MybatisUtiles.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res_n = 0 ; try&#123; res_n = userMapper.addUser(new User(0,&quot;北北&quot;,&quot;171771&quot;));// 增删改操作一定要提交事务 sqlSession.commit(); &#125; catch (Exception e)&#123; System.err.println(e.getMessage()); &#125; if (res_n&gt;0) &#123; System.out.println(&quot;插入成功!&quot;); &#125; else &#123; System.out.println(&quot;插入失败!&quot;); &#125; sqlSession.close(); &#125; //修改用户 @org.junit.Test public void updateUser()&#123; SqlSession sqlSession = MybatisUtiles.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res_n = 0 ; try&#123; res_n = userMapper.updateUser(new User(1,&quot;小有&quot;,&quot;010101&quot;)); sqlSession.commit(); &#125; catch (Exception e)&#123; System.err.println(e.getMessage()); &#125; if (res_n&gt;0)&#123; System.out.println(&quot;更新成功!&quot;); &#125; else&#123; System.out.println(&quot;更新失败!&quot;); &#125; sqlSession.close(); &#125; // 删除y @org.junit.Test public void deleteUser()&#123; SqlSession sqlSession = MybatisUtiles.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res_n = 0; try&#123; res_n = userMapper.deleteUser(0); sqlSession.commit(); &#125; catch (Exception e)&#123; System.err.println(e.getMessage()); &#125; if (res_n&gt;0)&#123; System.out.println(&quot;删除成功!&quot;); &#125; else&#123; System.out.println(&quot;删除失败!&quot;); &#125; sqlSession.close(); &#125;&#125; map作为结果集对于上述例子, 再进行修改操作时, 需要重复创建实体类对象,很明显效率不高且浪费内存,讲map作为参数类型,则灵活很多 ==并且参数是map的时候可以直接用占位符获取到键值,如: #{键名} , ${键名}== 持久层接口 1234567891011121314public interface UserMapper &#123;// 根据id 获取用户 LinkedList&lt;User&gt; getUser(int id); int addUser(User user); int updateUser(User user); int deleteUser(int id);// 使用map作为结果可以使 修改 更为灵活 int updateUser2(Map&lt;String,Object&gt; map);&#125; UserMapper.xml 映射器配置文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.UserMapper&quot;&gt;&lt;!--使用map作为结果集,这样就不必再重复写实体类的属性名,可直接使用占位符获得map的键值对的值请注意! 这里参数类型不需要写包名是因为mybatis为我们常用的类起了别名--&gt; &lt;update id=&quot;updateUser2&quot; parameterType=&quot;map&quot;&gt; update `user` set pwd = #&#123;value&#125; where id = #&#123;uid&#125; &lt;/update&gt;&lt;/mapper&gt; maven测试方法: 1234567891011121314@org.junit.Test public void updateByMap()&#123; SqlSession sqlSession = MybatisUtiles.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); Map&lt;String,Object&gt; map = new HashMap(); map.put(&quot;uid&quot;,1); map.put(&quot;value&quot;,&quot;000000&quot;); userMapper.updateUser2(map); sqlSession.commit(); sqlSession.close(); &#125; 配置解析 MyBatis 3 | 配置 注意! 编写mybatis-config.xml配置文件时,对于元素的编写位置顺序有要求 Property (属性)属性也就是设置链接数据的驱动类名,url,用户名,密码等,配置的方式有很多 注意: 所有property元素都必须放在dataSource元素中 方式一: 在核心配置文件中使用property元素属性来配置 12345678 &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;&lt;!-- 注意: 由于xml中无法直接使用 &amp; ,所以需要使用 转义字符 &amp;amp; , 此外高版本的mysql驱动还需要设置时区--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; 方式二: 通过properties元素的resource或者url属性引入配置文件 1234567891011121314 &lt;properties resource=&quot;db.properties&quot;&gt;&lt;!-- 这里的property元素是声明的,不放到dataSource元素里并不会使用--&gt; &lt;/properties&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- $&#123;keyname&#125;表示属性占位符,引用db.properties文件的key --&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;pwd&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; db.properties文件内容如下所示: 1234driver = com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8username=rootpwd=123456 方式三: 还是通过方式二引入properties文件,不过在创建SqlSession对象时候在使用properties文件的参数 12345SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);// ... 或者 ...SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props); 优先级问题:如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载： 首先读取在 properties 元素体内指定的属性。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。 最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。 因此，通过方法参数传递的属性具有最高优先级(不灵活)，resource/url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。 Setting (设置)一个配置完整的 settings 元素的示例如下： 1234567891011121314151617&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; 简略(详见官网mybatis – MyBatis 3 | 配置) 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 true | false false aggressiveLazyLoading 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods)。 true | false false （在 3.4.1 及之前的版本中默认为 true） multipleResultSetsEnabled 是否允许单个语句返回多结果集（需要数据库驱动支持）。 true | false true useColumnLabel 使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。 true | false true useGeneratedKeys 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 true | false False autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出警告日志（&#39;org.apache.ibatis.session.&lt;br/&gt;AutoMappingUnknownColumnBehavior&#39; 的日志等级必须设置为 WARN）FAILING: 映射失败 (抛出 SqlSessionException) NONE, WARNING, FAILING NONE defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。 SIMPLE REUSE BATCH SIMPLE defaultStatementTimeout 设置超时时间，它决定数据库驱动等待数据库响应的秒数。 任意正整数 未设置 (null) defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。 任意正整数 未设置 (null) defaultResultSetType 指定语句默认的滚动策略。（新增于 3.5.2） FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT（等同于未设置） 未设置 (null) safeRowBoundsEnabled 是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 true | false False safeResultHandlerEnabled 是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。 true | false True mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。 SESSION | STATEMENT SESSION jdbcTypeForNull 当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 JdbcType 常量，常用值：NULL、VARCHAR 或 OTHER。 OTHER callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 true | false false returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2） true | false false logPrefix 指定 MyBatis 增加到日志名称的前缀。 任何字符串 未设置 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J(deprecated since 3.5.9) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 proxyFactory 指定 Mybatis 创建可延迟加载对象所用到的代理工具。 CGLIB | JAVASSIST JAVASSIST vfsImpl 指定 VFS 的实现 自定义 VFS 的实现的类全限定名，以逗号分隔。 未设置 useActualParamName 允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 -parameters 选项。（新增于 3.4.1） true | false true configurationFactory 指定一个提供 Configuration 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为static Configuration getConfiguration() 的方法。（新增于 3.2.3） 一个类型别名或完全限定类名。 未设置 shrinkWhitespacesInSql 从SQL中删除多余的空格字符。请注意，这也会影响SQL中的文字字符串。 (新增于 3.5.5) true | false false defaultSqlProviderType Specifies an sql provider class that holds provider method (Since 3.5.6). This class apply to the type(or value) attribute on sql provider annotation(e.g. @SelectProvider), when these attribute was omitted. A type alias or fully qualified class name Not set nullableOnForEach Specifies the default value of ‘nullable’ attribute on ‘foreach’ tag. (Since 3.5.9) true | false false typeAliases（类型别名）类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如： 12345678&lt;typeAliases&gt; &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt; &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt; &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt; &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt; &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt; &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name=&quot;domain.blog&quot;/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： 1234@Alias(&quot;author&quot;)public class Author &#123; ...&#125; 内置别名下面是一些为常见的 Java 类型内建的类型别名。**(即不需要声明包名了)它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。** 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator Evironments(环境配置)MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。 ==不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。== 所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推， 添加环境:可以使用Evironment元素添加配置环境 1234567891011121314151617181920212223242526&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 第二个环境 --&gt; &lt;environment id=&quot;demo&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 注意一些关键点: 默认使用的环境 ID（比如：default=”development”）。 每个 environment 元素定义的环境 ID（比如：id=”development”）。 事务管理器的配置（比如：type=”JDBC”）。 数据源的配置（比如：type=”POOLED”）。 默认环境和环境 ID 顾名思义。 环境可以随意命名，但务必保证默认的环境 ID 要匹配其中一个环境 ID。 使用环境:为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是： 12SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties); 如果忽略了环境参数，那么将会加载默认环境，如下所示： 12SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties); 事务管理器在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）： 提示: 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 JDBC(常用) – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来 管理事务作用域。 MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。例如: 123&lt;transactionManager type=&quot;MANAGED&quot;&gt; &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt; 这两种事务管理器类型都不需要设置任何属性。它们其实是类型别名，换句话说，你可以用 TransactionFactory 接口实现类的全限定名或类型别名代替它们。 1234567public interface TransactionFactory &#123; default void setProperties(Properties props) &#123; // 从 3.5.2 开始，该方法为默认方法 // 空实现 &#125; Transaction newTransaction(Connection conn); Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);&#125; 在事务管理器实例化后，所有在 XML 中配置的属性将会被传递给 setProperties() 方法。你的实现还需要创建一个 Transaction 接口的实现类，这个接口也很简单： 1234567public interface Transaction &#123; Connection getConnection() throws SQLException; void commit() throws SQLException; void rollback() throws SQLException; void close() throws SQLException; Integer getTimeout() throws SQLException;&#125; 使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。 数据源（dataSource）dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。 有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）： pool 池的意思 UNPOOLED(不使用连接池) 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性： driver – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 defaultNetworkTimeout – 等待数据库操作完成的默认网络超时时间（单位：毫秒）。查看 java.sql.Connection#setNetworkTimeout() 的 API 文档以获取更多信息。 作为可选项，你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如： POOLED (使用链接池)这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。 除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源： poolMaximumActiveConnections – 在任意时间可存在的活动（正在使用）连接数量，默认值：10 poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。 poolMaximumCheckoutTime – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒） poolTimeToWait – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。 poolMaximumLocalBadConnectionTolerance – 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程。 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 poolMaximumIdleConnections 与 poolMaximumLocalBadConnectionTolerance 之和。 默认值：3（新增于 3.4.5） poolPingQuery – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动出错时返回恰当的错误消息。 poolPingEnabled – 是否启用侦测查询。若开启，需要设置 poolPingQuery 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。 poolPingConnectionsNotUsedFor – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。 JNDI 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。 详情见官网.MyBatis 3 | 配置 Mapper(映射器)既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 file:/// 形式的 URL），或类名和包名等。 注册Mapper引入Mapper文件的方式: 注: maven项目中的 resources文件夹就相当于类的资源的引用 1234567&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;!--注意:这里的路径下一级用 / 表示,可以注册多个映射器--&gt; &lt;mapper resource=&quot;dao/UserMapper.xml&quot;/&gt; &lt;!-- 倘若文件在Resources文件夹,可以直接检测到,也就是说UserMapperxml文件若在Resources文件夹,可以这样 --&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 123456&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt; &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; 以下两种方式有一些注意点: 引入的映射器配置文件必须要和所绑定的接口同名同包 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; 1234567&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;!-- 文件名要和实现的接口同名, 且在同一个包下 --&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt; &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt; 使用注解映射对于像 BlogMapper 这样的映射器类来说，还有另一种方法来完成语句映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可以被替换成如下的配置： 12345package org.mybatis.example;public interface BlogMapper &#123; @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;) Blog selectBlog(int id);&#125; 使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。 选择何种方式来配置映射，以及认为是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。 映射的SQL字符串替换默认情况下，使用 #&#123;&#125; 参数语法时，MyBatis 会创建 PreparedStatement 参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。 这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL 语句中直接插入一个不转义的字符串(即直接替换字符串不做处理)可以使用 $&#123;&#125;。 比如 ORDER BY 子句，这时候你可以： 1ORDER BY $&#123;columnName&#125; 这样，MyBatis 就不会修改或转义该字符串了。 (当方法里有多个参数的时候, 可以在方法中在参数前面加上注解@Param生命, 被注解的参数可以直接被占位符使用) 当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。 举个例子，如果你想 select 一个表任意一列的数据时，不需要这样写： 12345678910@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User findById(@Param(&quot;id&quot;) long id);@Select(&quot;select * from user where name = #&#123;name&#125;&quot;)User findByName(@Param(&quot;name&quot;) String name);@Select(&quot;select * from user where email = #&#123;email&#125;&quot;)User findByEmail(@Param(&quot;email&quot;) String email);// 其它的 &quot;findByXxx&quot; 方法 而是可以只写这样一个方法： 12@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value); 其中 $&#123;column&#125; 会被直接替换，而 #&#123;value&#125; 会使用 ? 预处理。 这样，就能完成同样的任务： 123User userOfId1 = userMapper.findByColumn(&quot;id&quot;, 1L);User userOfNameKid = userMapper.findByColumn(&quot;name&quot;, &quot;kid&quot;);User userOfEmail = userMapper.findByColumn(&quot;email&quot;, &quot;noone@nowhere.com&quot;); 这种方式也同样适用于替换表名的情况。 提示 用这种方式接受用户的输入，并用作语句参数是不安全的，会导致潜在的 SQL 注入攻击。因此，要么不允许用户输入这些字段，要么自行转义并检验这些参数。 生命周期与作用域（Scope）理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。 提示: 依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession==每个线程都应该有它自己的 SqlSession 实例。==SqlSession 的实例不是线程安全的，因此是==不能被共享的==，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 结果映射 resultMapResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的数千行代码。下面演示了一个简单的例子: 实体类: 12345678910111213141516171819202122232425package com.someapp.model;public class User &#123; private int id; private String username; private String hashedPassword; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getHashedPassword() &#123; return hashedPassword; &#125; public void setHashedPassword(String hashedPassword) &#123; this.hashedPassword = hashedPassword; &#125;&#125; 基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和 hashedPassword。这些属性会对应到 select 语句中的列名。 这样的一个 JavaBean 可以被映射到 ResultSet，就像映射到 HashMap 一样简单。 12345&lt;select id=&quot;selectUsers&quot; resultType=&quot;com.someapp.model.User&quot;&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt; 类型别名是你的好帮手。使用它们，你就可以不用输入类的全限定名了。比如： 123456789&lt;!-- mybatis-config.xml 中 --&gt;&lt;typeAlias type=&quot;com.someapp.model.User&quot; alias=&quot;User&quot;/&gt;&lt;!-- SQL 映射 XML 中 --&gt;&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt; select id, username, hashedPassword from some_table where id = #&#123;id&#125;&lt;/select&gt; 在这些情况下，MyBatis 会在幕后自动创建一个 ResultMap，再根据属性名来映射列到 JavaBean 的属性上。如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如： 12345678&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt; select user_id as &quot;id&quot;, user_name as &quot;userName&quot;, hashed_password as &quot;hashedPassword&quot; from some_table where id = #&#123;id&#125;&lt;/select&gt; 在学习了上面的知识后，你会发现上面的例子没有一个需要显式配置 ResultMap，这就是 ResultMap 的优秀之处——你完全可以不用显式地配置它们。 虽然上面的例子不用显式配置 ResultMap。 但为了讲解，我们来看看如果在刚刚的示例中，显式使用外部的 resultMap 会怎样，==这也是解决列名不匹配的另外一种方式。== 1234567&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt; &lt;!-- propery属性代表绑定的实体类(User)的属性,column表示查询的字段名,两者建立关系 --&gt; &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt; &lt;!-- id标出主键,能提高效率 --&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot; /&gt;&lt;/resultMap&gt; 然后在引用它的语句中设置 resultMap 属性就行了（注意我们去掉了 resultType 属性）。比如: 12345&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt; select user_id, user_name, hashed_password from some_table where id = #&#123;id&#125;&lt;/select&gt; 如果这个世界总是这么简单就好了。 高级结果映射resultMap 元素有很多子元素和一个值得深入探讨的结构。 下面是resultMap 元素的概念视图。 constructor- 用于在实例化类时，注入结果到构造方法中 idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 arg - 将被注入到构造方法的一个普通结果 id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result – 注入到字段或 JavaBean 属性的普通结果 association - 一个复杂类型的关联；许多结果将包装成这种类型 嵌套结果映射 – 关联可以是 resultMap 元素，或是对其它结果映射的引用 collection– 一个复杂类型的集合 嵌套结果映射 – 集合可以是 resultMap 元素，或是对其它结果映射的引用 discriminator– 使用结果值来决定使用哪个 resultMap case– 使用结果值来决定使用哪个 嵌套结果映射 – case 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射 constructor(构造方法)通过修改对象属性的方式，可以满足大多数的数据传输对象（Data Transfer Object, DTO）以及绝大部分领域模型的要求。但有些情况下你想使用不可变类。 一般来说，很少改变或基本不变的包含引用或数据的表，很适合使用不可变类。 构造方法注入允许你在初始化时为类设置属性的值，而不用暴露出公有方法。MyBatis 也支持私有属性和私有 JavaBean 属性来完成注入，但有一些人更青睐于通过构造方法进行注入。 constructor 元素就是为此而生的。 看看下面这个构造方法: 1234567public class User &#123; //... public User(Integer id, String username, int age) &#123; //... &#125;//...&#125; 为了将结果注入构造方法，MyBatis 需要通过某种方式定位相应的构造方法。 在下面的例子中，MyBatis 搜索一个声明了三个形参的构造方法，参数类型以 java.lang.Integer, java.lang.String 和 int 的顺序给出。 123456&lt;constructor&gt; &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&gt; &lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&gt; &lt;!-- 注意: mybatis内置别名讲 int 设置成了_int, int表示Integer--&gt; &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot;/&gt;&lt;/constructor&gt; 当你在处理一个带有多个形参的构造方法时，很容易搞乱 arg 元素的顺序。 从版本 3.4.3 开始，可以在指定参数名称的前提下，以任意顺序编写 arg 元素。 为了通过名称来引用构造方法参数，你可以添加 @Param 注解，或者使用 ‘-parameters’ 编译选项并启用 useActualParamName 选项（默认开启）来编译项目。下面是一个等价的例子，尽管函数签名中第二和第三个形参的顺序与 constructor 元素中参数声明的顺序不匹配。 12345&lt;constructor&gt; &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; name=&quot;id&quot; /&gt; &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot; name=&quot;age&quot; /&gt; &lt;arg column=&quot;username&quot; javaType=&quot;String&quot; name=&quot;username&quot; /&gt;&lt;/constructor&gt; 如果存在名称和类型相同的属性，那么可以省略 javaType 。 剩余的属性和规则和普通的 id 和 result 元素是一样的。 association(关联)主要是用来解决多表链接查询问题,也包括了实体类属性与数据库字段不同名的问题 关联（association）元素处理“有一个”类型的关系。 比如，在我们的示例中，一个博客有一个用户。关联结果映射和其它类型的映射工作方式差不多。 你需要指定目标属性名以及属性的javaType（很多时候 MyBatis 可以自己推断出来），在必要的情况下你还可以设置 JDBC 类型，如果你想覆盖获取结果值的过程，还可以设置类型处理器。 1234&lt;association property=&quot;author&quot; column=&quot;blog_author_id&quot; javaType=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;&lt;/association&gt; 首先，先让我们来看看这个元素的属性。你将会发现，和普通的结果映射差不多，只是它多了select或者resultMap属性,对应两种关联方式: 嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。 嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。 关联的嵌套 Select 查询 属性 描述 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 column=&quot;&#123;prop1=col1,prop2=col2&#125;&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 column=&quot;&#123;prop1=col1,prop2=col2&#125;&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 示例： 12345678910111213141516&lt;!--建立了一个结果映射,关联了selectAuthor这个查询 --&gt;&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt;&lt;/resultMap&gt;&lt;!--使用了blog的结果映射,进行查询,注意这里的id是实体类author对象的id --&gt;&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;!-- 查询数据库中author表,随后讲将结果映射成实体类author,并且被上面的结果映射引用,提供给selectBlog查询语句的使用--&gt;&lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt; SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;&lt;/select&gt; 就是这么简单。我们有两个 select 查询语句：一个用来加载博客（Blog），另外一个用来加载作者（Author），而且博客的结果映射描述了应该使用 selectAuthor 语句加载它的 author 属性。 这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为“N+1 查询问题”。 概括地讲，N+1 查询问题是这样子的： 你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。 对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。 这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。 好消息是，MyBatis 能够对这样的查询进行延迟加载，因此可以将大量语句同时运行的开销分散开来。 然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。 所以还有另外一种方法。 关联的嵌套结果映射 属性 描述 resultMap 结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 ResultSet。这样的 ResultSet 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。使用嵌套结果映射的一个例子在表格以后。 columnPrefix 当连接多个表时，你可能会不得不使用列别名来避免在 ResultSet 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。 下面的例子则是一个非常简单的例子，用于演示嵌套结果映射如何工作。 现在我们将博客表和作者表连接在一起，而不是执行一个独立的查询语句，就像这样： 12345678910111213&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio from Blog B left outer join Author A on B.author_id = A.id where B.id = #&#123;id&#125;&lt;/select&gt; 注意查询中的连接，以及为确保结果能够拥有唯一且清晰的名字，我们设置的别名。 这使得进行映射非常简单。现在我们可以映射这个结果： 123456789101112131415&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;!-- 引用了下面的作者信息结果映射 --&gt; &lt;association property=&quot;author&quot; column=&quot;blog_author_id&quot; javaType=&quot;Author&quot; resultMap=&quot;authorResult&quot;/&gt;&lt;/resultMap&gt;&lt;!-- 作者信息的结果映射 --&gt;&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;&lt;/resultMap&gt; 在上面的例子中，你可以看到，博客（Blog）作者（author）的关联元素委托名为 “authorResult” 的结果映射来加载作者对象的实例。 ==非常重要:== id 元素在嵌套结果映射中扮演着非常重要的角色。你应该总是指定一个或多个可以唯一标识结果的属性。 虽然，即使不指定这个属性，MyBatis 仍然可以工作，但是会产生严重的性能问题。 只需要指定可以唯一标识结果的最少属性。显然，你可以选择主键（复合主键也可以）。 现在，上面的示例使用了外部的结果映射元素来映射关联。这使得 Author 的结果映射可以被重用。 然而，如果你不打算重用它，或者你更喜欢将你所有的结果映射放在一个具有描述性的结果映射元素中。 你可以直接将结果映射作为子元素嵌套在内。这里给出使用这种方式的等效例子： 123456789101112&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;!-- 将结果映射作作为子元素,实际上与上例的authorResult一致,只能这个不能在其他地方使用而已(重用) --&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 那如果博客（blog）有一个共同作者（co-author）该怎么办？select 语句看起来会是这样的： 12345678910111213141516171819&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt; select B.id as blog_id, B.title as blog_title, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, CA.id as co_author_id, CA.username as co_author_username, CA.password as co_author_password, CA.email as co_author_email, CA.bio as co_author_bio from Blog B left outer join Author A on B.author_id = A.id left outer join Author CA on B.co_author_id = CA.id where B.id = #&#123;id&#125;&lt;/select&gt; 回忆一下，Author 的结果映射定义如下： 1234567&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;&lt;/resultMap&gt; 由于结果中的列名与结果映射中的列名不同。你需要指定 columnPrefix 以便重复使用该结果映射来映射 co-author 的结果。 1234567891011&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;!-- 关联 作者信息结果映射 --&gt; &lt;association property=&quot;author&quot; resultMap=&quot;authorResult&quot; /&gt; &lt;!-- 关联作者信息结果映射,并且引入一个新名称(coAuthor),与 作者信息结果映射不同的是给原理的列名加了前缀 co_ --&gt; &lt;association property=&quot;coAuthor&quot; resultMap=&quot;authorResult&quot; columnPrefix=&quot;co_&quot; /&gt;&lt;/resultMap&gt; 关联的多结果集（ResultSet）&lt;待学&gt; 属性 描述 column 当使用多个结果集时，该属性指定结果集中用于与 foreignColumn 匹配的列（多个列名以逗号隔开），以识别关系中的父类型与子类型。 foreignColumn 指定外键对应的列名，指定的列将与父类型中 column 的给出的列进行匹配。 resultSet 指定用于加载复杂类型的结果集名字。 从版本 3.2.3 开始，MyBatis 提供了另一种解决 N+1 查询问题的方法。 某些数据库允许存储过程返回多个结果集，或一次性执行多个语句，每个语句返回一个结果集。 我们可以利用这个特性，在不使用连接的情况下，只访问数据库一次就能获得相关数据。 在例子中，存储过程执行下面的查询并返回两个结果集。第一个结果集会返回博客（Blog）的结果，第二个则返回作者（Author）的结果。 123SELECT * FROM BLOG WHERE ID = #&#123;id&#125;SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125; 在映射语句中，必须通过 resultSets 属性为每个结果集指定一个名字，多个名字使用逗号隔开。 123&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,authors&quot; resultMap=&quot;blogResult&quot; statementType=&quot;CALLABLE&quot;&gt; &#123;call getBlogsAndAuthors(#&#123;id,jdbcType=INTEGER,mode=IN&#125;)&#125;&lt;/select&gt; 现在我们可以指定使用 “authors” 结果集的数据来填充 “author” 关联： 12345678910111213&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot; resultSet=&quot;authors&quot; column=&quot;author_id&quot; foreignColumn=&quot;id&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;bio&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; collection(集合) &lt;待学&gt;discriminator &lt;待学&gt;分页为了减少数据处理量 通过SQL中的limit实现分页补充sql分页知识: 1234-- startindex,n都是整型,startIndex代表查询到的结果集从哪里开始分页(默认第一行为0),pageSize代表每页多少多少行数据 select * from user limit startindex,-- 也可以将startindex 省略不写,将默认将startindex为0 , 如希望每页十行数据select * from user limit 10 通过RowBounds分页使用org.apache.ibatis.session包下的RowBounds类实现 12345678SqlSession sqlSession = MyBatisTool.getSqlSession(); // 构造方法的两个参数,分别是 starIndex , pageSizeRowBounds rowBounds = new RowBounds(1,4); // 直接调用 sqlSession对象的方法进行查询不需要在UserMapper.xml里配置sql语句了 users = sqlSession.selectList(&quot;dao.UserMapper.getAllUser&quot;,null,rowBounds); for (Object user:users) &#123; System.out.println(user); &#125; LomBok(快速生成JavaBean) Project Lombok官网 Project Lombok是一个java库，它会自动插入到你的编辑器和构建工具中，为你的java增添色彩。再也不用编写另一个 getter 或 equals 方法，只需一个注释，您的类就会有一个功能齐全的构建器，自动执行日志记录变量等等。 使用步骤:1. maven依赖包:1234567&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2.在IDE中下载对应插件3.在需要添加getter,setter等方法的类声明语句上加上注解 官方文档-注解) @Data 注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法 @Setter ：注解在属性上；为属性提供 setting 方法 @Setter ：注解在属性上；为属性提供 getting 方法 @Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象 @NoArgsConstructor ：注解在类上；为类提供一个无参的构造方法 @AllArgsConstructor ：注解在类上；为类提供一个全参的构造方法 @Cleanup : 可以关闭流 @Builder ： 被注解的类加个构造者模式 @Synchronized ： 加个同步锁 @SneakyThrows : 等同于try/catch 捕获异常 @NonNull : 如果给参数加个这个注解 参数为null会抛出空指针异常 @Value : 注解和@Data类似，区别在于它会把所有成员变量默认定义为private final修饰，并且不会生成set方法。 大佬的使用心得 为什么要放弃 Lombok ？ - 知乎 Lombok本身是一个优秀的Java代码库，它采用了一种取巧的语法糖，简化了Java的编码，为Java代码的精简提供了一种方式，但在使用此代码库时，需要了解到Lombok并非一个标准的Java库。使用Lombok，会增加团队的技术债务，降低代码的可读性，增大代码的耦合度和调式难度。虽然在一定程度上Lombok减少了样板代码的书写，但也带来了一些未知的风险。如果你正在参与一个团队项目（或大型项目）,考虑到后续的升级与扩展，是否使用Lombok，请与你的团队多沟通和三思。 动态SQL动态SQL:根据不同的条件生成不同的sql 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach if 元素使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如： 12345678&lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; 这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。 如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。 1234567891011&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;!--使用技巧: 当不需要筛选状态时,state = ‘ACTIVE’,可衔接一个永真式如 1=1 --&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; choose ,when ,otherwise 元素有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句,并且只匹配一个条件,相当于swtich 的case 加了break 还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员精选的 Blog）。 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where、set、trim为了解决臭名昭著的sql动态问题，引入了 where ,和 set 元素,并且可以自定义元素 where例如: 1234567891011121314&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; 如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样： 12SELECT * FROM BLOGWHERE 这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样: 123SELECT * FROM BLOGWHEREAND title like ‘someTitle’ 这时可以将where 作为元素引入 , where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 如果 where 元素与你期望的不太一样，你也可以通过trim 元素来自定义元素元素来个性化功能.(覆盖前缀后缀),比如:和 where 元素等价的自定义 trim 元素为： 1234&lt;!-- 与where元素的功能等价,相当于where标签 --&gt;&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ...&lt;/trim&gt; prefixOverrides 属性会忽略通过管道符( | )分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。 set用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如： 1234567891011&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;!-- 注意!最后一句不能加逗号 --&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 与 set 元素等价的自定义 trim 元素吧： 1234&lt;!-- 若有子元素生效,则插入前缀 set 并且覆盖掉后缀的都好,也就是说但凡后缀有逗号,就擦除 --&gt;&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; ...&lt;/trim&gt; 注意，我们覆盖了后缀值设置，并且自定义了前缀值。 trimmybatis允许我们使用trim元素自定义类似where 或 set 的元素 123&lt;trim prefix=&quot;前缀&quot; prefixOverrides=&quot;需要擦除的后缀内容&quot; suffixOverrides=&quot;需要擦除的后缀内容&quot;&gt; ...&lt;/trim&gt; 当trim的存在内容(如where元素的子元素返回内容时)会在trim元素的位置加上设置好的前缀(例如 where ,set) , 此外会检测trim元素中拼接好的sql 是否需要擦除前缀或者后缀内容 foreach动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。 12345678910&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P &lt;where&gt; &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;ID in (&quot; separator=&quot;,&quot; close=&quot;)&quot; nullable=&quot;true&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符( separator )。 ==也就是遍历一个集合, 拼接出一个字符串== 提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。(可以通过占位符使用)当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 如下例子将演示拼接如下sql语句 12select * from blog where (blog_id = ? or blog_id = ? blog_id = ? .....) 持久层接口: 1234public interface BlogMapper &#123;// 演示 forEach 元素 ArrayList&lt;Blog&gt; queryBlogsForEach(Map&lt;String,Object&gt; map);&#125; 映射器配置 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.BlogMapper&quot;&gt; &lt;select id=&quot;queryBlogsForEach&quot; parameterType=&quot;map&quot; resultMap=&quot;blogMap&quot;&gt; select * from blog &lt;where&gt;&lt;!-- ids 是我们通过参数map传过来的集合(其实也可将集合作为参数直接传进来),注意! 这里必须写实参名, xml里是不识别形参的id 是集合每次遍历到的元素(相当于把每次遍历到的值赋值给这个名为id的参数),值可以被使用占位符引用(即 #&#123;&#125; )--&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;( &quot; separator=&quot;or&quot; close=&quot;)&quot; &gt; blog_id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 测试程序: 12345678910111213141516171819202122 @org.junit.Test public void queryBlogsForEach()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper blogMapper = sqlSession.getMapper(BlogMapper.class); Map&lt;String,Object&gt; map = new HashMap(); ArrayList list = new ArrayList();// 向集合添加我们需要遍历的元素 list.add(&quot;1001&quot;); list.add(&quot;1003&quot;); list.add(&quot;1005&quot;); list.add(&quot;1007&quot;); list.add(&quot;1009&quot;);// 将集合放入键值对里, 因为我们是参数是键值对,其实也可以直接将集合作为参数传进去 map.put(&quot;ids&quot;,list); ArrayList&lt;Blog&gt; blogs = blogMapper.queryBlogsForEach(map); for (Blog blog : blogs) &#123; System.out.println(blog); &#125; &#125; sql (复用sql代码片段)这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如： 1&lt;sql id=&quot;userColumns&quot;&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt; 这个 SQL 片段可以在其它语句中使用，例如： 1234567&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;, &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; 也可以在 include 元素的 refid 属性或内部语句中使用属性值，例如： 1234567891011121314151617&lt;sql id=&quot;sometable&quot;&gt; $&#123;prefix&#125;Table&lt;/sql&gt;&lt;sql id=&quot;someinclude&quot;&gt; from &lt;include refid=&quot;$&#123;include_target&#125;&quot;/&gt;&lt;/sql&gt;&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt; select field1, field2, field3 &lt;include refid=&quot;someinclude&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt; &lt;property name=&quot;include_target&quot; value=&quot;sometable&quot;/&gt; &lt;/include&gt;&lt;/select&gt; 至此，我们已经完成了与 XML 配置及映射文件相关的讨论。完结撒花 ! 🌸🌸🌸 script (sql注解脚本)要在带注解的映射器接口类中使用动态 SQL，可以使用 script 元素。比如: 1234567891011@Update(&#123;&quot;&lt;script&gt;&quot;, &quot;update Author&quot;, &quot; &lt;set&gt;&quot;, &quot; &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;, &quot; &lt;/set&gt;&quot;, &quot;where id=#&#123;id&#125;&quot;, &quot;&lt;/script&gt;&quot;&#125;)void updateAuthorValues(Author author); bindbind 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如： 12345&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot; /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt; 缓存MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。 一级缓存(默认缓存,会话级缓存)默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中(SqlSession)的数据进行缓存。** 只有以下行为才会导致缓存更新: 执行了增删改语句 手动清理缓存 12// 手动清理缓存sqlSession.clearCache(); 二级缓存(接口级,命名空间级缓存)要启用全局的二级缓存(在配置配置文件中,已经默认开启了全局缓存)， 1234&lt;!-- 默认开启 --&gt;&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;settings&gt; 只需要在你的 SQL 映射文件中添加一行： 1&lt;cache/&gt; 基本上就是这样。这个简单语句的效果如下: 映射语句文件中的所有 select 语句的结果将会被缓存。 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。 缓存不会定时进行刷新（也就是说，没有刷新间隔）。 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。 提示: 缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。 这些属性可以通过 cache 元素的属性来修改。比如： 123456&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;&lt;!-- 可读写的缓存,映射的实体类需要可序列化 --&gt; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 可用的清除策略有： LRU – 最近最少使用：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 默认的清除策略是 LRU。 flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。 size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。 readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。 提示 二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新。 读取缓存原则本节只针对一级缓存与二级缓存: 在SqlSession关闭后,一级缓存消失,若开启二级缓存则会在会话关闭后保存至二级缓存 当另一个会话在查找时 , 会先去二级缓存查找,没有再去一级缓存查找,最后都没有才去查询数据库 使用自定义缓存除了上述自定义缓存的方式，你也可以通过实现你自己的缓存，或为其他第三方缓存方案创建适配器，来完全覆盖缓存行为。 日志ybatis 通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一： SLF4J Apache Commons Logging Log4j 2 Log4j (常用日志工具) JDK logging MyBatis 内置日志工厂基于运行时自省机制选择合适的日志工具。它会使用第一个查找得到的工具（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。 不少应用服务器（如 Tomcat 和 WebShpere）的类路径中已经包含 Commons Logging，所以在这种配置环境下的 MyBatis 会把它作为日志工具，记住这点非常重要。这将意味着，在诸如 WebSphere 的环境中，它提供了 Commons Logging 的私有实现，你的 Log4J 配置将被忽略。MyBatis 将你的 Log4J 配置忽略掉是相当令人郁闷的（事实上，正是因为在这种配置环境下，MyBatis 才会选择使用 Commons Logging 而不是 Log4J）。如果你的应用部署在一个类路径已经包含 Commons Logging 的环境中，而你又想使用其它日志工具，你可以通过在 MyBatis 配置文件 mybatis-config.xml 里面添加一项 setting 来选择别的日志工具。 1234567&lt;configuration&gt; &lt;settings&gt; ... &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; ... &lt;/settings&gt;&lt;/configuration&gt; 关于 SLF4J、Apache Commons Logging、Apache Log4J 和 JDK Logging 的 API 介绍不在本文档介绍范围内。不过，下面的例子可以作为一个快速入门。关于这些日志框架的更多信息，可以参考以下链接： SLF4J Apache Commons Logging Apache Log4j 1.x and 2.x JDK Logging API 日志配置:在 mybatis-config.xml文件中的settings元素里设置: 配置项: SLF4J LOG4J LOG4J2 JDK_LOGGING java自带的日志 COMMONS_LOGGING STDOUT_LOGGING 标准日志输出(不需要导包) NO_LOGGING 不使用日志 例如:当设置了STDOUT_LOGGING后,执行查询语句后的控制台输出: 1234567891011121314151617181920212223242526272829303132333435363738394041Logging initialized using &#x27;class org.apache.ibatis.logging.stdout.StdOutImpl&#x27; adapter.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.Class not found: org.jboss.vfs.VFSJBoss 6 VFS API is not available in this environment.Class not found: org.jboss.vfs.VirtualFileVFS implementation org.apache.ibatis.io.JBoss6VFS is not valid in this environment.Using VFS adapter org.apache.ibatis.io.DefaultVFSFind JAR URL: file:/E:/Code/Java_idea/mybatis/%e5%8a%a8%e6%80%81sql/target/classes/daoNot a JAR: file:/E:/Code/Java_idea/mybatis/%e5%8a%a8%e6%80%81sql/target/classes/daoReader entry: BlogMapper.classReader entry: BlogMapper.xmlListing file:/E:/Code/Java_idea/mybatis/%e5%8a%a8%e6%80%81sql/target/classes/daoFind JAR URL: file:/E:/Code/Java_idea/mybatis/%e5%8a%a8%e6%80%81sql/target/classes/dao/BlogMapper.classNot a JAR: file:/E:/Code/Java_idea/mybatis/%e5%8a%a8%e6%80%81sql/target/classes/dao/BlogMapper.classReader entry: ���� 4 \u0015\u0007 \u0013\u0007 \u0014\u0001 Find JAR URL: file:/E:/Code/Java_idea/mybatis/%e5%8a%a8%e6%80%81sql/target/classes/dao/BlogMapper.xmlNot a JAR: file:/E:/Code/Java_idea/mybatis/%e5%8a%a8%e6%80%81sql/target/classes/dao/BlogMapper.xmlReader entry: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;Checking to see if class dao.BlogMapper matches criteria [is assignable to Object]Opening JDBC ConnectionCreated connection 1990098664.Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@769e7ee8]==&gt; Preparing: select * from blog limit 0,5==&gt; Parameters: &lt;== Columns: blog_id, blog_title, blog_author, blog_create_time, blog_views&lt;== Row: 1001, c语言其实很简单, 小友, 2020-10-10, 100&lt;== Row: 1002, c语言与指针, 南城, 2020-12-03, 98&lt;== Row: 1003, 面向对象编程, 小友, 2021-12-03, 1010&lt;== Row: 1004, Java程序设计, 南枫, 2020-02-03, 354&lt;== Row: 1005, Java之旅, 小岛, 2022-01-15, 231&lt;== Total: 5Blog&#123;id=&#x27;1001&#x27;, title=&#x27;c语言其实很简单&#x27;, author=&#x27;小友&#x27;, createTime=&#x27;2020-10-10&#x27;, views=100&#125;Blog&#123;id=&#x27;1002&#x27;, title=&#x27;c语言与指针&#x27;, author=&#x27;南城&#x27;, createTime=&#x27;2020-12-03&#x27;, views=98&#125;Blog&#123;id=&#x27;1003&#x27;, title=&#x27;面向对象编程&#x27;, author=&#x27;小友&#x27;, createTime=&#x27;2021-12-03&#x27;, views=1010&#125;Blog&#123;id=&#x27;1004&#x27;, title=&#x27;Java程序设计&#x27;, author=&#x27;南枫&#x27;, createTime=&#x27;2020-02-03&#x27;, views=354&#125;Blog&#123;id=&#x27;1005&#x27;, title=&#x27;Java之旅&#x27;, author=&#x27;小岛&#x27;, createTime=&#x27;2022-01-15&#x27;, views=231&#125;进程已结束，退出代码为 0 Log4jLog4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 使用步骤: 导包 新建配置文件,放入maven项目的resources目录(classPath类路径)下 在mybatis的配置文件中进行设置即可 配置文件详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt; &lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt; &lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt; &lt;configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt; &lt;!--先定义所有的appender--&gt; &lt;appenders&gt; &lt;!--这个输出控制台的配置--&gt; &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt; &lt;/console&gt; &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt; &lt;File name=&quot;log&quot; fileName=&quot;log/test.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt; &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/info.log&quot; filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/warn.log&quot; filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt; &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt; &lt;/Policies&gt; &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt; &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt; &lt;/RollingFile&gt; &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;$&#123;sys:user.home&#125;/logs/error.log&quot; filePattern=&quot;$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt; &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt; &lt;loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt; &lt;root level=&quot;all&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt; &lt;appender-ref ref=&quot;RollingFileWarn&quot;/&gt; &lt;appender-ref ref=&quot;RollingFileError&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; 配置说明:(1). 输出方式appender一般有5种： ​ org.apache.log4j.RollingFileAppender(滚动文件，自动记录最新日志)​ org.apache.log4j.ConsoleAppender (控制台)​ org.apache.log4j.FileAppender (文件)​ org.apache.log4j.DailyRollingFileAppender (每天产生一个日志文件)​ org.apache.log4j.WriterAppender (将日志信息以流格式发送到任意指定的地方) (2). 日记记录的优先级priority，优先级由高到低分为 OFF ,FATAL ,ERROR ,WARN ,INFO ,DEBUG ,ALL。 Log4j建议只使用FATAL ,ERROR ,WARN ,INFO ,DEBUG这五个级别。 (3). 格式说明layout中的参数都以%开始，后面不同的参数代表不同的格式化信息（参数按字母表顺序列出）： %c 输出所属类的全名，可在修改为 %d{Num} ,Num类名输出的维（如：”org.apache.elathen.ClassName”,%C{2}将输出elathen.ClassName） %d 输出日志时间其格式为 %d{yyyy-MM-dd HH:mm:ss,SSS}，可指定格式 如 %d{HH:mm:ss} %l 输出日志事件发生位置，包括类目名、发生线程，在代码中的行数 %n 换行符 %m 输出代码指定信息，如info(“message”),输出message %p 输出优先级，即 FATAL ,ERROR 等 %r 输出从启动到显示该log信息所耗费的毫秒数 %t 输出产生该日志事件的线程名 插件快速开发通过MyBatisCodeHelper-Pro插件,我们可以为我们编写Mybatis提供便利 破解方法: [MyBatisCodeHelper-Pro插件破解版2.9.7] – 知了 (zhile.io)","categories":[{"name":"Java系列","slug":"Java系列","permalink":"https://lqy679.github.io/categories/Java%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"Spring","slug":"Spring","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T08:10:55.696Z","comments":true,"path":"2020/01/01/Spring/","link":"","permalink":"https://lqy679.github.io/2020/01/01/Spring/","excerpt":"Spring Spring Framework 中文文档 Spring是一个开源框架，它由[Rod Johnson](https://baike.baidu.com/item/Rod Johnson)创建。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。","text":"Spring Spring Framework 中文文档 Spring是一个开源框架，它由[Rod Johnson](https://baike.baidu.com/item/Rod Johnson)创建。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。 简介 2002年 ,首次推出了Spring框架的雏形 : interface21框架 Spring框架以interface为基础,经过重新设计,并不断丰富其内涵,于2004年3月24日发布了1.0正式版 spring理念: 使现有的技术更加容易使用,本身是一个大杂烩 , 整合了现有的技术框架 优点: 是一个开源免费框架(容器)! 是一个轻量级,非入侵式的框架 控制反转(IOC) ,面向切面编程(AOP) 支持事务处理,对框架整合支持! 组成: Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 . 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 拓展: Spring Boot 一个快速开发的脚手架 基于SpringBoot快速的开发单个微服务 约定大于配置 Spring Cloud SpringCloud 基于SpringBoot实现 SpringBoot的出现就是为了解决Spring的弊端: 即违背了原理的理念, 配置十分繁琐 , 人称 “ 配置地狱 ” ! IOC理论控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。 控制反转(inversion of control), 是一种设计思想,DI(dependency injection依赖注入)是IOC的一种方法.未使用IOC的程序中,我们使用面向对象编程,对象的创建和对象之间的依赖关系完全硬编码在程序中,对象的创建是由程序自己控制的.控制反转就是将对象的创建转移给了第三方.IOC就我认为是:获得依赖对象的方式反转了 【硬编码：是将数据直接其纳入到程序或其他可执行程序或其他可执行对象的源代码中的软件开发时间，与外部获取数据或在运行时生成数据不同。硬编码数据通常只能通过编辑源代码或重新编译可执行文件来修改。】 IOC是Spring框架的核心内容, 使用了多种方式完美的实现了IOC,xml配置与注解形式,新版本的spring也可以零配置实现IOC Spring容器在初始化的时候先读取配置文件,根据配置文件或者元数据创建与组织对象存入容器中,程序使用时在从IOC容器中取出需要的对象 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 我们先用我们原来的方式写一段代码 . 1、先写一个UserDao接口 123public interface UserDao &#123; public void getUser();&#125; 2、再去写Dao的实现类 123456public class UserDaoImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;获取用户数据&quot;); &#125;&#125; 3、然后去写UserService的接口 123public interface UserService &#123; public void getUser();&#125; 4、最后写Service的实现类 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 5、测试一下 12345@Testpublic void test()&#123; UserService service = new UserServiceImpl(); service.getUser();&#125; 这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 . 把Userdao的实现类增加一个 . 123456public class UserDaoMySqlImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;MySql获取用户数据&quot;); &#125;&#125; 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 在假设, 我们再增加一个Userdao的实现类 . 123456public class UserDaoOracleImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;Oracle获取用户数据&quot;); &#125;&#125; 那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 . 那我们如何去解决呢 ? 我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 . 123456789101112public class UserServiceImpl implements UserService &#123; private UserDao userDao;// 利用set实现 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 现在去我们的测试类里 , 进行测试 ; 123456789@Testpublic void test()&#123; UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser();&#125; 大家发现了区别没有 ? 可能很多人说没啥区别 . 但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 . 这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 ! 入门案例(hello Spring) 1.导包 ​ 只需要导入这一个(springframework)即可包含所有Spring所需要的jar包 注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .只需要导入 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt;&lt;/dependency&gt; 2.编写实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package pojo;public class User &#123; private int uid; private String name; private String pwd; public User() &#123; &#125; public User(int uid, String name, String pwd) &#123; this.uid = uid; this.name = name; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;uid=&quot; + uid + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125;&#125; 编写配置文件 将此文件放入类加载目录下 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 绑定实体类User --&gt; &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;&lt;!-- 设置属性,注意,绑定的实体类一定要有setter方法 标签的name表示需要控制的属性的名称 value属性代表要设置的值(基本数据类型) 如果要设置值为引用类类型(下面的例子有) 可以通过&lt;bean&gt;绑定其类似,然后使用ref属性引用其作为此属性的值--&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码 12345678 @Test public void test02()&#123;// 加载配置文件(可以通过添加多个参数配置多个文件),并且获取应用程序上下文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);// 通过上下文对象获取处理配置文件中处理过的Bean(实体类) , User user = (User) context.getBean(&quot;user&quot;); System.out.println(user); &#125; 思考? User对象是谁创建的 ? hello 对象是由Spring创建的 User对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 . 依赖注入 : 就是利用set方法来进行注入的. IOC是一种编程思想，由主动的编程变成被动的接收 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 . 简单模拟应用场景我们原先的习惯是这样的: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 持久层,接口约定public interface UserDao &#123; public void getUser();&#125;// 持久层实现1public class UserDaoImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;获取用户数据&quot;); &#125;&#125;// 持久层实现2public class UserDaoMySqlImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;MySql获取用户数据&quot;); &#125;&#125;// 业务层接口约定public interface UserService &#123; public void getUser();&#125;// 业务层实现public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125;// 测试@Testpublic void test()&#123; UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser();&#125; 现在我们用Spring来实现一下(假设上述的持久层接口和实现已经写好) : 配置文件(beans.xml) 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 绑定两个持久层实现类--&gt; &lt;bean id=&quot;UserDaoImpl&quot; class=&quot;dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;UserDaoImplMysql&quot; class=&quot;dao.UserDaoImplMysql&quot;&gt;&lt;/bean&gt;&lt;!--绑定业务层实现--&gt; &lt;bean id=&quot;UserServiceImpl&quot; class=&quot;service.UserServiceImpl&quot;&gt; &lt;!-- 设置业务层的UserDaoImpl属性,由此来决定执行哪个实现 标签的ref是引用了上面绑定的两个实现类,需要更改实现,只需要修改 ref属性即可 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;UserDaoImplMysql&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码: 1234567@Testpublic void test03()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserServiceImpl service = (UserServiceImpl) context.getBean(&quot;UserServiceImpl&quot;); service.getUser();&#125; IOC创建对象创建对象的时机:当我们将配置加载到应用程序上下文的时候就创建了 1234// 执行此语句 User 对象就已经创建ApplicationContext context = new ClassPathXmlApplicationContext(&quot;createUser.xml&quot;);// 而并非在此语句执行时创建User user = (User) context.getBean(&quot;user&quot;); 创建对象的方式:默认使用无参构造进行创建, 但可以通过配置文件中的constructor-arg元素选择构造器进行创建 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;&lt;!-- 使用有参构造进行创建对象: --&gt;&lt;!-- 1.通过有参构造的参数名设置参数创建对象--&gt;&lt;!-- &lt;constructor-arg name=&quot;name&quot; value=&quot;万叶&quot;&gt;&lt;/constructor-arg&gt;--&gt;&lt;!-- &lt;constructor-arg name=&quot;uid&quot; value=&quot;12&quot;&gt;&lt;/constructor-arg&gt;--&gt;&lt;!-- 2.通过索引设置构造器的参数创建对象--&gt;&lt;!-- &lt;constructor-arg index=&quot;0&quot; value=&quot;万叶&quot; &gt;&lt;/constructor-arg&gt;--&gt;&lt;!-- 3.通过有参构造的参数类型进行创建(不推荐)--&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;万叶&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 创建对象的复用性Spring为了避免重复创建对象浪费内存, 每次加载配置文件只创建一个对象(对应配置文件中配置的每一个bean),故多次通过getBean()获取的同名Bean其实是同一个对象 1234567@Testpublic void createUser()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;createUser.xml&quot;); User user1 = (User) context.getBean(&quot;user&quot;); User user2 = (User) context.getBean(&quot;user&quot;); System.out.println(user1 == user2); // 结果为true&#125; Bean的配置123456789101112131415161718192021&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;&lt;!--bean就是java对象,由Spring创建和管理--&gt;&lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; class 是bean的全限定名=包名+类名--&gt;&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;&lt;/bean&gt;&lt;!-- 可引入其它配置文件, 一般用于团队的合作--&gt;&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt; Bean作用域通过bean标签的scope属性设置作用域 1&lt;bean id=&quot;对象id&quot; class=&quot;包名.类名&quot; scope=&quot;需要设置的作用域名&quot;/&gt; Scope Description singleton （默认值）将单个 Bean 定义限定为每个 Spring IoC 容器的单个对象实例。 prototype 将单个 Bean 定义的作用域限定为任意数量的对象实例。 request 将单个 Bean 定义的作用域限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有自己的 Bean 实例，该实例是在单个 Bean 定义后面创建的。仅在网络感知Spring的上下文中有效。ApplicationContext session 将单个 Bean 定义作用域限定为 HTTP 的生命周期。仅在网络感知Spring的上下文中有效。Session``ApplicationContext application 将单个 Bean 定义的作用域限定为 的生命周期。仅在网络感知Spring的上下文中有效。ServletContext``ApplicationContext websocket 将单个 Bean 定义的作用域限定为 的生命周期。仅在网络感知Spring的上下文中有效。WebSocket``ApplicationContext 几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。 单例作用域 Singleton 原型作用域 Prototype Request当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。 Session当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 依赖注入通过构造器注入12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;&lt;!-- 使用有参构造进行创建对象(默认使用无参构造): --&gt;&lt;!-- 1.通过有参构造的参数名设置参数创建对象--&gt;&lt;!-- &lt;constructor-arg name=&quot;name&quot; value=&quot;万叶&quot;&gt;&lt;/constructor-arg&gt;--&gt;&lt;!-- &lt;constructor-arg name=&quot;uid&quot; value=&quot;12&quot;&gt;&lt;/constructor-arg&gt;--&gt;&lt;!-- 2.通过索引设置构造器的参数创建对象--&gt;&lt;!-- &lt;constructor-arg index=&quot;0&quot; value=&quot;万叶&quot; &gt;&lt;/constructor-arg&gt;--&gt;&lt;!-- 3.通过有参构造的参数类型进行创建(不推荐)--&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;万叶&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; setter方式注入实体类(getter,setter,toString已写好) 1234567891011public class User &#123; private String uid; private User user; private String[] books; private List hobbies; private Map cards; private Set games; private Properties info; private String girl; // ...&#125; 常用类型注入对应如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 基本类型注入--&gt; &lt;bean id=&quot;user1&quot; class=&quot;pojo.User&quot;&gt; &lt;property name=&quot;uid&quot; value=&quot;001&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot;&gt; &lt;!-- 引用类型bean(对象)注入--&gt; &lt;property name=&quot;user&quot; ref=&quot;user1&quot;&gt;&lt;/property&gt;&lt;!-- 数组注入--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;双城记&lt;/value&gt; &lt;value&gt;往后余生&lt;/value&gt; &lt;value&gt;秽土转生&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!-- 集合注入--&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;吉他&lt;/value&gt; &lt;value&gt;音乐&lt;/value&gt; &lt;value&gt;旅游&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;cards&quot;&gt; &lt;map&gt; &lt;entry key=&quot;邮政&quot; value=&quot;1001&quot; /&gt; &lt;entry key=&quot;信用社&quot; value=&quot;2001&quot;/&gt; &lt;entry key=&quot;建行&quot; value=&quot;3001&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;原神&lt;/value&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;王者荣耀&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 配置类注入--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/db01?&amp;amp;useSSL=true&lt;/prop&gt; &lt;prop key=&quot;user&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;!-- 注入null值,注意空串与null值不一样--&gt; &lt;property name=&quot;girl&quot;&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 命名空间方式注入注意:使用命令空间注入时要在xml添加关于命令空间的配置 1234&lt;!-- p命名空间xml-dta约束 --&gt;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;!-- c命名空间xml-dta约束 --&gt;xmlns:c=&quot;http://www.springframework.org/schema/c&quot; p(Properties)命名空间注入也就是相当于属性的快捷注入方式 注意: 使用的时候保证bean有无参构造并且需要注入的属性要有setter方法 12&lt;!-- 使用p命名空间注入属性--&gt; &lt;bean id=&quot;user1&quot; class=&quot;pojo.User&quot; p:uid=&quot;1001&quot;&gt;&lt;/bean&gt; c(Constructor-args)命名空间注入也就是相当于constructor-argsz的快捷注入方式 注意:要保证bean有 有参构造 12&lt;!-- 使用c命名空间注入属性--&gt;&lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:uid=&quot;1002&quot;&gt;&lt;/bean&gt; Bean自动装配自动装配是使用spring满足bean依赖的一种方法 , spring会在应用上下文中为某个bean寻找其依赖的bean。 在Spring中有三种装配的方式: 在xml中显式配置 在java中显示配置(使用注解) 隐式的bean发现机制和自动装配。 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。 下面将使用如下bean来进行测试: bean: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package pojo;public class People &#123; private Cat cat; private Dog dog; private String name; public void show()&#123; this.cat.show(); this.dog.show(); &#125; public People() &#123; &#125; public People(Cat cat, Dog dog, String name) &#123; this.cat = cat; this.dog = dog; this.name = name; &#125; @Override public String toString() &#123; return &quot;People&#123;&quot; + &quot;cat=&quot; + cat + &quot;, dog=&quot; + dog + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试程序: 123456@org.junit.Testpublic void test01()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); People people = (People) context.getBean(&quot;people&quot;); people.show();&#125; autowire byName当一个bean节点带有 autowire byName的属性时。 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称id的对象。 如果有，就取出注入；如果没有，就报空指针异常。 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;cat&quot; class=&quot;pojo.Cat&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;&gt;&lt;/bean&gt;&lt;!-- 手动装配:即注入属性--&gt;&lt;!-- &lt;bean id=&quot;people&quot; class=&quot;pojo.People&quot;&gt;--&gt;&lt;!-- &lt;property name=&quot;name&quot; value=&quot;南城&quot;&gt;&lt;/property&gt;--&gt;&lt;!-- &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;&gt;&lt;/property&gt;--&gt;&lt;!-- &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;&gt;&lt;/property&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- 根据名字自动装配: 这个名字是基于setter方法名和bean id来配置,并且会将setter方法名属性名首字母换成小写--&gt; &lt;bean id=&quot;people&quot; class=&quot;pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;南城&quot;&gt;&lt;/property&gt; &lt;/bean&gt; autowire byType使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;cat1&quot; class=&quot;pojo.Cat&quot;&gt;&lt;/bean&gt;&lt;!-- 手动装配:即注入属性--&gt;&lt;!-- &lt;bean id=&quot;people&quot; class=&quot;pojo.People&quot;&gt;--&gt;&lt;!-- &lt;property name=&quot;name&quot; value=&quot;南城&quot;&gt;&lt;/property&gt;--&gt;&lt;!-- &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;&gt;&lt;/property&gt;--&gt;&lt;!-- &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;&gt;&lt;/property&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- 根据类型自动装配,请注意,这时候配置的bean类型必须得唯一!--&gt; &lt;bean id=&quot;people&quot; class=&quot;pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;南城&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 注解实现自动装配jdk1.5支持注解,Spring2.5支持注解开发 在Spring4.0以后,使用注解需要导入aop的包(直接导入webmvc即可包含) 使用注解需要在xml配置文件引入配置约束,并且添加&lt;context:annotation-config/&gt; 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启注解设置 --&gt;&lt;context:annotation-config/&gt;&lt;/beans&gt; ==使用注解自动装配的属性前提该属性是需要在IOC容器中存在(即使在配置文件xml中注册了该bean)== @Autowired由于注解是通过反射实现的,故不依赖属性的stter方法了 装配顺序原则: 先byType 然后byName 扩展: @Autowired(required=false) 说明：false，对象可以为null；true，对象必须存对象，不能为null。 @Nullable 使用属性可以为null @Qualifier可以通过@Qualifier限定装配指定名字的bean @Autowired是默认优先根据类型自动装配的，加上@Qualifier则可以优先根据byName的方式自动装配 @Qualifier不能单独使用。 12// 指定装配 bean id 为cat2 的bean @Qualifier(value = &quot;cat2&quot;) 测试: 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启注解设置 --&gt; &lt;context:annotation-config/&gt; &lt;bean id=&quot;cat2&quot; class=&quot;pojo.Cat&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;猫猫2&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;cat&quot; class=&quot;pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;/&gt; &lt;bean id=&quot;people&quot; class=&quot;pojo.People_annotation&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243package pojo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;public class People_annotation &#123; @Autowired @Qualifier(value = &quot;cat2&quot;) private Cat cat; @Autowired private Dog dog; private String name; public void show()&#123; this.cat.show(); this.dog.show(); &#125; public People_annotation() &#123; &#125; @Override public String toString() &#123; return &quot;People_annotation&#123;&quot; + &quot;cat=&quot; + cat.toString() + &quot;, dog=&quot; + dog.toString() + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;/***********************使用了@Qualifier(value = &quot;cat2&quot;)测试*************************/ @org.junit.Test public void test02()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans_annotation.xml&quot;); People_annotation people =context.getBean(&quot;people&quot;, People_annotation.class); people.show(); System.out.println(people.toString()); &#125;/**************结果***************/喵~汪~People_annotation&#123;cat=Cat&#123;name=&#x27;猫猫2&#x27;&#125;, dog=pojo.Dog@7920ba90, name=&#x27;null&#x27;&#125;/***********只使用使用@AutoWired的结果*****************************/喵~汪~People_annotation&#123;cat=Cat&#123;name=&#x27;null&#x27;&#125;, dog=pojo.Dog@7920ba90, name=&#x27;null&#x27;&#125; @Resource这个注解是属于J2EE的(推荐使用,便于解耦),上面两个属于Spring @Resource注解既可以用在setter中也可以用在属性当中，当Resource指定属性name名字时，就只会按照指定的name去查找bean，否则会报错。 当注解写在字段上时，@Resource不指定name，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。如果最后都找不到与名称匹配的bean时才按照类型进行装配。我们运行也会成功 总结: @Resource 先byName,再byType,可以通过属性name将bean id限定 配置文件 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 开启注解设置 --&gt; &lt;context:annotation-config/&gt; &lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;/&gt; &lt;bean id=&quot;dog2&quot; class=&quot;pojo.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;修勾勾2&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;people&quot; class=&quot;pojo.People_annotation&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 123456789101112131415@Resource(name = &quot;dog2&quot;) private Dog dog;/*******测试程序与上面相同,结果:***********/喵~汪~People_annotation&#123;cat=Cat&#123;name=&#x27;猫猫2&#x27;&#125;, dog=Dog&#123;name=&#x27;修勾勾2&#x27;&#125;, name=&#x27;null&#x27;&#125;/**********************不指定名字****************************/@Resource private Dog dog;/*******测试程序与上面相同,结果:***********/喵~汪~People_annotation&#123;cat=Cat&#123;name=&#x27;猫猫2&#x27;&#125;, dog=Dog&#123;name=&#x27;null&#x27;&#125;, name=&#x27;null&#x27;&#125; 使用注解开发需要的配置注意! 使用注解需要在配置文件中引入相关的注解配置,以及扫描指定的包 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt; &lt;!-- 开启注解设置 --&gt;&lt;context:annotation-config/&gt; &lt;/beans&gt; 基础注解 @Component : 使用了该注解的类将会称为Spring的组件(即被Spring管理) @value : 注入属性值 12345678910111213141516171819@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123; @Value(&quot;南城&quot;) // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;南城&quot;/&gt; public String name;&#125;//如果提供了set方法，在set方法上添加@value(&quot;值&quot;);@Component(&quot;user&quot;)public class User &#123; public String name; @Value(&quot;秦疆&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 衍生注解所谓衍生,就有点类似html5的语义化标签(如header标签和div标签), 名字不同,功能都一样 @Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 @Controller：web层 @Service：service层 @Repository：dao层 自动装配注解 @Autowired @Qualifier 与@Autowired搭配使用限定bean id @Resource J2EE的原生注解 作用域@scope注解的值: singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 session request 123456@Controller(&quot;user&quot;)@Scope(&quot;prototype&quot;)public class User &#123; @Value(&quot;南城&quot;) public String name;&#125; xml与注解:XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 1&lt;context:annotation-config/&gt; 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ JavaConfig配置其实, 我们也可以完全不使用xml配置! JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。 @Configuration使用@Configuration注解可以将一个类声明成配置类,相当于xml中的&lt;beans&gt; @bean使用@bean 注解可以将一个返回bean的方法的返回值作为被Spring管理的bean,方法名就是bean id相当于xml中的&lt;bean&gt;,其底层是@Component实现的 @Import(类名.class)使用@Import注解可以引入其他的配置类 @ComponentScan(basePackages = “包名或者包路径”)使用@Component注解可以扫描指定的包的组件,也就是说被扫描的包中的类也可以使用@Component注册组件bean , 相当于: 123&lt;beans&gt; &lt;context:component-scan base-package=&quot;com.acme&quot;/&gt;&lt;/beans&gt; 看如下例子: 需要被管理的bean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package pojo;import org.springframework.beans.factory.annotation.Value;public class User &#123; private int uid; // 注入属性值 @Value(&quot;南城&quot;) private String name; private String pwd; public User() &#123; System.out.println(&quot;User的无参构造函数!&quot;); &#125; public User(String name) &#123; this.name = name; System.out.println(&quot;一个参数的有参数构造&quot;); &#125; public User(int uid, String name) &#123; this.uid = uid; this.name = name; System.out.println(&quot;两个参数的有参数构造&quot;); &#125; public User(int uid, String name, String pwd) &#123; this.uid = uid; this.name = name; this.pwd = pwd; System.out.println(&quot;三个参数的有参数构造&quot;); &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;uid=&quot; + uid + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125;&#125; 配置类AppConfig 1234567891011121314151617package config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;import pojo.User;@Configuration //@Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签public class AppConfig &#123; @Bean User getUser()&#123; return new User(); &#125;&#125; 测试: 123456789@Test public void test01()&#123; // 注意! 此时的应用程序上下文将通过 注解应用程序构造器 获得 ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); // 方法名即为 bean id User user = (User) context.getBean(&quot;getUser&quot;); System.out.println(user.toString()); &#125; 上述例子相当于: 12345&lt;beans&gt; &lt;bean id=&quot;getUser&quot; class=&quot;pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;南城&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 代理模式为什么要学习代理模式，因为AOP的底层机制就是动态代理！【SpringAOP和SpringMVC】 代理模式： 静态代理 动态代理 学习aop之前 , 我们要先了解一下代理模式！ 静态代理: 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 代码实现 Rent . java 即抽象角色 1234//抽象角色：租房public interface Rent &#123; public void rent();&#125; Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent&#123; public void rent() &#123; System.out.println(&quot;房屋出租&quot;); &#125;&#125; Proxy . java 即代理角色 123456789101112131415161718192021222324//代理角色：中介public class Proxy implements Rent &#123; private Rent rent; public Proxy() &#123; &#125; public Proxy(Rent rent) &#123; this.rent = rent; &#125; //租房 public void rent()&#123; seeHouse(); host.rent(); fare(); &#125; //看房 public void seeHouse()&#123; System.out.println(&quot;带房客看房&quot;); &#125; //收中介费 public void fare()&#123; System.out.println(&quot;收中介费&quot;); &#125;&#125; Client . java 即客户 123456789101112//客户类，一般客户都会去找代理！public class Client &#123; public static void main(String[] args) &#123; //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); &#125;&#125; 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。 静态代理的好处: 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 缺点 :类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 . 1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！ 1234567//抽象角色：增删改查业务public interface UserService &#123; void add(); void delete(); void update(); void query();&#125; 2、我们需要一个真实对象来完成这些增删改查操作 12345678910111213141516171819//真实对象，完成增删改查操作的人public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 3、需求来了，现在我们需要增加一个日志功能，怎么实现！ 思路1 ：在实现类上增加代码 【麻烦！】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！ 4、设置一个代理类来处理日志！代理角色 1234567891011121314151617181920212223242526272829303132//代理角色，在这里面增加日志的实现public class UserServiceProxy implements UserService &#123; private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) &#123; this.userService = userService; &#125; public void add() &#123; log(&quot;add&quot;); userService.add(); &#125; public void delete() &#123; log(&quot;delete&quot;); userService.delete(); &#125; public void update() &#123; log(&quot;update&quot;); userService.update(); &#125; public void query() &#123; log(&quot;query&quot;); userService.query(); &#125; public void log(String msg)&#123; System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;); &#125;&#125; 测试 12345678910public class Client &#123; public static void main(String[] args) &#123; UserService service = new UserServiceImp();// service.query();// 使用代理: UserServiceProxy serviceProxy = new UserServiceProxy(service); serviceProxy.query(); &#125;&#125; 动态代理: 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理—-JDK动态代理 基于类的动态代理–cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、 JDK的动态代理需要了解两个类 核心 : InvocationHandler 和 Proxy 利用Java的反射技术(Java Reflection)，在运行时创建一个实现某些给定接口的新类（也称“动态代理类”）及其实例（对象）,代理的是接口(Interfaces)，不是类(Class)，也不是抽象类。在运行时才知道具体的实现，spring aop就是此原理。 Proxy Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的父类。 **创建代理对象实例方法:**public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h); newProxyInstance( ) 方法有三个参数： loader: 用哪个类加载器去加载代理对象 interfaces:动态代理类需要实现的接口,并且通过这个接口找到具体的需要代理的实现类 h:调用程序处理对象, 代理实例在执行方法时，会调用h里面的invoke方法去执行 InvocationHandler (调用程序处理接口) InvocationHandler是由代理实例的调用处理程序实现的接口 。 每个代理实例都有一个关联的调用处理程序。 当在代理实例调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。 invoke(Object proxy, Method method, Object[] args)有三个参数: proxy: 代理实例 method: 代理实例执行方法时反射回来的方法 args: 代理实例执行方法时反射回来的方法参数 如下例子用之前静态代理添加日志功能的例子继续演示: UserService接口: 123456public interface UserService &#123; void add(); void delete(); void update(); void query();&#125; UserServiceImp业务实现: 123456789101112131415161718public class UserServiceImp implements UserService &#123; @Override public void add() &#123; System.out.println(&quot;增加用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询用户&quot;); &#125;&#125; 封装好的创建代理实例工具类: 1234567891011121314151617181920212223242526272829303132333435import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class InvocationHandlerProxy implements InvocationHandler &#123;// 被代理的真实目标对象(即原型对象) private Object target; public InvocationHandlerProxy(Object target) &#123; this.target = target; &#125; // 获取代理实例 public Object getProxyInstance()&#123;// 通过 当前对象的类加载器加载代理实例, 代理实例实现的接口(后面通过这个接口找到对应实现类) , this代表代理实例关联的调用程序对象 return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this); &#125; @Override// 当代理实例执行方法时, 会执行代理实例的关联的调用程序对象的invoke()方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(proxy,method.getName()); //返回方法的结果 /* 通过代理实例反射回来的method对象调用invoke(),实际上还是target去执行那个方法 */ return method.invoke(target,args); &#125; public void log(Object o ,String msg)&#123; System.out.println(&quot;代理对象:&quot;+o.getClass()+&quot;执行了&quot;+msg+&quot;方法!&quot;); &#125; public void setTarget(Object target) &#123; this.target = target; &#125;&#125; 测试程序Client: 12345678910public class Client &#123; public static void main(String[] args) &#123; UserServiceImp serviceImp = new UserServiceImp(); InvocationHandlerProxy invocationHandlerProxy = new InvocationHandlerProxy(serviceImp); UserService proxy = (UserService) invocationHandlerProxy.getProxyInstance(); proxy.query(); proxy.add(); &#125;&#125; Spring中的AOP相关概念:AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . 相关概念: 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 切面（Aspect）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。即原型对象 代理（Proxy）：向目标对象应用通知之后创建的对象。即代理对象或代理者 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。在使用环绕切入时必须通过链接点显式调用方法 SpringAOP中，通过Advice(通知)定义横切逻辑，Spring中支持5种类型的Advice: Advice类型 链接点 实现接口 前置通知:BeforeAdvice 切点(方法)执行前 org.springframework.aop.MethodBeforeAdvice 后置通知:AfterAdvice 切点(方法)执行后 org.springframework.aop.MethodAfterAdvice 环绕通知:AroundAdvice,Interceptor 切点(方法)执行前后 org.aopalliance.intercept.MethodInterceptor 异常通知:ThrowsAdvice 切点(方法)抛出异常时 org.springframework.aop.ThrowsAdvice 引介通知:IntroductionInterceptor 在类中新增方法 org.springframework.aop.IntroductionInterceptor; 需要的配置:使用api需要另外导入依赖包(不是webmvc里的包) 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 所需要的xml配置约束: 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;/beans&gt; 使用Spring API实现AOP我们需要将切入的代码实现相关的通知接口(如:MethodBeforeAdvice,AfterReturningAdvice等等…),随后使用&lt;aop:config&gt;中的&lt;aop:pointcut&gt;标签配置切入点,,使用 &lt;aop:advisor&gt;配置通知类实现 UserService接口: 12345678package aop;public interface UserService &#123; void add(); void delete(); void update(); void query();&#125; 业务代码接口实现: 123456789101112131415161718192021222324package aop;public class UserServiceImp implements UserService &#123; @Override public void add() &#123; System.out.println(&quot;增加用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询用户&quot;); &#125;&#125; 需要切入的代码: 前置通知需要实现org.springframework.aop.MethodBeforeAdvice接口 12345678910111213141516package aop.SpringAPI实现;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class BeforeLog implements MethodBeforeAdvice &#123;// 实现了此接口的类的before方法将会在切入点执行前执行 @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; /* * method 表示执行的方法对象 * args 方法所执行的参数 * target 表示被代理的对象(即原型对象) * */ System.out.println(target.getClass().getName()+&quot;执行方法&quot;+method.getName()+&quot;之前========&quot;); &#125;&#125; 后置通知需要实现org.springframework.aop.AfterReturningAdvice接口 1234567891011121314151617package aop.SpringAPI实现;import org.springframework.aop.AfterReturningAdvice;import java.lang.reflect.Method;public class AfterLog implements AfterReturningAdvice &#123; // 实现了此接口的类的before方法将会在切入点执行后执行 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; /* * returnValue 表示执行方法所返回的值 * method 表示执行的方法对象 * args 方法所执行的参数 * target 表示被代理的对象(即原型对象) * */ System.out.println(target.getClass().getName()+&quot;执行方法&quot;+method.getName()+&quot;之后========返回值为&quot;+returnValue); &#125;&#125; applicationconfig.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 注册bean--&gt; &lt;bean id=&quot;serviceImp&quot; class=&quot;aop.UserServiceImp&quot;/&gt; &lt;bean id=&quot;beforeLog&quot; class=&quot;aop.SpringAPI实现.BeforeLog&quot; /&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;aop.SpringAPI实现.AfterLog&quot;/&gt;&lt;!-- aop配置--&gt; &lt;aop:config&gt;&lt;!-- 设置 切入点,表达式:expression=&quot;execution(* aop.UserServiceImp.*(..))表示:切入点为 当执行 aop包下UserServiceImp类的任意方法且此方法有0至多个参数,且该方法的返回值也是任意的也就是说: UserServiceImp类的所有方法执行时进行切入--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* aop.UserServiceImp.*(..))&quot;/&gt;&lt;!-- 配置 切入通知--&gt; &lt;aop:advisor advice-ref=&quot;beforeLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试: 123456789101112131415import aop.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import 动态代理.增加功能.UserServiceImp;public class MainDemo1 &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;appconfig1.xml&quot;); // 注意!!! 这里接收的是上转型对象,注册的bean是实现类,接收的类型是接口类型// 使用实现类接口将会报切入异常:com.sun.proxy.$Proxy3 cannot be cast to 动态代理.增加功能.UserServiceImp UserService service = (UserService) context.getBean(&quot;serviceImp&quot;); service.query(); &#125;&#125; 注意与拓展:&lt;aop:config&gt;切点表达式: 关于Spring中AOP的切点表示更多详细参考:切点表达式用法 (cnblogs.com) 由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的部件，并且在Spring中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的。如下是execution表达式的语法： 1execution(方法访问修饰符? 返回值 方法含包名全路径?方法名(参数类型) 抛出的异常类型?) 这里问号表示当前项可以有也可以没有，其中各项的语义如下： *通配符，该通配符主要用于匹配单个单词，或者是以某个词为前缀或后缀的单词。 ..通配符，该通配符表示0个或多个项，主要用于方法的含包名全路径和参数类型中，如果用于含包名全路径中，==则表示匹配当前包及其子包==，如果用于参数类型中，则表示匹配0个或多个参数。 如下示例表示匹配返回值为任意类型，并且是com.spring.service包及其子包下的任意类的名称为businessService的方法，而且该方法不能有任何参数： 1execution(* com.spring.service..*.businessService()) ​ 这里需要说明的是，包路径service...businessService()中的..应该理解为延续前面的service路径，表示到service路径为止，或者继续延续service路径，从而包括其子包路径；后面的.businessService()，这里的*表示匹配一个单词，因为是在方法名前，因而表示匹配任意的类。 ​ 如下示例是使用..表示任意个数的参数的示例，需要注意，表示参数的时候可以在括号中事先指定某些类型的参数，而其余的参数则由..进行匹配： 1execution(* com.spring.service.BusinessObject.businessService(java.lang.String,..)) 实现类与接口的转换:由于我们的实现类(即UserServiceImp)交给了Spring进行代理来实现AOP,所以我们在获取bean时应该使用实现类对应的接口来获取 1context.getBean(&quot;serviceImp&quot;,UserService.class).add(); 使用自定义类实现AOP我们除了可以通过实现相关的接口来进行通知增强外,还可以自定义切入通知类 ,只需要使用&lt;aop:aspect ref=&quot;myAdvice&quot; &lt;/aop:aspect&gt;配置切面标签中配置切面即可 UserService接口与其实现类与上面的例子一致,就省略了 UserService接口,实现类 略 自定义通知类 MyAdvice: 123456789101112package aop.自定义类实现;public class MyAdspect &#123; public void before()&#123; System.out.println(&quot;================执行方法前============&quot;); &#125; public void after()&#123; System.out.println(&quot;================执行方法后============&quot;); &#125;&#125; applicationconfig.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 被管理的原型对象--&gt; &lt;bean id=&quot;serviceImp&quot; class=&quot;aop.UserServiceImp&quot;/&gt;&lt;!--引入自定义的切面类--&gt; &lt;bean id=&quot;myAdvice&quot; class=&quot;aop.自定义类实现.MyAspect&quot;/&gt; &lt;aop:config&gt;&lt;!-- 设置切入点--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* aop.UserServiceImp.*(..))&quot;/&gt;&lt;!-- 配置自定义的切面, ref引入自定义通知类--&gt; &lt;aop:aspect ref=&quot;myAspect&quot; id=&quot;myAspect&quot;&gt;&lt;!-- 配置具体切入方式和通知类的具体方法实现以及切入点--&gt; &lt;aop:before method=&quot;after&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:after method=&quot;before&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试: 123456789101112131415package aop.自定义类实现;import aop.UserService;import aop.UserServiceImp;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainDemo2 &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;appconfig2.xml&quot;); UserService userService = (UserService) context.getBean(&quot;serviceImp&quot;); userService.add(); &#125;&#125; 补充:环绕切入**环绕切入需要显式的通过链接点ProceedingJoinPoint**对象调用proceed()方法执行目标(原型对象)调用的方法 自定义切面类: 12345678910import org.aspectj.lang.ProceedingJoinPoint;public class MyAspect &#123; public void round(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;================执行方法前============&quot;); Object returnValue = joinPoint.proceed(); // 显式通过链接点执行原型对象执行的方法 System.out.println(&quot;执行了&quot;+joinPoint.getSignature()+&quot;方法&quot;+&quot;原型对象为&quot;+joinPoint.getTarget()+&quot;返回值:&quot;+returnValue); &#125;&#125; applicationconfig.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 被管理的原型对象--&gt; &lt;bean id=&quot;serviceImp&quot; class=&quot;aop.UserServiceImp&quot;/&gt;&lt;!--引入自定义的切面类--&gt; &lt;bean id=&quot;myAdvice&quot; class=&quot;aop.自定义类实现.MyAspect&quot;/&gt; &lt;aop:config&gt;&lt;!-- 设置切入点--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* aop.UserServiceImp.*(..))&quot;/&gt;&lt;!-- 配置自定义的切面, ref引入自定义通知类--&gt; &lt;aop:aspect ref=&quot;myAdvice&quot; id=&quot;myAspect&quot;&gt; &lt;!-- 配置具体切入方式和通知类的具体方法实现以及切入点--&gt; &lt;aop:around method=&quot;round&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 使用注解实现AOP实现aop的常用注解: @Aspect 标注为自定义切面类 @Before(&quot;execution(表达式)&quot;) 标注方法为前置通知方法 @After(&quot;execution(表达式&quot;) 标注方法为前置通知方法 @Around(&quot;execution(表达式&quot;) 标注方法为环绕通知方法(注意需要显示通过链接点调用方法) @EnableAspectJAutoProxy 用于自定义配置类, 开启自动代理 aop:aspectj-autoproxy：说明 通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 &lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class=”true”/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 自定义配置类不用配置文件如下例子完全采用注解注册bean,并且实现环绕切面 (UserService接口和实现类已省略) 自定义切面类: AnnotationAspect 123456789101112131415161718192021package aop.注解实现;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.context.annotation.EnableAspectJAutoProxy;import org.springframework.stereotype.Component;@Aspectpublic class AnnotationAspect &#123; @Around(&quot;execution(* aop.UserServiceImp.*(..))&quot;) public void around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;================执行方法前============&quot;); Object returnValue = joinPoint.proceed(); System.out.println(&quot;执行了&quot;+joinPoint.getSignature()+&quot;方法&quot;+&quot;原型对象为&quot;+joinPoint.getTarget()+&quot;返回值:&quot;+returnValue); &#125;&#125; java配置类: MyAppConfig 123456789101112131415161718package aop.注解实现;import aop.UserServiceImp;import org.springframework.context.annotation.*;import org.springframework.stereotype.Component;@Configuration@EnableAspectJAutoProxy //一定要开启自动代理才能生效public class MyAppConfig &#123; @Bean UserServiceImp getServiceImp()&#123; return new UserServiceImp(); &#125; @Bean AnnotationAspect getAnnotationAspect()&#123; return new AnnotationAspect(); &#125;&#125; 测试: 12345678public class MainDemo3 &#123; public static void main(String[] args) &#123; // 通过注解注册bean容器,完全不使用配置文件 ApplicationContext context = new AnnotationConfigApplicationContext(MyAppConfig.class); UserService userService = (UserService) context.getBean(&quot;getServiceImp&quot;); userService.add(); &#125;&#125; 使用配置文件结合注解使用本例中将通过配置文件开启注解扫描和自动代理设置,然后再使用注解实现 自定义切面类: AnnotationAspect 1234567891011121314151617181920package aop.注解实现;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.context.annotation.EnableAspectJAutoProxy;import org.springframework.stereotype.Component;@Aspectpublic class AnnotationAspect &#123; @Around(&quot;execution(* aop.UserServiceImp.*(..))&quot;) public void around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;================执行方法前============&quot;); Object returnValue = joinPoint.proceed(); System.out.println(&quot;执行了&quot;+joinPoint.getSignature()+&quot;方法&quot;+&quot;原型对象为&quot;+joinPoint.getTarget()+&quot;返回值:&quot;+returnValue); &#125;&#125; 接口实现类,注册组件: 123456789101112131415161718192021222324252627package aop;import org.springframework.stereotype.Component;@Component(&quot;serviceImp&quot;)public class UserServiceImp implements UserService &#123; @Override public void add() &#123; System.out.println(&quot;增加用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询用户&quot;); &#125;&#125; 配置文件: appconfig.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 开启注解设置 --&gt; &lt;context:annotation-config/&gt; &lt;!--指定注解扫描包--&gt; &lt;context:component-scan base-package=&quot;aop&quot;/&gt;&lt;!-- 开启自动代理--&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 测试: 123456789101112131415package aop.注解实现;import aop.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainDemo3 &#123; public static void main(String[] args) &#123; // 方式二: ApplicationContext context2 = new ClassPathXmlApplicationContext(&quot;appconfig3.xml&quot;); UserService userService2 = (UserService) context2.getBean(&quot;serviceImp&quot;); userService2.add(); &#125;&#125; Spring整合Mybatis 官方参考文档:mybatis-spring 什么是 MyBatis-Spring？ MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。 最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。 依赖配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!-- 测试工具--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;!-- Spring重要核心--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt;&lt;!-- Spring织入--&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt;&lt;!-- spring的jdbc--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt;&lt;!-- spring中的Mybatis--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt;&lt;!-- mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; 入门案例: 首先需要编写Spring的上下文件配置文件,然后将**数据源 ,SqlSessionFactoryBean(会话工厂) 注入Spring中**,至少需要定义这两个 数据源中需要设置driverClassName , url ,username ,password 会话工厂也有两个很重要的东西,必须配置数据源,映射器, 之前我们在mybatis中是通过引入配置文件mybatis-config.xml来创建会话工厂的,现在可以完全不用配置mybatis配置文件(如果没有其他配置要求的话) 通过会话工厂获得SqlSession对象(在Spring-Mybatis中是他的子类SqlSessionTemplate),随后也交给Spring管理 最后通过SqlSession获取Mapper执行对应方法 实体类: User (省略) dao接口:Userdao 12345678package spring_mybatis01.dao;import spring_mybatis01.pojo.User;import java.util.List;public interface UserDao &#123; List&lt;User&gt; getAllUser();&#125; Spring的配置文件 appconfig.xml , 注意！ 如果需要引入mybatis核心配置文件 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 配置数据源,这里配置的是Spring的JDBC的--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis? useSSL=true&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt;&lt;!-- 创建SqlSession工厂--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;&lt;!-- 直接给工厂对象注入数据源,映射器mapper,这两个是必须的--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;mybatis-config.xml&quot;/&gt; &lt;!--注意! 如果注入配置文件,则必须最先注入 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 必填项 --&gt;&lt;!-- 可以通过mybatis配置引入mapper配置,也可以通过mapperLocations属性注入 --&gt;&lt;!-- &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:spring_mybatis01/dao/*.xml&quot; /&gt;--&gt; &lt;/bean&gt;&lt;!-- 创建sqlSession对象--&gt; &lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;userDaoMapper&quot; class=&quot;spring_mybatis01.dao.UserDaoMapper&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionTemplate&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml , 一般我们用来对mybatis的一些设置，如mapper,缓冲之类的 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;mappers&gt;&lt;!-- &amp;lt;!&amp;ndash; 注意:这里的路径下一级用 / 表示,可以注册多个映射器 &amp;ndash;&amp;gt;--&gt; &lt;mapper resource=&quot;spring_mybatis01/dao/UserDaoMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; UserDaoMapper.xml , 也可以通过注解实现 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--命名空间作用是绑定 Dao/Mapper接口,相当于编写了一个类实现了该接口--&gt;&lt;mapper namespace=&quot;spring_mybatis01.dao.UserDao&quot;&gt; &lt;!-- id就当于Dao/Mapper接口的方法,相当于实现了接口重写了接口里的方法,方法体内容就是sql, 返回类型和参数类型应该与重写的方法保持一致--&gt; &lt;select id=&quot;getAllUser&quot; resultType=&quot;spring_mybatis01.pojo.User&quot;&gt; select * from `user` &lt;/select&gt;&lt;/mapper&gt; UserDaoMapper.class, 此类不是必要的,只是将通过Spring将SqlSessiontemplate注入,然后返回对应接口的mapper 123456789101112131415package spring_mybatis01.dao;import org.mybatis.spring.SqlSessionTemplate;public class DaoMapper &#123; private SqlSessionTemplate sqlSessionTemplate; // 根据参数类型,返回对应接口的Mapper public &lt;T&gt; T getMapper(Class&lt;T&gt; typeClass)&#123; return this.sqlSessionTemplate.getMapper(typeClass); &#125; public DaoMapper(SqlSessionTemplate sqlSessionTemplate) &#123; this.sqlSessionTemplate = sqlSessionTemplate; &#125;&#125; 测试程序: 123456789101112131415package spring_mybatis01;public class MainTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;appconfig.xml&quot;); // 通过Spring管理的DaoMapper类获取接口的sql映射器 UserDao userDaoMapper = context.getBean(&quot;daoMapper&quot;, DaoMapper.class).getMapper(UserDao.class); // 执行sql List&lt;User&gt; list = userDaoMapper.getAllUser(); for (User user: list) &#123; System.out.println(user); &#125; &#125;&#125; 注解实现**案例二: ** 此案例将大量通过注解实现 UserDao接口: 123456789package spring_mybatis02.dao;import org.apache.ibatis.annotations.Select;import spring_mybatis02.pojo.User;import java.util.List;public interface UserDao &#123; @Select(&quot;select * from `user`&quot;) List&lt;User&gt; getAllUser();&#125; Spring配置类: MyAppconfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package spring_mybatis02.config;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.mapper.MapperFactoryBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.datasource.DriverManagerDataSource;import spring_mybatis02.MainTest;import spring_mybatis02.dao.UserDao;import java.io.InputStream;import java.util.Properties;@Configurationpublic class MyAppConfig &#123; // 将工厂对象放入Spring @Bean SqlSessionFactory sqlSessionFactoryBean() throws Exception &#123; // 创建数据源 InputStream inputStream = MyAppConfig.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); Properties properties = new Properties(); properties.load(inputStream); String driver = properties.getProperty(&quot;driver&quot;); String url = properties.getProperty(&quot;url&quot;); String username = properties.getProperty(&quot;username&quot;); String password = properties.getProperty(&quot;password&quot;); DriverManagerDataSource dataSource = new DriverManagerDataSource(url,username,password); dataSource.setDriverClassName(driver); // 创建工厂bean, 并且为工厂对象设置数据源后放入Spring中 SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); return factoryBean.getObject(); &#125; // 通过Spring中的工厂对象创建SqlSession,并且也交给Spring管理 @Bean SqlSessionTemplate sqlSessionTemplate() throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactoryBean()); &#125; /*通过MapperFactoryBean获取SqlSession,进而获取到UserDao接口的Mapper, * 将其也交给Spring管理 * */ @Bean UserDao userDaoMapper() throws Exception &#123; // 注意! 要在配置对象中注册Mapper,可以是xml或者注解的接口 sqlSessionFactoryBean().getConfiguration().addMapper(UserDao.class); //相当于再配置文件中注册Mapper MapperFactoryBean mapperFactoryBean = new MapperFactoryBean(UserDao.class); mapperFactoryBean.setSqlSessionFactory(sqlSessionFactoryBean()); return mapperFactoryBean.getSqlSessionTemplate().getMapper(UserDao.class); &#125;&#125; 测试程序: 123456789101112131415161718package spring_mybatis02;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import spring_mybatis02.config.MyAppConfig;import spring_mybatis02.dao.UserDao;import spring_mybatis02.pojo.User;import java.util.List;public class MainTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(MyAppConfig.class); List&lt;User&gt; list = context.getBean(&quot;userDaoMapper&quot;,UserDao.class).getAllUser(); for (User u:list) &#123; System.out.println(u); &#125; &#125;&#125; 几个重要对象SqlSessionFactoryBean在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。 需要注意的是 SqlSessionFactoryBean 实现了 Spring 的 FactoryBean 接口（参见 Spring 官方文档 3.8 节 通过工厂 bean 自定义实例化逻辑 ）。 这意味着由 Spring 最终创建的 bean 并不是 SqlSessionFactoryBean 本身，而是工厂类（SqlSessionFactoryBean）的 getObject() 方法的返回结果。这种情况下，Spring 将会在应用启动时为你创建 SqlSessionFactory，并使用 sqlSessionFactory 这个名字存储起来。 属性:SqlSessionFactory 有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的 一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt;settings&gt; 或 &lt;typeAliases&gt; 元素。 需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（&lt;environments&gt;），数据源（&lt;DataSource&gt;）和 MyBatis 的事务管理器（&lt;transactionManager&gt;）都会被忽略。 SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。 如果 MyBatis 在映射器类对应的路径下找不到与之相对应的映射器 XML 文件，那么也需要配置文件。这时有两种解决办法：第一种是手动在 MyBatis 的 XML 配置文件中的 &lt;mappers&gt; 部分中指定 XML 文件的类路径；第二种是设置工厂 bean 的 mapperLocations 属性。 mapperLocations 属性接受多个资源位置。这个属性可以用来指定 MyBatis 的映射器 XML 配置文件的位置。属性的值是一个 Ant 风格的字符串，可以指定加载一个目录中的所有文件，或者从一个目录开始递归搜索所有目录。比如: 123456&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;&lt;!--注意! 如果注入配置文件,则必须最先注入 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;mybatis-config.xml&quot;/&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 必填项 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:spring_mybatis01/dao/*.xml&quot; /&gt;&lt;/bean&gt; SqlSessionTemplate在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。 一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。 使用 MyBatis-Spring 之后，你不再需要直接使用 SqlSessionFactory 了，因为你的 bean 可以被注入一个线程安全的 SqlSession，它能基于 Spring 的事务配置来自动提交、回滚、关闭 session。 当调用 SQL 方法时（包括由 getMapper() 方法返回的映射器中的方法），SqlSessionTemplate 将会保证使用的 SqlSession 与当前 Spring 的事务相关。 此外，它管理 session 的生命周期，包含必要的关闭、提交或回滚操作。另外，它也负责将 MyBatis 的异常翻译成 Spring 中的 DataAccessExceptions。 由于模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。 创建这个SqlSessionTemplate对象需要SqlSessionFactory对象来创建 123&lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; java: 12345// 通过Spring中的工厂对象创建SqlSession,并且也交给Spring管理 @Bean SqlSessionTemplate sqlSessionTemplate() throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory()); &#125; MapperFactoryBeanMapperFactoryBean 需要配置一个 SqlSessionFactory 或 SqlSessionTemplate。它们可以分别通过 sqlSessionFactory 和 sqlSessionTemplate 属性来进行设置。 如果两者都被设置，SqlSessionFactory 将被忽略。 可以通过MapperFactoryBean获取到SqlSessionTemplate. 12345678@Bean UserDao userDaoMapper() throws Exception &#123; // 注意! 如果是注解接口, 要在配置对象中注册Mapper sqlSessionFactory().getConfiguration().addMapper(UserDao.class); //相当于再配置文件中注册Mapper MapperFactoryBean mapperFactoryBean = new MapperFactoryBean(); mapperFactoryBean.setSqlSessionFactory(sqlSessionFactory()); return mapperFactoryBean.getSqlSessionTemplate().getMapper(UserDao.class); &#125; 如果映射器接口 UserMapper 在相同的类路径下有对应的 MyBatis XML 映射器配置文件，将会被 MapperFactoryBean 自动解析。不需要在 MyBatis 配置文件中显式配置映射器，除非映射器配置文件与接口类不在同一个类路径下。 参考 SqlSessionFactoryBean 的 configLocation 属性以获取更多信息。 SqlSessionDaoSupportSqlSessionDaoSupport 是一个抽象的支持类，用来为你提供 SqlSession。调用 getSqlSession() 方法你会得到一个 SqlSessionTemplate，之后可以用于执行 SQL 方法，就像下面这样: 12345public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; public User getUser(String userId) &#123; return getSqlSession().selectOne(&quot;org.mybatis.spring.sample.mapper.UserMapper.getUser&quot;, userId); &#125;&#125; 在这个类里面，通常更倾向于使用 MapperFactoryBean，因为它不需要额外的代码。但是，如果你需要在 DAO 中做其它非 MyBatis 的工作或需要一个非抽象的实现类，那么这个类就很有用了。 SqlSessionDaoSupport 需要通过属性设置一个 sqlSessionFactory 或 SqlSessionTemplate。如果两个属性都被设置了，那么 SqlSessionFactory 将被忽略。 假设类 UserMapperImpl 是 SqlSessionDaoSupport 的子类，可以编写如下的 Spring 配置来执行设置： 123&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; Mybatis-Spring中的事务一个使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 DataSourceTransactionManager 来实现事务管理。 一旦配置好了 Spring 的事务管理器，你就可以在 Spring 中按你平时的方式来配置事务。并且支持 @Transactional 注解和 AOP 风格的配置。在事务处理期间，一个单独的 SqlSession 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。 事务配置好了以后，MyBatis-Spring 将会透明地管理事务。 mybatis-spring参考文档 事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 事务四个属性ACID原则 **原子性（atomicity):**事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 **一致性（consistency）:**一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 **隔离性（isolation）:**可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 持久性（durability）:事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中 Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。 标准配置要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 DataSourceTransactionManager 对象： 123&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;constructor-arg ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 传入的 DataSource 可以是任何能够与 Spring 兼容的 JDBC DataSource。包括连接池和通过 JNDI 查找获得的 DataSource。 注意：为事务管理器指定的 DataSource 必须和用来创建 SqlSessionFactoryBean 的是同一个数据源，否则事务管理器就无法工作了。 交由容器管理事务(了解即可)如果你正使用一个 JEE 容器而且想让 Spring 参与到容器管理事务（Container managed transactions，CMT）的过程中，那么 Spring 应该被设置为使用 JtaTransactionManager 或由容器指定的一个子类作为事务管理器。最简单的方式是使用 Spring 的事务命名空间或使用 JtaTransactionManagerFactoryBean： 1&lt;tx:jta-transaction-manager /&gt; 1234567@Configurationpublic class DataSourceConfig &#123; @Bean public JtaTransactionManager transactionManager() &#123; return new JtaTransactionManagerFactoryBean().getObject(); &#125;&#125; 在这个配置中，MyBatis 将会和其它由容器管理事务配置的 Spring 事务资源一样。Spring 会自动使用任何一个存在的容器事务管理器，并注入一个 SqlSession。 如果没有正在进行的事务，而基于事务配置需要一个新的事务的时候，Spring 会开启一个新的由容器管理的事务。 注意，如果你想使用由容器管理的事务，而不想使用 Spring 的事务管理，你就不能配置任何的 Spring 事务管理器。且必须配置 SqlSessionFactoryBean 以使用基本的 MyBatis 的 ManagedTransactionFactory spring事务传播特性事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为： propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。 假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！ 声明式事务 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理 一般我们使用声明式事务,即通过Spring AOP织入实现事务管理 首先我们来看一个例子:这个例子演示了同时添加两个用户,并且故意把删除用户的语句写错 , 若不进行事务管理,插入语句将会执行成功; 而进行事务管理后, 由于事务中的删除语句出现错误,该事务将会回滚,导致事务中所有的语句都不会执行 实体类User省略,UserMapper接口如下: 12345678910111213package dao;import org.apache.ibatis.annotations.Param;import pojo.User;import java.util.List;import java.util.Map;public interface UserMapper &#123; List&lt;User&gt; getAllUser(); int addUser(@Param(&quot;user&quot;) User user); int removeUser(@Param(&quot;id&quot;) int id); int updateUser(@Param(&quot;map&quot;) Map&lt;String,Object&gt; map);&#125; 对应的UserMapper.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.UserMapper&quot;&gt; &lt;select id=&quot;getAllUser&quot; resultType=&quot;pojo.User&quot; &gt; select * from mybatis.user; &lt;/select&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;pojo.User&quot;&gt; insert into `user` values(#&#123;user.id&#125;,#&#123;user.name&#125;, #&#123;user.pwd&#125;) &lt;/insert&gt; &lt;delete id=&quot;removeUser&quot; parameterType=&quot;_int&quot;&gt; deletes from `user` where id = #&#123;id&#125; &lt;/delete&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt; update `user` set $&#123;map.column&#125; = #&#123;map.value&#125; where id = #&#123;map.id&#125; &lt;/update&gt;&lt;/mapper&gt; UserMapper的实现类: 123456789101112131415161718192021222324252627282930313233package dao;import org.mybatis.spring.support.SqlSessionDaoSupport;import pojo.User;import java.util.List;import java.util.Map;public class UserMapperImp extends SqlSessionDaoSupport implements UserMapper&#123; @Override public List&lt;User&gt; getAllUser() &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); addUser(new User(1001,&quot;小北&quot;,&quot;1010101&quot;)); addUser(new User(1002,&quot;小九&quot;,&quot;1010101&quot;)); removeUser(1002); return mapper.getAllUser(); &#125; @Override public int addUser(User user) &#123; return getSqlSession().getMapper(UserMapper.class).addUser(user); &#125; @Override public int removeUser(int id) &#123; return getSqlSession().getMapper(UserMapper.class).removeUser(1001); &#125; @Override public int updateUser(Map&lt;String, Object&gt; map) &#123; return getSqlSession().getMapper(UserMapper.class).updateUser(map); &#125;&#125; Spring配置文件applicationconfig.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt;&lt;!--注册会话工厂--&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:dao/*.xml&quot;/&gt; &lt;/bean&gt;&lt;!--注册会话--&gt; &lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!--测试用的--&gt;&lt;!-- &lt;bean id=&quot;daoMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;--&gt;&lt;!-- &lt;property name=&quot;mapperInterface&quot; value=&quot;dao.UserMapper&quot;/&gt;--&gt;&lt;!-- &lt;property name=&quot;sqlSessionTemplate&quot; ref=&quot;sqlSessionTemplate&quot;/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- 由于实现类继承SqlSessionDaoSupport类,可以直接在方法作用域中获取sql会话,所以要注入一个sql会话或者会话工厂--&gt; &lt;bean id=&quot;mapperImp&quot; class=&quot;dao.UserMapperImp&quot;&gt; &lt;property name=&quot;sqlSessionTemplate&quot; ref=&quot;sqlSessionTemplate&quot;/&gt; &lt;/bean&gt;&lt;!-- 进行事务管理需要注册事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;!-- 配置事务aop通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; &gt; &lt;!-- 设置通知属性,即声明哪些方法需要进行事务管理通知,没有设置的方法是不会进行事务管理的--&gt; &lt;tx:attributes&gt; &lt;!-- 可以设置一些事务的属性,一个tx:method标签可以看作一个事务,可以设置隔离级别,传播性,超时时间,只读等 --&gt; &lt;tx:method name=&quot;getAllUser&quot;/&gt; &lt;!--可以使用*通配符表示所有方法,并且设置了事务隔离级别,传播性,是否只读超时时间等--&gt;&lt;!-- &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;MANDATORY&quot; read-only=&quot;false&quot; timeout=&quot;1000&quot;/&gt;--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!-- 进行aop配置--&gt; &lt;aop:config&gt; &lt;!--设置aop切点,请注意不要将aop的切点与事务管理事务事务通知设置的方法搞混,两者本质是有区别的 但是它们两共同决定了一个方法是否进行事务管理 --&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* dao.UserMapperImp.getAllUser(..))&quot;/&gt; &lt;!-- 设置aop织入事务通知 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试程序: 123456789101112131415161718import dao.UserMapper;import dao.UserMapperImp;import org.mybatis.spring.SqlSessionTemplate;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.User;import java.util.HashMap;import java.util.List;import java.util.Map;public class MainTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationconfig.xml&quot;); // 这里注意,动态代理代理的是接口,所以不能写实现类类型 context.getBean(&quot;mapperImp&quot;,UserMapper.class).getAllUser(); &#125;&#125; 编程式事务MyBatis 的 SqlSession 提供几个方法来在代码中处理事务。但是当使用 MyBatis-Spring 时，你的 bean 将会注入由 Spring 管理的 SqlSession 或映射器。也就是说，Spring 总是为你处理了事务。 你不能在 Spring 管理的 SqlSession 上调用 SqlSession.commit()，SqlSession.rollback() 或 SqlSession.close() 方法。如果这样做了，就会抛出 UnsupportedOperationException 异常。在使用注入的映射器时，这些方法也不会暴露出来。 无论 JDBC 连接是否设置为自动提交，调用 SqlSession 数据方法或在 Spring 事务之外调用任何在映射器中方法，事务都将会自动被提交。 如果你想编程式地控制事务，请参考 the Spring reference document(Data Access -Programmatic transaction management-) 。下面的代码展示了如何使用 PlatformTransactionManager 手工管理事务。下面的代码展示了如何使用 PlatformTransactionManager 手工管理事务。 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 1234567891011121314151617public class UserService &#123; private final PlatformTransactionManager transactionManager; public UserService(PlatformTransactionManager transactionManager) &#123; this.transactionManager = transactionManager; &#125; public void createUser() &#123; TransactionStatus txStatus = transactionManager.getTransaction(new DefaultTransactionDefinition()); try &#123; userMapper.insertUser(user); &#125; catch (Exception e) &#123; transactionManager.rollback(txStatus); throw e; &#125; transactionManager.commit(txStatus); &#125;&#125; 在使用 TransactionTemplate 的时候，可以省略对 commit 和 rollback 方法的调用。 12345678910111213public class UserService &#123; private final PlatformTransactionManager transactionManager; public UserService(PlatformTransactionManager transactionManager) &#123; this.transactionManager = transactionManager; &#125; public void createUser() &#123; TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager); transactionTemplate.execute(txStatus -&gt; &#123; userMapper.insertUser(user); return null; &#125;); &#125;&#125; 注意：虽然这段代码使用的是一个映射器，但换成 SqlSession 也是可以工作的。","categories":[{"name":"Java系列","slug":"Java系列","permalink":"https://lqy679.github.io/categories/Java%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"NoSQL","slug":"NoSQL","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T04:59:46.607Z","comments":true,"path":"2020/01/01/NoSQL/","link":"","permalink":"https://lqy679.github.io/2020/01/01/NoSQL/","excerpt":"非关系型数据库(NoSQL)初识NoSQL大数据时代对数据存储的挑战,对于实时性、动态性要求较高的的社交网站，如论坛、微博等，往往需要达到每秒上万次的读写请求，这种很高的并发性对数据库的并发负载相当大，特别是对与传统关系数据库的硬盘I/O是个很大的负担。关系型数据库是很难水平扩展的，当数据量和访问量多到需要增加硬件和服务器节点来扩大容量和负载量，关系型数据库往往需要停机维护和数据迁移，这对一个需要24小时不停服务的网站是非常不可取。 动态交互网站Web2.0每天产生的数据量是巨大的，如果采用传统的关系型数据库将海量数据存放到具有固定结构的二维表格中，不管是查询还是更新操作效率都是非常低。 高并发读写需求 高扩展性 高效率存储和访问需求 高可用","text":"非关系型数据库(NoSQL)初识NoSQL大数据时代对数据存储的挑战,对于实时性、动态性要求较高的的社交网站，如论坛、微博等，往往需要达到每秒上万次的读写请求，这种很高的并发性对数据库的并发负载相当大，特别是对与传统关系数据库的硬盘I/O是个很大的负担。关系型数据库是很难水平扩展的，当数据量和访问量多到需要增加硬件和服务器节点来扩大容量和负载量，关系型数据库往往需要停机维护和数据迁移，这对一个需要24小时不停服务的网站是非常不可取。 动态交互网站Web2.0每天产生的数据量是巨大的，如果采用传统的关系型数据库将海量数据存放到具有固定结构的二维表格中，不管是查询还是更新操作效率都是非常低。 高并发读写需求 高扩展性 高效率存储和访问需求 高可用 NoSQL是Not Only SQL的缩写，它的含义为“不仅仅是SQL”。NoSQL是一种非关系型、分布式、无需遵循ACID原则、不提供SQL功能的数据库，是对关系型数据库在灵活性和扩展性上的补充。 与关系型数据库的区别存储方式: 关系型数据库采用**表的格式(结构化数据)**进行存储，数据以行和列的方式进行存储，读取和查询都十分方便。 非关系型数据库是以数据集的方式进行存储，即将大量数据都集中在一起存储，类似于键值对、图结构或者文档。 查询方式: 关系型数据库是采用结构化查询语言（即 SQL）来对数据库进行查询，SQL支持数据库的CRUD操作，具有非常强大的功能。 ​ 非关系型数据库使用的是非结构化查询语言（UnQL），UnQL以数据集（如文档）为单位来管理和操作数据，由于没有统一的标准，所以每个数据库厂商提供产品标准是不一样的。 读写性能: 关系型数据库强调数据的一致性，为此降低了数据的读写性能。虽然关系型数据库可以很好的存储和处理数据，但是处理海量数据时效率会变得很低，尤其是遇到高并发读写时，性能会很快的下降。 非关系型数据库可以很好的应对海量数据，也就是说，它可以很好的读写每天产生的非结构化数据。由于非关系型数据库是以数据集的方式进行存储的，因此扩展和读写都是非常容易的。 事务性: 关系型数据库强调ACID规则，可满足对事务性要求较高或需要进行复杂数据查询的数据操作，也可充分满足数据库操作的高性能和稳定性要求。同时也强调数据的强一致性，对事务操作有很好的支持 非关系型数据库强调BASE原则，它可以减少了对数据的强一致性支持，不能很好地支持事务操作。 存储结构: 关系型数据库按照结构化的方法存储数据，在插入数据前需定义好存储数据的表结构，这使得整张数据表的可靠性和稳定性都比较高，但数据表存储数据后，若要修改数据表的结构就会十分困难。 非关系型数据库采用的是动态结构，如果面对大量非结构化数据的存储，它可以非常轻松的适应数据类型和结构的改变，也可以根据数据存储的需要灵活的改变数据库的结构。 存储规范: 关系型数据库为了规范化数据、避免重复数据以及充分利用存储空间，将数据按照最小关系表的形式进行存储，这使得数据管理变得很清晰、一目了然。不过随着表数量的增加，表之间的关系会导致数据的管理变 得越来越复杂。 非关系型数据库采用用平面数据集的方式集中存放数据，虽然会出现数据被重复存储造成浪费存储空间的情况。但是通常单个数据库都是采用单独存储的形式，很少采用分割存储的方式，因此数据往往被存储成一个整体对数据的读写提供了极大的方便。 拓展方式: 关系型数据库主要通过提高计算机自身性能缓解存储与读写压力，即所谓的纵向扩展。因为数据表之间存在着各种关系，所以采用横向扩展的方式会较为复杂，需要保证具有关联的数据表在同一服务器 非关系型数据库采用数据集存储数据，这使得数据之间无关联性，可以分布式存储，因此可以采用横向扩展方式来扩展数据库，也就是说，可以添加更多数据库服务器到资源池来缓解存储与读取压力。 NoSQL理论CAP原则CAP原则又称CAP定理，它包括一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三大要素。 **一致性:**系统在执行过某项操作后，仍然处于一致的状态。 **可用性:**系统的结果必须在给定的时间内返回，若超时，则被认为是不可用。 分区容错性:分区容错性可理解为系统对节点动态加入和离开的处理能力（集群一直处于可用状态），因为节点的加入和离开可认为是集群内部的网络分区。 CAP原则一个分布式系统最多可以同时实现两个要素，即AP或CP或AC。选择AC策略，意味着放弃P，也就是说，保证了系统的一致性和可用性，却违背了分布式系统的分区容错性；选择CP策略，意味着放弃A，也就是说，保证了系统的一致性和分区容错性，但用户的体验较差，即当系统宕机时，需要等待所有节点的数据一致时，用户才可访问系统；选择AP策略，意味着放弃C，也就是说，保证了系统的可用性和分区容错性，但是节点之间的数据会出现不一致的现象。因此，我们可以根据自己的需求，选择对应的策略 取舍策略 应用场景 CA（一致性和可用性） Oracle、SQLServer以及MySQL等 CP（一致性和分区容错性） MongoDB、HBase以及Redis等 AP（可用性和分区容错性） CouchDB、Cassandra以及DynamoDB等 BASE理论BASE理论是对CAP原则中一致性和可用性权衡的结果，也是对CAP原则的延伸。BASE理论的核心思想是即使无法保证系统的强一致性（Strong Consistency，即CAP的一致性就是强一致性），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。 BASE理论与CAP原则类似，它也包含三大要素即: 基本可用（Basically Available）:分布式系统在出现不可预知故障的时候，允许损失部分可用性，保证系统的核心可用即可。 软状态（Soft-State）: 允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。 最终一致性（Eventually Consistent）:系统中的所有数据副本经过一定时间后，最终能够达到一致的状态，不需要实时保证系统数据的强一致性。 BASE理论与关系型数据库中的ACID理论是两种截然相反的理论。 区别 BASE理论 ACID理论 一致性 弱一致性 强一致性 可用性 可用性优先 可用性不作要求 灵活性 变化速度快、灵活 难以变化 NoSQL数据库分类 分类 数据类型 常见数据库 应用场景示例 键值对存储数据库 Key指向Value 的键值对 Redis、 Tokyo Cabinet/Tyrant、Voldemort、 Oracle BDB 会话存储、 网站购物车等 文档存储数据库 BSON类型（全称Binary JSON，即二进制JSON），也称为类JSON MongoDB、 CouchDB、RavenDB 内容管理应用程序、电子商务应用程序等 列式存储数据库 以列进行存储，将同列数据存储到一起 HBase、Cassandra、Riak、HyperTable 日志记录、 博客网站等 图形存储数据库 图结构 Neo4j、FlockDB、AllegroGrap、GraphDB 欺诈检测、 推荐应用等 键值对数据库键值对存储数据库是NoSQL数据库中的一种类型，也是最简单的NoSQL数据库。键值对存储数据库中的数据是以键值对的形式来存储的。常见的键值对存储数据库有Redis、Tokyo Cabinet/Tyrant、Voldemort以及Oracle BDB等数据库。键值对存储数据库的结构示意图如下。 键值对存储数据库的结构实际上是一个映射，即Key是查找每条数据的唯一标识符，Value是该数据实际存储的内容。键值对存储数据库结构是采用哈希函数来实现键到值的映射，当查询数据时，基于Key的哈希值会直接定位到数据所在的位置，实现快速查询，并支持海量数据的高并发查询。 应用场景: 会话存储应用场景: 会话存储指的是一个面向会话的应用程序（如Web应用程序）在用户登录时启动会话，并保持活动状态直到用户注销或会话超时，在此期间，应用程序将所有与会话相关的数据存储在内存或键值对存储数据库中。会话数据包括用户资料信息、消息、个性化数据和主题、建议、有针对性的促销和折扣。每个用户会话具有唯一的标识符，除了主键之外，任何其他键都无法查询会话数据，因此键值对存储数据库更适合于存储会话数据。 购物车应用场景: 购物车指的是电子商务网站中的购物车功能。在假日购物季，电子商务网站可能会在几秒钟内收到数十亿的订单，键值对存储数据库可以处理海量数据的扩展和极高的状态变化，同时通过分布式处理和存储为数百万并发用户提供服务。此外，键值对存储数据库还具有内置冗余的功能，可以处理丢失的存储节点。 文档存储数据库文档存储数据库是用于存储和管理文档，其中文档是结构化的数据（如JSON格式）。文档存储数据库存储的文档可以是不同结构的，即JSON、XML以及BSON等格式。 常见的文档存储数据库有MongoDB、CouchDB以及RavenDB等数据库。文档存储数据库的结构示意图如下。 应用场景: 内容管理应用程序:内容管理应用程序存储数据，首选的就是文档存储数据库，例如博客和视频平台主要使用的数据库就是文档存储数据库。通过文档存储数据库，内容管理应用程序所跟踪的每个实体都可存储为单个文档。随着需求的发展，对于开发人员来说，可以使用文档存储数据库更直观地更新应用程序。此外，如果需要更改数据模型，则只需要更新受影响的文档即可，而不需要更新架构，也不需要等到数据库停机时进行更改。 电子商务应用程序:在电子商务应用程序中，文档存储数据库可以高效且有效的存储商品的信息。例如，在电子商务应用程序中，不同的产品具有不同数量的属性。若是在关系型数据库中管理数千个属性，则效率比较低，并且阅读的性能会受到影响；若是使用文档存储数据库的话，可以在单个文档中描述每个产品的属性，既可以方便管理，又可以加快阅读产品的速度，并且更改一个产品的属性不会影响其他的产品。 列式存储数据库列式存储数据库是以列为单位存储数据，然后将列值顺序地存入数据库中，这种数据存储方法不同于基于行式存储的传统关系型数据库。列式存储数据库可以高效地存储数据，也可以快速地处理批量数据实时查询数据。常见的列式存储数据库有HBase、Cassandra、Riak以及HyperTable等数据库。列式存储数据库的结构示意图如下。 在列式存储数据库中，如果列值不存在，则不需要存储（阴影部分为列值不存在），这样的话，遇到Null值，就不需要存储，可以减少I/O操作和避免内存空间的浪费。 应用场景: 事件应用记录:在事件记录中，使用列式存储数据库来存储应用程序的状态以及应用程序遇到错误等事件信息。由于列式存储数据库具有高扩展性，因此可高效地存储应用程序源源不断产生的事件记录。 博客网站应用:在博客网站中，列式存储数据库可以将博客的“标签”、“类别”、“连接”及“引用通告”等内容存放在不同的列中，便于进行数据分析。 图形存储数据库图形存储数据库不是网络数据库，它是NoSQL数据库的一种类型，其主要是应用图形理论来存储实体之间的关系信息，其中，实体被视为图形的“节点”，关系被视为图形的“边”，“边”按照关系将“节点”按进行连接。常见的图形存储数据库有Neo4j、FlockDB、AllegroGrap以及GraphDB等数据库。图形存储数据库的结构示意图如下。 ​ 利用图形存储数据库存储的数据，可以很清晰知道两个实体之间的关系，即A和D是朋友，C是A朋友的朋友。 应用场景:欺诈检测应用:在欺诈检测中，图形存储数据库能够有效地防范复杂的欺诈行为。在现代欺诈及各种类型的金融犯罪中，例如银行欺诈、信用卡欺诈、电子商务欺诈以及保险欺诈等，欺诈者通过使用改变自己身份等的手段逃避风控规则，从而达到欺诈目的。尽管欺诈者是可以改变所有涉及网络的关联关系，也可以在所有涉及网络的群体中同步执行相同操作来躲避风控，但我们可以通过图形存储数据库建立跟踪全局用户的跟踪视角，实时利用图形存储数据库来分析具有欺诈行为的离散数据，从而识别欺诈环节，这样的话，最大程度上快速有效地防范和解决欺诈行为。 推荐应用: 在推荐应用中，我们可以借助图形存储数据库存储购物网站中客户的购买记录、客户兴趣等信息，然后根据客户当前浏览的商品结合已存储的购物信息，从而推荐相关的商品。 MongoDB使用 MongoDB中文手册|官方文档中文版 - MongoDB-CN-Manual (mongoing.com) ==注意:本文档所写时使用版本为 4.4== MongoDB最大的特点是支持的查询语言非常强大，而且支持对数据建立索引，从而提高数据查询速度。 简介优势:高可用性: MongoDB副本所组成的一个集群，称为副本集，它提供了自动故障转移和数据冗余功能，以防止数据丢失，从而提高数据的可用性 易扩展性: MongoDB的设计采用横向扩展，可通过分片将数据分布在集群机器中。MongoDB能够自动处理跨集群的数据和负载，自动重新分配文档，并将用户的请求路由到正确的机器上。 多种存储引擎: MongoDB支持多个存储引擎包括WiredTiger存储引擎、内存存储引擎（n-Memory）和MMAPv1存储引擎。 体系结构MongoDB的逻辑结构是体系结构的一种形式，它是一种层次结构，主要由文档(Document)、集合(Collection)、数据库(DataBase)这三部分组成。MongoDB的逻辑结构是面向用户的。 MongoDB概念与关系型数据库（RDBMS）非常类似： 数据库（database）：最外层的概念，可以理解为逻辑上的名称空间，一个数据库包含多个不同名 称的集合。 集合（collection）：相当于SQL中的表，一个集合可以存放多个不同的文档。 文档（document）：一个文档相当于数据表中的一行，由多个不同的字段组成。 字段（field）：文档中的一个属性，等同于列（column）。 索引（index）：独立的检索式数据结构，与SQL概念一致。 id：每个文档中都拥有一个唯一的id字段，相当于SQL中的主键（primary key）。 视图（view）：可以看作一种虚拟的（非真实存在的）集合，与SQL中的视图类似。 从MongoDB 3.4版本开始提供了视图功能，其通过聚合管道技术实现。 聚合操作（$lookup）：MongoDB用于实现“类似”表连接（tablejoin）的聚合操作符。 尽管这些概念大多与SQL标准定义类似，但MongoDB与传统RDBMS仍然存在不少差异，包括： 半结构化，在一个集合中，文档所拥有的字段并不需要是相同的，而且也不需要对所用的字段进行声明。因此，MongoDB具有很明显的半结构化特点。除了松散的表结构，文档还可以支持多级的 嵌套、数组等灵活的数据类型，非常契合面向对象的编程模型。 弱关系，MongoDB没有外键的约束，也没有非常强大的表连接能力。类似的功能需要使用聚合管道技术来弥补。 MongoDB默认提供admin、local、config以及test数据库四个数据库，具体介绍如下： admin数据库，主要存储数据库账号的相关信息。 local数据库，可以用于存储限于本地单台服务器的任意集合，如oplog日志就存储在local数据库中，该数据库的数据不会被复制到从节点上。 config数据库，用于存储分片集群中与分片相关的元数据信息。 test数据库，是MongoDB默认创建的一个测试库，当连接mongod服务时，如果不指定连接的具体数据库，默认就会连接到test数据库。 文档是以键值对的形式存储在集合中，其中，键用于唯一标识一个文档，为字符串类型，而值则可以是各种复杂的文件类型，我们称这种存储形式为BSON（BSON是类JSON的一种二进制形式的存储格式，简称BinaryJSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型）。 文档中不能有重复的键，每个文档都有一个默认的_id键，它相当于关系型数据库中的主键，这个键的值在同一个集合中必须是唯一的，_id键值默认是ObjectId类型，在插入文档的时候，如果用户不设置文档的_id值，MongoDB会自动生成一个唯一的ObjectId值进行填充。 数据类型:文档的键是字符串类型，而值除字符串类型外，还可以为内嵌文档、数组、Date等类型，文档内容具体如下 数据类型 相关说明 Double 双精度浮点型，用于存储浮点值 String 字符串，是常用的数据类型，MongoDB仅支持UTF-8 编码的字符串 Object 对象类型，存储嵌入式文档 Array 数组类型，用于将数组或列表或多个值存储为一个键 Binary data 二进制数据：用于存储二进制数据 Undefined 已弃用 ObjectId 对象ID类型，用于存储文档的ID Boolean 布尔类型，用于存储布尔（true/false）值 Date 日期类型，以UNIX时间格式存储标准时间的毫秒数，不存储时区 Null 空值类型，用于创建空值 Regular Expression 正则表达式类型，用于存储正则表达式 数据类型 相关说明 Symbol 已弃用 Int32 整型，用于存储32位整型数值 Timestamp 时间戳类型，用于记录文档修改或添加的具体时间 Int64 整型，存储64位整型数值 Decimal128 Decimal类型，用于记录、处理货币数据，例如：财经数据、税率数据等 Min key 将一个值与 BSON元素的最低值相对比 Max key 将一个值与 BSON元素的最高值相对比 DBPointer 已弃用 Code 代码类型，用于将JavaScript代码存储到文档中 使用规范 安装配置和启动Mongodb for windows安装启动:直接下载无脑安装(推荐压缩包解压安装) 默认安装启动:MongoDB 手册 -windos下安装 配置文件启动, 在默认安装启动的基础上: 在解压目录\\bin目录中，新建mongod.cfg ，内如参考如下： 官方配置文件文档: Configuration File Options — MongoDB Manual 123storage:#The directory where the mongod instance stores its data.Default Value is &quot;\\data\\db&quot; on Windows. dbPath: D:\\Environment\\Mongodb\\data 对于大多数独立服务器，这是一个足够的基础配置。它做了几个假设，但请考虑 以下解释： fork是 ，它启用true守护进程模式mongod，分离（即“叉子”） 来自当前会话的 MongoDB，并允许您运行数据库作为常规服务器。 bindIp是 ，它强制 服务器，以仅侦听本地主机 IP 上的请求。仅绑定到 应用程序级系统可以访问的安全接口 系统网络过滤提供的访问控制 （即”localhost防火墙“). port是 ，这是默认值 用于数据库实例的 MongoDB 端口。MongoDB可以绑定到任何 港口。您还可以使用网络根据端口过滤访问 过滤工具。27017 windos基础配置参考: 注 :Linux与windos文件*路径表示方式不一样,采用反斜杠这种形式 :/etc/mongod.conf* 12345678910111213141516171819202122232425262728293031323334353637383940414243# mongod.conf# for documentation of all options, see:# http://docs.mongodb.org/manual/reference/configuration-options/# Where and how to store data.storage: dbPath: D:\\Environment\\Mongodb\\data journal: enabled: true# engine:# mmapv1:# wiredTiger:# where to write logging data.systemLog: destination: file logAppend: true path: D:\\Environment\\Mongodb\\log\\mongod.log# network interfacesnet: port: 27017 # 默认绑定本地ip即只有本机能访问,一般设置成0.0.0.0所有主机都可访问 bindIp: 127.0.0.1#设置进程为后台启动processManagement: fork: true#security:#operationProfiling:#replication:#sharding:## Enterprise-Only Options:#auditLog:#snmp: 【注意】 配置文件中如果使用双引号，比如路径地址，自动会将双引号的内容转义。如果不转义，则会报错： 1error-parsing-yaml-config-file-yaml-cpp-error-at-line-3-column-15-unknown-escape-character-d 解决：a. 对 \\ 换成 / 或 b. 如果路径中没有空格，则无需加引号。 配置文件是以yaml格式写的,所以在具体配置前不要添加tab键,否则会报如下错误Unrecognized option: storage 配置文件中不能以Tab分割字段 服务启动方式：mongod --config mongod.cfg Mangodb for CentOS 7安装启动123456789# 下载安装包wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.4.9.tgz# 解压tar -zxvf mongodb-linux-x86_64-rhel70-4.4.9.tgz#创建dbpath和logpathmkdir -p /mongodb/data /mongodb/log /mongodb/conf#进入mongodb解压目录的bin目录下,启动mongodb服务mongod --port=27017 --dbpath=/mongodb/data --logpath=/mongodb/log/mongodb.log--bind_ip=0.0.0.0 --fork 命令参数: --dbpath :指定数据文件存放目录--logpath :指定日志文件，注意是指定文件不是目录--logappend :使用追加的方式记录日志--port:指定端口，默认为27017--bind_ip:默认只监听localhost网卡--fork: 后台启动--auth: 开启认证模式 添加环境变量: 修改/etc/profile，添加环境变量,方便执行MongoDB命令 1vim /etc/profile 添加内容: 12export MONGODB_HOME=/usr/local/soft/mongodbPATH=$PATH:$MONGODB_HOME/bin 然后执行source /etc/profile 重新加载环境变量 配置文件启动新建编辑/etc/mongod.conf文件，内容如下： 1234567891011121314systemLog: destination: file path: /mongodb/log/mongod.log # log path logAppend: truestorage: dbPath: /mongodb/data # data directory engine: wiredTiger #存储引擎 journal: #是否启用journal日志 enabled: truenet: bindIp: 0.0.0.0 port: 27017 # portprocessManagement: fork: true 配置文件格式为 yaml格式 以配置文件启动: 12mongod --config /etc/mongod.confmongod -f /etc/mongod.conf 关闭服务: 方式一: 1mongod --port=27017 --dbpath=/mongodb/data --shutdown 方式二: 进入mongodb shell: 12use admindb.shutdownServer() 配置文件 官方文档: Run-time Database Configuration — MongoDB Manual 注: Windows的配置文件与Linux的配置部分配置项目有所不同,具体参考文档 连接与交互:shell方式: windos : ​ 在安装目录\\bin\\目录启动mongo.exe或者cmd 直接输入mongo(注: 这样需要配置环境变量) Linux: 注意: 如果没配置环境变量请在``安装目录\\bin`目录中使用命令 1mongo --port=27017 命令参数: --port:指定端口，默认为27017--host:连接的主机地址，默认127.0.0.1 javaScript支持:mongo shell是基于JavaScript语法的，MongoDB使用了SpiderMonkey作为其内部的JavaScript解释器引擎，这是由Mozilla官方提供的JavaScript内核解释器，该解释器也被同样用于大名鼎鼎的Firefox浏览器产品之中。SpiderMonkey对ECMA Script标准兼容性非常好，可以支持ECMA Script 6。 ​ 使用Nvicat连接像MySQL一样连接即可 安全认证:mongodb默认是没有不需要登陆的,我们可以设置安全认证方式: 创建管理员账号: 12345678# 设置管理员用户名密码需要切换到admin库use admin #创建管理员db.createUser(&#123;user:&quot;xxx&quot;,pwd:&quot;123456&quot;,roles:[&quot;root&quot;]&#125;)# 查看所有用户信息show users#删除用户db.dropUser(&quot;xxx&quot;) 默认情况下，MongoDB不会启用鉴权 : 1234# 以鉴权模式启动MongoDBmongod -f /mongodb/conf/mongo.conf --auth# 连接时需要提供用户密码mongo 192.168.65.174:27017 -u 用户名 -p 密码 --authenticationDatabase=admin 常用权限: 权限名 描述 root 只在admin数据库中可用。超级账号，超级权限 readWrite 允许用户读写指定数据库 dbAdmin 允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile dbOwner 允许用户在指定数据库中执行任意操作，增、删、改、查等 userAdmin 允许用户向system.users集合写入，可以在指定数据库里创建、删除和管理用户 clusterAdmin 只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限 readAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的读写权限 userAdminAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的userAdmin权限 dbAdminAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限 基本命令操作 参考教程: 哔哩哔哩_bilibili 命令 说明 show dbs或show databases 显示数据库列表 use 数据库名 切换数据库，如果不存在创建数据库 load(“xxx.js”) 执行一个JavaScript脚本文件 db.dropDatabase() 删除数据库 show collections,show tables 显示当前数据库的集合列表 db.集合名.stats() 查看集合详情 db.集合名.drop() 删除集合 show users 显示当前数据库的用户列表 show roles 显示当前数据库的角色列表 show profile 显示最近发生的操作 exit, quit() 退出当前shell help 查看mongodb支持哪些命令 db.help() 查询当前数据库支持的方法 db.集合名.help() 显示集合的帮助信息 db.version() 查看数据库版本 数据库操作12345678# 切换数据库,不存在则会创建数据库(插入数据后才会真正创建)use 数据库名称# 查看所有的数据库show databases 或 show dbs# 查看正在使用的数据库db# 删除当前数据库 db.dropDatabase() MongoDB 中默认的数据库为 test，如果你没有选择数据库，集合将存放在 test 数据库中,一般。 数据库名可以是满足以下条件的任意UTF-8字符串。 不能是空字符串（“”)。 不得含有’ ‘**（空格)、.、$**、/、\\和\\0 (空字符)。 应全部小写。 最多64字节。 有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。 admin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器. local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 集合(表)操作由于mongodb的集合很类似关系型数据库表,故以下所说的表是指 集合的意思 1234567#查看所有集合show collectionsshow tables#删除集合db.集合名.drop()#简单创建集合db.createCollection(&quot;集合名&quot;) 注意: 当集合不存在时，向集合中插入文档也会创建集合 创建集合还可以添加配置项options: db.createCollection(name, options) options参数解释: 字段 类型 描述 capped 布尔 （可选）如果为true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 size 数值 （可选）为固定集合指定一个最大值（以字节计）。如果 capped 为 true，也需要指定该字段。 max 数值 （可选）指定固定集合中包含文档的最大数量。 文档操作CURD:注意: mongodb shell 是支持 javaScript 的, 下面不再赘述 ==此外: 文档对象操作支持嵌套操作,如 对象.属性,但这样必须加双引号, 即: “对象”.属性== 插入文档:3.2 版本之后新增了 db.collection.insertOne() 和 db.collection.insertMany()。 注意: 添加文档操作要切换到对应的数据库下操作 insertOne(): 只插入一个文档 1234567891011121314151617181920212223242526db.集合名.insertOne( json对象, options:&#123; writeConcern: 值 &#125;)// 例如: 创建一个学生 集合并插入一个数据db.students.insertOne(&#123; stu_id:&quot;001&quot;, name:&quot;张三&quot;, age: 18 &#125;// insertOne函数插入成功提示:&#123; &quot;acknowledged&quot; : true, &quot;insertedId&quot; : ObjectId(&quot;63a2d990e809659ecfa63084&quot;)&#125; // 使用 insert()函数:db.students.insert(&#123; stu_id:&quot;001&quot;, name:&quot;张三&quot;, age: 18 &#125; // 使用 insert()函数插入成功提示: WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 其中 options 配置项目是可选的,属性值: writeConcern: 决定一个写操作落到多少个节点上才算成功。writeConcern 的取值包括： 0：发起写操作，不关心是否成功 majority：写操作需要被复制到大多数节点上才算成功 1~ n (n 为集群最大数据节点数)：写操作需要被复制到指定节点数才算成功； 下文同样如此 还可以使用save()来插入数据,如果 _id 主键存在则更新数据，如果不存在就插入数据。 批量插入: 实际上insert() , save()方法也能插入多个文档(json数组) 123456789db.collection.insertMany( // json数组 [ json对象1 , json对象2, ... ], //options 配置对象 &#123; writeConcern: 数字, ordered: 布尔值 &#125;) ordered：指定是否按顺序写入，默认 true，按顺序写入。 writeConcern：和上面插入单个文档一样,写入策略，默认为 1，即要求确认写操作，0 是不要求。 此外还可以通过加载js脚本实现批量插入 book.js内容 123456789101112131415161718var tags = [&quot;nosql&quot;,&quot;mongodb&quot;,&quot;document&quot;,&quot;developer&quot;,&quot;popular&quot;];var types = [&quot;technology&quot;,&quot;sociality&quot;,&quot;travel&quot;,&quot;novel&quot;,&quot;literature&quot;];var books=[];for(var i=0;i&lt;50;i++)&#123; var typeIdx = Math.floor(Math.random()*types.length); var tagIdx = Math.floor(Math.random()*tags.length); var favCount = Math.floor(Math.random()*100); var book = &#123; title: &quot;book-&quot;+i, type: types[typeIdx], tag: tags[tagIdx], favCount: favCount, author: &quot;xxx&quot;+i &#125;; books.push(book)&#125;db.books.insertMany(books); 随后执行在mongo shell 中执行 注意: 如果使用默认的数据库test ,无法执行脚本 12load(&quot;books.js&quot;) // 使用的是相对路径,执行成功后返回 true// 如果不知道命令行在当前哪个路径,可使用 pwd()查看 查询文档集合对象的find()方法可以查询集合中的若干文档。语法格式如下: 1db.集合名.find(query, projection) query ：可选,只为json对象，使用查询操作符指定查询条件,省略则查询所有文档 projection ：可选，使用投影操作符指定返回的键。省略该参数会返回所有键（默认省略）。**投影时，可通过设置指定的键值为1或者0来决定是否返回 , **如 : &#123;key1:1,key5:1&#125;,不过需要注意一下几点: id会默认自动返回,并且id为1的时候，只能设置选择哪些其他字段为1 id是0的时候，其他字段可以是0；如果没有_id字段约束，多个其他字段必须同为0或同为1。 如果查询返回的条目数量较多，mongo shell则会自动实现分批显示。默认情况下每次只显示20条，可以输入it命令读取下一批。 findOne()方法查询集合中的第一个文档。语法格式如下： 1db.集合名.findOne(query, projection) 条件查询实例: 123456#查询带有nosql标签的book文档：db.books.find(&#123;tag:&quot;nosql&quot;&#125;)#按照id查询单个book文档：db.books.find(&#123;_id:ObjectId(&quot;61caa09ee0782536660494d9&quot;)&#125;)#查询分类为“travel”、收藏数&gt;60个的book文档：db.books.find(&#123;type:&quot;travel&quot;,favCount:&#123;$gt:60&#125;&#125;) 投影查询实例： 注意: 投影时object_id是默认返回的, 123456789101112# 查询所有的文档,但是只返回 title , author 这个两个键db.books.find(&#123;&#125;,&#123;title:1,author:1&#125;)# 查询 favCount 大于60的书籍,并且不返回他们的_id ,类型和作者db.books.find(&#123; favCount: &#123; $gt: 60 &#125;&#125;, &#123; _id: 0, type: 0, author: 0&#125;) 查询条件对照表: SQL MQL a = 1 {a: 1} a &lt;&gt; 1 即 a != 1 {a: {$ne: 1}} a &gt; 1 {a: {$gt: 1}} a &gt;= 1 {a: {$gte: 1}} a &lt; 1 {a: {$lt: 1}} a &lt;= 1 {a: {$lte: 1}} 查询逻辑对照表: SQL MQL a = 1 AND b = 1 {a: 1, b: 1}或{$and: [{a: 1}, {b: 1}]} a = 1 OR b = 1 {$or: [{a: 1}, {b: 1}]} a IS NULL {a: {$exists: false}} a IN (1, 2, 3) {a: {$in: [1, 2, 3]}} 查询逻辑运算符: $lt: 存在并小于 $lte: 存在并小于等于 $gt: 存在并大于 $gte: 存在并大于等于 $ne: 不存在或存在但不等于 $in: 存在并在指定数组中 $nin: 不存在或不在指定数组中 $or: 匹配两个或多个条件中的一个 $and: 匹配全部条件 排序,分页在 MongoDB 中使用 集合的sort() 方法对数据进行排序 12#指定按收藏数（favCount）降序返回,参数 -1 代表降序,默认为1,升序db.books.find(&#123;type:&quot;travel&quot;&#125;).sort(&#123;favCount:-1&#125;) 分页查询:结果集方法: skip()用于指定跳过记录数，limit()则用于限定返回结果数量。参数，以此实现分页的功能。比如，假定每页大小为4条，查询第3页的book文档： 1db.books.find().skip(8).limit(4) 正则表达式查询MongoDB 使用$regex操作符来设置匹配字符串的正则表达式。 1234#使用正则表达式查找type包含 so 字符串的bookdb.books.find(&#123;type:&#123;$regex:&quot;so&quot;&#125;&#125;)# 或者db.books.find(&#123;type:/so/&#125;) 更新文档可以用update命令对指定的数据进行更新，命令的格式如下： 1db.collection.update(query,update,options) query,update,options的值都是json对象, 和查询操作的条件类似 query：描述更新的查询条件； update：描述更新的操作及新的内容； options：描述更新的选项 upsert: 可选，如果不存在update的记录，是否插入新的记录。默认false，不插入 multi: 可选，是否按条件查询出的多条记录全部更新。 默认false,只更新找到的第一条记录 writeConcern :可选，决定一个写操作落多少个节点上才算成功。 更新操作符: 操作符 格式 描述 $set {$set:{field:value}} 指定一个键并更新值，若键不存在则创建 $unset {$unset : {field : 1 }} 删除一个键 $inc {$inc : {field : value } } 对数值类型进行增减 $rename {$rename : {old_field_name :new_field_name } } 修改字段名称 $push { $push : {field : value } } 将数值追加到数组中,若数组不存在则会进行初始化 $pushAll {$pushAll : {field : value_array }} 追加多个值到一个数组字段内 $pull {$pull : {field : _value } } 从数组中删除指定的元素 $addToSet {$addToSet : {field : value } } 添加元素到数组中，具有排重功能 $pop {$pop : {field : 1 }} 删除数组的第一个或最后一个元素 如:某个book文档被收藏了，则需要将该文档的favCount字段自增 1db.books.update(&#123;_id:ObjectId(&quot;61caa09ee0782536660494d9&quot;)&#125;,&#123;$inc:&#123;favCount:1&#125;&#125;) 例:修改标题为: my book 的书籍的字段信息,不存在则插入此字段 12345db.books.update( &#123;title:&quot;my book&quot;&#125;, &#123;$set:&#123;tags:[&quot;nosql&quot;,&quot;mongodb&quot;],type:&quot;none&quot;,author:&quot;fox&quot;&#125;&#125;, &#123;upsert:true&#125;) 更新多个文档:默认情况下，update方法只在更新第一个文档之后返回，如果需要更新多个文档，则可以使用multi选项。 12# 将分类为“novel”的文档的增加发布时间（publishedDate）db.books.update(&#123;type:&quot;novel&quot;&#125;,&#123;$set:&#123;publishedDate:new Date()&#125;&#125;,&#123;&quot;multi&quot;:true&#125;) update衍生方法:update命令的选项配置较多，为了简化使用还可以使用一些快捷命令: updateOne()：更新单个文档。 updateMany()：更新多个文档。 replaceOne()：替换单个文档。 实现replace语义update命令中的更新描述（update）通常由操作符描述，如果更新描述中不包含任何操作符，那么MongoDB会实现文档的replace语义!!!! ==直接替换而不是修改== 12345# 注意: 这样做不是修改标题,而是直接替换掉该文档db.books.update( &#123;title:&quot;my book&quot;&#125;, &#123;justTitle:&quot;my first book&quot;&#125;) findAndModify()findAndModify兼容了查询和修改指定文档的功能，findAndModify只能更新单个文档 123456789101112# 将某个book文档的收藏数（favCount）加1db.books.findAndModify(&#123; query:&#123;_id:ObjectId(&quot;61caa09ee0782536660494dd&quot;)&#125;, update:&#123;$inc:&#123;favCount:1&#125;&#125;&#125;)# 返回新修改的数据db.books.findAndModify(&#123; query:&#123;_id:ObjectId(&quot;61caa09ee0782536660494dd&quot;)&#125;, update:&#123;$inc:&#123;favCount:1&#125;&#125;, new: true&#125;) 该操作会返回符合查询条件的文档数据，并完成对文档的修改。 默认情况下，findAndModify会返回修改前的“旧”数据。如果希望返回修改后的数据，则可以指定new选项 与findAndModify语义相近的命令如下： findOneAndUpdate()：更新单个文档并返回更新前（或更新后）的文档。 findOneAndReplace()：替换单个文档并返回替换前（或替换后）的文档。 删除文档:删除文档可以使用remove()和delete() 注意： remove、deleteMany等命令需要对查询范围内的文档逐个删除，如果希望删除整个集合，则使用drop命令会更加高效 官方推荐使用 deleteOne() 和 deleteMany() 方法删除文档 实例: 123db.books.deleteMany (&#123;&#125;) //删除集合下全部文档db.books.deleteMany (&#123; type:&quot;novel&quot; &#125;) //删除 type等于 novel 的全部文档db.books.deleteOne (&#123; type:&quot;novel&quot; &#125;) //删除 type等于novel 的一个文档 findOneAndDelete()remove、deleteOne等命令在删除文档后只会返回确认性的信息，如果希望获得被删除的文档，则可以使用findOneAndDelete() 12# 删除匹配到的第一条文档,并且返回其信息db.books.findOneAndDelete(&#123;type:&quot;novel&quot;&#125;) findOneAndDelete命令还允许定义“删除的顺序”，即按照指定顺序删除找到的第一个文档 12# 按favCount升序方法查找类型为 novel的第一文档,并且删除db.books.findOneAndDelete(&#123;type:&quot;novel&quot;&#125;,&#123;sort:&#123;favCount:1&#125;&#125;) 聚合操作聚合操作处理数据记录并返回计算结果(诸如统计平均值，求和等)。聚合操作组值来自多个文档，可以对分组数据执行各种操作以返回单个结果。聚合操作包含三类：单一作用聚合、聚合管道、MapReduce。 单一作用聚合：提供了对常见聚合过程的简单访问，操作都从单个集合聚合文档。 聚合管道是一个数据聚合的框架，模型基于数据处理流水线的概念。文档进入多级管道，将文档转 换为聚合结果。 MapReduce操作具有两个阶段：处理每个文档并向每个输入文档发射一个或多个对象的map阶 段，以及reduce组合map操作的输出阶段。 单一聚合MongoDB提供 db.collection.estimatedDocumentCount(), db.collection.count(),db.collection.distinct() 这类单一作用的聚合函数。 所有这些操作都聚合来自单个集合的文档。虽然这些操作提供了对公共聚合过程的简单访问，但它们缺乏聚合管道和map-Reduce的灵活性和功能。 方法 描述 db.collection.estimatedDocumentCount() 忽略查询条件，返回集合或视图中所有文档的计数 db.collection.count(query) 返回与find()集合或视图的查询匹配的文档计数.等同于db.collection.find(query).count() db.collection.distinct() 去重,在单个集合或视图中查找指定字段的不同值，并在数组中返回结果。 12345678#检索books集合中所有文档的计数 db.books.estimatedDocumentCount()#计算与查询匹配的所有文档db.books.count(&#123;favCount:&#123;$gt:50&#125;&#125;)#返回不同type的数组db.books.distinct(&quot;type&quot;)#返回收藏数大于90的文档不同type的数组db.books.distinct(&quot;type&quot;,&#123;favCount:&#123;$gt:90&#125;&#125; 聚合管道什么是 MongoDB 聚合框架MongoDB 聚合框架（Aggregation Framework）是一个计算框架，它可以：作用在一个或几个集合上；对集合中的数据进行的一系列运算；将这些数据转化为期望的形式；从效果而言，聚合框架相当于 SQL 查询中的GROUP BY、 LEFT OUTER JOIN 、 AS等。 通过aggregate()方法和管道操作符可进行相关的管道聚合操作 管道（Pipeline）和阶段（Stage）整个聚合运算过程称为管道（Pipeline），它是由多个阶段（Stage）组成的， 每个管道： 接受一系列文档（原始数据）；每个阶段对这些文档进行一系列运算；结果文档输出给下一个阶段； 聚合管道操作语法: 12pipeline = [$stage1, $stage2, ...$stageN];db.collection.aggregate(pipeline, &#123;options&#125;) pipelines 一组数据聚合阶段。除$out、$Merge和$geonear阶段之外，每个阶段都可以在管道中出现多次。options 可选，聚合操作的其他参数。包含：查询计划、是否使用临时文件、 游标、最大操作时间、读写策略、强制索引等等 常用的管道聚合阶段: 官方文档: Aggregation Pipeline Stages — MongoDB Manual 如: 阶段 描述 SQL等价运算符 $match 筛选条件 WHERE $project 投影 AS AS $lookup 左外连接 LEFT OUTER JOIN $sort 排序 ORDER BY $group 分组 GROUP BY $skip/$limit 分页 $unwind 展开数组 $graphLookup 图搜索 $facet/$bucket 分面搜索 例子: 案例数据准备: 通过load()执行脚本添加数据 1234567891011121314151617181920var tags = [&quot;nosql&quot;,&quot;mongodb&quot;,&quot;document&quot;,&quot;developer&quot;,&quot;popular&quot;];var types = [&quot;technology&quot;,&quot;sociality&quot;,&quot;travel&quot;,&quot;novel&quot;,&quot;literature&quot;];var books=[];for(var i=0;i&lt;50;i++)&#123; var typeIdx = Math.floor(Math.random()*types.length); var tagIdx = Math.floor(Math.random()*tags.length); var tagIdx2 = Math.floor(Math.random()*tags.length); var favCount = Math.floor(Math.random()*100); var username = &quot;xx00&quot;+Math.floor(Math.random()*10); var age = 20 + Math.floor(Math.random()*15); var book = &#123; title: &quot;book-&quot;+i, type: types[typeIdx], tag: [tags[tagIdx],tags[tagIdx2]], favCount: favCount, author: &#123;name:username,age:age&#125; &#125;; books.push(book)&#125;db.books.insertMany(books); 具体操作如下: $project相当于sql中的 as 1234567891011121314#投影操作， 将原始字段投影成指定名称， 如将集合中的 title 投影成 namedb.books.aggregate([&#123;$project:&#123;name:&quot;$title&quot;&#125;&#125;])#$project 可以灵活控制输出文档的格式，也可以剔除不需要的字段db.books.aggregate([&#123;$project:&#123;name:&quot;$title&quot;,_id:0,type:1,author:1&#125;&#125;])#从嵌套文档中排除字段db.books.aggregate([ &#123;$project:&#123;name:&quot;$title&quot;,_id:0,type:1,&quot;author.name&quot;:1&#125;&#125;])#或者db.books.aggregate([ &#123;$project:&#123;name:&quot;$title&quot;,_id:0,type:1,author:&#123;name:1&#125;&#125;&#125;]) $match相当于sql中的 where $match用于对文档进行筛选，之后可以在得到的文档子集上做聚合，$match可以使用除了地理空间之外的所有常规查询操作符，在实际应用中尽可能将$match放在管道的前面位置。这样有两个好处：一是可以快速将不需要的文档过滤掉，以减少管道的工作量；二是如果再投射和分组之前执行$match，查询可以使用索引。 1db.books.aggregate([&#123;$match:&#123;type:&quot;technology&quot;&#125;&#125;]) $count相当于sql中的 count()计数并返回与查询匹配的结果数 123# 返回书籍中 类型为 techology 的书籍总数db.books.aggregate([&#123;$match:&#123;type: &quot;technology&quot;&#125;&#125;,&#123;$count: &quot;type_count&quot;&#125;]) $group相当于 sql 中的 group by 按指定的表达式对文档进行分组，并将每个不同分组的文档输出到下一个阶段。输出文档包含一个_id字段，该字段按键包含不同的组。输出文档还可以包含计算字段，该字段保存由$group的_id字段分组的一些accumulator表达式的值。$group不会输出具体的文档而只是统计信息。 123&#123; $group: &#123; _id: &lt;expression&gt;, &lt;field1&gt;: &#123; &lt;accumulator1&gt; : &lt;expression1&gt; &#125;, ...&#125; &#125; _id字段是必填的,代表分组的依据;但是，可以指定id值为null来为整个输入文档计算累计值。 剩余的计算字段是可选的，并使用运算符进行计算。 _id和表达式可以接受任何有效的表达式。 accumulator操作符: 名称 描述 类比sql $avg 计算均值 avg() $first 返回每组第一个文档，如果有排序，按照排序，如果没有按照默认的存储的顺序的第一个文档。 limit 0,1 $last 返回每组最后一个文档，如果有排序，按照排序，如果没有按照默认的存储的顺序的最后个文档。 - $max 根据分组，获取集合中所有文档对应值得最大值。 max $min 根据分组，获取集合中所有文档对应值得最小值。 min $push 将指定的表达式的值添加到一个数组中。 - $addToSet 将表达式的值添加到一个集合中（无重复值，无序）。 - $sum 计算总和 sum - $stdDevPop 返回输入值的总体标准偏差（population standard deviation） - $stdDevSamp 返回输入值的样本标准偏差（the sample standard deviation） - $group阶段的内存限制为100M。默认情况下，如果stage超过此限制，$group将产生错误。但是，要允许处理大型数据集，请将allowDiskUse选项设置为true以启用$group操作以写入临时文件。 book的数量，收藏总数和平均值 1234567891011121314151617db.books.aggregate([ &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125;, pop: &#123; $sum: &quot;$favCount&quot; &#125;, avg: &#123; $avg: &quot;$favCount&quot; &#125; &#125; &#125;]) 统计每个作者的book收藏总数: 12345678910db.books.aggregate([ &#123; $group: &#123; _id: &quot;$author.name&quot;, pop: &#123; $sum: &quot;$favCount&quot; &#125; &#125; &#125;]) 统计每个作者的每本book的收藏数 123456789101112131415161718192021db.books.aggregate([ &#123; $group: &#123; _id: &#123; name: &quot;$author.name&quot;, title: &quot;$title&quot; &#125;, pop: &#123; $sum: &quot;$favCount&quot; &#125; &#125; &#125;,// 投影 &#123; $project: &#123; title: &quot;$_id.title&quot;, author: &quot;$_id.name&quot;, favCount: &quot;$pop&quot; &#125; &#125;]) 每个作者的book的type合集: 12345678910db.books.aggregate([ &#123; $group: &#123; _id: &quot;$author.name&quot;, types: &#123; $addToSet: &quot;$type&quot; &#125; &#125; &#125;]) $unwind可以将数组拆分为单独的文档,v3.2+支持如下语法： 12345678910&#123;$unwind: &#123; // 要指定字段路径，在字段名称前加上$符并用引号括起来。 path: &lt;field path&gt;, // 可选,一个新字段的名称用于存放元素的数组索引。该名称不能以$开头。 includeArrayIndex: &lt;string&gt;, // 可选，default :false，若为true,如果路径为空，缺少或为空数组，则$unwind输出文档 preserveNullAndEmptyArrays: &lt;boolean&gt;&#125; &#125; 姓名为xx006的作者的book的tag数组拆分为多个文档: 1234db.books.aggregate([ &#123;$match:&#123;&quot;author.name&quot;:&quot;xx006&quot;&#125;&#125;, &#123;$unwind:&quot;$tag&quot;&#125;]) 每个作者的book的tag合集 12345678910db.books.aggregate([ &#123; $match: &#123; &quot;author.name&quot;: &quot;xx006&quot; &#125; &#125;, &#123; $unwind: &quot;$tag&quot; &#125;]) 每个作者的book的tag合集: 12345678910111213db.books.aggregate([ &#123; $unwind: &quot;$tag&quot; &#125;, &#123; $group: &#123; _id: &quot;$author.name&quot;, types: &#123; $addToSet: &quot;$tag&quot; &#125; &#125; &#125;]) $sort对所有输入文档进行排序，并按排序顺序将它们返回到管道。 1// 语法:&#123; $sort: &#123; &lt;field1&gt;: &lt;sort order&gt;, &lt;field2&gt;: &lt;sort order&gt; ... &#125; &#125; 要对字段进行排序，请将排序顺序设置为1或-1，以分别指定升序或降序排序，如下例所示： 123db.books.aggregate([ &#123;$sort : &#123;favCount:-1,title:1&#125;&#125;]) $limit限制传递到管道中下一阶段的文档数: 123db.books.aggregate([ &#123;$limit : 5 &#125;]) 注意：当$sort在管道中的$limit之前立即出现时，**$sort操作只会在过程中维持前n个结果**，其中n是指定的限制，而MongoDB只需要将n个项存储在内存中。 $skip跳过进入stage的指定数量的文档，并将其余文档传递到管道中的下一个阶段 $lookupMongodb 3.2版本新增，主要用来实现多表关联查询， 相当关系型数据库中多表关联查询。每个输入待处理的文档，经过$lookup 阶段的处理，输出的新文档中会包含一个新生成的数组（可根据需要命名新key ）。数组列存放的数据是来自被Join集合的适配文档，如果没有，集合为空（即 为[ ]) 语法: 12345678db.collection.aggregate([&#123; $lookup: &#123; from: &quot;&lt;collection to join&gt;&quot;, localField: &quot;&lt;field from the input documents&gt;&quot;, foreignField: &quot;&lt;field from the documents of the from collection&gt;&quot;, as: &quot;&lt;output array field&gt;&quot; &#125;&#125;) 参数详解: from 同一个数据库下等待被Join的集合。 localField :源集合中的match值，如果输入的集合中，某文档没有 localField这个Key（Field），在处理的过程中，会默认为此文档含有 localField：null的键值对。 foreignField : 待Join的集合的match值，如果待Join的集合中，文档没有foreignField值，在处理的过程中，会默认为此文档含有 foreignField：null的键值对。 as 为输出文档的新增值命名。如果输入的集合中已存在该值，则会覆盖掉 注意：null = null 此为真其语法功能类似于下面的伪SQL语句： 12345SELECT *, &lt;output array field&gt;FROM collectionWHERE &lt;output array field&gt; IN (SELECT * FROM &lt;collection to join&gt; WHERE &lt;foreignField&gt;= &lt;collection.localField&gt;); 案例: 数据准备: 123456789101112db.customer.insert(&#123;customerCode:1,name:&quot;customer1&quot;,phone:&quot;13112345678&quot;,address:&quot;test1&quot;&#125;)db.customer.insert(&#123;customerCode:2,name:&quot;customer2&quot;,phone:&quot;13112345679&quot;,address:&quot;test2&quot;&#125;)db.order.insert(&#123;orderId:1,orderCode:&quot;order001&quot;,customerCode:1,price:200&#125;)db.order.insert(&#123;orderId:2,orderCode:&quot;order002&quot;,customerCode:2,price:400&#125;)db.orderItem.insert(&#123;itemId:1,productName:&quot;apples&quot;,qutity:2,orderId:1&#125;)db.orderItem.insert(&#123;itemId:2,productName:&quot;oranges&quot;,qutity:2,orderId:1&#125;)db.orderItem.insert(&#123;itemId:3,productName:&quot;mangoes&quot;,qutity:2,orderId:1&#125;)db.orderItem.insert(&#123;itemId:4,productName:&quot;apples&quot;,qutity:2,orderId:2&#125;)db.orderItem.insert(&#123;itemId:5,productName:&quot;oranges&quot;,qutity:2,orderId:2&#125;)db.orderItem.insert(&#123;itemId:6,productName:&quot;mangoes&quot;,qutity:2,orderId:2&#125;) 关联查询: 顾客表和订单表关联 1234567891011db.customer.aggregate([ &#123; $lookup: &#123; from: &quot;order&quot;, localField: &quot;customerCode&quot;, foreignField: &quot;customerCode&quot;, as: &quot;customerOrder&quot; &#125; &#125;]) 多表关联 12345678910111213141516171819db.order.aggregate([ &#123; $lookup: &#123; from: &quot;customer&quot;, localField: &quot;customerCode&quot;, foreignField: &quot;customerCode&quot;, as: &quot;curstomer&quot; &#125; &#125;, &#123; $lookup: &#123; from: &quot;orderItem&quot;, localField: &quot;orderId&quot;, foreignField: &quot;orderId&quot;, as: &quot;orderItem&quot; &#125; &#125;]) MapReduce(待学)视图MongoDB视图是一个可查询的对象，它的内容由其他集合或视图上的聚合管道定义。 MongoDB不会将视图内容持久化到磁盘。 当客户端查询视图时，视图的内容按需计算。 MongoDB可以要求客户端具有查询视图的权限。 MongoDB不支持对视图进行写操作。 创建视图12345678db.createView(&quot;&lt;viewName&gt;&quot;,&quot;&lt;source&gt;&quot;,[&lt;pipeline&gt;],&#123; &quot;collation&quot; : &#123; &lt;collation&gt; &#125;&#125;) viewName : 必须，视图名称 source : 必须，数据源，集合/视图 [] : 可选，一组管道 collation 可选，排序规则 假设现在查看当天最高的10笔订单视图，例如需要实时显示金额最高的订单 1234567891011121314151617db.createView( &quot;orderInfo&quot;, //视图名称 &quot;order&quot;, //数据源 [ //筛选符合条件的订单，大于当天，这里要注意时区 &#123; $match: &#123; &quot;orderTime&quot;: &#123; $gte: ISODate(&quot;2022-01-26T00:00:00.000Z&quot;) &#125; &#125;&#125;, //按金额倒序 &#123; $sort: &#123; &quot;price&quot;: -1 &#125; &#125;, //限制10个文档 &#123; $limit: 10 &#125;, //选择要显示的字段 //0: 排除字段，若字段上使用（_id除外），就不能有其他包含字段 //1: 包含字段 &#123; $project: &#123; _id: 0, orderNo: 1, price: 1, orderTime: 1 &#125; &#125; ]) 视图创建成功后可以像集合一样直接使用db.视图名.find()视图查询数据 多个集合创建视图: 跟单个是集合是一样，只是多了$lookup连接操作符，视图根据管道最终结果显示，所以可以关联多个集合 12345678910db.orderDetail.drop()db.createView( &quot;orderDetail&quot;, &quot;order&quot;, [ &#123; $lookup: &#123; from: &quot;shipping&quot;, localField: &quot;orderNo&quot;, foreignField:&quot;orderNo&quot;, as: &quot;shipping&quot; &#125; &#125;, &#123; $project: &#123; &quot;orderNo&quot;: 1, &quot;price&quot;: 1, &quot;shipping.address&quot;: 1 &#125; &#125; ]) 删除视图1db.orderInfo.drop(); 修改视图123456789101112db.runCommand(&#123; collMod: &quot;orderInfo&quot;, viewOn: &quot;order&quot;, pipeline: [ &#123; $match: &#123; &quot;orderTime&quot;: &#123; $gte: ISODate(&quot;2020-04-13T16:00:00.000Z&quot;) &#125; &#125;&#125;, &#123; $sort: &#123; &quot;price&quot;: -1 &#125; &#125;, &#123; $limit: 10 &#125;, //增加qty &#123; $project: &#123; _id: 0, orderNo: 1, price: 1, qty: 1, orderTime: 1 &#125; &#125; ]&#125;) 索引索引是一种用来快速查询数据的数据结构。B+Tree就是一种常用的数据库索引数据结构，MongoDB采用B+Tree 做索引，索引创建在colletions上。MongoDB不使用索引的查询，先扫描所有的文档，再匹配符合条件的文档。 使用索引的查询，通过索引找到文档，使用索引能够极大的提升查询效率。 索引数据结构:B-Tree说法来源于官方文档，然后就导致了分歧：有人说MongoDB索引数据结构使用的是B-Tree,有的人又说是B+Tree。B+Tree是B-Tree的子集 MongoDB官方文档：https://docs.mongodb.com/manual/indexes/MongoDB indexes use a B-tree data structure. 索引操作:创建索引创建索引语法格式 注意：3.0.0 版本前创建索引方法为 db.collection.ensureIndex() 1db.collection.createIndex(keys, options) Key 值为json对象，字段值为1 按升序创建索引， -1 按降序创建索引 , 可选参数options对象key-value配置列表如下： Parameter Type Description background Boolean 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。 unique Boolean 建立的索引是否唯一。指定为true创建唯一索引。默认值为false. name string 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 sparse Boolean 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false. expireAfterSeconds integer 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。 v index version 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。 weights document 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。 default_language string 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语 language_override string 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language. 案例:1234// 为value集合的 open,close字段 创建索引后台执行db.values.createIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;)// 为value集合的title字段创建唯一索引db.values.createIndex(&#123;title:1&#125;,&#123;unique:true&#125;) 查看索引:1234// 查看索引信息db.books.getIndexes()// 查看索引键db.books.getIndexKeys() 查看索引占用空间 1db.collection.totalIndexSize([is_detail]) is_detail：可选参数，传入除0或false外的任意数据，都会显示该集合中每个索引的大小及总大小。如果传入0或false则只显示该集合中所有索引的总大小。默认值为false。 删除索引1234// 删除集合指定索引db.col.dropIndex(&quot;索引名称&quot;)// 删除集合所有索引db.col.dropIndexes() 索引分类:按照索引包含的字段数量，可以分为单键索引和组合索引（或复合索引）。按照索引字段的类型，可以分为主键索引和非主键索引。按照索引节点与物理记录的对应方式来分，可以分为聚簇索引和非聚簇索引，其中聚簇索引是指索引节点上直接包含了数据记录，而后者则仅仅包含一个指向数据记录的指针。按照索引的特性不同，又可以分为唯一索引、稀疏索引、文本索引、地理空间索引等 单键索引在某一个特定的字段上建立索引 mongoDB在ID上建立了唯一的单键索引,所以经常会使用id来进行查询； 在索引字段上进行精确匹配、排序以及范围查找都会使用此索引 1db.books.createIndex(&#123;title:1&#125;) 复合索引复合索引是多个字段组合而成的索引，其性质和单字段索引类似。但不同的是，复合索引中字段的顺序、字段的升降序对查询性能有直接的影响，因此在设计复合索引时则需要考虑不同的查询场景。 1db.books.createIndex(&#123;type:1,favCount:1&#125;) 多键索引在数组的属性上建立索引。针对这个数组的任意值的查询都会定位到这个文档,既多个索引入口或者键值引用同一个文档 1234567891011// 假设有数据如下:db.inventory.insertMany([&#123; _id: 5, type: &quot;food&quot;, item: &quot;aaa&quot;, ratings: [ 5, 8, 9 ] &#125;,&#123; _id: 6, type: &quot;food&quot;, item: &quot;bbb&quot;, ratings: [ 5, 9 ] &#125;,&#123; _id: 7, type: &quot;food&quot;, item: &quot;ccc&quot;, ratings: [ 9, 5, 8 ] &#125;,&#123; _id: 8, type: &quot;food&quot;, item: &quot;ddd&quot;, ratings: [ 9, 5 ] &#125;,&#123; _id: 9, type: &quot;food&quot;, item: &quot;eee&quot;, ratings: [ 5, 9, 5 ] &#125;])// 创建多键索引db.inventory.createIndex( &#123; ratings: 1 &#125; ) 多键索引很容易与复合索引产生混淆，复合索引是多个字段的组合，而多键索引则仅仅是在一个字段上出现了多键（multi key）。而实质上，多键索引也可以出现在复合字段上 12//复合多键索引db.inventory.createIndex( &#123; item:1,ratings: 1&#125; ) ==注意： MongoDB并不支持一个复合索引中同时出现多个数组字段== 地理空间索引在移动互联网时代，基于地理位置的检索（LBS）功能几乎是所有应用系统的标配。MongoDB为地理空间检索提供了非常方便的功能。地理空间索引（2dsphereindex）就是专门用于实现位置检索的一种特殊索引。 案例：MongoDB如何实现“查询附近商家”？ 假设商家的数据模型如下： 12345678db.restaurant.insert(&#123; restaurantId: 0, restaurantName:&quot;兰州牛肉面&quot;, location : &#123; type: &quot;Point&quot;, coordinates: [ -73.97, 40.77 ] &#125;&#125;) 创建一个2dsphere索引 1db.restaurant.createIndex(&#123;location : &quot;2dsphere&quot;&#125;) 查询附近10000米商家信息 1234567891011db.restaurant.find( &#123; location:&#123; $near :&#123; $geometry :&#123; type : &quot;Point&quot; , coordinates : [ -73.88, 40.78 ] &#125; , $maxDistance:10000 &#125; &#125;&#125; ) $near查询操作符，用于实现附近商家的检索，返回数据结果会按距离排序。 $geometry操作符用于指定一个GeoJSON格式的地理空间对象，type=Point表示地理坐标点， coordinates则是用户当前所在的经纬度位置；$maxDistance限定了最大距离，单位是米。 全文索引MongoDB支持全文检索功能，可通过建立文本索引来实现简易的分词检索。 1db.reviews.createIndex( &#123; comments: &quot;text&quot; &#125; ) $text操作符可以在有全文索引的集合上执行文本检索。**$text将会使用空格和标点符号作为分隔符对检**索字符串进行分词， 并且对检索字符串中所有的分词结果进行一个逻辑上的 OR 操作。全文索引能解决快速文本查找的需求，比如有一个博客文章集合，需要根据博客的内容来快速查找，则可以针对博客内容建立文本索引。 案例: 1234567891011// 数据准备db.stores.insert( [ &#123; _id: 1, name: &quot;Java Hut&quot;, description: &quot;Coffee and cakes&quot; &#125;, &#123; _id: 2, name: &quot;Burger Buns&quot;, description: &quot;Gourmet hamburgers&quot; &#125;, &#123; _id: 3, name: &quot;Coffee Shop&quot;, description: &quot;Just coffee&quot; &#125;, &#123; _id: 4, name: &quot;Clothes Clothes Clothes&quot;, description: &quot;Discount clothing&quot;&#125;, &#123; _id: 5, name: &quot;Java Shopping&quot;, description: &quot;Indonesian goods&quot; &#125; ]) 创建name和description的全文索引 1db.stores.createIndex(&#123;name: &quot;text&quot;, description: &quot;text&quot;&#125;) 通过$text操作符来查寻数据中所有包含“coffee”,”shop”，“java”列表中任何词语的商店 1db.stores.find(&#123;$text: &#123;$search: &quot;java coffee shop&quot;&#125;&#125;) MongoDB的文本索引功能存在诸多限制，而官方并未提供中文分词的功能，这使得该功能的应用场景十分受限。 通配符索引MongoDB的文档模式是动态变化的，而通配符索引可以建立在一些不可预知的字段上，以此实现查询的加速。MongoDB 4.2 引入了通配符索引来支持对未知或任意字段的查询。 案例: 准备商品数据，不同商品属性不一样 1234567891011121314151617181920212223242526272829303132db.products.insert([ &#123; &quot;product_name&quot;: &quot;Spy Coat&quot;, &quot;product_attributes&quot;: &#123; &quot;material&quot;: [&quot;Tweed&quot;, &quot;Wool&quot;, &quot;Leather&quot;], &quot;size&quot;: &#123; &quot;length&quot;: 72, &quot;units&quot;: &quot;inches&quot; &#125; &#125; &#125;, &#123; &quot;product_name&quot;: &quot;Spy Pen&quot;, &quot;product_attributes&quot;: &#123; &quot;colors&quot;: [&quot;Blue&quot;, &quot;Black&quot;], &quot;secret_feature&quot;: &#123; &quot;name&quot;: &quot;laser&quot;, &quot;power&quot;: &quot;1000&quot;, &quot;units&quot;: &quot;watts&quot;, &#125; &#125; &#125;, &#123; &quot;product_name&quot;: &quot;Spy Book&quot; &#125;]) 创建通配符索引 1db.products.createIndex( &#123; &quot;product_attributes.$**&quot; : 1 &#125; ) 通配符索引可以支持任意单字段查询 product_attributes或其嵌入字段： 123db.products.find( &#123; &quot;product_attributes.size.length&quot; : &#123; $gt : 60 &#125; &#125; )db.products.find( &#123; &quot;product_attributes.material&quot; : &quot;Leather&quot; &#125; )db.products.find( &#123; &quot;product_attributes.secret_feature.name&quot; : &quot;laser&quot; &#125; ) 注意事项: 通配符索引不兼容的索引类型或属性: Compound , TTL , Text, 2d(Gepospatial) , 2dsphere(Geospatial) , Hashed , Unique 通配符索引是稀疏的，不索引空字段。因此，通配符索引不能支持查询字段不存在的文档 12345// 通配符索引不能支持以下查询db.products.find( &#123;&quot;product_attributes&quot; : &#123; $exists : false &#125; &#125; )db.products.aggregate([&#123; $match : &#123; &quot;product_attributes&quot; : &#123; $exists : false &#125; &#125; &#125;]) 通配符索引为文档或数组的内容生成条目，而不是文档/数组本身。因此通配符索引不能支持精确的文档/数组相等匹配。通配符索引可以支持查询字段等于空文档{}的情况。 1234db.products.find(&#123; &quot;product_attributes.colors&quot; : [ &quot;Blue&quot;, &quot;Black&quot; ] &#125; )db.products.aggregate([&#123;$match : &#123; &quot;product_attributes.colors&quot; : [ &quot;Blue&quot;, &quot;Black&quot; ] &#125;&#125;]) Mongodb Java API原生api 操作 连接到MongoDB 首先需要导入依赖项,才能进行后续相关操作: 123456&lt;!-- https://mvnrepository.com/artifact/org.mongodb/mongo-java-driver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;3.12.10&lt;/version&gt;&lt;/dependency&gt; 连接:新建一个工具类获取连接对象: 1234567891011121314151617181920212223242526272829303132333435import com.mongodb.MongoClient;import com.mongodb.MongoClientOptions;import com.mongodb.ServerAddress;import com.mongodb.client.MongoClients;import com.mongodb.client.MongoCollection;import com.mongodb.client.MongoDatabase;public class MongoDBPoolUtil &#123; private static MongoClient client = null; static &#123; if (client == null) &#123; MongoClientOptions.Builder builder = new MongoClientOptions.Builder(); //设置每个连接地址的最大连接数 builder.connectionsPerHost(10); //设置连接的超时时间 builder.connectTimeout(5000); //设置读写的超时时间 builder.socketTimeout(5000); ServerAddress address = new ServerAddress(&quot;localhost&quot;, 27017); client = new MongoClient(address, builder.build()); &#125; &#125; //获取MongoDB数据库 public static MongoDatabase getDatabase(String databaseName) &#123; return client.getDatabase(databaseName); &#125; //获取Mongo集合 public static MongoCollection getCollection(String databaseName, String collectionName) &#123; return getDatabase(databaseName).getCollection(collectionName); &#125;&#125; 基本操作:操作方式与 mongodb shell 原生方法有点类似 可以通过过滤器Filters类的静态方法进行逻辑实现条件判断 查询:为了便于创建投影文档，Java 驱动程序提供了Projection类,可使用它的静态方法实现投影操作 12// 查询全部文档,qty,type字段不展示MongoCursor cursor = collection.find().projection(Projections.exclude(&quot;qty&quot;,&quot;type&quot;)).cursor(); 12345678910111213141516171819202122232425262728293031323334@Test public void find() &#123; MongoCollection collection = MongoDBPoolUtil.getCollection(&quot;db_java&quot;, &quot;goods&quot;);// 查询第一个 System.out.println(collection.find().first()); System.out.println(&quot;=====全部查询=======&quot;);// 查询全部 MongoCursor cursor = collection.find().cursor(); while (cursor.hasNext()) &#123; System.out.println(cursor.next()); &#125; System.out.println(&quot;=====条件查询=======&quot;);// 条件查询 MongoCursor res = collection.find(new Document(&quot;_id&quot;, 1)).cursor();// while (res.hasNext()) &#123;// System.out.println(res.next());// &#125; // 查询 qty 字段大于8 的文档 res = collection.find( new Document(&quot;qty&quot;,new Document(&quot;$gt&quot;,8)) ).cursor();// 使用Filters会更简便:// res = collection.find((Filters.gt(&quot;qty&quot;,8))).cursor(); // 查询 color字段为green,并且qty字段&gt;=8的文档 res = collection.find( Filters.and( Filters.eq(&quot;color&quot;,&quot;green&quot;), Filters.gte(&quot;qty&quot;,8) )).cursor(); while (res.hasNext()) &#123; System.out.println(res.next()); &#125; &#125; 删除若要删除集合中的文档，可以使用 deleteOne 和 deleteMany 方法。与查询非常类似,不再赘述 更新:可以使用集合的 updateOne（） 或 updateMany 方法。 注意: 无法修改_id字段的值,因为他是不可变的 可以通过 Updates 类的静态方法进行类似Mongodb shell 的更新操作 更新选项: 还可以包含一个 UpdateOptions类的静态方法指定 upsert 选项或 bypassDocumentationValidation 选项。 12345678910111213141516@Test public void update()&#123;// collection.updateOne(//// 条件// new Document(&quot;_id&quot;,1),//// 更新操作// new Document(// &quot;$set&quot;,new Document(&quot;qty&quot;,12)// )// );// 上面等同于: collection.updateOne(Filters.eq(&quot;_id&quot;,1), Updates.set(&quot;qty&quot;,12)); System.out.println(&quot;更新完毕!&quot;);// 批量更新,参数都是一样的 collection.updateMany(Filters.lte(&quot;qty&quot;,10), Updates.set(&quot;type&quot;,&quot;few&quot;)); &#125; tips:在某些情况下，您可能需要更新文档中的许多字段，使用合的 replaceOne()效率更高。请参阅替换文档。 插入注意: 如果未指定主键_id,则会自动随机生成一个_id 单个文档插入集合，可以使用集合的 insertOne（） 方法,插入多个 使用insertMany（） 1234567891011121314151617181920212223242526@Test public void insert() &#123; Document doc = new Document( &quot;_id&quot;, 6 ); doc.append(&quot;color&quot;, &quot;red&quot;); doc.append(&quot;qty&quot;, 4);// collection.insertOne(doc); // 插入单个文档// System.out.println(doc + &quot;,插入成功!&quot;); HashMap map1 = new HashMap(); map1.put(&quot;_id&quot;, 6); map1.put(&quot;color&quot;, &quot;black&quot;); map1.put(&quot;qty&quot;, 77); Document doc1 = new Document(map1); map1.clear(); map1.put(&quot;_id&quot;, 7); map1.put(&quot;color&quot;, &quot;pink&quot;); map1.put(&quot;qty&quot;, 18); Document doc2 = new Document(map1); List&lt;Document&gt; docs = new ArrayList&lt;&gt;(); docs.add(doc1); docs.add(doc2); collection.insertMany(docs); System.out.println(docs+&quot;批量插入成功!&quot;); &#125; 排序,分页调用结果集的 sort()可实现排序 skip()和limit()配合可以实现分页 聚合操作详情见: 集合体 (mongodb.github.io) SpringData MongDB 官网: https://projects.spring.io/spring-data-mongodb/ SpringData家族成员之一，用于操作MongoDB的持久层框架，封装了底层的mongodb-driver。 SpringData简介Spring Data的使命是为数据访问提供一个熟悉且一致的，基于Spring的编程模型，同时仍然保留底层数据存储的特殊特征。它使使用数据访问技术、关系和非关系数据库、map-reduce 框架和基于云的数据服务变得容易。这是一个伞形项目，其中包含许多特定于给定数据库的子项目。这些项目是通过与这些令人兴奋的技术背后的许多公司和开发人员合作开发的。 特征: 强大的存储库和自定义对象映射抽象 从存储库方法名称派生的动态查询 提供基本属性的实现域基类 支持透明审核（已创建，上次更改） 可以集成自定义存储库代码 通过JavaConfig和自定义XML命名空间轻松集成Spring。 与Spring MVC控制器的高级集成 对跨存储持久性的实验性支持 与Mybatis区别:首先,Mybatis只支持SQL (关系型数据库) , 而 SpringData (简称JPA/Hibernate) 支持SQL 和 NoSQL 环境准备:导入依赖项 123456789&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--spring data mongodb--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot配置文件: 123456789spring: application: name: SpringDataMongoDB data: mongodb:# host: localhost# port: 27019# database: db_java uri: mongodb://localhost:27017/db_java uri 详细配置参考: https://docs.mongodb.com/manual/reference/connection-string/ ==注意层级关系,不要写错配置文件== 注入mongoTemplate 12@AutowiredMongoTemplate mongoTemplate; 集合操作:12345678910@Testpublic void testCollection()&#123; boolean exists = mongoTemplate.collectionExists(&quot;emp&quot;); if (exists) &#123; //删除集合 mongoTemplate.dropCollection(&quot;emp&quot;); &#125; //创建集合 mongoTemplate.createCollection(&quot;emp&quot;);&#125; 文档操作:实体类映射相关注解: @Document 修饰范围: 用在类上 作用: 用来映射这个类的一个对象为mongo中一条文档数据。(ORM 对象关系映射) 属性:( value 、collection )用来指定操作的集合名称 @Id 修饰范围: 用在成员变量、方法上 作用: 用来将成员变量的值映射为文档的_id的值 @Field 修饰范围: 用在成员变量、方法上 作用: 用来将成员变量及其值映射为文档中一个key:value对。 属性:( name , value )用来指定在文档中 key的名称,默认为成员变量名 @Transient 修饰范围:用在成员变量、方法上 作用:用来指定此成员变量不参与文档的序列化 建立与文档映射的实体类: 12345678910111213141516@Document(&quot;emp&quot;) // 映射mongodb文档@lombok.Data@AllArgsConstructor@NoArgsConstructorpublic class Employee &#123; @Id private Integer id; @Field(&quot;username&quot;) private String name; @Field private int age; @Field private Double salary; @Field private Date birthday;&#125; 添加文档:12345678910111213141516171819@Testpublic void testInsert()&#123; Employee employee = new Employee(1, &quot;小明&quot;, 30,10000.00, new Date()); //添加文档 // sava: _id存在时更新数据 //mongoTemplate.save(employee); // insert： _id存在抛出异常 支持批量操作 mongoTemplate.insert(employee); List&lt;Employee&gt; list = Arrays.asList( new Employee(2, &quot;张三&quot;, 21,5000.00, new Date()), new Employee(3, &quot;李四&quot;, 26,8000.00, new Date()), new Employee(4, &quot;王五&quot;,22, 8000.00, new Date()), new Employee(5, &quot;张龙&quot;,28, 6000.00, new Date()), new Employee(6, &quot;赵虎&quot;,24, 7000.00, new Date()), new Employee(7, &quot;赵六&quot;,28, 12000.00, new Date())); //插入多条数据 mongoTemplate.insert(list,Employee.class); 查询文档:可以使用 mongodb shell 原生写法传递Json字符串进行条件查询: 1234567891011void useJsonFind() &#123; // 查询年龄为18的员工 String json1 = &quot;&#123;age:28&#125;&quot;; BasicQuery query1 = new BasicQuery(json1); mongoTemplate.find(query1,Employee.class).forEach(System.out::println); System.out.println(&quot;================================&quot;); // age&gt;=26 and salary &lt; 8000 String json2 = &quot;&#123;$and: [&#123;age: &#123;$gte: 26&#125;&#125;,&#123;salary: &#123;$lt: 8000&#125;&#125;]&#125;&quot;; BasicQuery query2 = new BasicQuery(json2); mongoTemplate.find(query2,Employee.class).forEach(System.out::println); &#125; Criteria是标准查询的接口，使用Criteria.where(“字段名”)可选择文档字段,使用其它方法进行逻辑运算，方便我们操作查询语句。对照表如下: Criteria静态方法 Mongodb逻辑运算符 说明 Criteria and(String key) $and and Criteria andOperator(Criteria…criteria) $and and Criteria orOperator(Criteria…criteria) $or or Criteria gt(Object o) $gt &gt; Criteria gte(Object o) $gte &gt;= Criteria is(Object o) $is == Criteria ne(Object o) $ne != Criteria It(Object o) $It &lt; Criteria Ite(Object o) $Ite &lt;= Criteria in (Object…o) $in 包含 Criteria nin (Object…o) $nin 不包含 12345678910111213141516171819202122232425262728293031323334@Test void find() &#123; System.out.println(&quot;=====查询全部=====&quot;); List list = mongoTemplate.findAll(Employee.class, &quot;emp&quot;);// list.forEach(o -&gt; System.out.println(o));// 简写: list.forEach(System.out::println); System.out.println(&quot;=====根据id查询=====&quot;); System.out.println(mongoTemplate.findById(1, Employee.class));// System.out.println(&quot;==========findOne返回第一个文档===========&quot;); //如果查询结果是多个，返回其中第一个文档对象// System.out.println(mongoTemplate.findOne(new Query(), Employee.class)); System.out.println(&quot;==========条件查询===========&quot;); //new Query()表示没有条件// 单条件简单查询: //查询薪资大于等于8000的员工// mongoTemplate.find(new Query(Criteria.where(&quot;salary&quot;).gte(8000)),Employee.class)// .forEach(System.out::println); //查询薪资大于4000小于10000的员工 //Query query = new Query(Criteria.where(&quot;salary&quot;).gt(4000).lt(10000)); //正则查询（模糊查询） java中正则不需要有// //Query query = new Query(Criteria.where(&quot;name&quot;).regex(&quot;张&quot;));//and or 复杂条件查询: Criteria criteria = new Criteria(); //and: 查询年龄大于25&amp;薪资大于8000的员工 criteria.andOperator(Criteria.where(&quot;age&quot;).gt(25),Criteria.where(&quot;salary&quot;).gt(8000)); //or: 查询姓名是张三或者薪资大于8000的员工// criteria.orOperator(Criteria.where(&quot;name&quot;).is(&quot;张三&quot;),Criteria.where(&quot; salary&quot;).gt(5000)); Query query = new Query(criteria); mongoTemplate.find(query,Employee.class).forEach(System.out::println); &#125; ==注意! new Query(criteria) criteria对象调用了andOperator()等进行多条件判断时才会生效== 1234567Criteria criteria = new Criteria();criteria.andOperator(Criteria.where(&quot;age&quot;).gt(25), Criteria.where(&quot;salary&quot;).gt(8000));mongoTemplate.find(new Query(criteria), Employee.class);// 这样不会生效:criteria.where(&quot;age&quot;).is(28);mongoTemplate.find(new Query(criteria), Employee.class); 排序, 分页: 1234567891011121314@Test void sort_Limit()&#123; Query query = new Query(); // 按薪资降序排列 query.with(Sort.by(Sort.Order.desc(&quot;salary&quot;))); List list = mongoTemplate.find(query,Employee.class); System.out.println(&quot;======排序======&quot;); list.forEach(System.out::println); System.out.println(&quot;=====分页=====&quot;); int limit = 3; int page = 2; query.skip((page-1)*limit).limit(limit); mongoTemplate.find(query,Employee.class).forEach(System.out::println); &#125; 更新文档在Mongodb中无论是使用客户端API还是使用Spring Data，更新返回结果一定是受行数影响。如果更新后的结果和更新前的结果是相同，返回0。 updateMulti() 更新所有满足条件的记录 upsert() 没有符合条件的记录则插入数据 updateFirst() 只更新满足条件的第一条记录 123456789101112@Test void update()&#123; Criteria criteria = new Criteria(); //设置更新的条件: age &gt;= 26 and salary&lt;10000 criteria.andOperator(Criteria.where(&quot;age&quot;).gte(26),Criteria.where(&quot;salary&quot;).lt(10000)); Query query = new Query(criteria); // Update类封装了Mongodb的更新操作符 Update update = new Update(); update.set(&quot;salary&quot;,10000); UpdateResult updateResult = mongoTemplate.updateMulti(query,update,Employee.class); System.out.println(&quot;影响行数:&quot;+updateResult.getModifiedCount()); &#125; 删除文档:与查询方法参数基本相同, 方法为: remove() ,注意没有delete()方法 聚合操作MongoTemplate提供了aggregate()方法来实现对数据的聚合操作。 并且Aggregation类属性提供了类似于MongoDB的管道阶段操作符 支持的操作 Java接口 描述 SQL等价运算符 $match Aggregation.match 筛选条件 WHERE $project Aggregation.project 投影 AS AS $group Aggregation.group 分组 GROUP BY $sort Aggregation.sort 排序 ORDER BY $skip/$limit Aggregation.skip/limit 分页 $unwind Aggregation.geoNear 展开数组 $geoNear Aggregation.geoNear 输出接近某一个地理位置的有序文档 此外,Aggregation类方法还提供了MongoDB相关的聚合运算 聚合表达式 java操作 说明 $sum Aggregation.group().sum(“field”).as(“sum”) 求和 $avg Aggregation.group().avg(“field”).as(“avg”) 求平均 $min Aggregation.group().min(“field”).as(“min”) 获取集合中所有文档对应值得最小值 $max Aggregation.group().max(“field”).as(“max”) 获取集合中所有文档对应值得最大值 $first Aggregation.group().first(“field”).as(“first”) 根据资源文档的排序获取第一个文档数据 $last Aggregation.group().last(“field”).as(“last”) 根据资源文档的排序获取最后一个文档数据 $push Aggregation.group().push(“field”).as(“push”) 在结果文档中插入值到一个数组中 $addToSet Aggregation.group().addToSet(“field”).as(“addToSet”) 在结果文档中插入值到一个数组中，但不创建副本 准备工作:下载数据文件美国城市邮政编码数据集: https://media.mongodb.org/zips.json 新建集合zips导入数据(可以使用Navicat工具进行导入): 也可以使用Mongdo命令行工具mongoimport工具导入数据(推荐) 1234mongoimport -h localhost -d db_java -c zips --file E:\\桌面\\临时文件\\zips.json#更详细:# mongoimport -h 192.168.65.204 -d aggdemo -u fox -p fox --authenticationDatabase=admin -c zips --file D:\\ProgramData\\mongodb\\import\\zips.json 命令参数: h,–host ：代表远程连接的数据库地址，默认连接本地Mongo数据库； –port：代表远程连接的数据库的端口，默认连接的远程端口27017； -u,–username：代表连接远程数据库的账号，如果设置数据库的认证，需要指定用户账号； -p,–password：代表连接数据库的账号对应的密码； -d,–db：代表连接的数据库； -c,–collection：代表连接数据库中的集合； -f, –fields：代表导入集合中的字段； –type：代表导入的文件类型，包括csv和json,tsv文件，默认json格式； –file：导入的文件名称 –headerline：导入csv文件时，指明第一行是列名，不需要导入； 新建实体类映射: 12345678910111213141516@Document(&quot;zips&quot;)@Data@AllArgsConstructor@NoArgsConstructorpublic class Zips &#123; @Id //映射文档中的_id private String id; @Field private String city; @Field private Double[] loc; @Field private Integer pop; @Field private String state;&#125; 案例:返回人口超过1000万的州: 对应的 mongo shell 1234db.zips.aggregate( [ &#123; $group: &#123; _id: &quot;$state&quot;, totalPop: &#123; $sum: &quot;$pop&quot; &#125; &#125; &#125;, &#123; $match: &#123; totalPop: &#123; $gt: 10*1000*1000 &#125; &#125; &#125;] ) 对应的SQL: 1234SELECT state, SUM(pop) AS totalPopFROM zipsGROUP BY stateHAVING totalPop &gt;= (10*1000*1000) java实现: 12345678910111213141516171819@Test void aggregationTest1() &#123; // $group GroupOperation groupOperation = Aggregation.group(&quot;state&quot;).sum(&quot;pop&quot;).as(&quot;totalPop&quot;); // $match MatchOperation matchOperation = Aggregation.match(Criteria.where(&quot;totalPop&quot;).gte(10*1000*1000)); SortOperation sortOperation = Aggregation.sort(Sort.Direction.DESC,&quot;totalPop&quot;); //排序 TypedAggregation&lt;Zips&gt; aggregation = Aggregation.newAggregation(Zips.class,groupOperation,matchOperation,sortOperation); System.out.println(&quot;==============使用Map映射(推荐用法兼容新更好)===============&quot;); AggregationResults results2 = mongoTemplate.aggregate(aggregation,Map.class); List&lt;LinkedHashMap&gt; list = results2.getMappedResults(); // 每个map结构为 含有两个键: _id, totalPop 即使 &#123;_id:值,totalPop:值&#125; list.forEach(System.out::println); System.out.println(&quot;==============使用实体类映射===============&quot;); AggregationResults results1 = mongoTemplate.aggregate(aggregation,Zips.class); Document doc = results1.getRawResults(); // 使用实体类映射将返回一个结果集文档对象 System.out.println(doc); &#125; 返回各州平均人口: mongo shell 123456db.zips.aggregate( [ &#123; $group: &#123; _id: &#123; state: &quot;$state&quot;, city: &quot;$city&quot; &#125;, cityPop: &#123; $sum: &quot;$pop&quot; &#125;&#125; &#125;, &#123; $group: &#123; _id: &quot;$_id.state&quot;, avgCityPop: &#123; $avg: &quot;$cityPop&quot; &#125; &#125; &#125;, &#123; $sort:&#123;avgCityPop:-1&#125;&#125;] ) java实现: 123456789@Test void aggregationTest2()&#123; GroupOperation group1 = Aggregation.group(&quot;state&quot;,&quot;city&quot;).sum(&quot;pop&quot;).as(&quot;cityPop&quot;); GroupOperation group2 = Aggregation.group(&quot;$_id.state&quot;).avg(&quot;cityPop&quot;).as(&quot;avgCityPop&quot;); SortOperation sortOperation = Aggregation.sort(Sort.Direction.DESC,&quot;avgCityPop&quot;); TypedAggregation aggregation = Aggregation.newAggregation(Zips.class,group1,group2,sortOperation); List list = mongoTemplate.aggregate(aggregation,Map.class).getMappedResults(); list.forEach(System.out::println); &#125; 按州返回人口最大和最小的城市: mongo shell 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162db.zips.aggregate([ &#123; $group: &#123; _id: &#123; state: &quot;$state&quot;, city: &quot;$city&quot; &#125;, pop: &#123; $sum: &quot;$pop&quot; &#125; &#125; &#125;, &#123; $sort: &#123; pop: 1 &#125; &#125;, &#123; $group: &#123; _id: &quot;$_id.state&quot;, biggestCity: &#123; $last: &quot;$_id.city&quot; &#125;, biggestPop: &#123; $last: &quot;$pop&quot; &#125;, smallestCity: &#123; $first: &quot;$_id.city&quot; &#125;, smallestPop: &#123; $first: &quot;$pop&quot; &#125; &#125; &#125;, &#123; $project: &#123; _id: 0, state: &quot;$_id&quot;, biggestCity: &#123; name: &quot;$biggestCity&quot;, pop: &quot;$biggestPop&quot; &#125;, smallestCity: &#123; name: &quot;$smallestCity&quot;, pop: &quot;$smallestPop&quot; &#125; &#125; &#125;, &#123; $sort: &#123; state: 1 &#125; &#125;]) java实现: 1234567891011121314151617181920212223242526@Test void aggregationTest3()&#123; GroupOperation group1 = Aggregation.group(&quot;state&quot;,&quot;city&quot;).sum(&quot;pop&quot;).as(&quot;pop&quot;); SortOperation sort1 = Aggregation.sort(Sort.Direction.ASC,&quot;pop&quot;); GroupOperation group2 = Aggregation.group(&quot;_id.state&quot;) .last(&quot;_id.city&quot;).as(&quot;biggestCity&quot;) .last(&quot;pop&quot;).as(&quot;biggestPop&quot;) .first(&quot;_id.city&quot;).as(&quot;smallestCity&quot;) .first(&quot;pop&quot;).as(&quot;smallestPop&quot;); // $project ProjectionOperation projectionOperation = Aggregation.project(&quot;state&quot;,&quot;biggestCity&quot;,&quot;smallestCity&quot;) .and(&quot;_id&quot;).as(&quot;state&quot;) .andExpression(&quot;&#123; name: \\&quot;$biggestCity\\&quot;, pop: \\&quot;$biggestPop\\&quot; &#125;&quot;) .as(&quot;biggestCity&quot;) .andExpression(&quot;&#123; name: \\&quot;$smallestCity\\&quot;, pop: \\&quot;$smallestPop\\&quot; &#125;&quot;) .as(&quot;smallestCity&quot;) .andExclude(&quot;_id&quot;); SortOperation sort2 = Aggregation.sort(Sort.Direction.ASC,&quot;state&quot;); TypedAggregation aggregation = Aggregation.newAggregation(Zips.class,group1,sort1,group2,projectionOperation,sort2); AggregationResults results = mongoTemplate.aggregate(aggregation,Map.class); List mapList = results.getMappedResults(); mapList.forEach(System.out::println); &#125; Redis使用简介Redis诞生于2009年全称是Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征： 键值（key-value）型，value支持多种不同数据结构，功能丰富 单线程，每个命令具备原子性 低延迟，速度快（基于内存、IO多路复用、良好的编码）。 支持数据持久化 支持主从集群、分片集群 支持多语言客户端 作者：Antirez Redis的官方网站地址：https://redis.io/ 安装大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis. 注意: 也可使用 docker 安装部署 此处选择的Linux版本为CentOS 7. Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖： 1yum install -y gcc tcl 然后将Redis安装包上传到虚拟机的任意目录：例如放到/usr/local/src 目录 1234cd /usr/local/srctar -xzf redis-6.2.6.tar.gzcd redis-6.2.6make &amp;&amp; make install 默认的安装路径是在 /usr/local/bin目录下： 该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中： redis-cli：是redis提供的命令行客户端 redis-server：是redis的服务端启动脚本 redis-sentinel：是redis的哨兵启动脚本 启动:默认启动:安装完成后，在任意目录输入redis-server命令即可启动Redis： 1redis-server 这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下CTRL + C则Redis停止。不推荐使用。 指定配置启动:如果要让Redis以后台方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（/usr/local/src/redis-6.2.6），名字叫redis.conf： 我们先将这个配置文件备份一份 1cp redis.conf redis.conf.backup 随后修改配置文件: 123456789101112131415161718# 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0bind 0.0.0.0# 守护进程，修改为yes后即可后台运行daemonize yes # 密码，设置后访问Redis必须输入密码requirepass 123321# 其他配置:# 监听的端口port 6379# 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志.持久化等文件会保存在这个目录dir .# 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15databases 1# 设置redis能够使用的最大内存maxmemory 512mb# 日志文件，默认为空，不记录日志，可以指定日志文件名logfile &quot;redis.log&quot; 指定配置文件启动: 12cd /usr/local/src/redis-6.2.6redis-server redis.conf 停止服务： 123# 因为之前配置了密码，因此需要通过 -u 来指定密码redis-cli -u 123321 shutdown# 也可通过 ps -ef 查看运行的进程,随后通过命令 kill -9 进程号 强制终止进程 开机自启我们也可以通过配置来实现开机自启。首先，新建一个系统服务文件： 1vim /etc/systemd/system/redis.service 内容如下: 1234567891011[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target 然后重载系统服务： 1systemctl daemon-reload 执行下面的命令，可以让redis开机自启： 1systemctl enable redis 现在，我们可以用下面这组命令来操作redis了： 12345678# 启动systemctl start redis# 停止systemctl stop redis# 重启systemctl restart redis# 查看状态systemctl status redis 连接交互安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括： 命令行客户端 图形化桌面客户端 编程客户端 Redis命令行客户端:Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下： 1redis-cli [options] [commonds] 其中常见的options有： -h 127.0.0.1：指定要连接的redis节点的IP地址，默认是127.0.0.1 -p 6379：指定要连接的redis节点的端口，默认是6379 -a 123321：指定redis的访问密码 其中的commonds就是Redis的操作命令，例如： ping：与redis服务端做心跳测试，服务端正常会返回pong 不指定commond时，会进入redis-cli的交互控制台： 图形化桌面客户端GitHub上的大神编写了Redis的图形化桌面客户端，地址：https://github.com/uglide/RedisDesktopManager 不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。 在下面这个仓库可以找到windos的安装包：https://github.com/lework/RedisDesktopManager-Windows/releases 基本常见命令常见数据结构介绍Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样： Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ https://redis.io/commands ）可以查看到不同的命令： https://redis.io/commands 通用命令:通用指令是部分数据类型的，都可以使用的指令，常见的有： keys：查看符合模板的所有key del：删除一个指定的key exists：判断key是否存在 expire：给一个key设置有效期，有效期到期时该key会被自动删除 ttl：查看一个KEY的剩余有效期, -1代表永久有效, -2 代表已经过期或者不存在 通过help [command] 可以查看一个命令的具体用法，例如： 提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高 内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~ String命令String类型，也就是字符串类型，是Redis中最简单的存储类型。 其value是字符串，不过根据字符串的格式不同，又可以分为3类： string：普通字符串 int：整数类型，可以做自增.自减操作 float：浮点类型，可以做自增.自减操作 String的常见命令有： set 键 值：添加或者修改已经存在的一个String类型的键值对 get 键：根据key获取String类型的value mset 键1 值1 键2 值2 键3 值3...：批量添加多个String类型的键值对 mget 键1 值1 键2 值2 键3 值3...：根据多个key获取多个String类型的value incr 键 ：让一个整型的key自增1 incrby 键 步长 :让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2 setnx 键 值：添加一个String类型的键值对，前提是这个key不存在，否则不执行 setex 键 有效期 值：添加一个String类型的键值对，并且指定有效期(秒) INCRBYFLOAT：让一个浮点类型的数字自增并指定步长 注意:关于SET 和GET命令: 如果key不存在则是新增，如果存在则是修改 Key的层级结构Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？ 例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？ 我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范： Redis的key允许有多个单词形成层级结构，多个单词之间用’:‘隔开，格式如下： 项目名:业务名:类型:id 这个格式并非固定，也可以根据自己的需求来删除或添加词条。 例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key： user相关的key：heima:user:1 product相关的key：heima:product:1 如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储： KEY VALUE heima:user:1 {“id”:1, “name”: “Jack”, “age”: 21} heima:product:1 {“id”:1, “name”: “小米11”, “price”: 4999} 一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据 Hash命令:Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。 String结构是将对象序列化为JSON字符串后存储，当需要==修改对象某个字段时很不方便==： Key Value heima:user:1 {“id”:1, “name”: “Jack”, “age”: 21} heima:user:2 {“id”:1, “name”: “Rose”, “age”: 18} Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD： Hash类型的常见命令 Hset key field value：添加或者修改hash类型key的field的值 Hget key field：获取一个hash类型key的field的值 Hmset：批量添加多个hash类型key的field的值 Hmget：批量获取多个hash类型key的field的值 Hgetall：获取一个hash类型的key中的所有的field和value Hkeys：获取一个hash类型的key中的所有的field Hincrby:让一个hash类型key的字段值自增并指定步长 Hsetnx：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 案例: 1234567# 插入hash结构数据HSET heima:user:3 name Lucy #大key是 heima:user:3 小key是name，小value是LucyHSET heima:user:3 age 21 #如果操作不存在的数据，则是新增HSET heima:user:3 age 17 #如果操作存在的数据，则是修改# 查看数据HGET heima:user:3 name HGET heima:user:3 age List命令Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。 特征也与LinkedList类似： 有序 元素可以重复 插入和删除快 查询速度一般 常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。 List的常见命令有： LPUSH key element ... ：向列表左侧插入一个或多个元素 LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil RPUSH key element ... ：向列表右侧插入一个或多个元素 RPOP key：移除并返回列表右侧的第一个元素 LRANGE key star end：返回一段角标范围内的所有元素 BLPOP和BRPOP, 与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回null Set命令Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征： 无序 元素不可重复 查找快 支持交集.并集.差集等功能 Set类型的常见命令: Sadd key member ... ：向set中添加一个或多个元素 Srem key member ... : 移除set中的指定元素 Scard key： 返回set中元素的个数 Sismember key member：判断一个元素是否存在于set中 Smembers：获取set中的所有元素 Sinter key1 key2 ... ：求key1与key2的交集 Sdiff key1 key2 ... ：求key1与key2的差集 Sunion key1 key2 ...：求key1和key2的并集 案例: 1234567891011121314151617181920212223242526272829303132333435127.0.0.1:6379&gt; SADD zs lisi wangwu zhaoliu(integer) 3 127.0.0.1:6379&gt; SADD ls wangwu mazi ergou(integer) 3 127.0.0.1:6379&gt; SCARD zs(integer) 3 127.0.0.1:6379&gt; SINTER zs ls1) &quot;wangwu&quot; 127.0.0.1:6379&gt; SDIFF zs ls1) &quot;zhaoliu&quot;2) &quot;lisi&quot; 127.0.0.1:6379&gt; SUNION zs ls1) &quot;wangwu&quot;2) &quot;zhaoliu&quot;3) &quot;lisi&quot;4) &quot;mazi&quot;5) &quot;ergou&quot; 127.0.0.1:6379&gt; SISMEMBER zs lisi(integer) 1 127.0.0.1:6379&gt; SISMEMBER ls zhangsan(integer) 0 127.0.0.1:6379&gt; SREM zs lisi(integer) 1 127.0.0.1:6379&gt; SMEMBERS zs1) &quot;zhaoliu&quot;2) &quot;wangwu&quot; SortedSet命令Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。 SortedSet具备下列特性： 可排序 元素不重复 查询速度快 因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。 常见命令有： ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值 ZREM key member：删除sorted set中的一个指定元素 Zscore key member : 获取sorted set中的指定元素的score值 Zrank key member：获取sorted set 中的指定元素的排名 ZCARD key：获取sorted set中的元素个数 Zcount key min max：统计score值在给定范围内的所有元素的个数 Zincrby key increment member：让sorted set中的指定元素自增，步长为指定的increment值 Zrange key min max：按照score排序后，获取指定排名范围内的元素 ZrangeByscore key min max：按照score排序后，获取指定score范围内的元素 ZDIFF.ZINTER.ZUNION：求差集.交集.并集 注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加rev即可，例如： 升序获取sorted set 中的指定元素的排名：ZRANK key member 降序获取sorted set 中的指定元素的排名：ZREVRANK key memeber Java连接在Redis官网中提供了各种语言的客户端，地址：https://redis.io/docs/clients/ 其中Java客户端也包含很多 标记为❤的就是推荐使用的java客户端，包括： Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。 Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。 Jedis快速入门==注意:Jedis是线程不安全的!== 引入依赖: 123456&lt;!--jedis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt; JedisJava类中封装了很多方法和原生Redis命令基本一致,直接调用操作即可 测试: 123456789101112131415161718192021222324252627282930313233343536373839404142public class JedisTest &#123; Jedis jedis; // 首先: 必须建立连接 @BeforeEach //单元测试的常用注解: 最先执行 void setUp()&#123; jedis = new Jedis(&quot;192.168.60.128&quot;,6379); jedis.auth(&quot;123456&quot;); // 选择数据库 jedis.select(0); &#125; @Test void testString()&#123; jedis.set(&quot;name&quot;,&quot;南城&quot;); System.out.println(jedis.get(&quot;name&quot;)); &#125; @Test void testHash()&#123; //添加user:1 jedis.hset(&quot;user:1&quot;,&quot;name&quot;,&quot;Luck&quot;); jedis.hset(&quot;user:1&quot;,&quot;age&quot;,&quot;18&quot;); // 添加user:2 Map user2 = new HashMap&lt;String,String&gt;(); user2.put(&quot;name&quot;,&quot;Jack&quot;); user2.put(&quot;age&quot;,&quot;20&quot;); jedis.hset(&quot;user:2&quot;,user2); System.out.println(jedis.hgetAll(&quot;user:1&quot;)); System.out.println(jedis.hgetAll(&quot;user:2&quot;)); /* 运行结果: &#123;name=Luck, age=18&#125; &#123;age=20, name=Jack&#125; */ &#125; @AfterEach void tearDwon()&#123; // 释放链接 if (jedis!=null) jedis.close(); &#125;&#125; 线程池:Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式 有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。 首先我们来准备一下连接池生产工厂类: 1234567891011121314151617181920public class JedisConnectionFactory &#123; private static JedisPool jedisPool; static &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); // 最大连接数 poolConfig.setMaxTotal(8); // 最大空闲链接数 poolConfig.setMaxIdle(8); // 最小空闲链接数 poolConfig.setMinIdle(0); // 设置最大等待时间 poolConfig.setMaxWaitMillis(200); // 初始化连接池对象, 同时设置ip端口,超时时间 jedisPool = new JedisPool(poolConfig,&quot;192.168.60.128&quot;,6735,2000); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; SpringDataRedisSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis 提供了对不同Redis客户端的整合（Lettuce和Jedis）, SpringBData默认使用Lettuce 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： API 返回值类型 说明 redisTemplate.opsForValue() ValueOperations 操作String类型数据 redisTemplate.opsForHash() HashOperations 操作Hash类型数据 redisTemplate.opsForList() ListOperations 操作List类型数据 redisTemplate.opsForSet() SetOperations 操作Set类型数据 redisTemplate.opsForZSet() ZSetOperations 操作SortedSet类型数据 redisTemplate 通用的命令 快速入门SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单： 首先导入依赖: 1234567891011121314151617181920 &lt;!--redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--common-pool--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--Jackson依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; springboot配置文件: 1234567891011spring: redis: host: 192.168.150.101 port: 6379 password: 123321 lettuce: pool: max-active: 8 #最大连接 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100ms #连接等待时间 测试代码: 12345678910@SpringBootTestclass SpringDataRedisApplicationTests &#123; @Autowired private RedisTemplate&lt;String, String&gt; redisTemplate; @Test void String() &#123; redisTemplate.opsForValue().set(&quot;name&quot;, &quot;顾北&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;)); &#125;&#125; 数据序列化SerializerRedisTemplate可以接收任意Object作为值写入Redis： 只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的： 缺点： 可读性差 内存占用较大 我们可以自定义RedisTemplate的序列化方式，代码如下： 在com.项目名xxx.redis.config包下创建: 12345678910111213141516171819202122@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123; // 创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 设置连接工厂 template.setConnectionFactory(connectionFactory); // 创建JSON序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 设置Key的序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // 设置Value的序列化 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); // 返回 return template; &#125;&#125; 整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。 为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间 这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。 省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用： 123456789101112131415161718192021@SpringBootTestclass SpringDataRedisApplicationTests &#123; // 使用 StringRedisTemplate @Autowired private StringRedisTemplate redisTemplate; @Test void String() throws JsonProcessingException &#123; // 使用 jackson 库 解析 JSON ObjectMapper objectMapper = new ObjectMapper(); User user = new User(&quot;南城&quot;,20); // 讲 Java对象序列化成 JSON后插入 String jsonStr = objectMapper.writeValueAsString(user); redisTemplate.opsForValue().set(&quot;user:200&quot;,jsonStr); // 讲 JSON 字符串取出来后反序列化成Java对象 final String s = redisTemplate.opsForValue().get(&quot;user:200&quot;); User o = objectMapper.readValue(s,User.class); System.out.println(o); &#125;&#125; 最后小总结： RedisTemplate的两种序列化实践方案： 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，手动把对象序列化为JSON 读取Redis时，手动把读取到的JSON反序列化为对象 Hash结结构和其他结构操作Hash结构时需要注意: api 不是类似原生的Redis命令风格设计,而是按照Java的Map操作api进行设计的 而其他结构如: List ,Set 等则和原生Redis命令类似 12345678910@Testvoid testHash()&#123; HashOperations&lt;String, Object, Object&gt; hashOperations = redisTemplate.opsForHash(); hashOperations.put(&quot;user:400&quot;,&quot;name&quot;,&quot;北笙&quot;); hashOperations.put(&quot;user:400&quot;,&quot;age&quot;,&quot;18&quot;); Map map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;北笙&quot;); map.put(&quot;age&quot;,&quot;17&quot;); hashOperations.putAll(&quot;user:400&quot;,map);&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://lqy679.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"mysql","slug":"mysql","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T05:00:03.146Z","comments":true,"path":"2020/01/01/mysql/","link":"","permalink":"https://lqy679.github.io/2020/01/01/mysql/","excerpt":"关系型数据库(MySQL)数据库分类关系型数据库(SQL) 如mySQL SQLserver Oracle 通过表和表之间,行列之间的关系进行数据的存储非关系型数据库(NoSQL) 如Redis, MongDB 对象存储(如key: value), 通过对象自身的属性来决定","text":"关系型数据库(MySQL)数据库分类关系型数据库(SQL) 如mySQL SQLserver Oracle 通过表和表之间,行列之间的关系进行数据的存储非关系型数据库(NoSQL) 如Redis, MongDB 对象存储(如key: value), 通过对象自身的属性来决定 MySQL 安装以及常用命令行 下载mysql安装mySQL教程:https://mp.weixin.qq.com/s/E1PM4EHwU6Joot4OG0gDjw 可自行前往官网下载,不建议使用最新版本(不稳定),随后解压到自己想要安装的地方 压缩版5.7版本下载地址: https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-winx64.zip 编写相关配置文件在mysql安装目录下,新建一个my.ini文件,文件内容如下(具体配置自行修改) 12345[mysqld]basedir=D:\\Program Files\\mysql-5.7\\ # mysql安装目录datadir=D:\\Program Files\\mysql-5.7\\data\\ # 数据存放的目录,没有需自己添加port=3306 # 配置默认端口skip-grant-tables 注意:没有data文件夹自己新建一个,与上面配置文件一致 配置环境变量(非必须)配置环境变量可以让我更方便的全局使用命令行, 一下默认有jdk的相关配置基础,默认不具体放图 在系统变量中新建变量名为MySQL,值为mysql的安装目录,在原有的系统变量Path中,添加值 %MySQL%\\bin (其实也就是相对路径映射) 安装和初始化mysql 在window下进入管理员权限的dos窗口(使用系统的搜索工具搜索cmd,然后选中右击以管理员身份运行即可进入) 随后输入命令mysqld –install (注意:没有配置变量请切换mysql的安装目录使用此命令)dos系统切换目录的命令是 cd 目录,更多请自行访问DOS命令大全 安装好后再输入初始化命令mysqld --initialize-insecure --user=mysql (注意一定要先配置好my.ini文件) 随后输入命令net start mysql启动服务 最后链接数据库即可(链接命令在下文的常用命令那里有) 常用命令**注意:**使用命令行配置系统环境变量可以不用切换到bin目录,注意,在使用安装命令和初始化命令时,请打开管理员权限的dos窗口 12345678910111213141516mysqld –install #安装mysqlmysqld --initialize-insecure --user=mysql #初始化数据文件net stop mysql #停止mysql服务net start mysql #启动mysql服务mysql -uroot -p #链接数据,随后在输入密码, 密码可以为空#修改用户密码update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host = &#x27;localhost&#x27;; flush privileges; #修改用户密码 刷新权限 ##### 注意:以下命令是在mySQL 下执行的,注意目录有个空格且命令有分号 #####show databases; # 注意有分号,且默认的mySQLuse 数据库名; # 切换到某个数据库,show tables; # 查看当前数据库下所有的表describe 表名; # 查看表的信息create database #数据库名;exit ; # 退出链接 用于获取sql的一些命令12show create table 表名 -- 查看创建表的语句,也可以常见创建库的desc 表名; --查看表的结构 关于mysql一些知识 mysql数据库的字符集编码mysql的默认字符集编码是Latin1 ,不支持中文 在创建数库表时设置1234567CREATE TABLE `user` ( `id` int(10) NOT NULL, `name` varchar(10) NOT NULL, `sex` varchar(4) DEFAULT NULL, `birthday` date DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 在my.ini配置文件中设置默认编码(不推荐): 1character-set-server=utf8 mysql的数据库引擎 INNODB MYISAM 事务支持 支持 不支持 数据行锁定 支持 不支持 外键约束 支持 不支持 全文索引 不支持 支持 表空间的大小 较大,为myisam的两倍 较小 常规使用操作: MYISAM 节约空间，速度较快 INNODB 安全性高，事务的处理，多表多用户操作 **在物理空间存在的位置:**所有的数据库文件都在data目录下,本质还是文件的存储！ Mysql引擎在物理引擎文件上面的区别 innoDB 在数据库表中只有一个**fm文件 *.frm表结构的定义文件 .MYD文件 数据文件* *.MYI 索引文件 mysql 的常用数据类型 数值 int 4 字节 比较常用 bigint 8字节 float 浮点数 4字节数 double 浮点数 8字节 decimal 字符串形式的浮点数 (用于金融计算) 字符串 char 固长字符串(0-255) varchar 可变字符串(0-65535) tinytext 微型文本 2^8-1 text 文本串 2^16-1 日期时间(以字面量表示要有引号) date YYYY-MM-DD ,日期格式 time HH:mm:ss 时间格式 datetime YYYY-MM-DD HH:mm:ss 最常用的时间格式 timestamp 时间戳 1970年1月1日到现在的毫秒数 mysql常用函数 数学函数: ABS() : 返回绝对值 abs CEILING() : 天花板函数 ceiling FLOOR() : floor 地板函数 RAND() – 返回0-1的随机数 rand() 字符串函数: CHAR_LENGTH(‘字符串’) : char_lengrh 返回字符串长度 CONCAT(‘字符串’,’字符串’) : concat 拼接字符串 INSERT(‘字符串’,int,int,’字符串’) : insert 从指定位置替换字符串 UPPER(‘字符串’) : 转大写母 LOWER(‘字符串’) : 转小写字母 REPLACE(‘字符串’,’指定的’,’替换后的’) perlace 替换指定的字符串 日期函数 CURRENT_DATE() – 获取当前日期,current_date() CURDATE() – 获取当前日期 curdate() NOW() – 获取当前日期 now() LOCATIME() – 本地时间 localtime () SYSDATE() – 系统时间 sysdate() 系统函数 SYSTEM_USER() USER() VERSION() 12345678910111213141516171819202122232425262728293031SELECT ABS(-8) -- 绝对值SELECT CEILING(9.4) -- 向上取整SELECT FLOOR(9.4) -- 向下取整SELECT RAND() -- 返回0-1随机数SELECT SIGN(-10) -- 判断一个数的符号 0-0 负数返回-1 正数返回1-- 字符串函数SELECT CHAR_LENGTH(&#x27;2323232&#x27;) -- 返回字符串长度SELECT CONCAT(&#x27;我&#x27;,&#x27;233&#x27;) -- 拼接字符串SELECT INSERT(&#x27;java&#x27;,1,2,&#x27;cccc&#x27;) -- 从某个位置开始替换某个长度SELECT UPPER(&#x27;abc&#x27;) SELECT LOWER(&#x27;ABC&#x27;)SELECT REPLACE(&#x27;坚持就能成功&#x27;,&#x27;坚持&#x27;,&#x27;努力&#x27;)-- 查询姓 周 的同学 ，改成邹SELECT REPLACE(studentname,&#x27;周&#x27;,&#x27;邹&#x27;) FROM studentWHERE studentname LIKE &#x27;周%&#x27;-- 时间跟日期函数（记住）SELECT CURRENT_DATE() -- 获取当前日期SELECT CURDATE() -- 获取当前日期SELECT NOW() -- 获取当前日期SELECT LOCATIME() -- 本地时间SELECT SYSDATE() -- 系统时间SELECT YEAR(NOW())SELECT MONTH(NOW())SELECT DAY(NOW())SELECT HOUR(NOW())SELECT MINUTE(NOW())SELECT SECOND(NOW())-- 系统SELECT SYSTEM_USER()SELECT USER()SELECT VERSION() 聚合函数 函数名称 描述 COUNT() 计数 SUM() 求和 AVG() 平均值 MAX() 最大值 MIN() 最小值 其中 count(字段,尤其是主键)效率最高 count(1) 效率略高于count(＊) count(＊) 在只有一个字段时会优于count(1) ### mysql中的数据表 修改表字段123456ALTER TABLE 旧表名 RENAME AS 新表名 -- 修改表名 ALTER TABLE 表名 ADD 字段名 数据类型号 约束 --增加表的字段 ALTER TABLE 表名 MODIFY 字段名 VARCHAR(11) -- modify 修改约束,但不能修改名字ALTER TABLE 表名 CHANGE 字段名 新字段名 INT(1) -- change字段重命名,也可以改属性,但是名字无论是否改变都要写两次-- 删除表的字段ALTER TABLE 表名 if exists DROP 字段名 DML语言TRUNCATE和TRUNCATE的区别 相同点： 都能删除数据，都不会删除表结构 不同：TRUNCATE 重新设置自增列 计数器会归零TRUNCATE 不会影响事务 mysql事务 **原子性（Atomicity）:**要么都成功，要么都失败 一致性（Consistency）: 事务前后的数据完整性要保持一致 持久性（Durability): 事务一旦提交就不可逆转，被持久化到数据库中,提交不成功就恢复原状 隔离性: 事务产生多并发时，互不干扰 事务隔离级 Read UnCommitted(读未提交)最低的隔离级别。一个事务可以读取另一个事务并未提交的更新结果。 Read Committed(读提交)大部分数据库采用的默认隔离级别。一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以的读取到同一笔数据更新后的结果。 Repeatable Read(重复读)mysql的默认级别。整个事务过程中，对同一笔数据的读取结果是相同的，不管其他事务是否在对共享数据进行更新，也不管更新提交与否。 Serializable(序列化)最高隔离级别。所有事务操作依次顺序执行。注意这会导致并发度下降，性能最差。通常会用其他并发级别加上相应的并发锁机制来取代它。 事务隔离级常见问题:参考链接: https://www.cnblogs.com/balfish/p/8298296.html 脏读: 指一个事务读取了另外一个事务未提交的数据(即不要的数据,脏的数据).这跟不可重复读类似，但是第二个事务不需要执行提交。 虚读(幻读): 是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。（重点是可能由于其他数据插入了所需要查询的数据,行数变了导致不一样） **不可重复读:**在一个事务内读取表中的某一行数据，多次读取结果不同。（重点是由于别的事务对数据进行了更改,导致两次读取的值不一样） 规范数据库设计 糟糕的数据库设计: 数据冗余,浪费空间 数据库插入和删除都会麻烦,异常(屏蔽使用物理外键) 程序的性能差 良好的数据库设计: 节省内存空间 保证数据库的完整性 方便我们开发系统 软件开发中,关于数据库的开发设计: 分析需求 概要设计:设计关系图E-R图 三大范式注:每个范式都必须满足前一个范式 第一范式(1NF)原子性: 保证每一列不可再分 第二范式(2NF)完全依赖:非主属性完全依赖于主键 第三范式(3NF)消除传递依赖:非主属性必须直接依赖于主键 规范性和性能的问题关联查询的表不得超过三张表 考虑商业化的需求和目标,数据库性能更重要 在规范性能问题时,适当考虑规范性 故意给某些表增加一些冗余字段(从表查询变为单表查询) 故意增加一些计算列(从大数据量降低为小数据量的查询:索引) JDBC(重点) JDBC介绍Sun公司为了简化开发人员的(对数据库的统一)操作,提供了(Java操作数据库的)规范,俗称JDBC,这些规范的由具体由具体的厂商去做对于开发人员来说,我们只需要掌握JDBC接口的操作即可 所需要的jar包 java.sql(默认有) javax.sql(默认有)还需要导入数据库驱动包 java程序链接mySQL==注意! 增删改操作都需要提交事务== 步骤: 加载驱动 登陆链接数据库对象 创建statement对象,用于执行sql语句 statement(清单) 执行sql语句 返回结果集,结果集中封装了我们查询的所有结果 释放链接 12345678910111213141516171819202122232425262728 // 1.加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //协议://主机:端口/数据库名?编码设置&amp;使用安全的链接 String url = &quot;url=jdbc:mysql://localhost:3306/db01?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&quot;; String use = &quot;root&quot;; //用户名 String password = &quot;123456&quot;; //密码 //2.登陆链接数据库对象 Connection connection = DriverManager.getConnection(url, use, password); //3.创建statement对象,用于执行sql语句 statement(清单) Statement statement = connection.createStatement(); //4.执行sql语句 String sql = &quot;SELECT * from class&quot;; //sql语句 //5.返回结果集,结果集中封装了我们查询的所有结果 ResultSet resultSet = statement.executeQuery(sql); while (resultSet.next())&#123; System.out.println(&quot;classno:&quot;+resultSet.getNString(&quot;classno&quot;)); System.out.println(&quot;classname:&quot;+resultSet.getNString(&quot;classname&quot;)); System.out.println(&quot;department:&quot;+resultSet.getNString(&quot;department&quot;)); System.out.println(&quot;monitor(班长):&quot;+resultSet.getNString(&quot;monitor(班长)&quot;)); System.out.println(&quot;==========================================================&quot;); &#125; //6.释放链接 resultSet.close(); statement.close(); connection.close(); &#125;&#125; 几个重要对象DirverManager 驱动管理 12Class.forName(&quot;com.mysql.jdbc.Driver&quot;);DriverManager.registerDriver(new Driver()); //这是Driver源码 URL 资源地址 12//协议://主机:端口/数据库名?时区设置&amp;编码设置&amp;使用安全的链接String url = &quot;url=jdbc:mysql://localhost:3306/db01?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&quot;; Connection 链接对象,操作数据库的对象 123456789connection.commit(); //提交事务connection.rollback(); //回滚事务connection.setAutoCommit(); //自动提交事务/* Statemen 清单,执行sql的对象 */```javastatement.executeQuery(&quot;sql&quot;); //执行查询,返回结果集statement.executeUpdate(&quot;sql&quot;); //执行更新(插入和删除也算更新),返回受影响的行数statement.execute(&quot;sql&quot;); //执行全部的sql语句 ResultSet:查询后的结果集 获取数据: 12345resultSet.getNString();resultSet.getObject(); //不知道什么类型的情况下使用resultSet.getInt();resultSet.getDate();resultSet.getFloat(); 指针移动: 12345resultSet.next();resultSet.previous();resultSet.absolute();resultSet.beforeFirst();resultSet.afterLast(); 关闭链接 123resultSet.close();statement.close();connection.close(); SQL注入的问题SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。即:通过sql语句的漏洞来实现一些非法操作. 12// 欲根据用户id来进行获取用户的其他信息,但是使用如下语句就会将所有用户的信息都查询到select * from db01.user where (id =&#x27; &#x27;or 1=1)&quot;; --sql注入 PreparedStatement对象可以防止sql注入,并且效率更高,如:在编辑sql语句时使用?代表占位符,并且预编译sql语句,随后在设置参数防止sql注入 常用方法:123456preparedStatement.executeQuery();preparedStatement.executeUpdate();preparedStatement.setString(); //给参数传递字符串类型的值preparedStatement.setInt(); //给参数传递 int 类型的值preparedStatement.setDate(); //给参数传递 Date 类型的值... 等等 例子: 12345678//带参数的sql语句String sql = &quot;select * from db01.user where(id = ?)&quot; ;//预编译sql语句并且返回一个PreparedStatement对象preparedStatement = con.prepareStatement(sql);//给参数传递值(适当的使用对应类型的方法能提高效率)preparedStatement.setString(1,id); //注意下标从1开始//运行sql语句resultSet = preparedStatement.executeQuery(); 解藕,封装工具类我们可以将配置信息编写成配置文件(xxx.properties),然后通过Properties类读取文件内容对应参数来配置信息 配置文件db.properties, 我们需要将此配置文件放入字节码的相同路径(maven项目的resources目录下) 123456# 驱动类名driver=com.mysql.cj.jdbc.Driver# //协议://主机:端口/数据库名?设置时区&amp;编码设置&amp;使用安全的链接协议url=jdbc:mysql://localhost:3306/db01?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=trueuser=rootpassword=123456 JdbcUtil类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package SQL_injection;import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JdbcUtility &#123;// 初始化变量,并且避免作用域问题 static Properties properties = new Properties(); static Connection con = null; static PreparedStatement preparedStatement = null; static ResultSet resultSet = null; static String username = null; static String password = null; //初始化配置 static &#123; // 获取输入流, 通过此类的类加载器获取类加载路径,进而获取到配置文件的输入流 InputStream in = JdbcUtility.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); try &#123; // 通过properties对象加载配置文件的输入流 properties.load(in);//相当于加载驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 只不过是将配置文件的driver参数获取出来 JdbcUtility.class.forName(properties.getProperty(&quot;driver&quot;)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //使用配置文件内容信息链接数据库 public JdbcUtility()&#123; try &#123; //获取配置文件信息 String url = properties.getProperty(&quot;url&quot;); String user = properties.getProperty(&quot;user&quot;); String password = properties.getProperty(&quot;password&quot;); // 根据参数链接数据库 con = DriverManager.getConnection(url,user,password); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; //使用自定义的用户名和密码登陆数据库 public JdbcUtility(String username,String password)&#123; try &#123; con = DriverManager.getConnection(properties.getProperty(&quot;url&quot;), username, password); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; public boolean select(String id)&#123; String sql = &quot;select * from db01.user where(id = ?)&quot; ; //执行查询语句 try &#123; preparedStatement = con.prepareStatement(sql); preparedStatement.setString(1,id); resultSet = preparedStatement.executeQuery(); if(!resultSet.next()) &#123; System.out.println(&quot;查询失败!&quot;); return false; &#125; &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; return true; &#125; public void getResult()&#123; try &#123; do &#123; System.out.print(&quot;id:&quot;+resultSet.getString(1)+&quot;\\t&quot;); //System.out.println(&quot;password:&quot;+resultSet.getString(0)+&quot;\\t&quot;); System.out.print(&quot;name:&quot;+resultSet.getString(3)+&quot;\\t&quot;); System.out.print(&quot;sex:&quot;+resultSet.getString(4)+&quot;\\t&quot;); System.out.print(&quot;birthday:&quot;+resultSet.getString(5)+&quot;\\t&quot;); System.out.println(); &#125; while (resultSet.next()); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public void insert(String id ,String name,String sex )&#123; String sql = &quot;insert into db01.user (id,name,sex,birthday) &quot; + &quot;values(?,?,?,?)&quot; ; try &#123; preparedStatement = con.prepareStatement(sql); preparedStatement.setString(1,id); preparedStatement.setString(2,name); preparedStatement.setString(3,sex); Date date = new Date(new java.util.Date().getTime()); preparedStatement.setDate(4,date); int n = preparedStatement.executeUpdate(); if (n == 0) System.out.println(&quot;插入失败!&quot;); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; //删除 public void delete(String id)&#123; String sql = &quot;delete from db01.user where(id = ?);&quot; ; try &#123; preparedStatement = con.prepareStatement(sql); preparedStatement.setString(1,id); if (preparedStatement.executeUpdate()==0) System.out.println(&quot;删除失败!&quot;); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; public void update(String id,String columnname,String value)&#123; String sql = &quot;update db01.user set &quot;+columnname +&quot; = ? where (id = ? )&quot; ; try &#123; preparedStatement = con.prepareStatement(sql); //preparedStatement.setString(1,columnname); preparedStatement.setString(1,value); preparedStatement.setString(2,id); if(preparedStatement.executeUpdate()==0) System.out.println(&quot;更新失败&quot;); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; //关闭 public void close()&#123; try &#123; resultSet.close(); con.close(); preparedStatement.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125;&#125; JDBC操作事务==注意! 增删改操作都需要提交事务== 常用方法123connection.setAutoCommit(boolean flag); //设置事务是否自动提交,默认是提交的connection.commit(); //提交事务connection.rollback(); //回滚事务,一般不用设置,事务一般发送错误会自动回滚 下面代码是模拟一笔转账操作,A账户减少100元,B账户增加100元,两个sql操作为一个事务,同时执行成功或者失败(失败事务发生回滚) 12345678910111213141516171819JdbcUtility jdbc = new JdbcUtility();try &#123; //关闭自动提交事务 jdbc.con.setAutoCommit(false); //进行一笔转账操作,其中update()方法,参数1代表付款或者收款人,参数2代表是否收款 jdbc.update(&quot;A&quot;,true); jdbc.update(&quot;B&quot;,false); //提交一笔转账事务 jdbc.con.commit(); &#125; catch (SQLException throwables) &#123; try &#123; //实际上事务会自动回滚当出现错误时 jdbc.con.rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; throwables.printStackTrace();&#125; 数据库链接池池化技术:准备一些预先资源,过来就连接预先准备好的 123456数据库---＞执行完毕---＞释放 这种方式十分浪费资源相关概念:常用连接数: 10最小连接数: 5最大连接数: 15等待超时: 100ms 连接池，必须实现接口 DateSource 开源数据源实现技术使用了以下的数据库连接池后,我们以后项目开发中就不需要编写连接数据库的代码了,DBCP: Spring 推荐使用C3P0: Hibernate 推荐使用c3p0Druid: 阿里巴巴的技术 123456789 /*****************这是使用DBCP来连接数据库的操作***************************/static InputStream in = JdbcUtilityDemo.class.getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;);static Properties properties = new Properties();static BasicDataSource dateSource = null;properties.load(in);//创建数据源 工厂模式--&gt;; 创建对象dateSource = BasicDataSourceFactory.createDataSource(properties);//最后再得到连接dateSource.getConnection(); 总结:使用数据库连接池本质上就是帮助开发人员省区来连接数据库的操作,使得我们只需要获取其来连接对象Connection即可无论使用什么数据源，本质是不变的，DateSource接口不会变，方法就不会变","categories":[{"name":"数据库","slug":"数据库","permalink":"https://lqy679.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"SpringMVC","slug":"SpringMVC","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T11:39:57.595Z","comments":true,"path":"2020/01/01/SpringMVC/","link":"","permalink":"https://lqy679.github.io/2020/01/01/SpringMVC/","excerpt":"SpringMVCMVC MVC是**模型(Model)、视图(View)、控制器(Controller)**的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。","text":"SpringMVCMVC MVC是**模型(Model)、视图(View)、控制器(Controller)**的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 Model时代Model1时代: 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model2时代:Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析:Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 MVC框架需要做哪些事 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： ​ 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. 关于三层架构 参考链接:Java中DAO层、Service层和Controller层的区别诚o的博客-CSDN博客 DAO层：DAO层叫数据访问层，全称为data access object，属于一种比较底层，比较基础的操作，具体到对于某个表的增删改查，也就是说某个DAO一定是和数据库的某一张表一一对应的，其中封装了增删改查基本操作，建议DAO只做原子操作，增删改查。 Service层：Service层叫服务层，被称为服务，粗略的理解就是对一个或多个DAO进行的再次封装，封装成一个服务，所以这里也就不会是一个原子操作了，需要事务控制。 Controler层：Controler负责请求转发，接受页面过来的参数，调用对应的Service进行处理，接到返回值，再传给页面。 总结：个人理解DAO面向表，Service面向业务。后端开发时先数据库设计出所有表，然后对每一张表设计出DAO层，然后根据具体的业务逻辑进一步封装DAO层成一个Service层，对外提供成一个服务. 回顾Servlet所需要的依赖包 12345678910111213141516171819&lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; servlet: 12345678910111213141516171819202122232425262728293031import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.annotation.*;import java.io.IOException;@WebServlet(name = &quot;HelloServlet&quot;, value = &quot;/hello&quot;)public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); if (request.getParameter(&quot;method&quot;).equals(&quot;add&quot;))&#123;// request.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;); request.setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;); //由于是请求转发,用这个也可以 &#125; else if(request.getParameter(&quot;method&quot;).equals(&quot;delete&quot;))&#123; request.setAttribute(&quot;msg&quot;,&quot;执行了delete&quot;); &#125; else &#123; System.out.println(&quot;错误!&quot;); &#125; request.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(request,response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request,response); &#125;&#125; jsp页面,注意,放在WEB-INF目录下也可行: 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 使用带参数的url测试: localhost:8080/method?method=add localhost:80808/method?method=delete Spring MVC初识 官方文档:Spring-MVC Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 最重要的一点还是用的人多 , 使用的公司多 . ==Spring的web框架围绕DispatcherServlet [ Servlet调度 ] 设计。== DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . DispatcherServlet​ Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 ​ Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。 执行原理: 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。**DispatcherServlet调用HandlerMapping(请求处理器映射),HandlerMapping根据请求url查找Handler。(请求处理器)** HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 HandlerExecution(请求处理执行器)表示具体的Handler,其主要作用通过HandlerAdapter(处理器适配器)是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 Handler让具体的Controller执行。 Controller(控制器)将具体的执行信息(如ModelAndView)返回给HandlerAdapter。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 **ViewResolver(视图解析器)**将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 几个重要的对象DispatcherServlet(Servlet调度): 负责对所有请求响应工作的协调调度,所有的用户请求都会最先被他拦截以决定如何处理(即调度),受到请求后会调用HandlerMapping(处理器映射); 并且还会将从处理器适配那里获得的模型视图通过ViewResolver(视图解析器)解析后返回给用户 HandlerMapping(处理器映射): 通过Servlet调度对象发送来的url返回给一个HandlerExecution(请求处理执行器)给Servlet调度对象. HandlerAdapter(处理器适配器): 会收到Servlet调度发来的HandlerExecution(请求处理执行器),然后按照特定的规则去执行Handler , 并且返回ModelAndView模型视图给Servlet调度对象 Controller(控制器)即Hander: 将具体的执行信息(如ModelAndView模型视图)返回给HandlerAdapter处理器适配器 ViewResolver(视图解析器): 解析模型视图,返回给Servlet调度对象 入门程序:所需要的相关依赖包: 123456789101112131415161718192021222324252627282930313233&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- ServletAPI --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt;&lt;/dependency&gt; 配置文件实现:首先在web.xml中注册Servlet ,这个Servlet是调度对象DispatcherServlet 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml 这个Spring配置文件将 处理映射器,处理适配器,模板视图解析器,以及我们自己编写的执行控制器(类似Servlet) 都交给了Spring进行管理--&gt; &lt;!--为Servlet调度对象初始化处理映射器,处理适配器,模板视图解析器,以及执行控制器--&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!--启动级别-1--&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 注意!!! / 匹配所有的请求；（不包括.jsp） /* 匹配所有的请求；（包括.jsp） --&gt; &lt;!-- 因为Servlet调度对象需要拦截接管所有请求,所以需要将它的映射路径设置为根路径 / --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Spring的配置文件,名字可以随意,但一般使用将其命名为 Servlet名-servlet.xml,由于是第一个mvc程序我将其命名成了springmvc-servlet.xml, 这个配置文件将一些重要的对象交给了spring管理,并且web.xml文件中注册的调度servlet初始化时关联引用了此文件的信息, 此外,我们以后编写的执行控制器(也就是servlet)也将在此文件下配置(即交给spring管理) 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 添加处理映射器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;&lt;!-- 添加处理适配器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;!--模型视图解析器:DispatcherServlet给他的ModelAndView--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;&lt;!-- 设置视图解析寻找识别规则 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--前缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;!--后缀--&gt; &lt;/bean&gt;&lt;!-- 注意! 这里的bean id 就相当于Servlet的Mapper映射url,即使请求路径,所以 / 是必须的--&gt; &lt;bean id=&quot;/hello&quot; class=&quot;HelloController&quot;/&gt;&lt;/beans&gt; 自己编写的执行控制器HelloController.java,就类似以前javaweb中编写的servlet 123456789101112131415161718import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;// 本质上就是对Servlet的再次封装public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv = new ModelAndView(); // 创建视图模型 mv.setViewName(&quot;hello&quot;); // 设置视图的名称,注意!这里一定要与jsp或html前端页面的文件名一致 //下面是设置模型视图的属性名和属性值,类似request.setAttribute()方法 mv.addObject(&quot;msg&quot;,&quot;你好!SpringMVC&quot;); return mv; //返回给模型视图解析器 &#125;&#125; 前端页面:hello.jsp 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 注解实现:web.xml基本与上个例子基本一致,用于注册Servlet调度 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!--启动级别-1--&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 注意!!! / 匹配所有的请求；（不包括.jsp） /* 匹配所有的请求；（包括.jsp） --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Spring的Servlet配置文件springmvc-servlet.xml ,注意! 由于使用了注解,还需要开启Spring的组件注解扫描,以及SpringMVC的注解驱动等, 同时也不要在加我们编写的Controller实现类加入Spring容器中(因为注解已经帮我们做了) 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--指定注解扫描包--&gt; &lt;context:component-scan base-package=&quot;hello_annotation&quot;/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt;&lt;!-- 添加处理映射器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;&lt;!-- 添加处理适配器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;!--模型视图解析器:DispatcherServlet给他的ModelAndView--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;&lt;!-- 设置视图解析寻找识别规则 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--前缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;!--后缀--&gt; &lt;/bean&gt;&lt;/beans&gt; 编写控制器,我们不在需要实现Controller接口重写handleRequest方法,我们给类标上@Controller注解后,随后在类中编写的方法标注上 @RequestMapping(&quot;请求的url&quot;)后,一个方法相当于一个Servlet,不需要在Spring中注册了,注意!这个方法叫做请求映射方法,要为public 1234567891011121314151617181920212223package hello_annotation;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Controller // 类级别的注解public class HelloControllerAnnotaion&#123; // 注意!!! 方法一定要是 public @RequestMapping(&quot;/hello2&quot;) // 注意!!! 这个注解是方法级别的(如果放在类名上就是多级目录),设置请求的url(注意! 请求时如果有项目名要加项目名) /* * 这样标注了注解的方法相当于一个Servlet, * 不过需要返回一个字符串,这个字符串的内容就是视图模型名,视图模型解析器根据此名字进行解析(在Spring配置文件中进行了配置) * 此外可以在方法可以接收视图模型对象,请求头,响应头等对象参数,以供使用 * */ public String sayHello(Model model, HttpServletRequest request, HttpServletResponse response)&#123; model.addAttribute(&quot;msg&quot;,&quot;这是注解实现的Hello SpringMVC呀!&quot;); System.out.println(request); String viewName = &quot;hello&quot;; return viewName; &#125;&#125; 前端页面:hello.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 小结: 编写web.xml , 注册DispatcherServlet以及根路径映射 编写springmvc配置文件(必须配置处理器映射器、处理器适配器、视图解析器) 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 @RequestMappingSpring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 可以通过参数设置限定接收的请求方法类型: 1@RequestMapping(value = &quot;/method&quot;,method = &#123;RequestMethod.POST&#125;) // 只接收post请求,不设置则接收所有请求 限定类型的请求映射12345@GetMapping(&quot;/url&quot;)@PostMapping(&quot;/url&quot;)@PutMapping(&quot;/url&quot;)@DeleteMapping(&quot;/url&quot;)@PatchMapping(&quot;/url&quot;) 设置编码与响应体:1@RequestMapping(value = &quot;url&quot;,produces = &quot;application/json;charset=utf-8&quot;) @ResponseBody一般情况下被@RequestMapping标注的方法一般是返回一个视图名然后交给视图解析器解析,所以返回的最终是一个页面,我们也可以使用**@ResponseBody将此方法设置为响应体,进行这样标注后方法的返回值将作为数据返回给前面页面** RestFul 风格Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get ​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET ​ http://127.0.0.1/item/saveItem.action 新增,POST ​ http://127.0.0.1/item/updateItem.action 更新,POST ​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源(通过限定请求类型实现) ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ ​ http://127.0.0.1/item/1 查询,GET ​ http://127.0.0.1/item 新增,POST ​ http://127.0.0.1/item 更新,PUT ​ http://127.0.0.1/item/1 删除,DELETE 路径参数12345678910@Controllerpublic class RestFulControl &#123;// 路径参数 , 根据路径参数返回相加结果,这就是Restul风格,传统风格下使用问号分隔请求url和参数,参数之间用&amp;分隔 @RequestMapping(&quot;/add/&#123;var1&#125;/&#123;var2&#125;&quot;) // &#123;方法参数名&#125; 占位符用于将路径的值传给(被注解的)方法参数,注意一下数据类型 String pathAdd(Model model, HttpServletResponse response, @PathVariable int var1,@PathVariable int var2)&#123; model.addAttribute(&quot;res&quot;,var1+var2); return &quot;result&quot;; &#125; @RequestMappingSpring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 可以通过参数设置限定接收的请求方法类型: 1@RequestMapping(value = &quot;/path&quot;,method = &#123;RequestMethod.POST&#125;) // 只接收post请求,不设置则接收所有请求 限定类型的请求映射12345@GetMapping(&quot;/url&quot;)@PostMapping(&quot;/url&quot;)@PutMapping(&quot;/url&quot;)@DeleteMapping(&quot;/url&quot;)@PatchMapping(&quot;/url&quot;) 设置编码与响应体:1@RequestMapping(value = &quot;url&quot;,produces = &quot;application/json;charset=utf-8&quot;) 请求与数据处理请求结果跳转的方式:Servlet API通过设置ServletAPI , 不需要视图解析器 . 1、通过HttpServletResponse进行输出 2、通过HttpServletResponse实现重定向 3、通过HttpServletResponse实现转发 1234567891011121314151617181920212223242526package control;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.ServletException;import javax.servlet.http.*;import java.io.IOException;@Controllerpublic class SkipController &#123; // Servlet API(请求头响应头) 实现请求转发或者重定向 @RequestMapping(&quot;/s1_&#123;pram&#125;&quot;) public void servletApi(HttpServletRequest request ,HttpServletResponse response,@PathVariable String pram) throws ServletException, IOException &#123; //注意! 方法要为public if (&quot;forward&quot;.equals(pram))&#123; request.getRequestDispatcher(&quot;/WEB-INF/jsp/page.jsp&quot;).forward(request,response); &#125; else if (&quot;redirect&quot;.equals(pram))&#123; response.sendRedirect(&quot;/project_name/index.jsp&quot;); /* 重定向与请求转发不同不能访问WEB-INF下的内容, 此外使用重定向就不能再返回一个视图名了, 要把方法返回值改为 void 此外,响应头实现的重定向是要写全项目名的(可以跳转到外链) */ &#125; &#125;&#125; 注意点: 请求映射方法要设置为public 重定向时请求映射方法不能再返回视图名了,要设置为void,转发时可以因为转发优先于返回视图名 重定向要写全项目名(应用程序上下文) 不要忘记开启Spring配置文件的注解扫描和MVC的注解驱动扫描 ModelAndView设置ModelAndView对象 , ==根据view的名称== , 让视图解析器解析后让Servlet调度对象执行对应跳转操作 . 页面(含路径文件名) : {视图解析器前缀} + forward:或redirect:viewName +{视图解析器后缀} 12345678910111213141516171819202122232425262728package control;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controllerpublic class SkipController &#123; // 使用SpringMVC实现转发和重定向,编写特定规则的视图名让Servlet调度实现 @RequestMapping(&quot;/s2_&#123;pram&#125;&quot;) public String springMVC(@PathVariable String pram, Model model)&#123; if (&quot;forward&quot;.equals(pram))&#123; model.addAttribute(&quot;msg&quot;,&quot;请求转发呀!&quot;) ; return &quot;forward:/WEB-INF/jsp/page.jsp&quot;; &#125; else if (&quot;redirect&quot;.equals(pram))&#123;// return &quot;redirect:/index.jsp&quot; ; //注意!!! SpringMVC的重定向不要写项目名,默认带了项目名// return &quot;redirect:https://www.baidu.com&quot;; //但是又可以跳转外链,哈哈哈哈 &#125; return &quot;page&quot;; //这里 返回的视图 本质上也是一个由Servlet调度实现的请求转发 &#125;&#125; 注意与总结: SpringMVC的重定向若是内链则不需要写项目名了 org.springframework.web.servlet.view.InternalResourceViewResolver,在只使用SpringMVC的转发和重定向时,不是必须配置的,由此可知解析器只负责解析页面路径名称 映射方法返回的视图名跳转页面实际上也是一个通过Servlet调度实现的请求转发 数据处理接收数据在Servlet中我们通常通过Request,Session,Cookie等获取前端参数,而在SpringMVC中可直接在请求映射方法中声明参数来获得参数,参数名一致时可以直接使用,不一致则需要用到注解@RequestParam(前端请求参数名),此外,请求的参数名与方法参数不一致的时候可能会使接收的参数为null 补充: ** @RequestBody注解用于获取请求体的前端请求参数**, @RequestParam用于获取请求头的前端请求参数 例如请求的url为:http://localhost:8080/project_name/d1?username=南城 12345678910111213141516package control;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class DataProcessController &#123; @RequestMapping(&quot;/d1&quot;) public String receive(Model model,@RequestParam(&quot;username&quot;) String name)&#123; String str = &quot;前端传来的参数为:&quot;+name; model.addAttribute(&quot;msg&quot;,str); return &quot;page&quot;; &#125;&#125; 此外,如果接收的参数过多,可以在Java中构建实体类bean来进行映射,从而使用对象作为参数类接收,不过参数名要和对象属性名一致(顺序可以不一致) 例如请求的url为:http://localhost:8080/project_name/d2?name=小有&amp;id=001 12345678910111213141516package control;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import pojo.User; //接收对象 @RequestMapping(&quot;/d2&quot;) public String receiveObject(Model model, User user)&#123; String str = user.toString(); model.addAttribute(&quot;msg&quot;,str); return &quot;page&quot;; &#125;&#125; 发送数据在学习Servlet中我们可以通过响应头调用输出流方法向前端返回数据 , 在SpringMVC我们之前已经用过的方法是通过给模型,视图模型添加属性来向前端返回数据,此外还可以通过注解@ResponseBody ,@RestController使用控制器变成响应返回数据的Servlet而不是返回视图模型让解析器解析 通过响应体返回数据:@ResponseBody: 用于请求映射方法上(注解为@RequestMapping的方法) ,加上@ResponseBody后 , 方法的返回值将不再默认的返回视图名供给解析器解析 , 而是作为响应体返回数据 @RestController:作用在类上,相当于一个衍生的@Controller , 用了此注解的这个控制器(类)的方法都相当于加了@ResponseBody 123456789101112131415161718192021222324252627package control;import com.alibaba.fastjson.JSONObject;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import pojo.User;/*将Java对象转换成json字符串返回给前端 */@Controllerpublic class RespondJson &#123; //produces:指定响应体返回类型和编码 @RequestMapping(value = &quot;/t1&quot;,produces = &quot;text/json;charset=utf-8&quot;) @ResponseBody // 将方法返回值标注为响应体信息,即方法不再返回视图名给解析器而是直接作为响应体返回信息 public String t1()&#123; String date = &quot;&quot;; User u = new User(201,&quot;南城&quot;); JSONObject josn_u = new JSONObject(); josn_u.put(&quot;id&quot;,u.getId()); josn_u.put(&quot;name&quot;,u.getName()); date = josn_u.toJSONString(); return date; &#125;&#125; 前端页面会显示: {“name”:”南城”,”id”:201} 假设url为: localhost:8080/t2/&#123;&quot;id&quot;:201,&quot;name&quot;:&quot;南城&quot;&#125; , 会将路径参数JSON字符串转换为java对象 12345678910111213141516@RestController // 响控制器,标注了此注解的类的所有请求映射方法都默认被标注为@RespondBody ,直接向前端返回数据public class ReceiveJSON_Respond &#123; /*接收前端的路径参数,此路径参数为json字符串,随后将json字符串转换成Java对象 */ @RequestMapping(value = &quot;/t2/&#123;json&#125;&quot;,produces = &quot;text/json;charset=utf-8&quot;) public String test2(@PathVariable String json)&#123; String date = &quot;已经接收!&quot;; JSONObject jsonObject = (JSONObject) JSONObject.parse(json); User u = new User((int)jsonObject.getIntValue(&quot;id&quot;),jsonObject.getString(&quot;name&quot;)); System.out.println(u); return date; &#125;&#125;// 后台打印结果为: User&#123;id=201, name=&#x27;南城&#x27;&#125; 将前端表单页面的数据(JSON对象数组)传到后台,然后变量打印这个对象数组 页面代码, 表单文本框里输入的内容为: [&#123;&quot;id&quot;:201,&quot;name&quot;:&quot;南城&quot;&#125;,&#123;&quot;id&quot;:212,&quot;name&quot;:&quot;小岛&quot;&#125;] 12345678910111213&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;发送JSON对象:&lt;/h3&gt; &lt;form action=&quot;/projectname/t3&quot; method=&quot;get&quot; &gt; &lt;!--注意! 前端请求路径要写全项目名--&gt; 字符串:&lt;input type=&quot;text&quot; name=&quot;json&quot;&gt; &lt;br&gt; &lt;!--一定要有name属性,后端根据此属性名找value--&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;哎嘿,发送&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; Java后台: 12345678910111213141516171819202122232425262728293031323334package control;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import pojo.User;import javax.servlet.http.HttpServletRequest;import java.util.ArrayList;import java.util.List;@RestController // 响控制器,标注了此注解的类的所有请求映射方法都默认被标注为@RespondBody ,直接向前端返回数据public class ReceiveJSON_Respond &#123; //获取前端传递的数组 @RequestMapping(value = &quot;/t3&quot;,produces = &quot;text/json;charset=utf-8&quot;) public String getJsonArray(HttpServletRequest request)&#123; String json = request.getParameter(&quot;json&quot;); // 获取请求参数,来自表单的参数json JSONArray jsonArray = JSONObject.parseArray(json); //将字符串转换成JSON数组 List&lt;User&gt; list = jsonArray.toJavaList(User.class); // 将JSON数组转换成java集合 for (User u:list) &#123; //遍历集合 System.out.println(u); &#125; String date = &quot;已接收!&quot; ; return date; &#125;&#125;/* 打印结果:User&#123;id=201, name=&#x27;南城&#x27;&#125;User&#123;id=212, name=&#x27;小岛&#x27;&#125;/* 通过Model返回视图:通过Model 123456789// 通过添加模型对象属性@RequestMapping(&quot;/ct2/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;msg&quot;,name); System.out.println(name); return &quot;test&quot;;&#125; 通过ModelMap,ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； 12345678@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;name&quot;,name); System.out.println(name); return &quot;hello&quot;;&#125; 通过模型视图对象ModelAndView, 本质是结合了ModelMap和View ,与这两者没有继承关系,是借用两者实现的 123456789public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); // 设置视图名,即需要跳转的对象 return mv; //返回一个模型视图对象 &#125;&#125; 就对于新手而言简单来说使用区别就是： Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 乱码问题方案一:修改web.xml添加过滤器以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .修改了xml文件需要重启服务器！ 在web.xml中添加过滤器 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 . 我们可以使用修改tomcat配置文件 ：设置编码！ 方案二:修改Tomcat配置在tomcat目录下的conf目录下的server.xml文件中,修改如下节点 123&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 方案三:自定义过滤器 如下过滤器代码摘抄自网络 编写好如下过滤器后,还需要在web.xml中注册配置一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.kuang.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/*** 解决get和post请求 全部乱码的过滤器*/public class GenericEncodingFilter implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125;&#125;//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123; private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) &#123; super(request);// super必须写 this.request = request; &#125; // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() &#123; // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(&quot;post&quot;)) &#123; // post请求 try &#123; // 处理post乱码 request.setCharacterEncoding(&quot;utf-8&quot;); return request.getParameterMap(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123; // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) &#123; String[] values = parameterMap.get(parameterName); if (values != null) &#123; for (int i = 0; i &lt; values.length; i++) &#123; try &#123; // 处理get乱码 values[i] = new String(values[i] .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; hasEncode = true; &#125; return parameterMap; &#125; return super.getParameterMap(); &#125; //取一个值 @Override public String getParameter(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) &#123; return null; &#125; return values[0]; // 取回参数的第一个值 &#125; //取所有值 @Override public String[] getParameterValues(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; &#125;&#125; 拦截器SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器: servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 自定义拦截器那如何实现拦截器呢？ 想要自定义拦截器，必须实现 HandlerInterceptor 接口。 1.编写HandlerInterceptor实现类12345678910111213141516171819202122232425262728package com.kuang.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123; //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 (即拦死在这) public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; System.out.println(&quot;------------处理前------------&quot;); return true; &#125; //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;------------处理后------------&quot;); &#125; //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; System.out.println(&quot;------------清理------------&quot;); &#125;&#125; 2.在SpringMVC配置文件中配置1234567891011&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=&quot;com.kuang.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器可以用来实现登陆状态校验 文件资源IO(待学)SSM整合Maven依赖包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!-- 测试工具--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- Spring重要核心--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt;&lt;/dependency&gt;&lt;!-- SpringAOP织入--&gt;&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring中的Mybatis--&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring的jdbc(使用连接池技术可不用)--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据库连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt;&lt;!--Servlet - JSP --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; Maven资源过滤文件 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; pojo实体类实体类User 123456789101112131415161718192021222324252627package com.pojo;public class User &#123; private int id; private String name; private String pwd; public User() &#123; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; /* getter 和 setter */&#125; dao层数据库相关配置与Mybatis数据库配置文件database.properties 12345# 注意! 使用了 c3p0 数据库链接池的属性要设置为 jdbc.属性名,不加会报错!jdbc.driver = com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8jdbc.username=rootjdbc.password=123456 mybati核心配置mybatis-config.xml , 也可以进行mybatis其他的设置,如起别名等 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;mappers&gt; &lt;!-- 将包内的映射器接口实现全部注册为映射器,注意配置文件要与接口同名同包 --&gt; &lt;package name=&quot;com.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Spring中dao层配置文件spring-dao.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 关联数据库配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; &lt;!-- 2.设置mybatis数据源 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!-- c3p0连接池的私有属性--&gt; &lt;!-- &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;--&gt; &lt;!-- &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;--&gt; &lt;!-- 关闭连接后不自动commit--&gt; &lt;!-- &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;--&gt; &lt;!-- 获取连接超时时间--&gt; &lt;!-- &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;--&gt; &lt;!-- 当获取连接失败重试次数--&gt; &lt;!-- &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;--&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 关联MyBaties核心配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.htmlMybatis在与Spring集成的时候可以配置MapperFactoryBean来生成Mapper接口的代理.MapperFactoryBean 创建的代理类实现了 UserMapper 接口,并且注入到应用程序中。 因为代理创建在运行时环境中(Runtime,译者注) ,那么指定的映射器必须是一个接口,而 不是一个具体的实现类。没有必要在Spring的XML配置文件中注册所有的映射器。相反,你可以使用一个MapperScannerConfigurer, 它将会查找类路 径 下 的 映射器并自动将它们创建成MapperFactoryBean。&lt;注意!!!&gt;, 没有必要去指定SqlSessionFactory 或 SqlSessionTemplate , 因为MapperScannerConfigurer 将会创建 MapperFactoryBean,之后自动装配。但是,如果你使 用了一个以上的 DataSource ,那么自动装配可能会失效 。这种 情况下,你可以使用 sqlSessionFactoryBeanName 或 sqlSessionTemplateBeanName 属性来设置正确的 bean 名 称来使用。这就是它如何来配置的,&lt;注意!!!&gt;bean的名称是必须的,而不是 bean 的引用,因 此,value 属性在这里替代通常的 ref:即: 这个扫描类帮我们做了这些事: 扫描指定包下的接口,获得Mapper对象,随后业务层将会用到此Mapper来进行操作ApplicationContext context = new ClassPathXmlApplicationContext(&quot;appconfig.xml&quot;);UserDao userDaoMapper = context.getBean(&quot;daoMapper&quot;, DaoMapper.class).getMapper(UserDao.class);--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.dao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; dao接口 UserMapper12345678910111213141516package com.dao;import com.pojo.User;import org.apache.ibatis.annotations.Param;import java.util.List;public interface UserMapper &#123; List getAllUser(); int addUser(User user); int deleteUser(@Param(&quot;id&quot;) int id); int updateUser(User user); User getUser(@Param(&quot;id&quot;) int id);&#125; 接口映射器(sql配置)如果是配置文件,最好和接口同包同名 , 也可以在接口上使用注解 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.dao.UserMapper&quot;&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.pojo.User&quot;&gt; insert into `user` values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;); &lt;/insert&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from `user` where id=#&#123;id&#125; &lt;/delete&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.pojo.User&quot;&gt; update `user` set id = #&#123;id&#125;,name = #&#123;name&#125;,pwd = #&#123;pwd&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;select id=&quot;getUser&quot; resultType=&quot;int&quot;&gt; select * from `user` where id = #&#123;id&#125;; &lt;/select&gt; &lt;select id=&quot;getAllUser&quot; resultType=&quot;com.pojo.User&quot;&gt; SELECT * from `user` &lt;/select&gt;&lt;/mapper&gt; service层(业务层)Service接口 ,非必需,根据项目情况而定 123456789101112131415161718package com.service;import com.pojo.User;import org.apache.ibatis.annotations.Param;import java.util.List;interface UserService &#123; List getAllUser(); int addUser(User user); int deleteUser(@Param(&quot;id&quot;) int id); int updateUser(User user); User getUser(@Param(&quot;id&quot;) int id);&#125; Service实现类ServiceImp 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.service;import com.dao.UserMapper;import com.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserServiceImp implements UserService &#123; /* 业务层调用dao层(Mapper对象)来执行对应的数据库操作; 对应接口的MapperBean由Spring的MapperScannerConfigurer生成 由于UserMapper的映射器对象已经在spring-dao.xml配置中用扫描器注册了,所以可以使用自动装配 此外: // 官方不建议字段自动装配,而是推荐setter注入更灵活 */ @Autowired @Qualifier(&quot;userMapper&quot;) private UserMapper userMapper; @Override public List getAllUser() &#123; return userMapper.getAllUser(); &#125; @Override public int addUser(User user) &#123; return userMapper.addUser(user); &#125; @Override public int deleteUser(int id) &#123; return userMapper.deleteUser(id); &#125; @Override public int updateUser(User user) &#123; return userMapper.updateUser(user); &#125; @Override public User getUser(int id) &#123; return userMapper.getUser(id); &#125;&#125; Spring中Service层配置文件123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描service相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.service&quot; /&gt; &lt;!-- UserServiceImpl注入到IOC容器中,用 注解@Service来注册bean了就不在需要 &lt;bean id=&quot;UserServiceImpl&quot; class=&quot;com.service.UserServiceImp&quot;&gt; 这里引用的userMapper,在spring-dao.xml中注入了,使用到了Spring自带的扫描器 MapperScannerConfigurer &lt;property name=&quot;userMapper&quot; ref=&quot;userMapper&quot;/&gt; &lt;/bean&gt;--&gt; &lt;!-- 配置事务管理器,为啥要在这里配置事务管理呢,因为业务层嘛,可能会有一些会回滚的操作,所以业务层才需要事务管理 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池,在spring-dao.xml里配置啦 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; controller层控制器UserController.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.controller;import com.pojo.User;import com.service.UserServiceImp;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.List;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; /* controller层调用业务层, 业务层通过 @Service 注解在Spring中注入了 这里自动装配 业务层实现类(bean对象) 控制层通过调用业务层实现类来进行对应的业务操作 */ @Autowired // 官方不建议字段注入 自动装配,而是推荐setter注入更灵活更安全 @Qualifier(&quot;userServiceImp&quot;) private UserServiceImp mapperImp; //由于类也有url,所以请求的url为:user/getAllUser @RequestMapping(value = &quot;/getAllUser&quot;,produces = &quot;text/html;charset=utf-8&quot;) @ResponseBody public String getAllUser()&#123; String date =&quot;&quot;; List&lt;User&gt; users = mapperImp.getAllUser(); for (User user:users)&#123; date+=user+&quot;&lt;br&gt;&quot; ; System.out.println(user); &#125;//返回数据 return date; &#125;&#125; Spring中的控制层配置文件spring-controller.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.controller&quot; /&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 设置ViewResolver视图解析器相关属性 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; Spring整合所有应用上下文配置applicationContext.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;!--引入dao层配置--&gt; &lt;import resource=&quot;spring-service.xml&quot;/&gt; &lt;!--引入业务层配置--&gt; &lt;import resource=&quot;spring-controller.xml&quot;/&gt; &lt;!--引入控制层层配置--&gt;&lt;/beans&gt; web配置配置整个web应用程序的配置文件``web.xml` 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了 tomcat是根据总配置文件来启动的--&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--encodingFilter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间(根据需要设置)--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 至此,所有的配置都做完了,完结撒花 🌸🌸🌸","categories":[{"name":"Java系列","slug":"Java系列","permalink":"https://lqy679.github.io/categories/Java%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"JavaWeb","slug":"javaweb","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T08:07:51.541Z","comments":true,"path":"2020/01/01/javaweb/","link":"","permalink":"https://lqy679.github.io/2020/01/01/javaweb/","excerpt":"JavaWeb1、基本概念Web开发静态web","text":"JavaWeb1、基本概念Web开发静态webhtml ,css,提供可所有人看的数据不会发生变化 缺点 web页面无法动态更新 无法与数据库交互 动态web提供可别人的数据会发生变化 技术栈:Servlet/JSP ,ASP, PHP 缺点 加入服务器的动态web资源出现了错误,我们需要编写后他程序重新发布 web 应用程序可以提供浏览器访问的程序 html文件,css文件…等许多web资源 访问的资源或者页面都存在于世界上某个角落的计算机上 URL JSP(Servlet) java程序 jar包 配置文件(properties) web应用程序编写完毕之后,若想提供给外界访问,需要一个服务器来统一管理 2、web服务器 1.技术简介ASP 微软开发:国内最早流行的,使用C# IIS 在html 嵌入了VB脚本 ASP+COM 在ASP开发中基本一个页面都会有几千行页面代码 维护成本高 PHP PHP开发速度快,功能强大,跨平台,代码简单 无法承载大访问量的情况(局限性) JSP/Servlet sun公司主推的B/S架构 (B/S 浏览器和服务端,C/S 客户端和服务端) 基于java语言 可以承载三高(高并发,高性能,高可用)问题 语法像ASP 2.web服务器IIS微软的服务器,用来处理用户的一些请求和响应 Tomcat开源免费,属于轻量级服务器,适合java web初学者,是Servlet/JSP的容器,运行的实际上Servle和JS页面目录说明:服务器核心配置文件位于conf/server.xml server.xml文件可配置端口号 tomcat(默认端口号): 8080 MySQL:3306 http：80 https:443 默认端口号在配置文件的 可设置主机的名称默认主机名在配置文件中的除此之外还应该在修改主机名时还需要修改window的系统配置（即还要修改C盘:下的Windows目录下的System32目录下的drivers目录下的etc目录下的hosts文件)才能成功 面试题：谈谈网站是如何进行访问的？1.输入域名，回车2.检查本机的系统配置文件中有无此域名的隐射有：直接返回对应的IP地址，在我们需要访问的web程序，直接可以访问无：去DNS服务器找，找到就返回，没有就404 发布一个网站（1）将写的网站放到webapps文件夹下（2）网站该有的结构=&gt; webapps -&gt;ROOT -&gt;自己网站文件夹 +WEB-INF －classes:java程序 －lib :java所依赖的jar －web.xml: 网站的配置文件 ＋index.html ：网站默认首页 ＋网站的其他文件 3、HttpHttp:超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而消息内容则具有一个类似MIME的格式。 文本:html,字符串 超文本:图片,音乐,时间,定位,地图…Https:安全的http (safety 安全的) 两个时代 http 1.0 (即HTTP/1.0):客户端与web端链接后,只能获得一个web资源,然后断开链接 http 2.0 (即HTTP/1.1):客户端与web端链接后,可以获得多个web资源 3.1 http请求 客户端-&gt;发请求(Request)-&gt;服务器 1.1请求行请求行包括了http版本信息,请求方式,和资源路径 请求方式**:get Post** , head,delete,put,tract 区别:-&gt;get请求能携带的参数少,大小有限制,会在URL地址栏显示数据内容,不安全,但是高效一点 **-&gt;pose请求恰好与get相反 ** 如访问百度: 1234Request URL:https://www.baidu.com/ 请求地址Request Method:GET get方法/pose方法Status Code:200 OK 状态码Remote Address:183.232.231.174:443 远程地址(即百度的地址加端口) 1.2消息头12345Accept:text/html 告诉浏览器,他所支持的数据类型Accept-Encoding:gzip, deflate, br 支持哪种编码Accept-Language:en-US,en;q=0.9 语言Cache-Control:max-age=0 缓存控制Connection:keep-alive 请求完成是断开还是保持连接 3.2 http响应服务器-&gt;响应-&gt;客户端 1.1响应头123456Cache-Control:private 缓存控制Connection:keep-alive 连接:保持链接Content-Encoding:gzip 编码Content-Type:text/html;charset=utf-8 响应体类型以及编码,#当设置内容类型为 application/octet-stream时,设置如下响应头为下载文件的响应Content-Disposition: attachment; filename=myfile.tx 1.2响应体(和请求消息头差不多)1234567Accept:text/html 告诉浏览器,他所支持的数据类型Accept-Encoding:gzip, deflate, br 支持哪种编码, 常用编码 GBK ,UTF-8 ,GB2312,ISO8850-1Accept-Language:en-US,en;q=0.9 语言Cache-Control:max-age=0 缓存控制Connection:keep-alive 请求完成是断开还是保持连接reFresh:告诉客户端多久刷新一次,如 reFresh: 3;url=http://www.itcast.cn ,三秒后跳转到指定的urlLocation:让网页重新定位 响应状态码 2xx: 请求响应成功 3xx:请求重定向 4xx:找不到资源 如404 5xx:服务器代码错误,如502,网关错误 4、Maven作用一：maven主要是用来解决导入java类依赖的jar,编译java项目主要问题。(最早手动导入jar，使用Ant之类的编译java项目)以pom.xml文件中dependency属性管理依赖的jar包，而jar包包含class文件和一些必要的资源文件。当然它可以构建项目，管理依赖，生成一些简单的单元测试报告。 作用二：比如之前项目导入jar。是通过copy方式导入项目中，而且还会存在jar之间的依赖和冲突。而maven解决了这些问题，只是网速不好的时候有点烦。使用私服nexus解决这个问题。 作用三：jar 包管理，防止jar之间依赖起冲突 。小组之间建立个私服务，大家都用通用 的maven配置文件，不用自己手动去下载jar ，pom文件会自动管理下载好的jar包。 作用四：Maven是基于项目对象模型，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven能够很方便的帮你管理项目报告，生成站点，管理jar文件，等等。例如：项目开发中第三方jar引用的问题，开发过程中合作成员引用的jar版本可能不同，还有可能重复引用相同jar的不同版本，使用maven关联jar就可以配置引用jar的版本，避免冲突。 Maven的配置以及在idea中的设置https://blog.csdn.net/lqy5679/article/details/119345758 Maven 配置文件详解https://www.cnblogs.com/zhoudaxing/p/11338183.html 5、Servlet一种由sun公司开发的用动态web的技术 Servlet生命周期 初始化阶段(init)当客户端向Servlet容器发出HTTP请求访问Servlet时，Servlet容器首先会解析请求，检查内存中是否已经有了该Servlet对象，如果有，直接使用该Servlet对象；如果没有，就创建Servlet实例对象，然后通过调用init()方法完成Servlet的初始化。需要注意的是，==在Servlet的整个生命周期内，它的init()方法只被调用一次。== 运行阶段(service)在这个阶段，Servlet容器会为客户端请求创建请求对象和响应对象，然后将它们作为参数传递给Servlet的service()方法。service()方法从请求对象中获得客户端请求信息并处理该请求，通过响应对象生成响应结果。 在Servlet的整个生命周期内，对于Servlet的每一次访问请求，Servlet容器都会调用一次Servlet的service()方法，并且创建新的请求和响应对象，也就是说，==service()方法在Servlet的整个生命周期中会被调用多次。== 销毁阶段(destroy)当服务器关闭或web应用被移除出容器时，Servlet随着web应用的销毁而销毁。在销毁Servlet之前，Servlet容器会调用Servlet的destroy()方法，以便让Servlet对象释放它所占用的资源。在Servlet的整个生命周期中，==destroy()方法也只被调用一次。== 1.创建一个普通的Maven项目,删除里面的src目录,新建Moudel;这个空2.关于Maven父子工程的理解父项目的xml配置文件中会有 123&lt;modules&gt; &lt;module&gt;javaweb01_helloServlet&lt;/module&gt; &lt;/modules&gt; 子项目中会有parent标签(新版本会没有如Maven3.6)修改好pos.xml和web.xml配置文件 编写servlet一定要记得改配置文件web.xml注册servlet和映射 标准模板如下: 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot; metadata-complete=&quot;true&quot;&gt; &lt;/web-app&gt; 3.创建一个类,编写HelloServl程序 1234567891011121314public class HelloServlet extends HttpServlet &#123;// 由于get或者只是请求实现的不同方式,可以相互调用 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获得响应输出流 PrintWriter write = resp.getWriter(); writer.print(&quot;Hello,Servlet&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 4.在web.xml中注册Servlet,编写Servlet的映射 为什么要编写映射,我们写的是Java程序,而要通过浏览器需要链接web服务器,所以我们需要在web服务器器中注册我们写的Servlet,还需要给他一个浏览器能够访问的路径 5.1 Servlet Mapping映射方式一:在web.xml配置文件中注册servlet 一个servlet 可以指定一个或多个映射,并且可以使用通配符(*) 每个映射路径代表了浏览器URL地址栏的首页下的路径,Servlet用于接受这些请求,并且绑定一个用于处理请求做出响应的java程序 注意:尽量不要使用 / 这种映射路径,因为这样会覆盖掉首页* 1234567891011121314151617181920212223242526&lt;!-- 注册Servle,可以注册多个,一个servlet代表一个请求响应--&gt;; &lt;servlet&gt;; &lt;servlet-name&gt;hello&lt;/servlet-name&gt;; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt;; &lt;!--注意:有包名需要写包名 --&gt;; &lt;/servlet&gt;;&lt;!-- Servlet的映射,一个Servlet对应一个Servlet映射--&gt;; &lt;servlet-mapping&gt;; &lt;servlet-name&gt;;hello&lt;/servlet-name&gt;; &lt;!--这个是路径是指 首页/hello,注意区分 --&gt;; &lt;url-pattern&gt;;/hello&lt;/url-pattern&gt;; &lt;/servlet-mapping&gt;; &lt;servlet-mapping&gt;; &lt;servlet-name&gt;;hello&lt;/servlet-name&gt;; &lt;url-pattern&gt;;/hello2&lt;/url-pattern&gt;; &lt;/servlet-mapping&gt;;&lt;!--使用通配符*--&gt;; &lt;servlet-mapping&gt;; &lt;servlet-name&gt;;hello&lt;/servlet-name&gt;; &lt;url-pattern&gt;;/hello/*&lt;/url-pattern&gt;; &lt;/servlet-mapping&gt;;&lt;!-- 不要使用/*这种映射路径--&gt;;&lt;!-- &lt;servlet-mapping&gt;;--&gt;;&lt;!-- &lt;servlet-name&gt;;hello&lt;/servlet-name&gt;;--&gt;;&lt;!-- &lt;url-pattern&gt;;/*&lt;/url-pattern&gt;;--&gt;;&lt;!-- &lt;/servlet-mapping&gt;;--&gt;; 方式二:使用注解@WebServlet注解注册servlet@WebServelt的属性: String name 指定Servlet的name属性。如果没有显式指定，则该Servlet的取值即为类的全限定名。 String[] value 该属性等价于urlPatterns属性。urlPatterns和value属性不能同时使用。 String[] urlPatterns 指定一组Servlet的URL匹配模式。 int loadOnStartup 指定Servlet的加载顺序， WebInitParam[] 指定一组Servlet初始化参数。 例如: 下面的两段代码等效 在web.xml中 1234567891011 &lt;!--注册servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt; &lt;!--注意:有包名需要写包名 --&gt; &lt;/servlet&gt;&lt;!-- Servlet的映射,一个Servlet可以对应多个Servlet映射--&gt; &lt;servlet-mapping&gt;; &lt;servlet-name&gt;hello&lt;/servlet-name&gt;; &lt;!--这个是路径是指 应用上下文/hello,注意区分 --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在servlet中 1234567891011121314151617181920 // 使用注解来注册servlet @WebServlet(name = &quot;hello&quot; ,value = &quot;/hello&quot;)public class HelloServlet extends HttpServlet &#123;// 由于get或者只是请求实现的不同方式,可以相互调用 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;utf-8&quot;); //获得响应输出流 resp.setCharacterEncoding(&quot;UTF-8&quot;); resp.setContentType(&quot;text/html;utf-8&quot;); PrintWriter writer = resp.getWriter(); writer.print(&quot;java后台输出流!&quot;); System.out.println(&quot;进入了get方法&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 5.2 ServletContext1.共享数据(用多了服务器会崩)web容器启动的时候,他会为每个web程序都创建一个对应的ServletContext对象,他代表了当前的web应用: 共享数据:多个Servlet可以共享同一个ServletContext对象 如:HelloServlet中有一数据,而GetServlet中需要拿到并且打印此数据,代码如下 1234567891011121314151617181920public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;// this.getInitParameter() //初始化参数, 也可以通过注解来配置// this.getServletConfig() // 获得Servlet配置// this.getServletContext() //获得Servlet上下文 //获得Servlet上下文对象 ServletContext context = this.getServletContext(); //数据 String value = &quot;雯雯&quot;; //注意! 其中第一个String参数为 属性名 , 第二个Object类型参数为属性的值 context.setAttribute(&quot;username&quot;,value); System.out.println(&quot;Hello&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 12345678910111213141516171819public class GetServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获得共享的Servlet对象 ServletContext context = this.getServletContext(); //设置响应头的文本类型 resp.setContentType(&quot;text/html&quot;); //设置响应头的字符编码 resp.setCharacterEncoding(&quot;UTF-8&quot;); //获得属性名为 username 的值 String name = (String) context.getAttribute(&quot;username&quot;); //在响应页面打印数据 resp.getWriter().println(&quot;名字:&quot;+name); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 配置文件web.xml为: 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot; metadata-complete=&quot;true&quot;&gt;;&lt;!--注册HelloServlet的Servlet和其映射--&gt;; &lt;servlet&gt;; &lt;servlet-name&gt;;hello&lt;/servlet-name&gt;; &lt;servlet-class&gt;;ServletContext01.HelloServlet&lt;/servlet-class&gt;; &lt;/servlet&gt;; &lt;servlet-mapping&gt;; &lt;servlet-name&gt;;hello&lt;/servlet-name&gt;; &lt;url-pattern&gt;;/hello&lt;/url-pattern&gt;; &lt;/servlet-mapping&gt;; &lt;!--注册GetServlet的Servlet和其映射--&gt;; &lt;servlet&gt;; &lt;servlet-name&gt;;get&lt;/servlet-name&gt;; &lt;servlet-class&gt;;ServletContext01.GetServlet&lt;/servlet-class&gt;; &lt;/servlet&gt;; &lt;servlet-mapping&gt;; &lt;servlet-name&gt;;get&lt;/servlet-name&gt;; &lt;url-pattern&gt;;/get&lt;/url-pattern&gt;; &lt;/servlet-mapping&gt;;&lt;/web-app&gt;; 2.获得初始化参数1.首先在web.xml中配置初始化参数 12345&lt;!--设置web应用的初始化参数参数--&gt;; &lt;context-param&gt;; &lt;param-name&gt;;url&lt;/param-name&gt;; &lt;param-value&gt;;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;; &lt;/context-param&gt;; 2.编写Java程序 123456789101112131415public class ContextGetParameter extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获得上下文对象 ServletContext con = this.getServletContext(); //获得 参数名为 url 的 值 String url = con.getInitParameter(&quot;url&quot;); // 使用响应页面的输入流打印 参数 url 的值 resp.getWriter().println(url); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 3.在web.xml中注册Servlet以及参数 12345678&lt;servlet&gt;; &lt;servlet-name&gt;getParameter&lt;/servlet-name&gt;; &lt;servlet-class&gt;ServletContext01.ContextGetParameter&lt;/servlet-class&gt;; &lt;/servlet&gt;; &lt;servlet-mapping&gt; &lt;servlet-name&gt;getParameter&lt;/servlet-name&gt; &lt;url-pattern&gt;/getParam&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;; 3.请求转发 如下代码将通过 请求 /rd 转发到请求 /param1.首先编写java程序 12345678910111213public class ContextRequestDispatcher extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext con = this.getServletContext(); // 获得 /getParam 的请求转发 RequestDispatcher requestDispatcher = con.getRequestDispatcher(&quot;/getParam&quot;); // 将本次请求响应转发 为 /getParam ,即本次请求相当于请求到 /Param requestDispatcher.forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp);; &#125;&#125; 2.配置文件web.xml注册Servlet以及映射 1234567&lt;servlet&gt;; &lt; servlet-name&gt;;ResquestDispatcher&lt;/servlet-name&gt;; &lt;servlet-class&gt;;ServletContext01.ContextRequestDispatcher&lt;/servlet-class&gt;; &lt;/servlet&gt;; &lt;servlet-mapping&gt;; &lt;servlet-name&gt;;ResquestDispatcher&lt;/servlet-name&gt;; &lt;url-pattern&gt;;/rd&lt;/url-pattern&gt;; &lt;/servlet-mapping&gt;; 4.获取资源可能会出现的问题:当配置文件 如aa.properties文件可能不在resource目录下(在java目录下)时,可能在打包的时候无法将其打包**解决方案: **在本项目的配置文件pom,xml下build标签下的resources标签中添加配置 12345678&lt;resource&gt;; &lt;filtering&gt;;true&lt;/filtering&gt;; &lt;directory&gt;;src/main/java&lt;/directory&gt;; &lt;includes&gt;; &lt;include&gt;;**/*.properties&lt;/include&gt;; &lt;include&gt;;**/*.xml&lt;/include&gt;; &lt;/includes&gt;; &lt;/resource&gt;; 如下所示代码,为获取 db.properties中的数据(此文件在src/resource目录下),并且打印在响应页面下 1.首先编写java程序 12345678910111213public class ServletProperties extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext con = this.getServletContext(); // 获得 db 配置文件的输入流,注意! ,配置文件在打包后一定是在相对路径 classes 目录下的 InputStream in = con.getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;); //创建一个配置文件 Properties properties = new Properties(); // 将 db输入流写入 新建的配置文件 properties.load(in); //在响应页面打印配置文件的数据 String name = properties.getProperty(&quot;username&quot;); String password = properties.getProperty(&quot;password&quot;); resp.getWriter().println(name+&quot;:&quot;+password); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; his.doGet(req, resp); &#125;&#125; 2.在配置文件web.xml中注册servlet以及映射 12345678&lt;servlet&gt;; &lt;servlet-name&gt;;getResource&lt;/servlet-name&gt;; &lt;servlet-class&gt; ServletContext01.ServletProperties &lt;/servlet-class&gt; &lt;/servlet&gt;; &lt;servlet-mapping&gt;; &lt;servlet-name&gt;;getResource&lt;/servlet-name&gt;; &lt;url-pattern&gt;;/resource&lt;/url-pattern&gt;; &lt;/servlet-mapping&gt;; 5.3 HttpServletRequestHttpServletRequest代表客户端的请求,用户通过Htt协议访问服务器,HTTP请求中的所有信息会被封装到HttpServletRequest中,通过HttpServel的方法获得客户端的一些信息 1.获取前端传递的参数123String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); String[] hobbies = req.getParameterValues(&quot;hobby&quot;); 2.请求转发12RequestDispatcher requestDispatcher=request.getRequestDispatcher(path);requestDispatcher.forward(request,response); 5.4 HttpServletRespondweb服务器接受到客户端的http请求,针对这个请求,分别创建一个代表请求和响应的的对象,即HttpServletRequest和HttpServletRespond 如果要获取客户端请求过来的参数找:HttpServletRequest 如果要给客户端响应一些信息,找:HttpServletRespond 1.简单分类负责向浏览器发送数据的方法 12ServletOutputStream getOutputStream();PrintWriter getWriter(); 负责向浏览器发送响应头的方法 12345void setCharacterEncoding(String var1);void setContentLength(int var1);void setContentLengthLong(long var1);void setContentType(String var1);void addDateHeader(String var1, long var2); 2.下载文件123456789101112131415161718192021222324252627public class DemoRespond extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; // String realPath = this.getServletContext().getRealPath(&quot;\\常用命令.txt&quot;); //不能这样,因为这是Tomcat的相对路径 String realPath = &quot;E:/Code/Java_idea/HellServlet/Respond/src/main/resources/常用命令.txt&quot;; System.out.println(&quot;文件路径:&quot;+realPath); //重点!!!!:确定文件名,截取路径下最后一个/下的内容肯定是文件名 String filename = realPath.substring(realPath.lastIndexOf(&quot;/&quot;)+1); //百度上找.下载文件的消息头,不过要注意文件名是中文的问题 resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot;+URLEncoder.encode(filename,&quot;utf-8&quot;)); //获得文件的输入流 FileInputStream in_file= new FileInputStream(realPath); //获得响应页面的输出流 OutputStream out = resp.getOutputStream(); int len; byte[] buf = new byte[1024]; while((len=in_file.read(buf))!=-1)&#123; //将文件信息暂存到缓存数组中 out.write(buf,0,len); //将缓存数组中文件信息输出到响应页面 &#125; out.close(); in_file.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 在编写好后在web.xml文件中注册servlet以及其映射 3.实现图片验证码12345678910111213141516171819202122232425262728293031323334353637public class Demo extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //每隔5秒刷新一次 resp.setHeader(&quot;refresh&quot;,&quot;5&quot;); BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_3BYTE_BGR); //设置图片底部颜色 Graphics2D g = (Graphics2D) image.getGraphics(); //画笔 g.setColor(Color.white); g.fillRect(0,0,80,20); //填充形状 //设置画验证码的画笔格式 g.setColor(Color.CYAN); g.setFont(new Font(null,Font.BOLD,20)); //设置字体 g.drawString(makeNum(),0,20); //画字符串 //告诉浏览器用图片格式打开 resp.setContentType(&quot;image/jpeg&quot;); //不让浏览器缓存 resp.setDateHeader(&quot;expires&quot;,-1); resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;); resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;); //向响应页面输出图片 ImageIO.write(image,&quot;jpg&quot;,resp.getOutputStream()); &#125; //生成随机数验证码 String makeNum()&#123; Random random = new Random(); String num = random.nextInt(999999)+&quot;&quot;; //补齐为6位数的验证码 StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 6-num.length(); i++) &#123; sb.append(&quot;0&quot;); &#125; num = sb.toString()+num; return num; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 在编写好java程序后在web.xml文件中注册Servlet以及其映射 4.实现响应重定向常见场景: 用户登陆 12345678910111213public class Respond_Redirect extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //注意重定向一定要写出项目路径 resp.sendRedirect(&quot;/Respond/down&quot;); /* 重定向拆分 */ /*resp.setHeader(&quot;Location&quot;,&quot;/Respond/down&quot;); resp.setStatus(302);*/ &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 重定向与请求转发的区别 相同点: 两者都会发生跳转 不同点: 请求转发url地址栏不会发生变化;而重定向会发生变化 重定向和请求转发路径问题总结： 1、重定向的 / 表示：http://服务器ip:端口/ 2、请求转发的 / 表示：http://服务器ip:端口/项目名 怎么记忆呢，很简单，重定向是浏览器发来的，只知道发到某个服务器，但是不知道发到服务器的哪个project，所以需要自己用代码声明； 而请求转发是服务器某个project内部的转发，转来转去都是在某个project内部，所以不需要手动声明项目名。 7. Cookie、Session7.1 Cookie 7.1.1 简述客户端技术(响应,请求)cookie::一般保存在本地的用户路径下如appdata; 7.1.2 注意事项:上限大小问题: 一个cookie只能保存一个信息; 一个web网站点可以给浏览器发送多个cookie,最多存放20个cookie cookie有大小限制4kb 300个cookie浏览器上限删除cookie: 不设置有效期(maxAge),关闭浏览器,自动失效; 设置有效器时间为0; 7.1.3 应用常用方法1.从请求中拿到cookie信息2.服务器响应给客户端cookie3.Cookie中的的内容有 Cookie(String name, String value) 123cookie.setMaxAge(int expiry); //设置有效期cookie.getName(); cookie.getVaule; 如下是测试访问网站的时间的Deom 12345678910111213141516171819202122232425 //设置编码req.setCharacterEncoding(&quot;utf-8&quot;);resp.setCharacterEncoding(&quot;utf-8&quot;);resp.setContentType(&quot;text/html&quot;);//过去响应页面的输出流ServletOutputStream out = resp.getOutputStream();//获得浏览器请求发送的cookieCookie[] cookies = req.getCookies();//判断是否为第一次访问次网站.如果不是第一次则显示上次访问的时间,是第一次次则显示第一次访问 if (cookies!=null)&#123; for (int i = 0; i &lt; cookies.length; i++) &#123; Cookie cookie = cookies[i]; if(cookie.getName().equals(&quot;LastLogin&quot;))&#123; //判断cookie是否为自己上一次添加的,是则向响应写入cookie中记录的时间 long time = Long.parseLong(cookie.getValue()); //将cookie中的值解析为 long Date date = new Date(time); //根据cookie中解析的值创建一个时间 out.write(date.toString().getBytes(StandardCharsets.UTF_8)); //向响应页面写入时间,并且注意编码 &#125; &#125; &#125; else&#123; byte[] str = &quot;这是您第一次访问本站!&quot;.getBytes(&quot;utf-8&quot;); out.write(str); &#125; //每次访问之后会添加一个cookie,代表本次已经访问过,并且记录访问时的时间 resp.addCookie(new Cookie(&quot;LastLogin&quot;,System.currentTimeMillis()+&quot;&quot;)); 拓展:编码解码解决中文乱码问题12URLEncoder.encode(&quot;中文&quot;,&quot;utf-8&quot;); //编码URLDecoder.decode(cookie.getValue(),&quot;utf-8&quot;); //解码 7.2 Session(重点) 7.2.1 简述什么是session: 浏览器一旦访问服务端就会创建一个Session对象 一个Session独占一个浏览器,只有浏览器没关,这个Session就存在 用户登陆后,整个网站都会处于登陆状态如:保存用户信息,保留购物车信息… 服务端技术,利用这个技术,可以保存用户的会话信息,我们可以把信息或者数据放在Session中 获取Session12345request.getSession(); // 获取请求头的Sessionrequest.getSession(boolean create); //当 create为true时,等同于 request.getSession(), 会创建一个Session返回//当 create为false时, 若当前会话状态已经过过期或者不存在,则返回一个null 使用建议: **存数据:**使用getSession() 取数据: getSession(boolean create) 7.2.2应用1.使用场景: 保存一个登陆用户的信息; 购物车信息 在整个网站中经常会使用的数据 2.常用方法1.Session 浏览器会存在一个JSESSIONID,用于标识唯一的Session对象2.Session中存储的内容是 Session(String name,Object value),可以存储对象 12345session.setAttribute(String name,Object value); //设置属性,属性包括name , valuesession.getAttribute(String name) //根据参数name属性名返回对象属性的value setMaxInactiveInterval(int s); //设置有效期,单位为秒!!! session.invalidate(); //注销session session.isNew(); //判断的是否为新创建的 此外还可以通过配置web.xml文件定时注销Session , Tomcat的默认销毁时间是30分钟 123&lt;session-config&gt; &lt;!--注意:这种方式注销的单位为分钟--&gt; &lt;session-timeout&gt;1440&lt;/session-timeout&gt;&lt;/session-config&gt; 3.创建123//在创建一个Session时做了哪些事Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionId);resp.addCookie(cookie); 如下Demo,第一个Servlet是创建一个Session,第二个是获取Session的属性值,第三个是注销Session 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class SessionDemo extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.setContentType(&quot;text/html&quot;); //获得请求的Session HttpSession session = req.getSession(); //设置属性 session.setAttribute(&quot;name&quot;,&quot;南城&quot;); //判断Session是不是新创建了 if(session.isNew())&#123; resp.getWriter().println(&quot;session已经创建成功&quot;+session.getId()); &#125; else &#123; resp.getWriter().println(&quot;session在服务器存在:&quot;+session.getId()); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;/*************************分割线**************************/public class Session_get extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;utf-8&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.setContentType(&quot;text/html&quot;); //获得请求的Session HttpSession session = req.getSession(); //得到Session属性名为 name 的value Object name =(String) session.getAttribute(&quot;name&quot;); System.out.println(name); resp.getWriter().println(&quot;服务器中session中name属性的值为:&quot;+name); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125;/*************************分割线**************************/public class Session_invalidate extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HttpSession session = req.getSession(); //session.removeAttribute(&quot;name&quot;); //注意!移除属性名为name 的属性,session还是原来那个session //注销session session.invalidate(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 7.3 Session和Cookie的区别 Cookie是把用户的数据写给用户的浏览器,浏览器保存(可保存多个) Session是把用户的数据写到用户独占的Session中,服务端保存(保存重要信息,减少服务器资源的浪费) Session对象由服务器创建 8、JSP8.1 JSP简述什么是JSPJava Server Pages:java服务端页面,也和Servlet一样,用于动态web技术最大的特点: 写JSP就像写HTML 区别: HTML只给用户提供静态信息 JSP页面中可以嵌入java代码,为用户提供动态数据 JSP原理思路:JSP怎么执行的 服务器内部工作tomcat中有一个word目录;idea中使用Tomcat会在Idea中的tomcat中的生成一个项目的word下目录,目录如下: 发现页面index.jsp转换成了java程序*1C:＼Users＼Lenovo＼AppData＼Local＼JetBrains＼IntelliJIdea2021.1＼tomcat＼f25921c3-8f82-45ba-a1a3-0cd5e3df0ff2＼work＼Catalina＼localhost＼w1＼org＼apache＼jsp 浏览器向服务器中发送请求,不管访问什么资源,其实都是在访问Servlet!*JSP最终也会被转换成java类!JSP本质上就是个Servlet 源码如下 1.判断请求 1234567891011121314151617181920//初始化public void _jspInit() &#123; &#125;//销毁public void _jspDestroy() &#123; &#125;public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123; if (!javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123; final java.lang.String _jspx_method = request.getMethod(); if (&quot;OPTIONS&quot;.equals(_jspx_method)) &#123; response.setHeader(&quot;Allow&quot;,&quot;GET, HEAD, POST, OPTIONS&quot;); return; &#125; if (!&quot;GET&quot;.equals(_jspx_method) &amp;&amp; !&quot;POST&quot;.equals(_jspx_method) &amp;&amp; !&quot;HEAD&quot;.equals(_jspx_method)) &#123; response.setHeader(&quot;Allow&quot;,&quot;GET, HEAD, POST, OPTIONS&quot;); response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, &quot;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS&quot;); return; &#125; &#125; 2.内置一些对象下面的对象我们可以直接在JSP页面中直接使用! 12345678final javax.servlet.jsp.PageContext pageContext; //页面上下文javax.servlet.http.HttpSession session = null; //Session会话final javax.servlet.ServletContext application; //本质就是ServletContextfinal javax.servlet.ServletConfig config;javax.servlet.jsp.JspWriter out = null; //输出到页面的对象final java.lang.Object page = this; //当前final javax.servlet.http.HttpServletRequest requestfinal javax.servlet.http.HttpServletResponse response 3.输出页面前加了的代码 123456789//设置响应类型response.setContentType(&quot;text/html&quot;);pageContext = _jspxFactory.getPageContext(this, request, response,null, true, 8192, true);_jspx_page_context = pageContext;application = pageContext.getServletContext();config = pageContext.getServletConfig();session = pageContext.getSession();out = pageContext.getOut();_jspx_out = out; 在JSP页面中,只要是Java代码,就会原封不动的输出:如果是HTML代码,就会被转换为: 1out.write(&quot;＜html＞＼r＼n&quot;); 这样的格式输出到前端 8.3 JSP基础语法JSP作为Java的技术除了必须支持Java的所有语法外,还有自己的语法 1.jsp表达式用来将程序的输出,输出到客户端相当于在Servlet中书写了 out.print(变量或者表达式),为了查看清晰,通常可用${变量或者表达式代替} 12345&lt;% Java代码 %&gt; //可在html中嵌入Java代码&lt;%= 变量或者表达式 %&gt; // 会在html中打印变量或者表达式的值&lt;%= new Date()%&gt; //在html页面打印时间&lt;%! 声明,相当于在jsp的类里声明一些东西,如方法和成员变量和静态变量 %&gt;&lt;%-- 注释 --%&gt; 2.jsp的脚本片段123456789101112131415161718&lt;% int sum = 1; for (int i = 1; i &lt;= 100; i++) &#123; sum+=i; &#125;// 内置对象 out 相当于 resp.getWriter out.println(&quot;&lt;h2&gt;sum=&quot;+sum+&quot;&lt;/h2&gt;&quot;);%&gt;&lt;%--脚本拼接,可将多个脚本片段拼接起来--%&gt; &lt;% int x = 10; out.print(x); %&gt;&lt;p&gt;脚本片段&lt;/p&gt; &lt;% int y=20; out.print(y); %&gt; 3.JSP的声明(作用域)123&lt;!％ 此处的代相当于放在Servelt中的类体里面,其他脚本代码放在 _jspService()方法中％&gt; 4.JSP语法小结1234&lt;%java代码%&gt; &lt;!% 声明 %&gt;&lt;%=变量或者表达式%&gt; 通常可用$&#123;变量或者表达式代替&#125;&lt;%--注释--%&gt; JSP中的注释在前端页面不可见,只在源码中可见 8.4 JSP指令1.定制错误页面12&lt;%--定制错误页面,其中error为文件路径--%&gt;&lt;%@page errorPage=&quot;error/500.jsp&quot; %&gt; 此外还可以通过配置web.xml配置来定制 123456789&lt;!--定制错误页面--&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error/404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/500.jsp&lt;/location&gt; &lt;/error-page&gt; 2.设置网站头部尾部引入文件指令 1234&lt;%--不常用,讲其他包含文件的内容直接out.write(文件内容)的形式合并,本质上已经合并成一个文件,耦合度较高--%&gt; &lt;%@include file=&quot;common/header.jsp&quot; %&gt; &lt;h1&gt;我是网站主体&lt;/h1&gt; &lt;%@include file=&quot;common/footer.jsp&quot;%&gt; 如上代码在jsp.java源码中的的实现原理为将要包含文件的内容以out.write()的方式解析到jsp 1234567891011121314out.write(&quot; &lt;h1&gt;我是头部&lt;/h1&gt;\\r\\n&quot;); out.write(&quot;&lt;/body&gt;\\r\\n&quot;); out.write(&quot;&lt;/html&gt;\\r\\n&quot;); out.write(&quot;\\r\\n&quot;); out.write(&quot; &lt;h1&gt;我是网站主体&lt;/h1&gt;\\r\\n&quot;); out.write(&quot; &quot;); out.write(&quot;\\r\\n&quot;); out.write(&quot;\\r\\n&quot;); out.write(&quot;&lt;html&gt;\\r\\n&quot;); out.write(&quot;&lt;head&gt;\\r\\n&quot;); out.write(&quot; &lt;title&gt;Title&lt;/title&gt;\\r\\n&quot;); out.write(&quot;&lt;/head&gt;\\r\\n&quot;); out.write(&quot;&lt;body&gt;\\r\\n&quot;); out.write(&quot; &lt;h1&gt;我是尾部&lt;/h1&gt;\\r\\n&quot;); 使用JSP标签引入文件 12345&lt;%--JPS标签,本质上还是三个页面,页面直接不相互影响--%&gt;&lt;%-- &lt;jsp:include page=&quot;文件路径&quot;&gt;&lt;/jsp:include&gt;--%&gt; &lt;jsp:include page=&quot;common/header.jsp&quot;&gt;&lt;/jsp:include&gt; &lt;h1&gt;我是网站主体&lt;/h1&gt; &lt;jsp:include page=&quot;common/footer.jsp&quot;&gt;&lt;/jsp:include&gt; 其源码实现为: 12345org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, &quot;common/header.jsp&quot;, out, false); out.write(&quot;\\r\\n&quot;); out.write(&quot; &lt;h1&gt;我是网站主体&lt;/h1&gt;\\r\\n&quot;); out.write(&quot; &quot;); org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, &quot;common/footer.jsp&quot;, out, false); 8.5 内置对象和作用域9大内置对象 PageContext Request Respond Session Application(即ServletContext) config (即ServletConfig) out page (不常用) exception 四大作用域如在一个页面中设置一些信息如下 1234pageContext.setAttribute(&quot;name1&quot;, &quot;object1&quot;); //数据只在一个页面中有效 request.setAttribute(&quot;name2&quot;, &quot;object2&quot;); //在一个请求中有效,转发请求会携带这个数据 session.setAttribute(&quot;name3&quot;, &quot;object3&quot;); //有一次会话中有效.从打开浏览器到关闭 application.setAttribute(&quot;name4&quot;, &quot;object4&quot;); //只在服务器中有效,从打开服务器到关闭服务器,相当于ServletContext对象,整个web应用共享的对象 在另一个页面获取前上面页面设置的信息: 1234567&lt;%--发现只能取出3和4,是双亲委派机制,即先从父级作用域获取没有,在从自己作用域获取--%&gt;&lt;h1&gt;取出的值为:&lt;/h1&gt;&lt;h3&gt;$&#123;name1&#125;&lt;/h3&gt;&lt;h3&gt;$&#123;name2&#125;&lt;/h3&gt;&lt;h3&gt;$&#123;name3&#125;&lt;/h3&gt;&lt;h3&gt;$&#123;name4&#125;&lt;/h3&gt;&lt;h3&gt;$&#123;name5&#125;&lt;/h3&gt; request:比如新闻,用户看完就没用了Session:用户用完一会还有用,如购物车,登陆信息application:一个用户用完了其他用户还能用,如在某网站下载一些文件 8.6 JSP标签,JSTL标签,EL表达式EL表达式${} 获取数据 执行运算 获取web开发的常用对象 JSP标签1234&lt;jsp:forward page=&quot;jsptag2.jsp&quot;&gt; &lt;%--请求转发--%&gt; &lt;jsp:param name=&quot;name1&quot; value=&quot;value1&quot;/&gt; &lt;%--设置参数--%&gt; &lt;jsp:param name=&quot;name2&quot; value=&quot;value2&quot;/&gt;&lt;/jsp:forward&gt; JSTL 标准标签库核心标签库了解就够即可菜鸟教程:https://www.runoob.com/jsp/jsp-jstl.html使用步骤:(1)引入核心标签库对应的taglib(报错可能是因为服务器没有jstl标签的依赖包) 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; (2)使用其中的if和out 标签 123456789&lt;form action=&quot;JSTLDemo01.jsp&quot; method=&quot;get&quot;&gt;&lt;%-- EL表达式获取表单中的数据--%&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;$&#123;param.username&#125;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;&lt;/form&gt;&lt;%--判断参数username的值,并且定义一个变量 名为:isAdmin.值为这个if语句的值--%&gt;&lt;c:if test=&quot;$&#123;param.username==&quot;admin&quot;&#125;&quot; var=&quot;isAdmin&quot;/&gt; &lt;c:out value=&quot;管理员欢迎您!&quot; /&gt;&lt;c:out value=&quot;$&#123;isAdmin&#125;&quot;&gt;&lt;/c:out&gt; 9、javaBean实体类要求JavaBean有特定的写法 必须有无参构造 属性必须私有化（private）一般用来和数据库的字段做映射ORM : 对象关系映射 表 –&gt;类 字段–&gt;属性 行记录–&gt;对象12345678&lt;jsp:useBean id=&quot;Student&quot; class=&quot;com.pojo.Student&quot;/&gt; &lt;jsp:setProperty name=&quot;Student&quot; property=&quot;stuNO&quot; value=&quot;001&quot;&gt;&lt;/jsp:setProperty&gt; &lt;jsp:setProperty name=&quot;Student&quot; property=&quot;name&quot; value=&quot;lili&quot;&gt;&lt;/jsp:setProperty&gt; &lt;jsp:setProperty name=&quot;Student&quot; property=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/jsp:setProperty&gt; 学号:&lt;jsp:getProperty name=&quot;Student&quot; property=&quot;stuNO&quot;/&gt; 姓名:&lt;jsp:getProperty name=&quot;Student&quot; property=&quot;name&quot;/&gt; 年龄:&lt;jsp:getProperty name=&quot;Student&quot; property=&quot;age&quot;/&gt; (存在一个小问题！找不到实体类) JDBC(重点) JDBC介绍Sun公司为了简化开发人员的(对数据库的统一)操作,提供了(Java操作数据库的)规范,俗称JDBC,这些规范的由具体由具体的厂商去做对于开发人员来说,我们只需要掌握JDBC接口的操作即可 所需要的jar包 java.sql(默认有) javax.sql(默认有)还需要导入数据库驱动包 java程序链接mySQL步骤: 加载驱动 登陆链接数据库对象 创建statement对象,用于执行sql语句 statement(清单) 执行sql语句 返回结果集,结果集中封装了我们查询的所有结果 释放链接 12345678910111213141516171819202122232425262728 // 1.加载驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //协议://主机:端口/数据库名?编码设置&amp;使用安全的链接 String url = &quot;jdbc:mysql://localhost:3306/db01?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&quot;; String use = &quot;root&quot;; //用户名 String password = &quot;123456&quot;; //密码 //2.登陆链接数据库对象 Connection connection = DriverManager.getConnection(url, use, password); //3.创建statement对象,用于执行sql语句 statement(清单) Statement statement = connection.createStatement(); //4.执行sql语句 String sql = &quot;SELECT * from class&quot;; //sql语句 //5.返回结果集,结果集中封装了我们查询的所有结果 ResultSet resultSet = statement.executeQuery(sql); while (resultSet.next())&#123; System.out.println(&quot;classno:&quot;+resultSet.getNString(&quot;classno&quot;)); System.out.println(&quot;classname:&quot;+resultSet.getNString(&quot;classname&quot;)); System.out.println(&quot;department:&quot;+resultSet.getNString(&quot;department&quot;)); System.out.println(&quot;monitor(班长):&quot;+resultSet.getNString(&quot;monitor(班长)&quot;)); System.out.println(&quot;==========================================================&quot;); &#125; //6.释放链接 resultSet.close(); statement.close(); connection.close(); &#125;&#125; 几个重要对象DirverManager 驱动管理 12Class.forName(&quot;com.mysql.jdbc.Driver&quot;);DriverManager.registerDriver(new Driver()); //这是Driver源码 URL 资源地址 12//协议://主机:端口/数据库名?编码设置&amp;使用安全的链接String url = &quot;jdbc:mysql://localhost:3306/db01?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&quot;; Connection 链接对象,操作数据库的对象 123456789connection.commit(); //提交事务connection.rollback(); //回滚事务connection.setAutoCommit(); //自动提交事务**Statemen 清单,执行sql的对象**```javastatement.executeQuery(&quot;sql&quot;); //执行查询,返回结果集statement.executeUpdate(&quot;sql&quot;); //执行更新(插入和删除也算更新),返回受影响的行数statement.execute(&quot;sql&quot;); //执行全部的sql语句 ResultSet:查询后的结果集 获取数据: 12345resultSet.getNString();resultSet.getObject(); //不知道什么类型的情况下使用resultSet.getInt();resultSet.getDate();resultSet.getFloat(); 指针移动: 12345resultSet.next();resultSet.previous();resultSet.absolute();resultSet.beforeFirst();resultSet.afterLast(); 关闭链接 123resultSet.close();statement.close();connection.close(); JDBC工具类为了方便使用,我们一般会将其封装成一个工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package jdbcUtility;import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JdbcUtilityDemo &#123;//从配置文件db.properties中加载信息 static InputStream in = JdbcUtilityDemo.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); static Properties pro = new Properties(); static Statement statement; static Connection con; //从配置文件中初始化配置 static &#123; try &#123; pro.load(in); //将配置文件的信息加载到 pro对象中 Class.forName(pro.getProperty(&quot;driver&quot;)); //通过类反射加载驱动 //获得参数 String url = pro.getProperty(&quot;url&quot;); String user = pro.getProperty(&quot;user&quot;); String password = pro.getProperty(&quot;password&quot;); //设置链接参数 con = DriverManager.getConnection(url,user,password); statement = con.createStatement(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //查询 public ResultSet select(String sql) &#123; ResultSet resultSet = null; try &#123; resultSet = statement.executeQuery(sql); if (resultSet.next()) &#123; System.out.println(&quot;查询成功!&quot;); &#125; else&#123; System.out.println(&quot;查询失败!&quot;); return null; &#125; &#125; catch (SQLException throwable) &#123; System.out.println(throwable.toString()); &#125; while (true)&#123; if(resultSet==null) return null; try &#123; System.out.print(&quot;id:&quot;+resultSet.getObject(1)+&quot;\\t&quot;); System.out.print(&quot;password:&quot;+resultSet.getObject(2)+&quot;\\t&quot;); System.out.print(&quot;name:&quot;+resultSet.getObject(3)+&quot;\\t&quot;); System.out.print(&quot;sex:&quot;+resultSet.getObject(4)+&quot;\\t&quot;); System.out.print(&quot;birthday:&quot;+resultSet.getObject(5)+&quot;\\t&quot;); System.out.println(&quot;\\n&quot;); if (!resultSet.next()) break; &#125; catch (SQLException throwable) &#123; System.out.println(throwable.toString()); &#125; &#125; return resultSet; &#125; //更新,包括插入和删除 public int update(String sql) &#123; int n = 0; try &#123; n = statement.executeUpdate(sql); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; if(n&gt;0)&#123; System.out.println(&quot;修改成功!&quot;+&quot;\\n&quot;); &#125; else System.out.println(&quot;修改失败&quot;); return n; &#125; public void execSQL(String sql)&#123; try &#123; if (statement.execute(sql)) &#123; System.out.println(&quot;执行成功!&quot;); &#125; else System.out.println(&quot;执行失败&quot;); &#125; catch (SQLException throwable) &#123; System.out.println(throwable.toString()); &#125; &#125; public static void close()&#123; try &#123; statement.close(); con.close(); in.close(); &#125; catch (Exception throwables) &#123; throwables.printStackTrace(); &#125; &#125;&#125; 其中db.properties文件信息如下: 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db01?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=trueuser=rootpassword=123456 SQL注入的问题SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。即:通过sql语句的漏洞来实现一些非法操作. 12// 欲根据用户id来进行获取用户的其他信息,但是使用如下语句就会将所有用户的信息都查询到select * from db01.user where (id =&#x27; &#x27;or 1=1)&quot;; --sql注入 PreparedStatement对象可以防止sql注入,并且效率更高,如:在编辑sql语句时使用?代表占位符,并且预编译sql语句,随后在设置参数防止sql注入 常用方法:123456preparedStatement.executeQuery();preparedStatement.executeUpdate();preparedStatement.setString(); //给参数传递字符串类型的值preparedStatement.setInt(); //给参数传递 int 类型的值preparedStatement.setDate(); //给参数传递 Date 类型的值... 等等 例子: 12345678//带参数的sql语句String sql = &quot;select * from db01.user where(id = ?)&quot; ;//预编译sql语句并且返回一个PreparedStatement对象preparedStatement = con.prepareStatement(sql);//给参数传递值(适当的使用对应类型的方法能提高效率)preparedStatement.setString(1,id);//运行sql语句resultSet = preparedStatement.executeQuery(); JDBC操作事务常用方法123connection.setAutoCommit(boolean flag); //设置事务是否自动提交,默认是提交的connection.commit(); //提交事务connection.rollback(); //回滚事务,一般不用设置,事务一般发送错误会自动回滚 下面代码是模拟一笔转账操作,A账户减少100元,B账户增加100元,两个sql操作为一个事务,同时执行成功或者失败(失败事务发生回滚) 12345678910111213141516171819JdbcUtility jdbc = new JdbcUtility();try &#123; //关闭自动提交事务 jdbc.con.setAutoCommit(false); //进行一笔转账操作,其中update()方法,参数1代表付款或者收款人,参数2代表是否收款 jdbc.update(&quot;A&quot;,true); jdbc.update(&quot;B&quot;,false); //提交一笔转账事务 jdbc.con.commit(); &#125; catch (SQLException throwables) &#123; try &#123; //实际上事务会自动回滚当出现错误时 jdbc.con.rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; throwables.printStackTrace();&#125; 数据库链接池10、MVC三层架构什么是MVC: Model View Controller 模型 ,视图,控制器 早期建架构用户直接访问控制层,控制层就可以直接操作数据库 MVC架构介绍 Model 业务处理:业务逻辑(Service) 数据持久层: CRUD (Dao) View 展示数据 提供连接发起Servlet请求(a , form, img) Controller (Servlet) 接收用户请求: (req: 请求参数,Session信息…) 交给业务层处理对应的代码 控制视图的跳转 11、Filter过滤器与监听器Filter: 过滤器,用来过滤网站的数据 处理中文乱码 登陆验证… 编写过滤器实现过滤中文乱码问题过滤器中FilterChain过滤链对象FilterChain对象用于让请求继续执行,如果使用过滤将会导致过滤执行就就会停止执行后面语句 编写过滤器需要实现javax.servlet包下得Filter接口 12345678910111213141516171819202122232425public class CharacterEncodingFilter implements Filter &#123; @Override //初始化:在web服务启动时就会对过滤进行初始化 public void init(FilterConfig filterConfig) throws ServletException &#123; Filter.super.init(filterConfig); &#125; //执行 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(&quot;utf-8&quot;); servletResponse.setCharacterEncoding(&quot;utf-8&quot;); servletResponse.setContentType(&quot;text/html;charset=utf-8&quot;); System.out.println(&quot;过滤器执行前...&quot;); //过滤链: 让请求继续执行,不写则在程序此处停止 filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;过滤器执行后...&quot;); &#125; //销毁: 在web服务器关闭时才会销毁 @Override public void destroy() &#123; Filter.super.destroy(); System.out.println(&quot;销毁!&quot;); &#125;&#125; 同时还需要在web.xml文件中配置Filter,类似servle一样,也可以使用注解@WebFilter(value=&quot;url&quot;)注册 12345678910&lt;!--配置过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;DemoFilter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;&lt;!-- 注意! 这样在这个目录下过滤器才会生效--&gt; &lt;url-pattern&gt;/show/servlet&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 监听器类似GUI中的监听器，用于监听各种事件，如下例子使用Session监听器来实现统计在线人数的Demo 即:每开启一个对话则认为有一个用户在线,并且在前端页面打印出来人数 编写监听器(实现Session接口的servlet) 123456789101112131415161718192021222324252627282930313233343536373839package DemoListener;import javax.servlet.ServletContext;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;public class SessionListener implements HttpSessionListener &#123; @Override public void sessionCreated(HttpSessionEvent se) &#123;// 获得context对象 ServletContext context = se.getSession().getServletContext();// 获得 上下文存储的在线人数 Integer count = (Integer) context.getAttribute(&quot;onlineCount&quot;);// 如果此次访问为第一个用户 if(count == null)&#123; count = 1; &#125; else&#123; // 让 公用上下文对象的属性值+1 count++; &#125;// 更新在线人数 context.setAttribute(&quot;onlineCount&quot;,count); &#125;/*注意！关闭浏览器并不会导致Session销毁，浏览器关闭只会导致cookie消失,平常我们退出浏览器后要重新登陆是因为一般cookie中保存了SessionIDSession销毁只能是会话结束:(1)服务器关闭(2)Sesion会话超时(到达Seesion 有效期)(3)手动结束 session.invalidate(); */ @Override public void sessionDestroyed(HttpSessionEvent se) &#123; ServletContext context = se.getSession().getServletContext(); Integer count = (Integer) context.getAttribute(&quot;onlineCount&quot;); context.setAttribute(&quot;onlineCount&quot;,--count); &#125;&#125; 编写配置文件 web.xml 注册监听器 123&lt;listener&gt; &lt;listener-class&gt;DemoListener.SessionListener&lt;/listener-class&gt; &lt;/listener&gt; jsp响应页面 123456789101112131415161718192021222324&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;使用Session和监听器来查看访问的人数&lt;/h3&gt;&lt;p&gt; &lt;span&gt; 当前在线人数为:&lt;%-- 方式一 --%&gt; &lt;%=this.getServletConfig().getServletContext().getAttribute(&quot;onlineCount&quot;)%&gt;&lt;%-- EL表达式 --%&gt;&lt;%-- 注意!!! 通过 页面上下文获取 这样获取不到--%&gt; &lt;br&gt;EL表达式1: $&#123;pageContext.getAttribute(&quot;onlineCount&quot;)&#125;&lt;%-- 通过应用程序对象直接获取,即application相当于ServletContext--%&gt; &lt;br&gt;EL表达式2: $&#123;applicationScope.onlineCount&#125; 人! &lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ​ 文件上传处理文件上传原理当浏览器通过表单提交上传文件时，文件数据都附带在HTTP请求消息体中，并且采用MIME类型（多用途互联网邮件扩展类型）进行描述，在后台可以使用request对象提供的getInputStream()方法读取客户端提交过来的数据。但由于用户可能会同时上传多个文件，而在Servlet端直接读取上传数据，并分别解析出相应的文件数据是一项非常麻烦的工作。 为了方便处理用户上传的数据，Apache组织提供了一个开源组件Commons- FileUpload，该组件可以方便地将“multipart/form-data”类型请求中的各种表单域解析出来，并实现一个或多个文件的上传，同时也可以限制上传文件的大小等。Commons-FileUpload组件性能十分优异，并且使用非常简单。 前端页面上传表单注意点: 要设置name属性 请求方式post没有大小限制, get有 需要将enctype属性设置为multipart/form-date 1234&lt;form method=&quot;post&quot; action=&quot;/fileUpload&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;uploadFile&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;确定提交&quot;&gt; &lt;/form&gt; Commons- FileUpload组件需要的依赖包使用的jar包： commons-fileupload-1.4.jar commons-io-2.6.jar maven依赖: 12345678910111213&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt;&lt;/dependency&gt; 工作流程: 上传到服务器的具体流程如下: DiskFileItemFactory类DiskFileItemFactory类用于将请求消息实体中的每一个文件封装成单独的FileItem对象。如果上传的文件比较小，将直接保存在内存中，如果上传的文件比较大，则会以临时文件的形式，保存在磁盘的临时文件夹中。默认情况下，不管文件保存在内存还是磁盘临时文件夹，文件存储的临界值是10240字节，即10KB。 构造器: 方法声明 功能描述 DiskFileItemFactory() 采用默认临界值和系统临时文件夹构造文件项工厂对象 DiskFileItemFactory(int sizeThreshold，File repository) 采用参数指定临界值和系统临时文件夹构造文件项工厂对象 sizeThreshold:表示文件保存在内存还是磁盘临时文件夹中的临界值. repository表示临时文件的存储路径 常用方法: 方法声明 功能描述 **** setDefaultCharset(String charset) 设置编码集 setSizeThreshold(int sizeThreshold) 设置缓存区的最大临界值,单位是字节 setRepository(File repository) 临时文件的存储路径 ServletFileUpload类ServletFileUpload类是Apache组件处理文件上传的核心高级类，通过调用parseRequest(HttpServletRequest) 方法可以将HTML中每个表单提交的数据封装成一个FileItem对象，然后以List列表的形式返回。 构造器: 方法声明 功能描述 ServletFileUpload() 构造一个未初始化的ServletFileUpload实例对象 ServletFileUpload(FileItemFactory fileItemFactory) 根据参数指定的FileItemFactory 对象创建一个ServletFileUpload对象 常用方法: 方法声明 功能描述 **** setHeaderEncoding(String encoding) 设置请求头编码,防止文件乱码 setFileSizeMax(int byte) 限制单个文件上传的最大文件大小 setSizeMax(int byte) 限制本次请求最大能上传的所有文件总大小 parseRequest(HttpServletRequest req) 返回请求把每个表单封装成FileItem对象的List集合 FileItemFileItem接口主要用于封装单个表单字段元素的数据，一个表单字段元素对应一个FileItem对象。Commons-FileUpload组件在处理文件上传的过程中，将每一个表单域（包括普通的文本表单域和文件域）封装在一个FileItem对象中。为了便于讲解，在此将FileItem接口的实现类称为FileItem类 常用方法: 方法声明 功能描述 boolean isFormField() isFormField()方法用于判断FileItem类对象封装的数据是一个普通文本表单字段，还是一个文件表单字段，如果是普通文本表单字段则返回true，否则返回false。 String getName() getName()方法用于获取文件上传字段中的文件名。如果FileItem类对象对应的是普通文本表单字段，getName()方法将返回null，否则，只要浏览器将文件的字段信息传递给服务器，getName()方法就会返回一个字符串类型的结果，如C:\\Sunset.jpg。 String getFieldName() getFieldName()方法用于获取表单type类型为file的字段元素描述头的name属性值，也是表单标签name属性的值。例如“name=file1”中的“file1”。 type不为file则返回null String getString() getString()方法用于将FileItem对象中保存的数据流内容以一个字符串形式返回。它有两个重载的定义形式：①public String getString()②public String getString(java.lang.String encoding)前者使用默认的字符集编码将主体内容转换成字符串，后者使用参数指定的字符集编码将主体内容转换成字符串。 String getContentType() getContentType()方法用于获得上传文件的类型，即表单字段元素描述头属性“Content-Type”的值，如“image/jpeg”。如果FileItem类对象对应的是普通表单字段，该方法将返回null。 void write(File file) 不好用!!!! write()方法用于将FileItem对象中保存的主体内容保存到某个指定的文件中。如果FileItem对象中的主体内容是保存在某个临时文件中，那么该方法顺利完成后，临时文件有可能会被清除。另外，该方法也可将普通表单字段内容写入到一个文件中，但它主要用于将上传的文件内容保存到本地文件系统中。 基础使用测试用例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import org.apache.commons.fileupload.*;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;import java.util.List;@WebServlet(&quot;/fileUpload&quot;)public class FileUploadServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; if (!ServletFileUpload.isMultipartContent(req)) &#123; //判断是否为上传文件的请求 System.out.println(&quot;不是上传文件请求!&quot;); return; &#125; /* 关于上传的路径问题,需要永久保存的文件最好别放在web应用目录里 因为每次重新部署项目或者重启Tomcat都会刷新webapp的目录,到时候存放的文件就会被删除 临时文件就无所谓咯 */ String uploadPath = &quot;E:\\\\Code\\\\Java_idea\\\\java-web\\\\上传文件\\\\File&quot;;// String uploadPath = this.getServletContext().getRealPath(&quot;WEB-INF/upload&quot;); //注意部署的不是jar包会为null System.out.println(uploadPath); // 创建文件对象 File uploadFile = new File(uploadPath); if (!uploadFile.exists()) &#123; // 上传路径不存在就创建 uploadFile.mkdirs(); &#125; // 1.创建 文件项工厂 DiskFileItemFactory fileItemFactory = new DiskFileItemFactory(); fileItemFactory.setSizeThreshold(1024); // 设置缓存区为1M File tempFile = new File(uploadFile+&quot;temp&quot;); fileItemFactory.setRepository(tempFile); // 设置文件临时存储路径 fileItemFactory.setDefaultCharset(&quot;utf-8&quot;); // 设置文件编码 // 2.获取Servlet文件上传对象,通过 文件项工厂获取 ServletFileUpload fileUpload = new ServletFileUpload(fileItemFactory); fileUpload.setHeaderEncoding(&quot;utf-8&quot;); //设置编码 fileUpload.setFileSizeMax(1024*1024*60); // 限制单个文件上传的最大文件大小(单位是字节,下同) fileUpload.setSizeMax(1024*1024*20); // 设置本次请求最大能上传的所有文件总大小 // 3.根据Servlet文件上传对象获取本次请求的 文件项集合 List&lt;FileItem&gt; fileItems = null; try &#123; fileItems = fileUpload.parseRequest(req); &#125; catch (FileUploadException e) &#123; // 如果因为超过大小限制等原因导致抛出异常 resp.getWriter().write(&quot;滚!超过文件大小限制了&quot;); &#125; // 4.使用IO流通过 文件项 中获取文件的数据信息 InputStream fileInputStream = null; FileOutputStream fileOutputStream = null; byte[] buffer = new byte[1024]; //缓存字节数组 for (FileItem item : fileItems) &#123; //遍历 文件项集合 if (item.isFormField()) &#123; //判断是普通表单还是文件上传表单 System.out.print(&quot;表单name属性值:&quot; + item.getFieldName() + &quot;对对应属性value为&quot; + req.getParameter(item.getFieldName())); System.out.println(); &#125; else &#123; // 文件项是上传文件的表单 try &#123; System.out.print(&quot;表单name属性值:&quot; + item.getFieldName()); System.out.print(&quot;-文件名为:&quot; + item.getName()); System.out.print(&quot;-文件类型:&quot; + item.getContentType()); System.out.println(); if (item.getName().trim().equals(&quot;&quot;)||item.getName()==null)&#123; //如果有一个表单没上传或者文件名为空 continue; &#125; //创建文件 uploadFile = new File(uploadPath, item.getName()); uploadFile.createNewFile(); //获取该文件的输出流 fileOutputStream = new FileOutputStream(uploadFile); //数据流传输 fileInputStream = item.getInputStream(); //获取FileItem的输入流 int len = 0; while ((len = fileInputStream.read(buffer)) &gt; 0) &#123; fileOutputStream.write(buffer, 0, len); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; try &#123;// 关闭流 fileInputStream.close(); fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 删除临时文件 for (File f:tempFile.listFiles())&#123; if (!f.isDirectory())&#123; f.delete(); &#125; &#125; &#125;&#125; 文件上传进度监听器1234567891011 ServletFileUpload fileUpload = new ServletFileUpload(fileItemFactory); // 监听进度fileUpload.setProgressListener((pBytesRead, lpContentLength, n)-&gt;&#123; //pBytesRead:已读取到的文件大小 //pContentLenght：文件大小 System.out.println(&quot;总大小：&quot;+lpContentLength+&quot;已上传：&quot;+ (float)pBytesRead/lpContentLength*100+&quot;%&quot;); &#125;);// 注意! 实现监听器接口一定要在设置文件上传类属性之前 , 不然w生效 fileUpload.setHeaderEncoding(&quot;utf-8&quot;); //设置编码 fileUpload.setFileSizeMax(1024*1024*5); // 限制单个文件上传的最大文件大小(单位是字节,下同) fileUpload.setSizeMax(1024*1024*6); // 设置本次请求最大能上传的所有文件总大小 邮件发送邮件服务器与传输协议要在网络上实现邮件功能，必须要有专门的邮件服务器。这些邮件服务器类似于现实生活中的邮局，它主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中。 SMTP服务器地址：一般是 smtp.xxx.com，比如163邮箱是smtp.163.com，qq邮箱是smtp.qq.com。 SMTP协议: 通常把处理用户smtp请求(邮件发送请求)的服务器称之为SMTP服务器(邮件发送服务器)。 POP3协议: 通常把处理用户pop3请求(邮件接收请求)的服务器称之为POP3服务器(邮件接收服务器)。 工作原理: 步骤: ①发信人调用用户代理来撰写和编辑要发送的邮件。用户代理用SMTP协议把邮件传送给发送方邮件服务器。②发送方邮件服务器将邮件放入邮件缓存队列中，等待发送。③运行在发送方邮件服务器的SMTP客户进程，发现邮件缓存中有待发送的邮件，就向运行在接收方邮件服务器的SMTP服务器进程发起建立TCP连接④TCP连接建立后，SMTP客户进程开始向远程SMTP服务器进程发送邮件。当所有待发送邮件发完后，SMTP就关闭所建立的TCP连接。⑤运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户邮箱，等待收信人在方便时进行读取。⑥收信人打算收信时，调用用户代理，使用POP3(或IMAP）协议将自己的邮件从接收方邮件服务器的用户邮箱中取回（如果邮箱中有来信的话）。 邮箱提供的支持:我们需要到邮箱设置中开开启POP3/SMTP服务 , 获取授权码 , 如下以QQ邮箱为例, QQ邮箱–&gt;邮箱设置–&gt;账户–&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 开启POP3/SMTP服务，然后获取16位授权码（注意不要将授权码泄露，一个账户可以拥有多个授权码） Java第三方库我们可以调用activation-1.1.1.jar , mail-1.4.7.jar 第三方库使用java实现发送邮箱功能 Maven导入:12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; &lt;artifactId&gt;javax.mail&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.mail/javax.mail-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;javax.mail-api&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 工作流程: 代码实现:普通文本邮件发送:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.util.Properties;public class Demo1 &#123; public static void main(String[] args) throws MessagingException &#123; Properties properties = new Properties(); properties.setProperty(&quot;mail.host&quot;,&quot;smtp.qq.com&quot;);///设置QQ邮件SMTP服务器 properties.setProperty(&quot;mail.transport.protocol&quot;,&quot;smtp&quot;);//邮件发送协议 properties.setProperty(&quot;mail.smtp.auth&quot;,&quot;true&quot;);//需要验证用户密码 authentication //以前QQ邮箱需要设置SSL加密 , 现在不需要了// MailSSLSocketFactory sf=new MailSSLSocketFactory();// sf.setTrustAllHosts(true);// properties.put(&quot;mail.smtp.ssl.enable&quot;,&quot;true&quot;);// properties.put(&quot;mail.smtp.ssl.socketFactory&quot;,sf); //1.创建定义整个应用程序所需要的环境信息的session对象 Session session = Session.getDefaultInstance(properties, new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; // 设置链接SMTP服务器的用户邮箱,即发送者的邮箱 return new PasswordAuthentication(&quot;318482536@qq.com&quot;,&quot;邮箱厂商提供的校验码&quot;); &#125; &#125;); //开启session的debug模式，这样可以查看到程序发送Email的运行状态 session.setDebug(true); //2.通过session得到transport对象 Transport ts=session.getTransport(); //3.使用邮箱的用户名和授权码连上邮件服务器 ts.connect(&quot;smtp.qq.com&quot;,&quot;318482536@qq.com&quot;,&quot;邮箱厂商提供的校验码&quot;); //4.创建邮件：写文件 //注意需要传递session MimeMessage message=new MimeMessage(session); //指明邮件的发件人 message.setFrom(new InternetAddress(&quot;318482536@qq.com&quot;)); //指明邮件的收件人 message.setRecipient(Message.RecipientType.TO,new InternetAddress(&quot;318482536@qq.com&quot;)); //邮件标题 message.setSubject(&quot;邮件标题&quot;); //邮件的文本内容 message.setContent(&quot;文件内容&quot;,&quot;text/html;charset=UTF-8&quot;); //5.发送邮件 ts.sendMessage(message,message.getAllRecipients()); //6.关闭连接 ts.close(); &#125;&#125; 文本内嵌图片邮件发送:多用途互联网邮件扩展（英语：Multipurpose Internet Mail Extensions，缩写：MIME）是一个互联网标准，它扩展了电子邮件标准，使其能够支持： 非ASCII字符文本； 非文本格式附件（二进制、声音、图像等）； 由多部分（multiple parts）组成的消息体； 包含非ASCII字符的头信息（Header information）。这个标准被定义在 RFC 2045、RFC 2046、RFC 2047、RFC 2048、RFC 2049 等RFC中。 在上面普通文本文件的基础上,在设置邮件内容时,追加如下代码即可 12345678910111213141516171819202122232425262728//设置邮件的文本内容 //=================================准备图片数据======================================= MimeBodyPart image=new MimeBodyPart(); //图片需要经过数据化的处理 DataHandler dh=new DataHandler(new FileDataSource(&quot;E:\\\\幼年神里凌华.jpeg&quot;)); //在part中放入这个处理过图片的数据 image.setDataHandler(dh); //给这个part设置一个ID名字 image.setContentID(&quot;bz.jpg&quot;); //准备正文的数据 MimeBodyPart text=new MimeBodyPart(); text.setContent(&quot;这是一张正文&lt;img src=&#x27;cid:bz.jpg&#x27;&gt;&quot;,&quot;text/html;charset=UTF-8&quot;); //描述数据关系 MimeMultipart mm=new MimeMultipart(); mm.addBodyPart(text); mm.addBodyPart(image); mm.setSubType(&quot;related&quot;); //设置消息内容, 并且保存数据关系 message.setContent(mm); message.saveChanges(); //5.发送邮件 ts.sendMessage(message,message.getAllRecipients()); //6.关闭连接 ts.close(); 附件邮件发送:在普通本文邮件的基础上添加如下内容即可: 1234567891011121314151617181920212223/*************设置邮件的文本内容***********************/ //正文 MimeBodyPart text = new MimeBodyPart(); text.setContent(&quot;这是一封带有附件的邮件&quot;,&quot;text/html;charset=utf-8&quot;); //附件 MimeBodyPart appendix = new MimeBodyPart(); appendix.setDataHandler(new DataHandler(new FileDataSource(&quot;E:\\\\幼年神里凌华.jpeg&quot;))); appendix.setFileName(&quot;附件文件名.jpeg&quot;);// 拼接邮件内容 MimeMultipart allContent = new MimeMultipart(); allContent.addBodyPart(appendix);//附件 allContent.addBodyPart(text);//正文 allContent.setSubType(&quot;mixed&quot;); //正文和附件都存在邮件中，所有类型设置为mixed message.setContent(allContent); message.saveChanges(); //5.发送邮件 ts.sendMessage(message,message.getAllRecipients()); //6.关闭连接 ts.close(); 封装好的工具类:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import javax.mail.*;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.util.Properties;public class MailUtil &#123; public String addresser; //发送者邮箱名 public String hostName; // 邮箱主机名 private String checkCode; // 校验码 private Properties properties; // 配置 private Session session; private Transport transport; private boolean isDebug = false; // 默认用QQ发送 public void properties()&#123; properties(&quot;smtp.qq.com&quot;); &#125; //配置需要发送的邮箱类型,QQ ,163等 public void properties(String mailHost)&#123; this.hostName = mailHost; properties = new Properties(); properties.setProperty(&quot;mail.host&quot;,mailHost);///设置QQ邮件SMTP服务器 properties.setProperty(&quot;mail.transport.protocol&quot;,&quot;smtp&quot;);//邮件发送协议 properties.setProperty(&quot;mail.smtp.auth&quot;,&quot;true&quot;);//需要验证用户密码 authentication &#125; //设置发送者的邮箱信息,如邮箱名, 校验码,是否打印deBug日志 public void senderInfo(String addresser,String checkCode,boolean isDebug) throws MessagingException &#123; this.addresser = addresser; this.checkCode = checkCode; this.session = Session.getDefaultInstance(properties, new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication(addresser,checkCode); &#125; &#125;); this.transport = session.getTransport(); this.transport.connect(addresser,checkCode); &#125; // 发送普通文本邮件 public void sendTextMailMessage(String recipients,String mailTitle,String mailContent) throws MessagingException &#123; MimeMessage message=new MimeMessage(this.session); //设置邮件的发件人 message.setFrom(new InternetAddress(this.addresser)); //设置邮件的收件人 message.setRecipient(Message.RecipientType.TO,new InternetAddress(recipients)); //邮件标题 message.setSubject(mailTitle); //邮件的文本内容 message.setContent(mailContent,&quot;text/html;charset=UTF-8&quot;); //5.发送邮件 this.transport.sendMessage(message,message.getAllRecipients()); //6.关闭连接 this.transport.close(); &#125;&#125; 通过工具类使用: 12345678// 1.创建工具类对象MailUtil mailUtil = new MailUtil();// 2.设置服务器主机名mailUtil.properties(); //默认用QQ邮箱发送,也可以通过有参方法设置别的邮箱发送,设置成别的邮箱服务器主机名即可//mailUtil.properties(&quot;服务器主机名&quot;);// 3.设置发送邮件的相关信息mailUtil.senderInfo(&quot;发送者的邮箱名&quot;,&quot;邮箱服务厂商提供的校验码&quot;,true); //设置发送者的信息mailUtil.sendTextMailMessage(&quot;收件人的邮箱名&quot;,&quot;邮件标题&quot;,&quot;邮件内容&quot;); // 设置需要发送的内容标题等信息","categories":[{"name":"Java系列","slug":"Java系列","permalink":"https://lqy679.github.io/categories/Java%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"sql","slug":"sql","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-23T01:16:08.457Z","comments":true,"path":"2020/01/01/sql/","link":"","permalink":"https://lqy679.github.io/2020/01/01/sql/","excerpt":"SQL之增删改查注: 用方括号括起来的内容表示可选,非必填, [可选项 ] 此外,在mysql中,若想用的名称已经有关键字占用了(如user) , 可用反引号包裹,来使用 , 例如: select * from `user` 增删改查(数据表)","text":"SQL之增删改查注: 用方括号括起来的内容表示可选,非必填, [可选项 ] 此外,在mysql中,若想用的名称已经有关键字占用了(如user) , 可用反引号包裹,来使用 , 例如: select * from `user` 增删改查(数据表)insert插入数据指定插入哪些字段(如果有主键,主键必须插入内容); 并且插入是支持多行插入的 语法：insert into 表名 [（列名1,列名2 ,…….）] values (数据列表) [ ,(数据列表)…. ] 假设存在一个学生表,有 sid ,name ,age,score 四个字段 12345-- 插入多个学生信息,但不插入年龄insert into student (sid,name,score) values(1001,&quot;南城&quot;,98),(1002,&quot;南城2&quot;,98),(1003,&quot;南城3&quot;,98) 当需要插入全部字段时候,可以省略 (列名1, 列名2, 列名n…) ,但此时values 后面的数据列表顺序必须和表的结构一样 12345-- 不指定插入字段,全部插入,注意! 插入的数据,数据列表必须对应表的结构(成绩不能写在年龄前面)insert into student values(1001,&quot;南城&quot;, 18,98),(1002,&quot;南城2&quot;,19,98),(1003,&quot;南城3&quot;,20,98) 删除数据语法:delete from 表名 [where 定位条件] 若不写定位条件则将表中所有数据全部删除 !!! where可以配合多种运算符使用: 如: or 逻辑或 , and 逻辑与 , like 匹配 ,in 多项目匹配 比较运算(&gt; &lt; != = )** in运算符介绍: 字段 in(value1, value2, value3…) 相当于 字段 = value1 or 字段 = value2 or 字段 = value3 ….. 123-- 删除学生表中,年龄大于22,并且学号小于1800的,或者成绩为 0 的学生delete from studentwhere (age&gt;22 and sid &lt; 1800) or score = 0 修改(更新)数据语法：update 表名 set 列名 = 新值 [ , 列名 = 新值….] where 定位条件 123-- 将学号为1002的学生的成绩改为78 ,名字改为南枫update student set score = 78,name = &#x27;南枫&#x27; where id = &#x27;1002&#x27; 查找数据语法: :select [top n 指定返回前n行] 列名1 [as 别名] [,列名2[ as 别名],….] from 表名 [ where 定位条件 ] 若不写 where 则查询所有数据行 ; 列名1[,列名2,….] 代表需要查询数据行的哪些字段, 若要查询所有字段, 可以 用 * 替代 12345678 -- 查询学生表的所有信息 , 分号可写可不写select * from student ;-- 查询学生表中年龄大于18的,学生的姓名,成绩select name,score from student where age&gt;18 -- 此外还可以给查询到的结果集起别名,例如将上例中的name字段, 将以student_name的名字返回select name as student_name,score from student where age&gt;18 分页查询可在查询语句后追加limit 关键字进行结果集分页 limit [starindex] pageSize 参数:starindex 代表从哪个索引开始分页,第一条数据行索引为0,不写此参数也为0, 参数:pageSize代表每页最多有多少条数据行, 必填项* 12-- -- 查询学生表中年龄大于18的,学生的姓名,成绩,并且从结果集的第5行为开始展示,每页展示10个人select name,score from student where age&gt;18 limit 4 10 条件(模糊)查询where可以配合多种运算符使用: 如: or 逻辑或 , and 逻辑与 , like 匹配 ,in 多项目匹配 比较运算(&gt; &lt; != = )** in运算符介绍: 字段 in(value1, value2, value3…) 相当于 字段 = value1 or 字段 = value2 or 字段 = value3 … 更多详细可查阅资源SQL| 菜鸟教程 (runoob.com) ==注意! ! !对于判断 null值==不过对于列值为null的，要用 is null 或 is not null而不能用(!)=) 模糊查询(通配符使用)模糊查询通常是 like 配合SQL 通配符使用 通配符 描述 % 替代 0 个或多个字符 _ 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符 12345678-- 查找学生表中所有姓张的学生select * from student where name like &#x27;张%&#x27;-- 查找学生学号带有a,b,c任意一个字符的学生select * from student where sid like [&#x27;abc&#x27;]-- 查找学生学号不带有1,2,3,任意一个字符的学生select * from student where sid like [!&#x27;123&#x27;] 多表(链接)查询(join) &lt;待写&gt;所谓多表查询,就是把多个表链接起来(通过主键外键)进行查询 让我们来回顾一下查询语句的语法格式,其实更官方一点应该是这样描述的 语法: select [top n 指定返回前n行] 列名1[,列名2,或者用* 表示所有的列] [可用 as 来起临时名]form 数据源 [ where 条件] 数据源? 在前面的例子中, 我们这里的数据源一般是只单张表, 其实这里的数据源也可以是多张表的,使用连接方式关键字将多张表建立链接关系从而查询到多张表的数据, 使用关键字 on 确定链接的条件 1select student.* ,Score.* from student inner join Score on student.id=Score.sid sql数据库的表连接方式图文详解 - 后知然后觉 - 博客园 (cnblogs.com) 链接可分为: 外连接 左外连接( left join 或 left outer join):左外连接包括left join左表所有行。假设左表中某行在右表没有匹配。则结果中相应行右表的部分所有为空(NULL). 右外链接(right join 或 right outer join) :右外连接包括right join右表所有行，假设左表中某行在右表没有匹配，则结果中相应左表的部分所有为空(NULL)。 全然外链接(full join 或 full outer join) :全然外连接包括full join左右两表中所有的行，假设右表中某行在左表中没有匹配，则结果中相应行右表的部分所有为空(NULL)，假设左表中某行在右表中没有匹配，则结果中相应行左表的部分所有为空(NULL)。 内链接 join 或 inner join : 比较运算符，仅仅返回符合条件的行。 交叉连接 ​ cross join :叉联接也称作笛卡尔积。相当于两个表中的所有行进行排列组合。若表a有X行，表b有Y行，则将返回XY行记录。 链接方式图解:假设有两表: 左外链接: 右外链接: 内连接: 交叉链接:","categories":[{"name":"常用知识笔记","slug":"常用知识笔记","permalink":"https://lqy679.github.io/categories/%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"操作系统原理","slug":"操作系统原理","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T09:14:56.399Z","comments":true,"path":"2020/01/01/操作系统原理/","link":"","permalink":"https://lqy679.github.io/2020/01/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/","excerpt":"操作系统原理引论计算机系统由硬件和软件系统两大部门组成,硬件系统是计算机赖以工作的实体,软件系统泽保证了计算机系统的硬件部分按用户指的要求协调地工作 硬件系统: 由 cpu , 内存储器, 外存储器, 输入输出设备 组成, 只有硬件的计算机称为裸机","text":"操作系统原理引论计算机系统由硬件和软件系统两大部门组成,硬件系统是计算机赖以工作的实体,软件系统泽保证了计算机系统的硬件部分按用户指的要求协调地工作 硬件系统: 由 cpu , 内存储器, 外存储器, 输入输出设备 组成, 只有硬件的计算机称为裸机 软件系统分为 : 应用软件, 系统软件 定义: 操作系统是介于计算机硬件和应用软件之间的一个软件系统 操作系统的设计目标 方便性 有效性 可扩展性 开放性 可靠性 可移植性 操作系统的主要功能 处理器管理 存储管理 设备管理 文件管理 用户接口 网络与通信管理 操作系统的基本特征并发性(最重要的特征)并发性是指两个或两个以上的事情或活动在同一时间间隔内发生，（注意，并不是同一个时刻），也就是说在计算机系统中同时存在多个进程，从宏观上看，这些进程是同时并行向前推进的，从微观上讲，任何时刻下只有一个进程执行，如果在单CPU条件下，那么这些进程就是再CPU上交替执行的 操作系统的并发性能够有效改善系统资源的利用率，提高系统的效率，例如：一个进程等待I/O时，就让出CPU，并由系统调度并一个进程占用CPU运行，这样再一个进程等待I/O时候,CPU不会空闲，这就是并发技术 注意,并发性与并行性是两个概念，并发是指两个或以上程序在同一个时间段内同时执行，即宏观上并行，微观上串行，而并行则是指同时执行（同一个时刻都执行） 互斥使用方式（同步）：指当一个进程正在使用某种资源时，其他欲使用该资源的进程必须等待，仅当这个进程使用完该资源并释放后，才允许另一个进程使用这个资源。如打印机，磁带机等都是只允许互斥使用 同时使用方式（异步）：系统中有些资源允许在同一段时间内被多个进程同时使用，这里的“同时”的宏观意义上，典型的可供多个进程同时使用的资源是磁盘，可重进程序（可以供多个用户同时运行的程序），如编译程序 共享性（重要特征）在内存中并发执行的多个进程可以同时使用系统的资源，资源共享的方式可以分为以下两种。 虚拟性不确定性操作系统的逻辑结构 单内核结构 分层结构 微内核结构 操作系统的运行模型 独立运行的内核模型 嵌入到用户进程中执行的模型 作为独立进程运行的模型 操作系统的发展史 手工操作阶段 监控程序阶段(早期批处理阶段) 多道批处理操作系统 分时操作系统 主要的操作系统类型批处理操作系统特征:一批作业自动按提交顺序依次装入内层执行,每次只允许一个作业进入内存工作,先提交的作业总是先完成 分时操作系统 分时操作系统为用户提交互命令 分时操作系统采用分时方法，为多个终端用户服务 分时的方法是将CPU的执行时间划分成若干个时间片 分时操作系统以时间片为单位轮流为各个终端用户服务 时间片分时操作系统将CPU的执行时间划分为若干个片段，这些片段称为时间片。 响应时间是衡量分时操作系统性能的重要指标，时间片的时间长短可以通过控制终端的数量来调整 分时操作系统的特征 独立性 同时性（多路性） 交互性 及时性 分时操作系统与批操作系统的区别 追求的目标不同，批处理操作系统以提高资源利用率与系统吞吐量为主要目标，分时操作系统则以满足用户的人工交互需求以及方便用户使用计算机为主要目标 适应作业不同，批处理系统适用于非交互型的大型作业，而分时操作系统，则适用于交互型的小型作业 作业的控制方式不同，批处理操作系统由用户利用 作业控制语言 书写作业控制说明书并预先提交给系统，处理过程属于脱机工作，分时操作系统是交互型系统，由用户键盘输入操作命令来控制作业，处理过程属于联机工作 资源的利用率不同，批处理系统可合理安排不同负载的作业，使各种资源均衡使用，利用率较高，在分时操作系统中，当多个终端作业使用同类型编译程序和公共子程序（都属于可重载入代码）时，系统调用他的开销较小 实时操作系统典型代表： 火车或飞机订票系统，银行业务处理系统 实时操作系统的主要功能 实时时钟管理 过载保护 高可靠性和安全性 实时操作系统的特征 及时响应和处理 安全可靠 交互能力有限 多路性 分时操作系统与实时操作系统的区别 设计目标不同，分时操作系统为多用户提供一个通用的交互方式，实时操作系统则是为特殊用途提供的专用系统 交互性强弱不同，分时操作系统交互性强，实时操作系统交互性弱 响应时间要求不同，分时操作系统以用户能接受的响应时间为标准，实时操作系统则与受控对象以及应用场合无关，响应时间变化范围很大 微机操作系统也称个人计算机（PC）,一般是指的安装在个人计算机上的图形化界面操作系统，有以下4个特点： 微机操作系统基本上是根据用户使用键盘和鼠标发出的命令进行工作的，对人的动作和反应在时序上的要求并不是很严格 从应用环境来看，微机操作系统面向复杂多变的各类应用 从开发界面来看，微机操作系统为开发人员提供一个“黑箱”，让开发人员通过一系列标准的系统调用来使用操作系统的功能 微机操作系统相对于嵌入式操作系统来说，显得比较庞大，复杂。 微机操作系统分类单用户单任务操作系统单用户多任务操作系统多用户多任务操作系统微机操作系统的特征 开放性，支持不同系统互联，支持分布式处理和支持多CPU系统 通用性，支持应用程序的独立性与不同平台的可移植性。 高性能，随着硬件性能的提升，64位机的逐步普及以及CPU速度的进一步提高。微机操作系统引进了以前中大型机上才能实现的技术，支持虚拟存储器，多线程对称处理器SMP,促使计算机系统性能大大提高 采用微内核结构，提供基本支撑功能的内核极小，大部分操作系统功能由内核之外的运行的服务器（服务程序）来实现 网络操作系统三大主流： Unix,Linux，windows 网络操作系统的工作模式 C/S模式（客户机-服务器） 对等模式，每个站点既可作为服务器，又可以作为客户机 网络操作系统的功能 网络通信 资源管理 网络管理 互操作能力 多CPU操作系统引入的原因：1.增加系统的吞吐量， 2.节省投资 3.提高系统的可靠性 多CPU操作系统的类型1.主从式 2.独立监督式 3.浮动监督式 分布式操作系统定义：通过网络将多个分散的处理单元链接起来，并在分布式处理软件的支持下，构成一个整体而形成的系统 嵌入式操作系统 处理器管理进程进程的定义:进程是一个可并发执行的 , 具有独立功能的程序 , 关于某个数据集合的一次执行过程, 也是操作系统进行资源分配和调度的基本单位 进程的结构:进程实体 = 程序段 + 相关数据段 + PCB (Process Control Block) 进程的特征: **动态性:**进程的实质是程序的一次执行,因此进程是动态的,既然是一次执行,就表明进程有生命周期,具有 “创建 - 运行 - 消亡”的过程 并发性: 多个进程实体在一段时间内能够并发执行.引入进程的目的也正是为了使内存中多的多个程序能够在执行时间上重叠,以提高系统资源的利用率. 独立性: 每个进程都是一个独立运行的基本单位,也是系统进行资源分配和调度的基本单位 异步性:各进程按各自独立的,不可预知的速度向前推进,对单CPU系统而言,任何时刻只能有一个进程占用CPU, 进程获得了所需要的资源即可执行, 得不到所需要的资源则暂停执行.因此, 进程具有 “执行 - 暂停 - 执行” 这种间断性活动规律 结构性: 为了描述和记录进程运行的变化过程, 满足进程独立运行的要求以及能够反映 , 控制并发进程的活动, 系统为了每个进程配置了一个进程控制块PCB , 因此, 从结构上看, 每个进程都由程序段, 数据段, 以及PCB 这三部分组成 进程与程序的区别程序就像是一个乐谱, 任何时候你都可以翻阅他, 但乐谱本身就是静态的,进程则可以看作依照乐谱的一次演奏 , 这个演奏有开始有结束(具有生命期) , 并随着时间的流逝,演奏的音乐不复存在, 也就是说 , 这个演奏过程本身是动态的, 即重新演奏这个乐谱也绝不是刚刚逝去的那段音乐(不是刚刚执行的进程,而是开始一个新的进程) 主要区别体现在如下: 程序是指令的有序集合,是一个静态的概念, 其本身没用任何运行的含义; 进程是程序在CPU上的一次执行过程, 是一个动态的概念 程序作为软件资源可以长期保存 ; 而进程则有生命周期 , 它因创建而诞生 , 因调度而执行, 因得不到资源而暂停执行, 因撤销而消亡 程序作为静态文件既不运行, 也不分配和调度 ; 进程是一个独立运行的基本单位, 也是系统进行资源分配和调度的基本单位 程序是记录在介质(如磁盘)上指令的有序集合, 而进程则是由程序段, 数据段, 和PCB这三部分组成 进程状态两状态模型 : 运行(Running) 或 非运行(Not-running) 三种状态模型: 五种状态模型: 进程控制块(PBC)定义: 一种能够描述和控制进程运行的数据结构, PBC 操作系统中最重要的数据结构之一 PBC中的信息:进程标识符 ,进程当前的状态 , 进程中的程序段和数据段的地址 , 进程资源清单 , 进程优先级 , 进程同步与通信机制 , PCB队列指针或链接字 , 与进程相关的其他信息 PCB的组织方式:线性表方式 ,链接表方式 , 索引表方式 进程控制进程切换的实质是回收当前运行进程对CPU的控制权 , 并将CPU控制权转交给新调度的就绪进程 进程上下文:进程切换时机:引起进程切换的中断分为三种: **中断:**中断发生时,操作系统保存当前运行进程的现场信息,调度新进程运行 **异常:**当CPU在一条指令执行时,检查到有一个或多个预定义的条件或错误产生时就会产生异常,这时,终止当前运行进程的执行,CPU转去执行异常处理程序 **系统调用:**系统调用是对操作系统服务的显示请求.阻塞型系统调用发生时,则当前运行进程被阻塞,此时CPU转去执行进程调度程序 进程上下文:指操作系统用来管理和控制进程的内部数据集合,进程在其上下文中运行.可分为三部分 系统级上下文. 寄存器上下文 用户级上下文 进程上下文切换:进程切换发生时,当前运行进程让出其占用的CPU,由操作系统保存当前运行进程(旧进程)的上下文,并设置被进程调度程序选中的就绪进程(新进程)的上下文环境. 进程切换主要包括6个步骤: 当前运行进程(旧进程)被中断时,保存其CPU现场信息 对被中断的当前运行进程进行PCB更新,包括改变进程状态和其他相关信息. 将被中断的当前的运行进程的PCB移入适当的队列(因时间片到期则移入进程就绪队列,因某事件发生则移入相应的进程阻塞队列) 由进程调度程序选中一个就绪进程(新进程) , 为其设置执行的上下文环境并对其PCB进行更新 修改被选中新进程的地址空间,更新进进程的内存管理信息 恢复被选中的新进程最后一次进程上下文切换时所保存的CPU现场. 进程控制原语定义: 具有原子性的一段特殊程序,这段程序,要么全部的指令都执行,要么都不执行,在执行这段程序的指令期间不允许转去执行其他程序 处理器调度作业与进程的关系作业是用提交给操作系统完成的一个独立任务,是要求计算机所做工作的集合 区别如下: 作业是用户向计算机提交任务的任务实体,在用户向计算机提交作业后,该作业放入外存中的后备作业队列等待作业调度,而进程是完成用户任务的执行实体,是向系统申请分配资源的基本单位,任何一个进程,只要被创建,总是有相应部分存在于内存中 一个作业可以由多个作业组成,即同时对应多个进程,并且至少由一个进程组成 作业的概念主要用在批处理系统中,如UNIX这样的分时系统就没有作业的概念.而进程的概念几乎用在所有多道程序系统中 作业调度主要是检查系统是否满足作业的资源要求,以及按照一定的算法来把外存后备作业队列中的作业调入内存,为其创建进程插入就绪队列中 ; 进程调度则是根据一定的算法把CPU分配给进程就绪队列中的某个进程让其执行 批处理系统中作业与进程的关系批处理作业从与预输入到缓输出需要经历的四种状态: 提交状态 后备状态 执行状态 完成状态 分时系统中作业与进程的关系CPU的三级调度三级调度层次可分为三级: 高级调度(作业调度) , 中级调度(交换调度) , 低级调度(进程调度) 高级调度主要功能包括: 选择作业 分配资源 创建进程 作业控制 回收资源 中级调度主要功能: 在内存资源中紧张的情况下,从内存中暂存不运行的进程中选择一个或数个进程挂起 主要目的: 为了对系统负荷(内存资源)起到短期平滑和调度的作用,以便提高内存利用率和系统吞吐量 低级调度主要功能:按照一定的调度算法将CPU分派给进程就绪队列中的某个进程 处理器调度队列模型 (待补充)进程调度调度方式: 非抢占式调度:选中一个进程后会让这个进程一直执行下去,知道运行结束或者该进程发生等待事件而阻塞时才将CPU返还给调度程序 **特点:**实现简单,系统开销小,但出现紧急事件时不能立即处理,不适用于实时系统和分时系统 抢占式调度: 抢占原则有: 高级优先原则: 时间片原则: 调度时机:引起进程调度的原因主要有以下4个 创建一个新进程后 运行进程终止 运行进程阻塞 运行的进程时间片到期 进程优先级发生改变 不允许进程调度和切换的情况: 中断处理过程中,由于中断处理不属于某一进程,因此不应该作为进程的程序段而被剥夺CPU 进程在操作系统内核的临界区: 为实现临界区的互斥访问,通常以加锁的方式防止进程进入该临界区.在用户进程访问临界资源期间不允许切换到其他进程去执行 在需要完全屏蔽中断的原子操作执行过程中 调度实现:出现进程调度后,主要完成的任务是进程切换. 保存当前运行的现场信息. 选择即将运行的进程 为新选中的进程恢复线程 单处理器调度调度原则:面向系统准则:主要有以下4个方面准则 吞吐量 CPU利用率 (cpu利用率 = cpu有效工作时间 / cpu总的运行时间) , cpu总运行时间 = cpu有效时间 + cpu空闲等待时间 系统资源平衡利用 公平性 面向用户准则:主要应该遵循以下4个方面准则(对进程也适用): 周转时间 作业周转时间 Ti = 作业 i 完成时间 - 作业 i 提交时间 , 或者 Ti = 作业 i 运行时间 + 作业 i 等待时间 响应时间 截止时间 优先权准则 常用调度算法1. 先来先服务调度算法(FCFS)先来服务调度算法是一种非抢占式调度算法, 当某进程/线程占用了cpu后就一直运行,一直到该进程/线程运行结束才放弃cpu,或在运行中因发生某等待事件被阻塞而放弃cpu 2.短作业/短进程优先调度算法(SJF/SPF)此算法是一种非抢占式调度算法, 某作业的进程一旦获得了cpu,就一直运行到进程完成或因某件事阻塞而放弃cpu,所以短作业/短进程优先调度算法不适合分时系统或者实时系统 3.时间片轮转调度算法(RR)此算法实际上是一种基于时钟的抢占式调度算法, 核心是时间片. 主要用于低级调度. 进程就绪队列总是按进程到达系统的时间先后次序进行排队, 进程调度程序按先来先服务的原则,选择就绪队列中第一个进程,将cpu分配给他执行. 进程每次使用cpu的时间只能是一个时间片,当运行进程用完规定的时间片时必须放弃cpu使用权.这时, 线程调程序会将cpu分配给当前就绪队列的第一个进程, 而放弃cpu的进程则回到就绪队尾 4.高响应比优先调度算法(HRRF)此算法是一种基于动态优先数的非抢占式算法 , 可用于作业调度,进程/线程调度 每个进程都有一个动态优先数, 该优先数不仅是进程运行时间(估计值)的函数,还是其等待时间的函数 ,一般将响应优先数定义为 Rp Rp = 响应时间 / 运行时间 = 运行时间+等待时间/运行时间 = 1+ (等待时间/运行时间) , 选择相应比高的进程优先运行 ,. 5.优先级调度算法适用于 高级调度, 低级调度, 还用于实时系统 静态优先级: 作业或进程在进入创建时被赋予一个优先级,该优先级一旦确定则在其整个生命期内不再改变 . 动态优先级: 在调度对象刚进入系统时 , 也需要依据某种原则为其赋予一个优先级 , 但随着时间的推动, 不同调度对象的优先级在不断的进行动态调整, **在采用优先级的低级调度种,**又分为抢占式和非抢占式两种调度方式 抢占式式优先级调度: 非抢占式优先级调度: 6.多级反馈队列调度算法(MLFQ) 设置多个进程就绪队列,每个进程就绪队列一个优先级,每个队列执行的时间长度也不同, 原则是优先级越低时间片越长 新进程(就绪状态)进入内存后,先放入进程就绪队列Q1的队尾 , 运行按时间片轮转调度算法(RR)调度 仅当前面比较高优先级的队列均为空时 , 才能调度后面比较低优先级队列种的进程运行, 如果进程运行中 , 进程运行中有新进程进入更高优先级的队列, 则新进程讲抢占cpu ,被抢占CPU的进程则回到原队列的队尾. 优缺点 :优点 :短进程能够得到优先处理 ; 系统开销不大 ; 同时支持分时 , 实时 , 批处理的通用操作系统 缺点: 如果优先级比较高的队列一直不为空, 则优先级比较低队列中的进程可能长时间得不到运行 实时调度:实时调度与非实时调度的区别表现在以下4个方面: 实时调度所调度的任务有完成时限 , 而非实时调度没有 实时调度要求有比较快的进程/线程切换时间, 而非实时调度的进程切换时间比较长 实时调度主要强调在规定时限范围内完成对相应对象的控制 , 非实时调度强调资源的利用率(批处理系统) 和用户共享(分时系统) 实时调度为抢占式调度 , 非实时调度很少采用抢占式调度 线程(Thread)线程的概念定义: 进程内的一个执行单元 进程内的一个可独立调度的实体 进程是进程中一个相对独立的控制流序列 线程是执行得得上下文 属性: 基本不拥有系统资源 , 只拥有为保证运行而不可少的资源 . 如仅有子一个线程控制块(PCB) , 程序计数器(PC) , 一组寄存器以及堆栈等 线程是独立调度和分派的基本单位 , 也是独立运行的基本单位 同一个进程中所有线程共享该进程所拥有的全部资源 线程并发执行程度高 ,不但同一个进程内部的多个进程可以并发执行 , 而且属于不同进程的多个进程也可以并发执行 与进程类似 , 线程也拥有生命周期, 也存在 执行 ,就绪 , 阻塞 这三种基本状态. 线程与传统进程的区别 两者都有标识符(ID) , 一组寄存器 , 状态 , 优先级以所要遵循的调度策略 进程有一个进程控制块(PCB) , 线程有有一个线程控制块(TBC) 进程中的线程共享该进程的资源 , 子进程也共享父进程的资源 . 线程与传统进程(传统进程不涉及线程的概念)主要存在以下5个差异: 传统进程除是调度和分派的基本单位外 , 还是资源分配的基本单位 , 而线程只是调度和分派的基本单位, 不是资源分配的基本单位 在引入线程的系统中, 不仅同一个进程中的多个线程可以并发执行,并且属于不同线程中的多个线程也可以并发执行 (也称进程并发执行) ,线程并发执行程度高于传统进程并发执行的程度 创建和撤销一个线程所花费的时间开销小于创建和销毁一个传统进程 , 线程间彼此切换所需时间远少于传统进程间切换所需要的时间 线程可以使用他所隶属于进程的资源(如:程序段 , 数据段, 打开的文件及I/O设备等) ,并且属于同一个进程的所有线程共享一个地址空间 , 不同进程的地址空间是独立的 同一个进程里的线程, 数据可以直接相互传递使用 , 进程之间的数据传递只能通过通信方式传递,通信方式相对费时且不方便 线程实现原理内核态线程实现用户态线程实现 混合式线程实现 进程同步与通信并发进程的关系对于相关得并发进程 , 则存在以下两种相互制约的关系 . 间接制约关系: 直接制约关系: 进程的互斥与同步 进程同步: 指某些进程之间在逻辑上的相互制约关系 . 也就是说,若干个进程为完成一个共同的任务而相互合作,由于合作的每个进程都是以各自独立的 , 不可预知的速度推进 , 这就需要互相合作的进程在某些协调点处来协调他们的工作 .当一个合作进程到达此协调点后 , 在未得到其他合作进程发来的消息之前则阻止阻塞自己 , 直到其他合作进程给出协调信号后, 才被唤醒再继续执行 . 进程互斥: 指某个资源同一时间只允许一个进程对其进程访问, 这种访问具有唯一性和排他性, 进程互斥通常是进程之间争夺互斥资源而引起的, 在这种情况下 , 任何时刻都不允许或以上的并发进程同时执行那段访问该互斥资源的程序代码 进程互斥还会产出两个额外的问题: 饥饿: 一个进程所申请的资源总是被优先于自己的其他进程所占有 ,而导致**该进程长期处于就绪或阻塞状态(**不能被调度执行) 死锁: 一个进程集合中已占有部分资源的两个或以上进程 , 还需要等待获得已被其他进程占有的资源才能够继续执行 , 有可能会出现某些进程相互之间都在等待对方占有的资源而无法运行的局面 互斥与同步的联系:进程同步与进程互斥的相似之处是进程互斥实际上是进程同步的一种特殊情况, 即逐次使用互斥资源 , 这也是对进程使用资源次序的一种协调(同步) . 因此可以讲进程互斥和进程同步统称为进程同步. 进程同步与进程互斥的区别是进程互斥是由互斥资源引起 , 即各进程之间共享互斥资源的使用权 ; 进程同步是互相协作的并发进程之间存在必然联系 , 若当前运行进程执行过程中需要进行同步时, 在没有得到协同工作的其他合作进程发来的同步消息之前, 当前运行进程则不能继续向前推进(运行),在进程同步中, 虽然互斥资源依然制约着进程的执行, 但协调各进程向前推进的只能是通过进程同步来协调和制约各合作进程的执行 , 所以进程同步是在互斥的基础上(大多数情况),通过对资源的有序访问去完成一个共同的任务 临界资源与临界区临界资源: 一段时间内只允许一个进程使用的资源. 临界区: 进程中访问临界资源的代码段 同步机制的4条准则: 空闲先让 忙则等待 有限等待 让权等待 实现进程互斥方法硬件方法:1.开关中断指令:2.测试与设置指令3.交换指令软件方法:1.两标志进程互斥算法:2.三标志进程互斥算法:信号量机制**信号量:**在操作系统中, 信号量代表一类物理资源, 他是相应物理资源的抽象 , 具体实现时 , 信号量被定义成具有某种类型的变量, 通常为整型或者结构体类型 . 信号量除了初始化外 , 在其他情况下 其值只能由P和V两个原语操作才能改变 整型信号量; 结构体型信号量: 使用信号量实现进程互斥(待补充)使用信号量实现进程同步(待补充)经典互斥与同步问题与应用问题:生产者-消费者问题(待补充)哲学家进餐问题(待补充)读者-写者问题(待补充)睡眠理发师问题(待补充)应用缓冲区数据传送问题(待补充)吃水果问题(待补充)管制机制信号量机制虽然是一种有效的进程互斥与同步机制 , 但实现进程同步的P操作和V操作 可能分布在整个程序中 , 这不仅麻烦 , 操作不当还会导致死锁. **管制:**是一种新的进程互斥同步与同步机制 , 她能提供与信号量同等的功能 ,使用管制机制可以将分散在各进程中的同步操作集中起来统一控制和管理 , 进程通过调用管制中的过程或函数可以更方便的实现进程的互斥与同步 条件变量与管制结构1.条件变量条件变量是管制的一种进程同步机制 , 他能让多个进程之间传递信号, 并解决管制内进程可能出现的忙等问题 条件变量是封住在管制内的一种数据结构 , 他对应一个进程阻塞队列 , 并只能被管制中的函数访问, 且是管制内的所有函数的全局变量. 2.管制结构 管制发明人之一给管制的定义是: 一个管制定义一个数据结构和在该数据结构上的一组函数, 这组函数能够同步进程和改变管制中的局部.管制具有5个性质: 管制中不仅有数据而且有对数据的操作,即管制是一种扩展了的抽象数据类型. 管制这种扩展了的抽象数据类似的描述对象是互斥资源 , 因此管制实际上是互斥资源的管制模块. 作为一个软件模块 , 管制应符合模块化的要求 , 即管制应是一个基本程序单位, 并可以被单独编译 管制中的数据结构只能被管制中的函数使用, 管制内的数据结构和函数具体实现在外部是不可见的 为了实现对互斥资源的共享 , 管制应有互斥与同步机制 管制主要由三部分组成: 局部于管制内的数据结构 ; 管制内共享数据的初始化语句: 一组对管制内数据结构进程进行访问的调用函数 管制被请求或释放互斥资源的进程所调用 , 使用管制实现进程同步具有一下三个特点: 管制内的数据结构只能由管制定义的函数访问 , 任何外部函数都不能访问它们 , 同样局部于管制的函数也只能访问管制内的数据结构.因此可以把管制看作一个围墙 , 它把公用变量和对公用变量操作的一组函数保护起来, 所有要访问管制内数据的进程都必须过管制才能进入临界区 , 而管制每次只允许一个进程进入, 从而实现了多个进程对临界区的互斥访 任何时刻只能有一个进程在管制中执行, 其他申请进入管制的进程必须阻塞等待. 一个外部函数只有通过调用管制内的一个函数才能进入管制 管制解决问题:解决生产者-消费者问题解决哲学家进餐问题解决读者-写者问题解决睡眠理发师问题解决吃水果问题进程通信同步与通信是并发进程交互的两个基本要求 .进程同步主要解决临界区问题, 而进程通信主要指的进程之间的信息交换 .虽然信号量机制解决了进程的互斥与同步问题 , 但没有解决如何在进程之间传递大量信息的问题 通信的几种方式: 发送接收方先约定, 发送方利用磁盘等外存设备将要交换的数据写入指定的外存的指定区域 ,接收方通过该区域进行读取数据.这种方案实现简单,只需要操作文件系统即可 但通信过程需压迫IO操作 利用内核运行在内核态的特点,发送方通过内核程序将数据写入内核空间指定的区域 , 接收方则通过另一组内核程序 , 从指定的区域中读取数据,并将此数据写入接收方的内存数据空间中.这种方案需要操作系统专门的系统调用来实现 , 数据传输不需要IO操作(全部在内存中完成) ,因此速度快 根据进程之间交换信息量的大小 , 又可以将进程通信分为以下两种 : **低级通信:**进程之间一次只能传送很少的信息,前面已经介绍过的信号量方式 , 就是实现进程互斥和同步的低级通信.优点:速度快 ;缺点:传递的信息量少,效率低 ,过程对用户不透明.因此操作复杂 **高级通信:**一次间可以传输大量信息.优点: 通信效率高,过程对用户透明 , 编程相对简单 . 高级通信的目的不仅是为了控制进程的执行速度 ,而且是为了交换大量信息 . 进程间的高级通信分为三种: **共享内存通信:**通信利用双方共享的内存区来实现进程的通信 消息传递通信:利用操作系统提供的信息传递系统来实现通信.由于这种方式是直接使用操作系统提供的通信命令(原语)来进行通信 , 从而隐藏了进程通信实现的细节 , 大大降低了编程的复杂性并得到了广泛应用.消息传递系统根据实现方式的不同,又可分为消息缓冲方式(直接通信)和信箱通信方式(间接通信) **共享文件通信:**通信双方利用共享一个文件来实现进程通信,这种方式又称为 管道通信 , 因此共享的文件又称为管道 死锁首先普及几个概念: **可抢占资源:**某进程获得这类资源, 该资源可以再被系统或其他进程抢占 .(如CPU,正在执行的进程所使用的CPU可以被优先级更高的新就绪进程抢占 , 还有内存) **不可抢占资源:**某进程获得这类资源后 , 该资源不能再被其他进程所抢占,只能在进程使用完毕后由进程自己释放,否则可能导致进程所作的工作的出错或失败 (如前面提到的 临界资源 , 软件资源的信号,消息 ,设备缓冲区中存储的数据信息; 硬件资源的打印机, 磁带机) 互斥资源与不可抢占式的资源的联系与区别: 互斥资源是只能互斥使用, 不可抢占资源一定是互斥资源 (如打印机) , 但互斥资源不一定是不可抢占资源(如CPU) ,因此==不可抢占资源是互斥资源的子集== 产生死锁的原因: 系统资源不足 , 产生死锁的根本原因是可供多个进程共享的系统资源不足 ,当多个进程需求资源的总和大于系统能够提供的资源时 , 进程间就可能会因竞争不可抢占资源而导致死锁 ,并且死锁的发生总是在进程提出资源请求时 进程推进顺序不当 , 由于系统中各个进程都以各自独立地速度向前推进 , 因此就可能出现按这种顺序联合推进 , 使所有进程都能正常运行到结束 , 而按另一种联合推进 , 将会使两个或两个以上的进程出现这种情况 , 既占有部分资源又要申请其他阻塞进程所占有不可抢占资源的情况 , 从而导致这几个进程陷入死锁 产生死锁的必要条件: **互斥条件:**进程对所获得的资源进行排他性使用 , 任一时刻一个资源仅能被一个进程占用 **请求和保持条件:**一个进程请求资源得不到满足而阻塞自己时 , 并不释放已分配给它的资源 , 该条件也称为部分分配条件 不可抢占(不剥夺)条件: 进程所获得的资源在未使用完毕之前 , 不能被其他进程抢占 ,而只能占用该资源的进程自己释放 循环等待条件: 若干进程(两个或两个以上)形成一个循环等待链 , 链中每个进程都在等待该链中下一个进程所占的资源 条件4成立其实隐含了前三个条件的成立 , 可通过破坏上述四个条件中的任意一个来预防死锁的产生 死锁的预防:根据上述可知, 预防死锁的发生只需破坏四个条件之一即可 , 但破坏条件1显然不行 , 这是因为进行互斥访问是由不可抢占资源的固有特性决定的 , 因此预防死锁发生可设置限制条件 , 使请求和保持 ,不可抢占 , 循环等待这三个必要条件的某一个不成立即可 1.破坏请求和保持条件每个进程在运行之前 , 一次性申请它所需要的全部资源 , 并在资源未得到满足之前 , 不投入运行 , 进程一旦投入 , 则分配给它的资源就一直归该进程所有 ,且不再提出新的资源请求 **优点:**安全简单,易于实现 缺点: 系统资源严重浪费 ; 由于进程只有获得全部资源后才能运行, 因此会导致一些进程长时间得不到运行 ; 很多进程在运行之前, 系统并不知道它到底需要多少资源 2.破坏不可抢占条件进程在运过程中, 根据需要逐个提出资源请求, 当一个已经占有了某个资源的进程 , 且又提出新的资源请求而未得到满足时 ,则必须释放它已获得的全部资源 , 而进入阻塞状态 , 待以后需要时 , 再重新申请 **缺点:**1.有些资源被抢占后可能会引起错误(例如: 某进程使用打印机输出一些信息后, 因申请其他资源没有成功而被阻塞时放弃了打印机 , 该打印机被分配给其他进程使用输出信息 , 当该进程重新运行获得该打印机输出时 ,会造成前后两次的打印结果不连续) 2.该方法实现起来比较复杂且代价太大 , 进程的反复申请和释放资源会使进程推进缓慢 , 甚至可能导致进程的执行被无限推迟 , 这不但延长了系统的周转时间 , 也增加了系统的开销; 3.可能存在某些进程的资源总是被抢占而造成的 “饥饿” 3.破坏循环等待条件将系统中所有资源进行编号 , 并按规定进程申请资源时必须严格按照资源编号递增(或者递减)的顺序进行 , 如将输入机 ,磁带机,打印机,磁盘分别进行编号:1,2,3,4 . 进行再获得某个资源后,下一次只能申请较高(或较低)编号的资源 , 不能再申请低(或高)编号的资源 . **优点:**与上述前面两种策略比起来, 系统资源的利用率和吞吐量有明显改善 缺点: 1.进程实际使用资源顺序不一定与编号顺序一致 , 有可能会造成一定的资源浪费 2.资源不同的编号方法对资源利用率有重要影响, 且很难找到最优的编号方法 3. 资源编号必须相对稳定, 当系统添加新种类设备后 , 处理起来比较麻烦 ; 4.严格的资源分配顺序使用户编程的自主性受到限制 死锁的避免1.系统的安全状态和不安全状态2.使用银行家算法避免死锁3.银行家算法4.判断当前状态是否安全子算法死锁检测与接触1.死锁检测2.死锁定理3.,死锁检测算法4.死锁解除存储管理计算机的存储器分为两类: 一类是内部存储器(内存,CPU可以直接访问), 另一类是外部存储器(外存,不可直接访问) , 内存又叫主存储器,是计算机的重要资源之一.存储管理指的是管理内存,是操作系统的重要组成部分 程序运行需要两个最重要的条件, 一个是程序和数据要占有足够的内存空间 ; 另一个是得到CPU , 因此除了CPU管理之外, 存储管理的优劣也将影响的性能.对于外部存储器来说,其管理虽然与内存管理类似,但外存主要用于存放文件 程序链接和装入在多道程序环境中要使程序运行 ,首先必须为它创建进程 , 而创建进程就必须将程序和数据装入内存 ,能装入内存执行的程序执行的程序就属于可执行程序(例如:windowsz下的 .exe文件) .通常用户编写的源程序要经过一下步骤才能转变为可执行程序: 首先,由编译程序把源程序编译成若干个目标模块 然后,由链接程序把所有目标模块和它们需要的库函数链接在一起,形成一个完整的可装入模块 可装入模块可以通过装入内存成为可执行程序,当把CPU分配给它的时候就可以投入运行. 因此,要使源程序能够运行,必须经过 编译, 链接 ,装入 三个步骤 逻辑地址和物理地址 **逻辑地址(相对地址):**用户源程序经编译,链接,后得到可装入程序, 由于无法预先知道程序装入内存的具体位置,因此不可能在程序中直接使用内存地址 , 只能暂定的起始地址为 0 ,这样, 程序中指令和数据的地址都是相对 0 这个起始地址进行计算的 , 一般情况下: 目标模块和装入模块中的地址都是逻辑地址 逻辑地址空间: 一个目标模块或装入模块的所有逻辑地址的集合, 被称为逻辑地址空间或者相对地址空间 物理地址: 内存中实际存储单元的地址称为物理地址 ,也叫绝对地址或者内存地址.为了使程序装入内存后能够正常运行 , 就必须将程序代码中的逻辑地址转换为物理地址 , 这个转换操作称为地址转换 物理地址空间: 内存中全部存储单元的物理地址集合称为物理地址空间, 绝对地址空间或空间地址空间. 由于每个内存单元都有唯一的内存地址编号 ,因此物理地址空间是一个一维的线性空间 , 要使装入的内存的程序能够正常运行,互不干扰,就必须将不同的程序装入到内存空间的不同区域 虚拟地址空间: CPU支持的地址范围一般远大于机器实际内存大小 , 对于多出来的那部分地址(没对应实际内存)程序依然可能使用 , 我们将程序能够使用的整个地址范围称为虚拟地址范围 ,如win xp 采用32位地址结构 , 每个用户进程的虚拟地址空间,每个用户进程的虚拟地址为4GB , 但可能实际内存只有2GB , 虚拟地址空间的某个地址称为虚拟地址 , 而用户进程的虚拟地址就是前面所说的逻辑地址 程序链接源程序经过编译后所得到的目标模块 , 必须由链接程序将其链接成一个完整的可装入模块后, 才能装入内存运行.链接程序将几个目标模块装配成一个装入模块时 , 需要解决一下问题: 修改模块的相对地址 , 编译程序产生的各个目标模块中的地址都是相对地址 , 其其实地址都是 0 ,在将他们链成一个装入模块后, 由于各模块不能放入同一段逻辑地址空间, 故一些目标模块在装入模块中的其实地址不能再是0,因此要根据实际情况对模块中的相对地址进行修改 转换外部调用符号. 在将目标模块装配成可装入模块时 , 应将原目标模块中的外部符号转变为相对地址 . 对于目标模块的链接, 可以根据链接时间的不同分为一下三种不同的链接方式: 静态链接.程序运行前把源程序编译成的所有目标模块以及所需要的库函数链接成一个统一的装入模块.,以后不再分开 装入时动态链接.目标模块的链接是模块装入内存时进行的,即在模块转入过程中同时完成所有目标模块的链接 运行时动态链接.将一个目标模块装入内存后就启动运行该目标模块进程, 在进程运行过程中如果需要调用其他模块,则将需要调用的模块装入内存并链接到调用模块上, 然后进程继续运行 上述三种链接方式,使用较多的是运行时动态链接,这是因为它使某些模块的链接推迟到运行时,才进行,这样凡是程序执行过程中未用到的模块都不会装入内存.显然, 这种链接方式不仅可以节省内存空间,而且加快了程序目标模块的装入过程 程序装入源程序经过编译,链接后,可形成可装入模块 ,将它装入内存后就可以投入运行.由于程序的逻辑地址空间和内存的物理地址空间并不一致.因此装入程序在将程序(可装入模块) 装入内存后, 在程序执行之前还必须将程序代码中的逻辑地址转换为真实的物理地址,即进行地址转换 程序装入程序装入是指装入程序根据内存当前的实际使用情况 , 将程序装入到内存合适的物理位置 , 装入操作针对的是程序的整个逻辑地址空间,而对应的物理地址空间既可以是连续的,也可以是离散的.程序装入内存后并不能立即运行.(因为此时程序涉及到访问的地址是逻辑地址还未转换成物理地址) 根据装入时间的不同. 可以将程序装入分为运行前静态装入, 运行时动态装入两种; 静态重定位静态重定位指的是装入程序将全部程序装入到内存适当的位置 , 在该程序装入内存时或运行之前 , 一次性将程序中凡涉及访存地址的指令其访存地址按下面的公式全部相对地址替换成物理地址,并在程序运行过程中不再改变 物理地址 = 相对地址 + 程序存放的内存起始的内存起始地址 若采用静态重定位, 通常不允许程序静态重定向后,重新移动该程序代码和数据再内存的存放位置 , 因为这种移动意味着刚才对程序进行的重定向必须重新来过. 这将会耗费大量CPU时间 **优点:**简单,容易实现 缺点: 内存利用率不高 , 必须由用户在程序设计时采用某种方法解决存储空间不足的问题 , 不利于用户共享存放在内存中的同一个程序. 动态重定位动态重定位是指无论将程序一次性装入内存 , 还是在程序运行中动态装入个目标模块(或虚拟器存储器中动态装入程序的分页和分段)到内存 , 都不立即进行逻辑地址到物理地址的转换, 地址转换工作是在程序执行中进行的,即当执行的指令涉及到访存地址时再进行地址转换. 为了提高地址转换的速度 , 动态重定位要依靠硬件地址转换机构来完成, 硬件地址转换(重定位)机构需要一个或多个基地址寄存器(BR)和一个或多个逻辑地址寄存器(VR) . 物理地址 = BR + VR 其中,BR VR 分别表示基地址寄存器和程序逻辑地址寄存器中的内存 重定位的过程是: 装入程序将程序装入到内存中, 然后将程序所装入的内存区域首地址作为基地址送入BR中 ,在程序运行过程中, 当某条指令访问到一个相对地址时, 则将该相对地址送入VR中, 这时 , 硬件转换机构把BR 和VR中内容相加就形成了要访问的绝对地址 **优点: **有利于内存的管理和内存利用率的提高 , 构成了虚拟存储器的基础 ; 有利于程序段的共享 **缺点: **需要硬件支持 , 实现存储管理的软件算法比较复杂 存储器及存储管理的基本功能为了程序能够在内存中正常运行,不受到内存中其他程序的干扰.所以内存管理要达到以下两个目标: 地址保护 , 一个程序不能访问另一个程序的内存地址空间 地址无关 , 用户并不关心程序中使用的是何种地址 , 此时程序是在内存还是在外存,这些工作应由内存管理自动完成 存储管理应具有以下4个基本功能: 内存空间的分配于回收 , 按程序要求进行内存分配,当程序运行结束后,适时回收其占用的内存 实现地址转换. 实现程序中的逻辑地址到内存物理地址的转换 内存空间的共享与保护.对内存中的程序和数据实施保护 内存空间的扩充.实现内存的逻辑扩充.提供给用户更大的存储空间,允许超过内存容量的程序运行 多级存储器体系由于CPU中的寄存器也可以存储少量的信息 , 所以他也可以看作是存储体系中的一层.另外,现在的计算机系统一般都增加了高速缓存(Cache) .从寄存器到高速缓存,再到内存, 最后到外村,存取速度越来越慢 , 容量越来越大打, 成本和存取频度越来越低 **寄存器: **是CPU内部的高速存储单元 , 主要用于存放程序运行过程中所使用的各种数据 .寄存器的容量最小,但存取速度最高 高速缓冲存储器(Cache): 简称高速缓存.其存取速度与CPU速度相当, 非常快,但成本高且容量较小(一般为几kb到几百kb) ,主要用来存放使用频率较高的少量信息. **内部存储器: **简称内存又叫主存储器, 程序只有装入内存后才能运行, 因此内存一般用来存放用户正在执行的程序和使用到的数据,CPU可以直接执行内存中的指令以及存取内存中的数据.内存的读取速度要比高速缓存慢一点, 容量要比高速缓存大得多(一般为几GB) 外部存储器: 简称外存,又称辅助存储器,外存不能被CPU直接访问, 一般用来存放大量的,暂时不用的数据信息.外存的存取速度比较低且成本也较低,但容量较大(一般为几GB) 内存空间的分配与回收以及地址转换1.内存空间的分配与回收为了合理,有效的使用内存,在设计内存分配与回收算法时, 必须考虑以下4个问题: 数据结构: 登陆内存的使用情况,记录可供分配的内存空闲区大小和起始地址,以供分配和回收时使用 放置策略: 决定内存中放置信息(程序或数据)的区域(或位置) , 即怎样在当前的内存空闲区中选择一个或几个空闲区来放置信息 **调入策略: **确定外存中的进程段和数据段在什么时间 , 以什么样的控制方式进入内存 淘汰策略: 在需要讲某个程序段或数据段调入内存却出现内存没有足够空闲区时, 由淘汰来决定把内存中的哪些程序段和数据段由内存调出(淘汰)放入外存, 以便为调入的程序或数据段腾出足够的内存空间 2.地址转换(地址重定位)程序运行时不能直接使用逻辑地址访问 , 内存中的信息, 而必须把程序地址空间中的逻辑地址转换成内存空间中的物理地址, 才能完成对内存信息的访问. 实现逻辑地址到物理地址转换有以下三种方式: 编译或者编译时产生绝对地址 静态地址转换 动态地址转换 内存的共享,保护,及扩充1.内存空间的共享和保护计算机中使用存储保护主要包括界地址保护, 存储键地址保护等方式 界地址保护 上下界和地址检查机构,这种机制主要用于静态地址转换. 基址,限长寄存器和动态地址转换机构.这种机制主要用于动态地址转换 存储键保护 2.内存空间扩充实现内存扩充的根本方法是充分利用内存与外存资源,即只将当前需要使用的部分程序和数据放入内存, 不用的暂存于外存,当需要时再交换 控制程序和数据在内,外存之间交换的基本方式有以下两种: 用户自己控制方式 操作系统控制方式: 分区式存储管理单一连续分区存储管理1.实现原理单一连续分区存储管理方式只适合于用户,单任务操作系统, 是一种最简单的存储管理方式. 2.分配与回收分配过程是首先将装入内存的程序与用户区进行大小比较 , 若程序所需要内存空间没用超过用户区的大小,则为它分配内存空间;否则内存分配失败 , 若程序所需要内存空间没有超过用户区的大小 ,则为它分配内存空间 ; 否则内存分配失败.回收操作则是在用户区的程序运行结束后 , 将该区域标志置为未分配即可 3.地址转换与存储保护单一连续分区存储管理的地址转换可以采用静态重定位和动态重定位 4,单一连续分区管理优缺点**优点: **管理简单 , 开销小 安全性高, 除系统区外, 用户区种只有一个程序 , 不存在多个程序相互影响的问题 , 采用静态重定位方式不需要硬件支持 **缺点: **不支持多用户 , 程序的地址空间受用户区大小限制,这是因为程序在运行前必须一次性装入内存的连续区域, 若程序的地址空间比用户区大则无法装入; 由于一个程序独占系统资源 , 这样会造成系统资源严重浪费 固定分区存储管理1.实现原理固定分区存储管理是最早使用的一种可执行多道程序的存储管理方法 , 即将内存系统区之外的用户空间划分若干个固定大小的区域 , 每个区域称为一个分域并可装入一个用户程序运行.分区一旦划分完成,就在系统的整个运行期间保持不变.由于每个分区允许装入一道程序运行 ,这就意味着系统允许在内存中同时装入多道程序并发执行 2.分区划分分区的数目和每个分区的大小一般由系统操作员或操作系统决定.一般采用以下两种方式 分区大小相等. 分区大小不等 3.内存空间的分配与回收","categories":[{"name":"计算机基础理论","slug":"计算机基础理论","permalink":"https://lqy679.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"正则表达式","slug":"正则表达式","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T05:01:14.327Z","comments":true,"path":"2020/01/01/正则表达式/","link":"","permalink":"https://lqy679.github.io/2020/01/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"正则表达式元字符请注意:元字符就只是一个字符而已,代表的字符含义不确定而已 “^” ：^会匹配行或者字符串的==起始位置==，有时还会匹配整个文档的==起始位置。== “$” ：$会匹配行或字符串的==结尾==, 例如 \\d$ , 匹配以数字结尾的字符串 “\\d”: 匹配==数字==， “.”：匹配除了换行符(\\n)以外的任何字符 ==(相当于 \\w和 \\s的结合)== **”\\w”**：匹配字母，数字，下划线(==即大多数语言的标识符合法规则==). **”\\s”**：匹配==空格(space)== “[abc]”: 字符组 ==匹配包含括号内元素的字符==, 还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了， “\\b”: 代表==单词边界的意思==, 例如en\\b代表匹配单词末尾的“en” , \\ben代表匹配单词开头的“en”字符","text":"正则表达式元字符请注意:元字符就只是一个字符而已,代表的字符含义不确定而已 “^” ：^会匹配行或者字符串的==起始位置==，有时还会匹配整个文档的==起始位置。== “$” ：$会匹配行或字符串的==结尾==, 例如 \\d$ , 匹配以数字结尾的字符串 “\\d”: 匹配==数字==， “.”：匹配除了换行符(\\n)以外的任何字符 ==(相当于 \\w和 \\s的结合)== **”\\w”**：匹配字母，数字，下划线(==即大多数语言的标识符合法规则==). **”\\s”**：匹配==空格(space)== “[abc]”: 字符组 ==匹配包含括号内元素的字符==, 还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了， “\\b”: 代表==单词边界的意思==, 例如en\\b代表匹配单词末尾的“en” , \\ben代表匹配单词开头的“en”字符 反义写法很简单改成大写就行了，意思与原来的相反，这里就不举例子了 “\\W” 匹配任意不是字母，数字，下划线 的字符 “\\S” 匹配任意不是空白符的字符 “\\D” 匹配任意非数字的字符 “\\B” 匹配不是单词开头或结束的位置 “ [^abc] “ 匹配除了abc以外的任意字符 量词量词符号 “*“(贪婪) 重复零次或更多 ==(0到无穷未知个)== 例如”aaaaaaaa” 匹配字符串中所有的a 正则： “a*” 会出到所有的字符”a” “+”(懒惰) 重复一次或更多次 ==(1到无穷未知个)== 例如”aaaaaaaa” 匹配字符串中所有的a 正则： “a+” 会取到字符中所有的a字符， “a+”与”a*“不同在于”a+”至少是一次而”a*“ 可以是0次， “?”(占有) 重复零次或一次 ==(只有0或1个)== 例如”aaaaaaaa” 匹配字符串中的a 正则 ： “a?” 只会匹配一次，也就是结果只是单个字符a “{n}” 重复n次 ==(出现n次, 次数是明确的)== 例如从”aaaaaaaa” 匹配字符串的a 并重复3次 正则： “a{3}” 结果就是取到3个a字符 “aaa”; “{n,m}” 重复n到m次 ==(出现n-m次,次数是明确的)== 例如正则 “a{3,4}” 将a重复匹配3次或者4次 所以供匹配的字符可以是三个”aaa”也可以是四个”aaaa” 正则都可以匹配到 “{n,}” 重复n次或更多次 与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则”a{3,}” a至少要重复3次 例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123 而通常只能是3位或者4位， 正则: “^0\\d{2,3}-\\d{7}” 懒惰限定符先解释关于量词所涉及到的重要的三个概念 贪婪(贪心) 如”*”字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果 失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。相比下面两种贪婪量词对资源的消耗是最大的， 懒惰(勉强) 如 “?” 懒惰量词使用另一种方式匹配，它从目标的起始位置开始尝试匹配，每次检查一个字符，并寻找它要匹配的内容，如此循环直到字符结尾处。 占有 如”+” 占有量词会覆盖事个目标字符串，然后尝试寻找匹配内容 ，但它只尝试一次，不会回溯，就好比先抓一把石头，然后从石头中挑出黄金 “*?” 重复任意次，但尽可能少重复 如 “acbacb” 正则 “a.*?b” 只会取到第一个”acb” 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而”acbacb”最少字符的结果就是”acb” “+?” 重复1次或更多次，但尽可能少重复 与上面一样，只是至少要重复1次 “??” 重复0次或1次，但尽可能少重复 如 “aaacb” 正则 “a.??b” 只会取到最后的三个字符”acb” “{n,m}?” 重复n到m次，但尽可能少重复 ​ 如 “aaaaaaaa” 正则 “a{0,m}” 因为最少是0次所以取到结果为空 “{n,}?” 重复n次以上，但尽可能少重复 ​ 如 “aaaaaaa” 正则 “a{1,}” 最少是1次所以取到结果为 “a” 分组匹配正则表达式可以通过()和|配合可以进行分组和优先运算以及组内或逻辑运算, 例如:匹配日期: 1str_date = &quot;\\d&#123;4&#125;-(0[1-9]|1[0-2])-([0-2]\\d|[3][0-1])&quot; 分组调用与别名引用正则表达式可以\\分组索引分组值来引用分组实现复用分组 注: 索引值以1 开始 12str = r&quot;&lt;title&gt;This is python3&lt;/title&gt;&quot; #需要匹配的字符串regex = r&quot;&lt;(\\w+)&gt;([\\w\\W]*)&lt;/\\1&gt;&quot; #其中的 \\1 代表引用了第一个分组 (\\w+) 还可以通过(?P&lt;分组名&gt;)给分组起别名, 通过别名引用分组(?P=分组名) 12str = r&quot;&lt;title&gt;This is python3&lt;/title&gt;&quot; regex = r&quot;&lt;(?P&lt;tag&gt;\\w+)&gt;([\\w\\W]*)&lt;/(?P=tag)&gt;&quot; 常用的字符串处理函数(java)获得位置: int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。不存在返回 -1 **int indexOf(int ch,int fromIndex):**从fromIndex指定位置开始，获取ch在字符串中出现的位置。 int indexOf(String str):返回的是str在字符串中第一次出现的位置。 int indexOf(String str，int fromIndex):从fromIndex指定位置开始，获取str在字符串中出现的位置。 替换 String replace(oldchar,newchar); 分割 String[] split(regex); regex可以是正则表达式 截取 String subString(int begin); String subString(int begin,int end) //begin,end都是实际的位置坐标((从0开始),到end结束不包括end,也可以将end理解为从begin开始截取多少个字符 去两端的空格 String trim()","categories":[{"name":"常用知识笔记","slug":"常用知识笔记","permalink":"https://lqy679.github.io/categories/%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"SpringBoot","slug":"SpringBoot","date":"2020-01-01T10:57:32.000Z","updated":"2023-04-18T14:58:58.734Z","comments":true,"path":"2020/01/01/SpringBoot/","link":"","permalink":"https://lqy679.github.io/2020/01/01/SpringBoot/","excerpt":"SpringBootSpring是为了解决企业级应用开发的复杂性而创建的，简化开发。 为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean；","text":"SpringBootSpring是为了解决企业级应用开发的复杂性而创建的，简化开发。 为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 什么是SpringBoot什么是SpringBoot呢? 就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 微服务架构 微服务理解(国外论文) , 翻译转载:微服务（Microservices）——Martin Flower - 船长&amp;CAP - 博客园 (cnblogs.com) 微服务是一种架构风格，他要求我们在开发一个应用的时候，这个应用必须建成一系列小服务组合，可以通过http方式进行通信。 所谓微服务加购，就是打破之前all in one的架构方式，把每个功能元素独立出来，把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合，需要多一些可以整合多个功能元素，所以微服务架构是对功能元素进行赋值，而没有对整个应用进行复制，这样做的好处是： 节省了调用资源 每个功能元素的服务都是一个可替换的，可独立升级的软件代 体现了高内聚低耦合的思想 第一个SpringBoot程序 官网:Spring Boot 通过官方网站生成demo模板官网为我们提供了快速生成一个SpringBoot项目的工具,Spring Initializr 随后得到一个项目的压缩包,导入到IDE中即可 编写一个测试接口注意! 在Application类的包以及子目录才能被扫描到,所以我们的代码不要写在Application类的包目录之上 123456789101112package com.example.SpringBoot.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class Hello &#123; @RequestMapping(value = &quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 随后在浏览器的地址栏输入:localhost:8080/hrllo , 即可看到打印了hello 使用idea创建SpringBoot项目其实本质上也还是依赖官网 创建项目时勾选Spring Initializr,选择对应的配置项即可,不要忘记勾选web依赖 , 随后一直点击下一步就可以了 配置文件分析:pom.xml打开pom.xml，看看Spring Boot项目的依赖： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 父依赖 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- web场景启动器 --&gt; &lt;!--web依赖：tomcat,dispatcherServlet，xml...--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter：所有的springboot依赖都是使用这个开头的--&gt; &lt;!-- springboot单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 剔除依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;!-- 打包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如上所示，主要有四个部分： 项目元数据：创建时候输入的Project Metadata部分，也就是Maven项目的基本元素，包括：groupId、artifactId、version、name、description等 parent：继承spring-boot-starter-parent的依赖管理，控制版本与打包等内容 dependencies：项目具体依赖，这里包含了spring-boot-starter-web用于实现HTTP接口（该依赖中包含了Spring MVC），官网对它的描述是：使用Spring MVC构建Web（包括RESTful）应用程序的入门者，使用Tomcat作为默认嵌入式容器。spring-boot-starter-test用于编写单元测试的依赖包。更多功能模块的使用将在后面逐步展开。 build：构建配置部分。默认使用了spring-boot-maven-plugin，配合spring-boot-starter-parent就可以把Spring Boot应用打包成JAR来直接运行。 修改配置修改tomcat端口: 设置上下文(项目发布路径): 12#配置项目的访问路径server.servlet.context-path=/路径 彩蛋(Banner):我们可以更改SpringBoot的启动加载内容, 这里附上一个自动生成banner的网站 BootSchool 我们还可在resource文件夹下添加一个`` 部署由于SpringBoot将Tomcat作为默认嵌入容器,即内置了Tomcat,故我们部署web应用的时候不再需要打war包丢入Tomcat中,而是 使用java -jar命令直接运行将项目打包成的jar包即可 (1)使用maven插件打包: (2)**使用java -jar jar包名**运行jar包 如果是window下,打开powershell窗口(与cmd差不多 , 比cmd功能更强大一点),切换至jar的目录运行目录即可 原理初探父项目依赖: spring-boot-dependencies：核心依赖在父工程中！ 我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为有这些版本仓库 1、其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件 1234567&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 2、点进去，发现还有一个父依赖 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt;&lt;/parent&gt; 3、这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心； 4、以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 启动器 spring-boot-starter 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; springboot-boot-starter-xxx，说白了就是Springboot的启动场景 比如spring-boot-starter-web，他就会帮我们自动导入web的所有依赖 springboot会将所有的功能场景，都变成一个个的启动器 我们要使用什么功能，就只需要找到对应的启动器就好了start 主程序默认的主启动类123456789//@SpringBootApplication 来标注一个主程序类//说明这是一个Spring Boot应用@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; //以为是启动了一个方法，没想到启动了一个服务 SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; 我们来分析一下这些注解都干了什么 @SpringBootApplication 作用：标注在某个类上说明这个类是SpringBoot的主配置 SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 进入这个注解：可以看到上面还有很多其他注解！ 1234567891011121314@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; // ......&#125; @ComponentScan 这个注解在Spring中很重要 ,它对应XML配置中的元素。 作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 @SpringBootConfiguration 作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类； 我们继续进去这个注解查看 123456// 点进去得到下面的 @Component@Configurationpublic @interface SpringBootConfiguration &#123;&#125;@Componentpublic @interface Configuration &#123;&#125; 这里的 @Configuration，说明这是一个spring的配置类 ，配置类就是对应Spring的xml 配置文件； @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！ 我们回到 SpringBootApplication 注解中继续看。 @EnableAutoConfiguration开启自动配置功能 以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ； @EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效； 点进注解接续查看： **@AutoConfigurationPackage **自动配置包 123@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125; @import ：Spring底层注解@import ， 给容器中导入一个组件 Registrar.class 作用：自动配置包注册，将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ； 这个分析完了，退到上一步，继续看 @Import({AutoConfigurationImportSelector.class})给容器导入组件 AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码： 12// 获取所有的配置List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 获得候选的配置 1234567891011121314151617protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; // 和下面的方法对应 //这里的getSpringFactoriesLoaderFactoryClass（）方法 //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations;&#125;//和上面的类的方法loadFactoryNames里面的第一个参数对应//这里的getSpringFactoriesLoaderFactoryClass（）方法//返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123; return EnableAutoConfiguration.class; &#125; 这个方法getCandidateConfigurations()又调用了 SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法，获取所有的加载配置 12345public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); //这里它又调用了 loadSpringFactories 方法 return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125; 我们继续点击查看 loadSpringFactories 方法 项目资源:META-INF/spring.factories 系统资源:META-INF/spring.factories 从这些资源中配置了所有的nextElement（自动配置），分装成properties 12//将所有的资源加载到配置类中（将下面的抽离出来分析，第15行）Properties properties = PropertiesLoaderUtils.loadProperties(resource); 12345678910111213141516171819202122232425262728293031323334private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身 MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) &#123; return result; &#125; else &#123; try &#123; //去获取一个资源 &quot;META-INF/spring.factories&quot; Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;); LinkedMultiValueMap result = new LinkedMultiValueMap(); //判断有没有更多的元素，将读取到的资源循环遍历，封装成为一个Properties while(urls.hasMoreElements()) &#123; URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Entry&lt;?, ?&gt; entry = (Entry)var6.next(); String factoryClassName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) &#123; String factoryName = var9[var11]; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException var13) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13); &#125; &#125;&#125; 发现一个多次出现的文件：spring.factories，全局搜索它 spring.factories文件我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！ 我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration 可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！ 所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。 总结: SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作； 以前我们需要自动配置的东西，现在springboot帮我们做了 整合JavaEE，整体解决方案和自动配置的东西都在springboot-autoconfigure的jar包中； 它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器中 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并自动配置，@Configuration（javaConfig） ； 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作； 启动:初以为就是运行了一个main方法，没想到却开启了一个服务； 123456789@SpringBootApplicationpublic class Springboot01HellowordApplication &#123; public static void main(String[] args) &#123; //该方法返回一个ConfigurableApplicationContext对象 //参数一：应用入口的类； 参数二：命令行参数 SpringApplication.run(Springboot01HellowordApplication.class, args); &#125;&#125; SpringApplication.run()分析 分析该方法主要分两部分 一是SpringApplication的实例化， 二是run方法的执行； SpringApplication这个类主要做了以下四件事情： 推断应用的类型是普通的项目还是Web项目 查找并加载所有可用初始化器 ， 设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 查看构造器： 1234567public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123; // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances(); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass();&#125; run()方法流程分析 yaml配置文件SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value application.yaml 语法结构 ：key：空格 value yaml概述:YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言），但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。 这种语言以数据作为中心，而不是以标记语言为重点！ 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： 123&lt;server&gt; &lt;port&gt;8081&lt;port&gt;&lt;/server&gt; yaml配置： 12server： prot: 8080 基础语法:说明：语法要求严格！ 空格不能省略(并且不能多) 以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思； 比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen ‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出 比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 对象、Map（键值对） 12345678910#Map格式,注意缩进map: key1: value1 key2: value2# 对象,注意缩进student: name: qinjiang age: 3 #行内写法,注意有空格 student: &#123;name: qinjiang,age: 3&#125; 数组（ List、set ） 用 - value值表示数组中的一个元素,比如： 123456pets: - cat - dog - pig#行内写法pets: [cat,dog,pig] 修改SpringBoot的默认端口号 配置文件中添加，端口号的参数，就可以切换端口； 12server: port: 8082 注入配置文件yaml文件更强大的地方在于，他可以直接注入匹配值！ 在springboot项目中的resources目录下新建一个文件 application.yaml 编写一个实体类 Dog 123456789package nuc.ss.pojo;@Component //注册bean到容器中public class Dog &#123; private String name; private Integer age; //有参无参构造、get、set方法、toString()方法 &#125; 我们原来是通过value注解或者xml配置文件注入属性值的 1234567@Component //注册beanpublic class Dog &#123; @Value(&quot;阿黄&quot;) private String name; @Value(&quot;18&quot;) private Integer age;&#125; 测试类测试一下 1234567891011@SpringBootTestclass ApplicationTests &#123; @Autowired Dog dog; @Test void contextLoads() &#123; System.out.println(dog); &#125;&#125; 我们在编写一个复杂一点的实体类：Person 类 123456789101112@Component //注册bean到容器中public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; //有参无参构造、get、set方法、toString()方法 &#125; 我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！ 12345678910111213person: name: qinjiang age: 3 happy: false birth: 2000/01/01 maps: &#123;k1: v1,k2: v2&#125; lists: - code - girl - music dog: name: 旺财 age: 1 我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！ 123456789101112131415161718/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应*/@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; //有参无参构造、get、set方法、toString()方法&#125; 编写测试类测试一下 123456789@SpringBootTestclass Springboot02ConfigApplicationTests &#123; @Autowired private Person person; @Test void contextLoads() &#123; System.out.println(person); &#125;&#125; 加载指定的配置文件需要用到的两个注解: @PropertySource ：加载指定的配置文件； **@configurationProperties**：默认从全局配置文件中获取值； 我们去在resources目录下新建一个文件person.properties: 1name=lqy 然后在我们的代码中指定加载person.properties文件 1234567@PropertySource(value = &quot;classpath:person.properties&quot;)@Component //注册beanpublic class Person &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; ...... &#125; yaml配置文件占位符1234567891011121314person: name: qinjiang$&#123;random.uuid&#125; #自动生成uuid age: $&#123;random.int&#125; #生成随机整数 happy: false birth: 2020/07/13 #日期格式要求 maps: &#123;k1: v1,k2: v2&#125; lists: - code - music - girl dog: #类似三目运算符,如果person对象的hell值存在则使用hell的值,否则将值设置为hello_旺财 name: $&#123;person.hell:hello&#125;_旺财 age: 3 @ConfigurationProperties与@Value @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 @ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加 松散绑定：这个什么意思呢? 比如我的yaml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下 JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性 复杂类型封装，@ConfigurationProperties中可以注入对象(通过配置文件) ， 使用@value就不支持 JSR303数据校验Springboot中可以用@validated来**校验数据(作用于类上,校验类的注入属性)**，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式； 使用前需要配置依赖项: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 添加校验注解: 1234567@Component //注册bean@ConfigurationProperties(prefix = &quot;person&quot;)@Validated //数据校验public class Person &#123; @Email(message=&quot;邮箱格式错误&quot;) //name必须是邮箱格式,可以通过message自定义异常打印信息 private String name;&#125; 运行结果: default message [不是一个合法的电子邮件地址]; 常用校验格式注解:12345678910111213141516171819202122232425262728@NotNull(message=&quot;名字不能为空&quot;)private String userName;@Max(value=120,message=&quot;年龄最大不能查过120&quot;)private int age;@Email(message=&quot;邮箱格式错误&quot;)private String email;空检查@Null 验证对象是否为null@NotNull 验证对象是否不为null, 无法查检长度为0的字符串@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查@AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) string is between min and max included.日期检查@Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则.......等等除此以外，我们还可以通过正则表达式自定义一些数据校验规则 配置加载与多环境切换 官网参考:核心特性 (spring.io) profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；（不同位置的优先级如下图） 多环境配置文件我们在主配置文件编写的时候，文件名可以是 application-环境名.properties/yml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，默认使用application.properties主配置文件 yaml文档多模块和properties配置文件中一样，但是yml支持文档多模块,不需要创建多个配置文件 1234567891011121314151617181920server: port: 8081#选择要激活那个环境块spring: profiles: active: test---server: port: 8083spring: profiles: dev #配置环境的名称---server: port: 8084spring: profiles: test #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的, 即,properties配置文件优先级高于yaml文件(propertis文件最后扫描) 切换环境我们需要在主配置文件application.properties或yaml中添加设置spring.profiles.active=环境名 application.properties|yaml 123#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active=dev 配置文件加载位置 官网参考:核心特性 (spring.io) 配置文件的位置一般有如下几个**,按照优先级从低到高(即扫描顺序)以次为:** ./: 项目路径下的配置文件 ./config/ :项目路径下的config目录下的配置文件 ./*/config/: :项目路径下的config目录下所有子目录下的配置文件 classpath/: 类加载目录下的配置文件,在maven项目中是resource文件夹 classpath/config/: …. 需要注意的是:所以配置文件都会被加载设置了相同的配置那么后加载的(优先级高)的配置会覆盖掉之前加载的配置 例如同时设置了端口,最终以classpath/config/下的配置文件为准; 拓展(运维):外部配置我们还可以通过spring.config.location来改变默认的配置文件位置 ,项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高 1java -jar spring-boot-config.jar --spring.config.location=配置文件路径 配置文件详解 核心特性 (spring.io) 配置文件到底能写什么？怎么写？—-联系—- spring.factories文件 , 此文件中包含了很多的配置相关 自动配置原理 SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration @EnableAutoConfiguration 作用: 利用EnableAutoConfigurationImportSelector给容器中导入一些组件 可以查看selectImports()方法的内容,他返回了一个autoConfigurationEnty,来自this.getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata); 这个方法有一个值：List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);叫做获取候选的配置 ，我们点击继续跟踪 SpringFactoriesLoader.loadFactoryNames() 扫描所有jar包类路径下META-INF/spring.factories 把扫描到的这些文件的内容包装成properties对象 从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 在类路径下,META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加入到容器中： spring.factorties文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer# Auto Configuration Import Listenersorg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnBeanCondition,\\org.springframework.boot.autoconfigure.condition.OnClassCondition,\\org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration# Failure analyzersorg.springframework.boot.diagnostics.FailureAnalyzer=\\org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\\org.springframework.boot.autoconfigure.flyway.FlywayMigrationScriptMissingFailureAnalyzer,\\org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\\org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\\org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryBeanCreationFailureAnalyzer,\\org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer# Template availability providersorg.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 每一个自动配置类进行自动配置功能； 我们以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；@Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication( type = Type.SERVLET) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;) //判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty( prefix = &quot;spring.http.encoding&quot;, value = &#123;&quot;enabled&quot;&#125;, matchIfMissing = true) public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; //。。。。。。。&#125; 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 12345//从配置文件中获取指定的值和bean的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;) public class HttpProperties &#123; // .....&#125; 我们去配置文件里面试试前缀，看提示！ 小结: SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可； xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties:封装配置文件中相关属性； @Conditional了解完自动装配的原理后，我们来关注一个细节问题，自动配置类必须在一定的条件下才能生效； @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用(判断是否满足当前指定条件) @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnJava 容器中存在指定Bean ; @ConditionalOnMissingBean 容器中不存在指定Bean ; @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean ,或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类是否生效在application.properties通过启用 debug=true属性；在控制台打印日志，这样我们就可以很方便的知道哪些自动配置类生效 12#开启springboot的调试类debug=true 日志说明: Positive matches:（自动配置类启用的：正匹配） Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配） Unconditional classes: （没有条件的类） 【演示：查看输出的日志】 自定义启动器(了解拓展)自定义Starter我们分析完毕了源码以及自动装配的过程，我们可以尝试自定义一个启动器来玩玩！ 说明启动器模块是一个 空 jar 文件，仅提供辅助性依赖管理，这些依赖可能用于自动装配或者其他类库； 命名归约： 官方命名： 前缀：spring-boot-starter-xxx 比如：spring-boot-starter-web…. 自定义命名： xxx-spring-boot-starter 比如：mybatis-spring-boot-starter 编写启动器 在IDEA中新建一个空项目 spring-boot-starter-diy 新建一个普通Maven模块：kuang-spring-boot-starter 3 新建一个Springboot模块：kuang-spring-boot-starter-autoconfigure 5 点击apply即可，基本结构 7 在我们的 starter 中 导入 autoconfigure 的依赖！ 123456789&lt;!-- 启动器 --&gt;&lt;dependencies&gt; &lt;!-- 引入自动配置模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;artifactId&gt;kuang-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 将 autoconfigure 项目下多余的文件都删掉，Pom中只留下一个 starter，这是所有的启动器基本配置！ 10 我们编写一个自己的服务 12345678910111213141516171819package nuc.ss;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHello(String name)&#123; return helloProperties.getPrefix() + name + helloProperties.getSuffix(); &#125;&#125; 编写HelloProperties 配置类 123456789101112131415161718192021222324252627package nuc.ss;import org.springframework.boot.context.properties.ConfigurationProperties;// 前缀 kuang.hello@ConfigurationProperties(prefix = &quot;kuang.hello&quot;)public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 编写我们的自动配置类并注入bean，测试！ 123456789101112131415161718192021222324package nuc.ss;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 在resources编写一个自己的 META-INF\\spring.factories 123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\nuc.ss.HelloServiceAutoConfiguration 编写完成后，可以安装到maven仓库中！ 16 新建项目测试我们自己写的启动器 新建一个SpringBoot 项目 导入我们自己写的启动器 12345&lt;dependency&gt; &lt;groupId&gt;nuc.ss&lt;/groupId&gt; &lt;artifactId&gt;ss-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 编写一个 HelloController 进行测试我们自己的写的接口！ 1234567891011121314package nuc.ss.controller;@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return helloService.sayHello(&quot;zxc&quot;); &#125;&#125; 编写配置文件 application.properties 12ss.hello.prefix=&quot;ppp&quot;ss.hello.suffix=&quot;sss&quot; 启动项目进行测试，结果成功 ! 学完的东西一定要多下去实践！ 配置文件与配置类自定义自定配置文件绑定配置类在配置类与配置文件属性结构相似甚至相同的时候, 推荐使用配置文件绑定配置类, 这样能更方便的注入配置项 下面以支付宝接口的配置类举例: AlipayConfig.java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.bike_server.config;/* * *类名：AlipayConfig *功能：基础配置类 *详细：设置帐户有关信息及返回路径 *修改日期：2017-04-05 *说明： *以下代码只是为了方便商户测试而提供的样例代码，商户可以根据自己网站的需要，按照技术文档编写,并非一定要使用该代码。 *该代码仅供学习和研究支付宝接口使用，只是提供一个参考。 */import com.alipay.api.AlipayClient;import com.alipay.api.DefaultAlipayClient;import lombok.Getter;import lombok.Setter;import lombok.ToString;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.io.FileWriter;@Configuration// prefix 表示绑定配置文件的前缀配置项@ConfigurationProperties(prefix = &quot;alipay&quot;)// Spring注入依赖 Setter,Getter, 并且不能注入静态属性@Setter@Getter@ToStringpublic class AlipayConfig &#123;// 注入Spring容器 @Bean public AlipayClient getAlipayClient()&#123; //获得初始化的AlipayClient return new DefaultAlipayClient( this.gatewayUrl, this.app_id, this.merchant_private_key, &quot;json&quot;, this.charset, this.alipay_public_key, this.sign_type); &#125;//↓↓↓↓↓↓↓↓↓↓请在这里配置您的基本信息↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ // 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号 private String app_id; // 商户私钥，您的PKCS8格式RSA2私钥 private String merchant_private_key; // 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥。 private String alipay_public_key; // 服务器异步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 private String notify_url; // 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 private String return_url; // 签名方式 private String sign_type; // 字符编码格式 private String charset; // 支付宝网关 private String gatewayUrl; // 日志路径 private String log_path;//↑↑↑↑↑↑↑↑↑↑请在这里配置您的基本信息↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑&#125; 随后在任意路径(推荐在resources, 即classpath路径下面)创建并且编写自己的配置文件, 本案例中: 路径文件: classpath:config/AlipayConfig.yaml 注意: 文件的前缀要和@ConfigurationProperties(prefix = &quot;alipay&quot;)配置的对应 12345678910111213141516171819202122232425alipay: # 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号 app_id: 2021***** # 商户私钥，您的PKCS8格式RSA2私钥 merchant_private_key: MIIEvgIBAD.... # 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥 alipay_public_key: MIIBIjANBg.... # 服务器异步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 # 如果不设置,则支付成功后, 不接收支付宝官方的异步通知,但是同步通知页面路径(return_url)是必填的 notify_url: http://localhost:8081/payAsyncNotify # 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 return_url: http://localhost:8081/finishPay # 支付宝网关 gatewayUrl: https://openapi.alipaydev.com/gateway.do log_path: E:\\\\Code\\\\共享单车管理系统\\\\bike_server\\\\src\\\\main\\\\java\\\\com\\\\bike_server # 签名方式 sign_type: RSA2 charset: utf-8 随后在SringBoot的主配置文件中引入咱们的配置文件, 在application.yaml中,添加如下内容: 123spring config: import: classpath:config/AlipayConfig.yaml tips: 当我们讲自定义配置文件引入到主配置文件中时, 我们编写配置文件的时候会有自动提示 从配置文件中注入配置项的值这种情况通常是用于我们某些业务需要部分使用到配置文件的值,的时候, 并且配置文件的结构并没有与之对应的配置类, 这种方式并不要求配置文件需要有前缀 首先,创建并且编写我们的配置文件: classpath:/config/BikeServerConfig.yaml 123456# 过期时间(分钟) , 可以通过 #&#123;60 * 24 * 7&#125; 的形式进行计算 !tokenExpireTime: 10verifyCodeExpireTime: 2orderPayExpireTime: 5verifyCodeLength: 6 业务类: 1234567891011121314@Service@Getter@Setter@PropertySource(&quot;classpath:/config/BikeServerConfig.yaml&quot;)public class UserService&#123; // token 有效期 (单位:分钟) @Value(&quot;$&#123;tokenExpireTime&#125;&quot;) private int TOKEN_EXPIRE_TIME; // 验证码有效期 (单位:分钟) @Value(&quot;$&#123;verifyCodeExpireTime&#125;&quot;) private int VerifyCode_EXPIRE_TIME = 2; ...&#125; Web开发简介其实SpringBoot的东西用起来非常简单，因为SpringBoot最大的特点就是自动装配。 使用SpringBoot的步骤： 1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好 2、手动在配置文件中配置部分配置项目就可以运行起来了 3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。 要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！ 比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？ 向容器中自动配置组件 ：*** Autoconfiguration 自动配置类，封装配置文件的内容：***Properties 没事就找找类，看看自动装配原理！ 静态资源处理首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！ 写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？ 如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！ 我们先来聊聊这个静态资源映射规则： SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面； 我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法； 有一个方法：addResourceHandlers 添加资源处理 123456789101112131415161718192021222324@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; // 已禁用默认资源处理 logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; // 缓存控制 Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); // webjars 配置 if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; // 静态资源配置 String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125; 读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源； 内置静态资源映射规则1、那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码； 2、我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析： 12345678910111213// 进入方法public String[] getStaticLocations() &#123; return this.staticLocations;&#125;// 找到对应的值private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;// 找到路径private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; 3、ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。 4、所以得出结论，以下四个目录存放的静态资源可以直接被我们识别： 1234&quot;classpath:/META-INF/resources/&quot;&quot;classpath:/resources/&quot;&quot;classpath:/static/&quot;&quot;classpath:/public/&quot; 5、我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件； 自定义路径静态资源映射规则我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置； 12#自定义资源路径,可以设置多个,用逗号分隔, 一般放在类加载路径下spring.resources.static-locations=classpath:/路径名1,classpath:/路径名2 webjars静态资源映射规则使用SpringBoot需要使用Webjars，我们可以去搜索一下：https://www.webjars.org 什么是Webjars? Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。 比如要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 导入完毕，查看webjars目录结构，并访问Jquery.js文件！ 首页与图标设置静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！ 12345678910@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations()); return welcomePageHandlerMapping;&#125; 官网原文: 欢迎页面(Welcome Page) Spring Boot supports both static and templated welcome pages. It first looks for an index.html file in the configured static content locations. If one is not found, it then looks for an index template. If either is found, it is automatically used as the welcome page of the application. 设置首页 欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。 比如我访问 http://localhost:8080/ ，就会找静态资源文件夹下的 index.html 新建一个 index.htmt静态资源映射目录(resource,public,static等)中任意一个,首页就将默认欢迎页面替换成我们自己的首页 设置网页图标官网原文: 自定义应用图标（Custom Facicon） Spring Boot looks for a favicon.ico in the configured static content locations and the root of the classpath (in that order). If such a file is present, it is automatically used as the favicon of the application. 2.2.x之前的版本（如2.1.7）需要在配置文件中关闭默认图标 与其他静态资源一样，Spring Boot在配置的**静态内容位置中查找 favicon.ico文件(文件名固定的)**。如果存在这样的文件，它将自动用作应用程序的favicon。 关闭SpringBoot默认图标 12#关闭默认图标spring.mvc.favicon.enabled=false 自己放一个图标在静态资源目录下，如放在 static目录下 清除浏览器缓存Ctrl + F5！刷新网页，发现图标已经变成自己的了！ 注: 2.2.x之后的版本（如2.3.0）直接执行2和3就可以了 模板引擎Thymeleaf 前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。 jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。 那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？ SpringBoot推荐你可以来使用模板引擎： 模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图： 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。 我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。 引入依赖怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址： Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf Spring官方文档：找到我们对应的版本https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 在Maven中添加依赖, 其实我们也可以在创建SpringBoot项目时就直接添加依赖 12345&lt;!--thymeleaf--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; Thymeleaf分析与使用我们按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。 我们去找一下Thymeleaf的自动配置类：ThymeleafProperties 1234567891011121314@ConfigurationProperties( prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = &quot;classpath:/templates/&quot;; private String suffix = &quot;.html&quot;; private String mode = &quot;HTML&quot;; private Charset encoding;&#125; 我们可以在其中看到默认的前缀和后缀！我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。 Thymeleaf语法 官网:https://www.thymeleaf.org/ , 博客园中文文档:Thymeleaf 教程 | 範宗雲 (fanlychie.github.io) 入门:要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。 1xmlns:th=&quot;http://www.thymeleaf.org&quot; 测试: 在templates目录下新建一个page1.html前端页面 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 模板引擎提示信息: &lt;span th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 编写控制器 1234567891011121314package com.lqy.web.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ThymeleafDemo01 &#123; @RequestMapping(&quot;/t1&quot;) public String test01(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello Thymeleaf!&quot;); return &quot;page1&quot;; &#125;&#125; 测试url: http://localhost:8080/t1 表达式: 语法 名称 描述 作用 ${…} Variable Expressions 变量表达式 取出上下文变量的值 *{…} Selection Variable Expressions 选择变量表达式 取出选择的对象的属性值 #{…} Message Expressions 消息表达式 使文字消息国际化，I18N @{…} Link URL Expressions 链接表达式 用于表示各种超链接地址 ~{…} Fragment Expressions 片段表达式 引用一段公共的代码片段 1234567891011121314&lt;!--变量表达式$&#123;&#125;是面向整个上下文的，而选择变量表达式*&#123;&#125;的上下文是父标签（th:object）所选择的对象： --&gt;&lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p th:text=&quot;*&#123;name&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;*&#123;sex&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;!--链接表达式@&#123;&#125;是专门用来处理 URL 链接地址的。 --&gt;&lt;!-- 绝对地址 --&gt;&lt;p th:text=&quot;@&#123;https://fanlychie.github.io&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 相对地址如:commons/base.html --&gt;&lt;p th:text=&quot;@&#123;commons/base.html&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 上下文相对地址（相对于当前的服务） --&gt;&lt;p th:text=&quot;@&#123;/css/mian.css&#125;&quot;&gt;&lt;/p&gt; 内置对象: 对象 描述 #ctx 上下文对象 #vars 同 #ctx，表示上下文变量 #locale 上下文本地化（特定的地理区域）变量，可参考 java.util.Locale #request HttpServletRequest 对象，可参考 javax.servlet.http.HttpServletRequest #response HttpServletResponse 对象，可参考 javax.servlet.http.HttpServletResponse #session HttpSession 对象，可参考 javax.servlet.http.HttpSession #servletContext ServletContext 对象，可参考 javax.servlet.ServletContext 常见用法: 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;h1&gt;Test页面&lt;/h1&gt; &lt;!--不转义--&gt; &lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt; &lt;!--转义html文本内容--&gt; &lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt; &lt;hr&gt; &lt;!--遍历数据--&gt; &lt;!--th:each每次遍历都会生成当前这个标签：--&gt; &lt;h3 th:each=&quot;user:$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h3&gt; &lt;hr&gt; &lt;!--行内写法：官网#12--&gt; &lt;h3 th:each=&quot;user:$&#123;users&#125;&quot;&gt;[[ $&#123;user&#125; ]]&lt;/h3&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; MVC自动配置原理在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。 官网说明 Spring MVC Auto-configuration(摘抄自官网) 译: Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。Spring Boot provides auto-configuration for Spring MVC that works well with most applications.译: 自动配置在Spring默认设置的基础上添加了以下功能：The auto-configuration adds the following features on top of Spring’s defaults:译: 包含视图解析器Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.译: 支持静态资源文件夹的路径，以及webjarsSupport for serving static resources, including support for WebJars译: 自动注册了Converter：转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把”1”字符串自动转换为int类型Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】Automatic registration of Converter, GenericConverter, and Formatter beans.HttpMessageConvertersSpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；Support for HttpMessageConverters (covered later in this document).// 定义错误代码生成规则的Automatic registration of MessageCodesResolver (covered later in this document).// 首页定制Static index.html support.// 图标定制Custom Favicon support (covered later in this document).// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). /*如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己的@configuration类，类型为webmvcconfiguer，但不要添加@EnableWebMvc。如果要提供 、 或 的自定义实例，并且仍保留 Spring Boot MVC 自定义项，则可以声明一个 Bean 类型，并使用它来提供这些组件的自定义实例。*/If you want to keep Spring Boot MVC features and you want to add additional MVC configuration(interceptors, formatters, view controllers, and other features), you can add your own@Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to providecustom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, orExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. // 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 内容协商视图解析器 自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器； 即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。 我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！ 12345678910@Bean@ConditionalOnBean(ViewResolver.class)@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123; ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级 resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver;&#125; 我们可以点进这类看看！找到对应的解析视图的代码: 12345678910111213141516@Nullable // 注解说明：@Nullable 即参数可为nullpublic View resolveViewName(String viewName, Locale locale) throws Exception &#123; RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;); List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) &#123; // 获取候选的视图对象 List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes); // 选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) &#123; return bestView; &#125; &#125; // .....&#125; 我们继续点进去看，他是怎么获得候选的视图的呢？ getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！ 1Iterator var5 = this.viewResolvers.iterator(); 所以得出结论：ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的 我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！ 12345678910protected void initServletContext(ServletContext servletContext) &#123; // 这里它是从beanFactory工具中获取容器中的所有视图解析器 // ViewRescolver.class 把所有的视图解析器来组合的 Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values(); ViewResolver viewResolver; if (this.viewResolvers == null) &#123; this.viewResolvers = new ArrayList(matchingBeans.size()); &#125; // ...............&#125; 自定义视图解析器我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；我们去实现一下 可以在主程序的同级目录或者子目录下新建一个config目录表示是个配置类,内容如下: 1234567891011121314151617181920//扩展 springmvc DispatchServlet@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Bean public ViewResolver myViewResolver() &#123; return new MyViewResolver(); &#125; // 自定义了一个自己的视图解析器 // public interface ViewResolver 实现了视图解析器接口的类，我们就可以吧它看做视图解析器 public static class MyViewResolver implements ViewResolver &#123; @Override public View resolveViewName(String s, Locale locale) throws Exception &#123; return null; &#125; &#125;&#125; 所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！ 转换器与格式化器在WebMvcAutoConfiguration中找到格式化转换器： 123456789@Bean@Overridepublic FormattingConversionService mvcConversionService() &#123; // 拿到配置文件中的格式化规则 WebConversionService conversionService = new WebConversionService(this.mvcProperties.getDateFormat()); addFormatters(conversionService); return conversionService;&#125; 点击去：可以看到在我们的application.properties文件中，我们可以进行自动配置它！ 2.2.x之前版本 12345678public String getDateFormat() &#123; return this.dateFormat;&#125;/*** Date format to use. For instance, `dd/MM/yyyy`. 默认的 */private String dateFormat; 2.2.x之后的版本 123456789101112public String getDateFormat() &#123; return this.format.getDate();&#125;public String getDate() &#123; return this.date;&#125;/** * Date format to use, for example `dd/MM/yyyy`.默认的*/private String date; 如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则： 2.2.x版本之前的 配置文件 12# 配置文件spring.nvc.date-format= 源码 1234@Deprecatedpublic void setDateFormat(String dateFormat) &#123; this.dateFormat = dateFormat;&#125; 2.2.x版本之后的 配置文件 1spring.nvc.date= 源码 12345678@Deprecatedpublic void setDateFormat(String dateFormat) &#123; this.format.setDate(dateFormat);&#125;public void setDate(String date) &#123; this.date = date;&#125; 其余的就不一一举例了，大家可以下去多研究探讨即可！ 修改拓展默认配置 这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。 SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论； SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的； 如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！ 扩展使用SpringMVC 官方文档如下： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. 我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个； 我们新建一个包叫config，写一个类MyMvcConfig: 12345678910111213// 如果我们要扩展springmvc，官方建议我们这样去做@Configuration//应为类型要求为WebMvcConfigurer，所以我们实现其接口//扩展 springmvc DispatchServlet//@EnableWebMvc //这玩意就是导入了一个类，DelegatingWebMvcConfiguration，从容器中获取所有的webMvcConfig@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // 浏览器发送/test ， 就会跳转到test页面； registry.addViewController(&quot;/test2&quot;).setViewName(&quot;test&quot;); &#125;&#125; 确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！ 我们可以去分析一下原理： WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter 这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class) 我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration 这个父类中有这样一段代码： 1234567891011public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); // 从容器中获取所有的webmvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125; &#125;&#125; 我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个 123protected void addViewControllers(ViewControllerRegistry registry) &#123; this.configurers.addViewControllers(registry);&#125; 我们点进去看一下 12345678910public void addViewControllers(ViewControllerRegistry registry) &#123; Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) &#123; // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的 WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); &#125;&#125; 得出结论：所有的WebMvcConfiguration都会被使用，不止Spring自己的配置类，我们自己的配置类当然也会被调用； 全面接管重写SpringMVC配置官方原话:If you want to take complete control of Spring MVC , you can add your own @Configuration annotated with @EnableWebMvc. 全面接管即：SpringBoot对SpringMVC的原来的自动配置不需要了，所有都是我们自己去配置！ 只需在我们的配置类中要加一个@EnableWebMvc。 为什么加了一个注解，自动配置就失效了?我们看下源码： 这里发现它是导入了一个类，我们可以继续进去看 123@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123;&#125; 它继承了一个父类 WebMvcConfigurationSupport 123public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; // ......&#125; 我们来回顾一下Webmvc自动配置类 1234567891011@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; &#125; 拦截器Javaweb中有一个过滤器,拦截器跟过滤器非常类似,下面讲一下拦截器的使用方法: 新建一个类(名字自定义), 实现拦截器的口: 比如WebInterceptor 123456789101112131415161718192021222324252627/** * 自定义拦截器类, 配置拦截逻辑 */public class WebInterceptor implements HandlerInterceptor &#123;// 实现HandlerInterceptor接口// 访问控制器方法前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(new Date() + &quot;--preHandle:&quot; + request.getRequestURL()); return true; &#125; // 访问控制器方法后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(new Date() + &quot;--postHandle:&quot; + request.getRequestURL()); &#125; // postHandle方法执行完成后执行，一般用于释放资源 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(new Date() + &quot;--afterCompletion:&quot; + request.getRequestURL()); &#125;&#125; 再新建一个拦截器配置类,,配置类的接口, 如: WebConfig 12345678910111213141516171819202122232425/** * Web配置类 */@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; // 注意!!! 如果不将拦截器注入, 拦截器无法注入 Spring Bean @Bean public WebInterceptor webInterceptor()&#123; return new WebInterceptor(); &#125; /** * 添加Web项目的拦截器的拦截规则 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 对所有访问路径，都通过MyInterceptor类型的拦截器进行拦截, //注意这里不要使用 new WebInterceptor() ，否则就会出现拦截器里无法注入service的问题 registry.addInterceptor(new WebInterceptor()).addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/login&quot;, &quot;/index.html&quot;, &quot;/user/login&quot;, &quot;/css/**&quot;, &quot;/images/**&quot;, &quot;/js/**&quot;, &quot;/fonts/**&quot;); //放行登录页，登陆操作，静态资源 &#125;&#125; 这样就设置好了拦截器 链接数据库整合JDBC在创建项目时,勾选上SQL依赖里的JDBC API 项目建立好后, 在maven的配置文件中发现自动帮我们导入了如下启动器: 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下 12345678910111213141516171819package com.lqy.sql;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import javax.sql.DataSource;import java.sql.SQLException;@SpringBootTestclass SqlApplicationTests &#123; @Autowired DataSource dataSource; @Test void contextLoads() throws SQLException &#123; System.out.println(dataSource.getClass()); System.out.println(dataSource.getConnection()); &#125;&#125; 结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置 我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件： 1234567@Import( &#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class&#125;)protected static class PooledDataSourceConfiguration &#123; protected PooledDataSourceConfiguration() &#123; &#125;&#125; 这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源； HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀； 可以使用 spring.datasource.type 指定自定义的数据源类型，值为要使用的连接池实现的完全限定名。 关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate JdbcTemplate 有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库； 即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。 数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。 Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用 JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类 JdbcTemplate主要提供以下几类方法： execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句； update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句； query方法及queryForXXX方法：用于执行查询相关语句； call方法：用于执行存储过程、函数相关语句。 测试:SpringBoot测试类: 12345678910111213141516171819202122232425262728@SpringBootTestclass SqlApplicationTests &#123; @Autowired DataSource dataSource; @Autowired JdbcTemplate jdbcTemplate; @Test void contextLoads() throws SQLException &#123;/* JdbcTemplate是SpringBoot对JDBC进行的封装类 将查询到的结果集用List存储,由于没有实体类,每个list元素代表一行元素,并且是一个map集合(即键值对集合),map的key为列名,value类对应列的值 */ List&lt;Map&lt;String,Object&gt;&gt; res =jdbcTemplate.queryForList(sql); for (Map map:res) &#123; System.out.println(map); //这里默认调用了AbstractMap的toString,遍历map,内容用&#123;&#125;包裹,键值对以: 键=值 的形式表示 &#125; &#125;&#125;/* 打印结果:&#123;id=1, name=小有, pwd=000000&#125;&#123;id=2, name=枫原万叶, pwd=2222222&#125;&#123;id=3, name=慕雪归, pwd=3333333&#125;&#123;id=4, name=慕枫, pwd=12121&#125;&#123;id=5, name=北北, pwd=11313131&#125;&#123;id=7, name=南笙, pwd=171771&#125;/* 增删改查:123456789101112131415161718192021222324252627282930313233343536373839404142package com.lqy.sql.controller.res_controller;@RestControllerpublic class UserController &#123; @Autowired JdbcTemplate jdbcTemplate; @RequestMapping(&quot;/getAllUser&quot;) public List&lt;Map&lt;String,Object&gt;&gt; getAllUser()&#123; String sql = &quot;select * from `user`&quot;; List&lt;Map&lt;String,Object&gt;&gt; res =jdbcTemplate.queryForList(sql); return res; &#125; @RequestMapping(&quot;/addUser&quot;) public String addUser()&#123; String sql = &quot;insert into `user` values(99,&#x27;南城&#x27;,999)&quot;; jdbcTemplate.update(sql); return &quot;update-ok!&quot;; &#125; @RequestMapping(&quot;/deleteUser/&#123;id&#125;&quot;) //使用路径参数传递 public String deleteUser(@PathVariable(&quot;id&quot;) int id)&#123; //类似原生JDBC的 statement 使用占位符,防止字符串拼接导致sql注入 String sql = &quot;delete from `user` where(id = ?)&quot;; jdbcTemplate.update(sql,id); //第二个参数是将 ?占位符 替换成我们实际的参数, 也可以传递Object数组使用多个参数 return &quot;update-ok!&quot;; &#125; @RequestMapping(&quot;/updateUser/&#123;id&#125;@&#123;name&#125;&amp;&#123;pwd&#125;&quot;) public String updateUser(@PathVariable(&quot;id&quot;)int id,@PathVariable(&quot;name&quot;)String name,@PathVariable(&quot;pwd&quot;)String pwd)&#123; String sql = &quot;update `user` set name=?,pwd=? where id = ?&quot;; Object[] args = new Object[3]; args[0] = name; args[1] = pwd; args[2] = id; jdbcTemplate.update(sql,args); //使用了多个参数,所以用Object数组传递参数 return &quot;update-ok!&quot;; &#125;&#125; 整合Druid数据连接池Druid简介 Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。 Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。 Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。 Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。 Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。 Github地址：https://github.com/alibaba/druid/ com.alibaba.druid.pool.DruidDataSource 基本配置参数如下： 配置 缺省值 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：“DataSource-” + System.identityHashCode(this) jdbcUrl 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 validationQueryTimeout 单位:秒，检测连接是否有效的超时时间。底层调用jdbcStatement对象的void setQueryTimeout(int seconds)方法 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效 timeBetweenEvictionRunsMillis 1分钟( 1.0.14 ) 有两个含义： 1) Destroy线程会检测连接的间隔时间 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis 30分钟( 1.0.14 ) 连接保持空闲而不被驱逐的最长时间 connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 配置数据源1.添加依赖123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt; 2.切换数据源之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以通过修改配置文件application.properties设置配置spring.datasource.type 指定数据源。 12345678# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据库用户名&amp;密码和urlspring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8#设置数据源,替换掉默认的数据源spring.datasource.type=com.alibaba.druid.pool.DruidDataSource 在测试类中注入数据源并打印查看是否切换成功 12345678910111213141516171819202122232425262728package com.lqy.sql;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.sql.SQLException;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;import static java.util.Map.*;@SpringBootTestclass SqlApplicationTests &#123; @Autowired //自动装配注入数据源 DataSource dataSource; @Test void contextLoads() throws SQLException &#123; System.out.println(dataSource.getClass());//打印结果为:com.alibaba.druid.pool.DruidDataSource ,切换成功了 &#125;&#125; 3.配置参数(非必要)切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项 有两种设置方式: 一是我们自己编写配置类结合配置文件来进行配置,我们需要引入Driud的依赖包, 二是直接引入Druid启动器依赖包 , 我们直接在配置文件上改配置 , 在数据监控那会详细说明 (推荐) (1).编写配置类注意! 如果我们引入的是Druid的SpringBoot启动器,就不需要再自己编写配置类了 (通过配置类,类似Spring中xml文件里的&lt;beans&gt;)将DruidDataSource注入到Spring中,@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)的作用就是将SpringBoot配置文件中属性名前缀为spring.datasource(这个我们可以随意起名)的属性值注入到DruidDataSource数据源中的同名属性值中 12345678910111213141516171819202122package com.lqy.sql.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class DruidConfig &#123; /* 将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建 绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效 @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中 前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中 */ @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DruidDataSource druidDataSource() &#123; return new DruidDataSource(); &#125;&#125; (2)编写配置文件在SpringBoot配置文件中编写如下配置: 1234567891011121314151617181920212223242526272829303132333435363738394041# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据库用户名&amp;密码和urlspring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8#设置数据源,替换掉默认的数据源spring.datasource.type=com.alibaba.druid.pool.DruidDataSource#config druid#连接池的设置#初始化时建立物理连接的个数spring.datasource.initialSize=5#最小连接池数量spring.datasource.minIdle=5#最大连接池数量 maxIdle已经不再使用spring.datasource.maxActive=20#获取连接时最大等待时间，单位毫秒spring.datasource.maxWait=60000#申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。spring.datasource.testWhileIdle=true#既作为检测的间隔时间又作为testWhileIdel执行的依据spring.datasource.timeBetweenEvictionRunsMillis=60000#销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接spring.datasource.minEvictableIdleTimeMillis=30000#用来检测连接是否有效的sql 必须是一个查询语句#mysql中为 select &#x27;x&#x27;#oracle中为 select 1 from dualspring.datasource.validationQuery=select &#x27;x&#x27;#申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为truespring.datasource.testOnBorrow=false#归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为truespring.datasource.testOnReturn=false#是否缓存preparedStatement,mysql5.5+建议开启#spring.datasource.poolPreparedStatements=true#配置扩展插件,stat:监控统计、wall：防御sql注入 ,log4j(可能需要另外导包)：日志记录spring.datasource.druidFilters=stat,wall#通过connectProperties属性来打开mergeSql功能；慢SQL记录spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500#合并多个DruidDataSource的监控数据spring.datasource.useGlobalDataSourceStat=true 在测试类测试一下是否读取到配置文件的配置 123456789101112131415161718192021package com.lqy.sql;@SpringBootTestclass SqlApplicationTests &#123; @Autowired DataSource dataSource; @Test public void test02() throws SQLException &#123; //看一下默认数据源 System.out.println(dataSource.getClass()); //获得连接 Connection connection = dataSource.getConnection(); System.out.println(connection); DruidDataSource druidDataSource = (DruidDataSource) dataSource; System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive()); System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize()); //关闭连接 connection.close(); &#125;&#125; 配置Druid数据源监控 配置参考:2509-Druid监控功能的深入使用与配置-基于SpringBoot-完全使用 .properties配置文件 - 爱码网 (likecs.com) Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。 所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理； 通过配置类配置在配置类中再次注入数据监控相关的bean 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.lqy.sql.config;@Configurationpublic class DruidConfig &#123; /* 将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建 绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效 @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中 前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中 */ // 配置Druid @Bean @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DruidDataSource druidDataSource() &#123; return new DruidDataSource(); &#125; //配置 Druid 监控管理后台的Servlet；内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式 @Bean public ServletRegistrationBean statViewServlet() &#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);// 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet的父类 com.alibaba.druid.support.http.ResourceServlet 中找到 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;, &quot;root&quot;); //后台管理界面的登录账号 initParams.put(&quot;loginPassword&quot;, &quot;admin&quot;); //后台管理界面的登录密码 //后台允许谁可以访问 //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问 //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问 initParams.put(&quot;allow&quot;, &quot;&quot;); //deny：Druid 后台拒绝谁访问 //initParams.put(&quot;name&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问 //设置初始化参数 bean.setInitParameters(initParams); return bean; &#125; //配置 Druid 监控 之 web 监控的过滤器filter //WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计 @Bean public FilterRegistrationBean webStatFilter() &#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); //&quot;/*&quot; 表示过滤所有请求 bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParams); return bean; &#125;&#125; 这样,数据监控就配置好了,我们可以通过urlhttp://localhost:8080/druid/login.html根据我们设置的用户名密码登陆 通过配置文件配置只通过配置文件配置,我们就只需要引入Druid的启动器依赖,而不用Druid依赖,两者会起冲突 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt; 配置文件这些配置只关于数据源监控的配置, 不包含数据源切换的配置,所以这些配置要在切换完切换源之后追加的配置 123456789101112131415161718 # StatViewServlet配置，说明请参考Druid Wiki，配置_StatViewServlet配置#是否启用StatViewServlet默认值truespring.datasource.druid.stat-view-servlet.enabled=true#进入监控页面的url,设置为/druid/*就好spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*#是否允许手动重置监控数据spring.datasource.druid.stat-view-servlet.reset-enable=false#设置账号密码spring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=123456 # WebStatFilter配置，说明请参考Druid Wiki，配置_配置WebStatFilter#是否启用StatFilter默认值truespring.datasource.druid.web-stat-filter.enabled=true#过滤哪些请求spring.datasource.druid.web-stat-filter.url-pattern=/*#排除哪些请求spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/* 去除监控页面广告由于1.2.xx版本源码结构已经更改,故需要去除广告尽量使用1.1.xx版本 教程:(23条消息) 如何去除Druid数据监控广告？_Roc-xb的博客-CSDN博客_druid去除广告 1、找到本地maven库中的对应的druid-1.1.xx.jar文件，用压缩包软件打开 2、找到support/http/resource/js/common.js, 打开找到 buildFooter 方法 12345this.buildFooter();buildFooter : function() &#123; var html =&#x27;此处省略一些相关JS代码&#x27;; $(document.body).append(html);&#125;, 3、删除此函数和及初始方法后覆盖文件 4、重启项目后，广告就会消失了 完整配置文件如果引入了Druid启动器依赖,直接copy即可,自定义配置类的话,就把属性前缀改成spring.datasource.druid就可以了,但是自定义配置的话就需要再手动注入监控器而不能通过配置文件配置比较麻烦 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#设置数据源,替换掉默认的数据源spring.datasource.type=com.alibaba.druid.pool.DruidDataSource# 数据库用户名&amp;密码和urlspring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8#config druid,引入Druid启动器会有前缀提示,自定义配置类可以自己设置属性前缀,但是不会有提示#连接池的设置#初始化时建立物理连接的个数spring.datasource.druid.initialSize=5#最小连接池数量spring.datasource.druid.minIdle=5#最大连接池数量 maxIdle已经不再使用spring.datasource.druid.maxActive=20#获取连接时最大等待时间，单位毫秒spring.datasource.druid.maxWait=60000#申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。spring.datasource.druid.testWhileIdle=true#既作为检测的间隔时间又作为testWhileIdel执行的依据spring.datasource.druid.timeBetweenEvictionRunsMillis=60000#销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接spring.datasource.druid.minEvictableIdleTimeMillis=30000#用来检测连接是否有效的sql 必须是一个查询语句#mysql中为 select &#x27;x&#x27;#oracle中为 select 1 from dualspring.datasource.druid.validationQuery=select &#x27;x&#x27;#申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为truespring.datasource.druid.testOnBorrow=false#归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为truespring.datasource.druid.testOnReturn=false#是否缓存preparedStatement,mysql5.5+建议开启spring.datasource.druid.poolPreparedStatements=true#配置扩展插件`stat:监控统计、wall：防御sql注入 ,log4j(可能需要另外导包)：日志记录spring.datasource.druid.filters=stat,wall#通过connectProperties属性来打开mergeSql功能；慢SQL记录spring.datasource.druid.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500#合并多个DruidDataSource的监控数据spring.datasource.druid.useGlobalDataSourceStat=true# StatViewServlet配置，说明请参考Druid Wiki，配置_StatViewServlet配置#是否启用StatViewServlet默认值truespring.datasource.druid.stat-view-servlet.enabled=true#进入监控页面的url,设置为/druid/*就好spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*#是否允许手动重置监控数据spring.datasource.druid.stat-view-servlet.reset-enable=false#设置账号密码spring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=123456# WebStatFilter配置，说明请参考Druid Wiki，配置WebStatFilter#是否启用StatFilter默认值truespring.datasource.druid.web-stat-filter.enabled=true#过滤哪些请求spring.datasource.druid.web-stat-filter.url-pattern=/*#排除哪些请求spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/* 整合mybatis 官网:mybatis-spring-boot-autoconfigure – Introduction 需要的依赖:1234567891011121314151617181920212223&lt;!-- web不是必须的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- mybatis必须--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt;&lt;!-- mysql驱动,这个是必须的--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;!-- SpringBoot测试单元,非必须--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 配置文件SpringBoot配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#mybatis给实体类设置别名mybatis.type-aliases-package=com.example.springbootmybatis.pojo#扫描mybatis的映射器配置文件mybatis.mapper-locations=classpath:mybatis/mapper/*.xml# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#设置数据源,替换掉默认的数据源spring.datasource.type=com.alibaba.druid.pool.DruidDataSource# 数据库用户名&amp;密码和urlspring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8#config druid,引入Druid启动器会有前缀提示,自定义配置类可以自己设置属性前缀,但是不会有提示#连接池的设置#初始化时建立物理连接的个数spring.datasource.druid.initialSize=5#最小连接池数量spring.datasource.druid.minIdle=5#最大连接池数量 maxIdle已经不再使用spring.datasource.druid.maxActive=20#获取连接时最大等待时间，单位毫秒spring.datasource.druid.maxWait=60000#申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。spring.datasource.druid.testWhileIdle=true#既作为检测的间隔时间又作为testWhileIdel执行的依据spring.datasource.druid.timeBetweenEvictionRunsMillis=60000#销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接spring.datasource.druid.minEvictableIdleTimeMillis=30000#用来检测连接是否有效的sql 必须是一个查询语句#mysql中为 select &#x27;x&#x27;#oracle中为 select 1 from dualspring.datasource.druid.validationQuery=select &#x27;x&#x27;#申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为truespring.datasource.druid.testOnBorrow=false#归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为truespring.datasource.druid.testOnReturn=false#是否缓存preparedStatement,mysql5.5+建议开启spring.datasource.druid.poolPreparedStatements=true#配置扩展插件`stat:监控统计、wall：防御sql注入 ,log4j(可能需要另外导包)：日志记录spring.datasource.druid.filters=stat,wall#通过connectProperties属性来打开mergeSql功能；慢SQL记录spring.datasource.druid.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500#合并多个DruidDataSource的监控数据spring.datasource.druid.useGlobalDataSourceStat=true# StatViewServlet配置，说明请参考Druid Wiki，配置_StatViewServlet配置#是否启用StatViewServlet默认值truespring.datasource.druid.stat-view-servlet.enabled=true#进入监控页面的url,设置为/druid/*就好spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*#是否允许手动重置监控数据spring.datasource.druid.stat-view-servlet.reset-enable=false#设置账号密码spring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=123456# WebStatFilter配置，说明请参考Druid Wiki，配置WebStatFilter#是否启用StatFilter默认值truespring.datasource.druid.web-stat-filter.enabled=true#过滤哪些请求spring.datasource.druid.web-stat-filter.url-pattern=/*#排除哪些请求spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/* 创建实体类User.java 123456789package com.example.springbootmybatis.pojo;public class User &#123; private int id; private String name; private String pwd; // 构造器,getter,setter,toString&#125; dao层接口UserMapper.java 123456789101112131415161718package com.example.springbootmybatis.dao;/*此注解表示了这是一个mybatis的mapper类,相当于mybatis扫描Mapper接口,同时将Mapper注入到Spring容器中 */@Mapperpublic interface UserMapper &#123; List&lt;User&gt; getAllUser(); User getUserById(); int addUser(User user); int deleteUser(int id); int updateUser(User user);&#125; 也可以在主程序类中加上一个Mapper扫描注解@MapperScan(&quot;包名&quot;),扫描指定包下的dao接口 ,这样就不用每次都在接口上写@Mapper注解了 (注: 但是这样idea会报红,但是程序本身是正确的,是idea的问题,如果有强迫症,还是在每个接口加上@Mapper吧) Mapper映射文件1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--命名空间作用是绑定 Dao/Mapper接口,相当于编写了一个类实现了该接口--&gt;&lt;mapper namespace=&quot;com.example.springbootmybatis.dao.UserMapper&quot; &gt;&lt;!-- 由于我们给实体类起了别名,在application中,所以不需要写含包类名的实体类了 此外,需要注意哪怕接口的方法是List类型,但是每行结果都是和实体类映射对应的 所以返回结果类型应该实体类类型--&gt; &lt;select id=&quot;getAllUser&quot; resultType=&quot;User&quot;&gt; select * from `user` &lt;/select&gt; &lt;select id=&quot;getUser&quot; resultType=&quot;User&quot;&gt; select * from `user` where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot;&gt; insert into `user` values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) &lt;/insert&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from `user` where id = #&#123;id&#125; &lt;/delete&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; update `user` set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 测试编写一个控制器测试一下! 12345678910111213141516171819202122232425262728293031package com.example.springbootmybatis.controller;@RestControllerpublic class UserController &#123; @Autowired UserMapper userMapper; @RequestMapping(&quot;/getAllUser&quot;) public List&lt;User&gt; getAllUser()&#123; return userMapper.getAllUser(); &#125; @RequestMapping(&quot;/addUser/&#123;id&#125;@&#123;name&#125;&amp;&#123;pwd&#125;&quot;) public String addUser(@PathVariable int id,@PathVariable String name,@PathVariable String pwd)&#123; userMapper.addUser(new User(id,name,pwd)); return &quot;update-ok!&quot;; &#125; @RequestMapping(&quot;/deleteUser/&#123;id&#125;&quot;) //使用路径参数传递 public String deleteUser(@PathVariable(&quot;id&quot;) int id)&#123; userMapper.deleteUser(id); return &quot;update-ok!&quot;; &#125; @RequestMapping(&quot;/updateUser/&#123;id&#125;@&#123;name&#125;&amp;&#123;pwd&#125;&quot;) public String updateUser(@PathVariable(&quot;id&quot;)int id,@PathVariable(&quot;name&quot;)String name,@PathVariable(&quot;pwd&quot;)String pwd)&#123; userMapper.updateUser(new User(id,name,pwd)); return &quot;update-ok!&quot;; &#125;&#125; Mybatis-Puls与敏捷CURD简介MyBatisPlus（简称MP）是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提高效率 官网：https://mybatis.plus/ https://mp.baomidou.com/ 特性: 无侵入：只做增强不做改变，不会对现有工程产生影响 强大的 CRUD 操作：内置通用 Mapper，少量配置即可实现单表CRUD 操作 支持 Lambda：编写查询条件无需担心字段写错 支持主键自动生成 内置分页插件 …… 快速入门需要的依赖: 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql驱动,这个是必须的--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 数据源,看情况 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt; 配置Jdbc参数（application.yml）…. 建表sql: 12345678910111213141516create database if not exists mybatisplus_db character set utf8;use mybatisplus_db;CREATE TABLE user (id bigint(20) primary key auto_increment,name varchar(32) not null,password varchar(32) not null,age int(3) not null ,tel varchar(32) not null);insert into user values(null,&#x27;tom&#x27;,&#x27;123456&#x27;,12,&#x27;12345678910&#x27;);insert into user values(null,&#x27;jack&#x27;,&#x27;123456&#x27;,8,&#x27;12345678910&#x27;);insert into user values(null,&#x27;jerry&#x27;,&#x27;123456&#x27;,15,&#x27;12345678910&#x27;);insert into user values(null,&#x27;tom&#x27;,&#x27;123456&#x27;,9,&#x27;12345678910&#x27;);insert into user values(null,&#x27;snake&#x27;,&#x27;123456&#x27;,28,&#x27;12345678910&#x27;);insert into user values(null,&#x27;张益达&#x27;,&#x27;123456&#x27;,22,&#x27;12345678910&#x27;);insert into user values(null,&#x27;张大炮&#x27;,&#x27;123456&#x27;,16,&#x27;12345678910&#x27;); 实体类: 12345678public class User &#123;private Long id;private String name;private String password;private Integer age;private String tel;//自行添加getter、setter、toString()等方法&#125; 定义数据接口，继承BaseMapper , 请注意这里的@Mapper注解是Mybatis-Puls注解, 而不是Mybatis, 也就不需要在xml文件里sql mybatis-puls 的Mapper内置封装了一些简单的增删改查 1234567import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.zgc.domain.User;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface UserDao extends BaseMapper&lt;User&gt; &#123; &#125; 测试: 123456789101112@SpringBootTestpublic class Mybatisplus01QuickstartApplicationTests &#123; @Autowired private UserDao userDao; @Test void testGetAll() &#123; //selectList()根据MP内置的条件构造器查询一个list集合，null表示没有条件，即查询所有 List&lt;User&gt; userList = userDao.selectList(null); System.out.println(userList); &#125; &#125; 日志在application.yml中配置日志输出 12345# 配置MyBatis日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 异步,定义任务与邮箱异步任务SpringBoot为我们提供了线程池,可供我们直接将一个方法变成异步方法(也就是另外开一个线程去做) , 我们需要在方法上加上一个注解@Async , 同时我们还需要在主程序类加上一个开启异步功能的注解@EnableAsync 异步方法: 即使休眠了,但是在程序调用方法时并不会等这个执行完在执行后续结果 12345678910//告诉Spring这是一个异步方法@Asyncpublic void hello()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;业务进行中....&quot;);&#125; 主程序类: 12345678@EnableAsync //开启异步注解功能@SpringBootApplicationpublic class SpringbootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootTaskApplication.class, args); &#125;&#125; 定时任务项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。 TaskExecutor接口（任务执行者） TaskScheduler接口（任务调度者） 两个注解： @EnableScheduling——开启定时功能的注解 , 在主程序类上标注 @Scheduled(cron = &quot;cron表达式&quot;)——什么时候执行 , 在方法上标注 cron表达式: cron表达式参考:cron表达式详解 - JaxYoun - 博客园 (cnblogs.com) Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义 秒 分 时 日 月 周几 字段 允许值 允许的特殊字符 秒（Seconds） 0~59的整数 , - * / 四个字符 分（Minutes） 0~59的整数 , - * / 四个字符 小时（Hours） 0~23的整数 , - * / 四个字符 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符 月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符 年(可选，留空)（Year） 1970~2099 , - * / 四个字符 特殊字符 代表含义 , 枚举 - 区间 * 任意 / 步长 ? 日/星期冲突匹配 L 最后 W 工作日 C 和calendar练习后计算过的值 # 星期，4#2 第二个星期三 测试: 注意:要在主程序写上开启定时任务的注解 1234567@EnableScheduling //开启基于注解的定时任务@SpringBootApplicationpublic class SpringbootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootTaskApplication.class, args); &#125;&#125; 定时任务方法: 12345678910111213141516@Service //业务层方法public class ScheduledService &#123; //cron表达式 // 秒 分 时 日 月 周几 /* 0 49 11 * * ? 每天的11点49分00秒执行 0 0/5 11,12 * * ? 每天的11点和12点每个五分钟执行一次 0 15 10 ? * 1-6 每个月的周一到周六的10点15分执行一次 0/2 * * * * ? 每2秒执行一次 */ @Scheduled(cron = &quot;0/2 * * * * ?&quot;) public void hello() &#123; System.out.println(&quot;hello,你被执行了&quot;); &#125;&#125; 邮箱功能邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持**(对javax.mail做了封装)** 详细原理可查看javaweb相关的邮箱功能 邮件发送需要引入spring-boot-start-mail 邮箱启动器依赖包 SpringBoot 自动配置MailSenderAutoConfiguration 定义MailProperties内容，配置在application.yml中 自动装配JavaMailSender 依赖项:引入这个启动器即可 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 看它引入的依赖，可以看到里面包含了jakarta.mail 12345&lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; &lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 查看自动配置类：MailSenderAutoConfiguration 这个类中存在bean，JavaMailSenderImpl 然后我们去看下配置类: MailProperties 1234567891011121314@ConfigurationProperties(prefix = &quot;spring.mail&quot;)public class MailProperties &#123; private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8; private String host; private Integer port; private String username; private String password; private String protocol = &quot;smtp&quot;; private Charset defaultEncoding = DEFAULT_CHARSET; private Map&lt;String, String&gt; properties = new HashMap&lt;&gt;(); private String jndiName; //set、get方法省略。。。&#125; 配置文件:在SpringBoot的配置文件中配置一下邮箱的配置: 123spring.mail.username=xxx@qq.comspring.mail.password=你的qq授权码spring.mail.host=smtp.qq.com 获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务 测试示例:1234567891011121314151617181920212223242526272829303132333435363738package com.example.SpringBoot;@SpringBootTestclass ApplicationTests &#123; @Autowired // 装配一下SpringBoot为我们封装好的邮箱实现类 JavaMailSenderImpl javaMailSender; @Test//邮件设置1：一个简单的邮件 void contextLoads() &#123; SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setSubject(&quot;狂神，你好&quot;); mailMessage.setText(&quot;谢谢你的狂神说Java系列课程&quot;); mailMessage.setTo(&quot;24736743@qq.com&quot;); mailMessage.setFrom(&quot;1710841251@qq.com&quot;); javaMailSender.send(mailMessage); &#125; @Test// 一个复杂的邮件 void contextLoads2() throws MessagingException &#123; MimeMessage mimeMessage = javaMailSender.createMimeMessage(); //组装 MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); //正文 helper.setSubject(&quot;狂神，你好~plus&quot;); helper.setText(&quot;&lt;p style=&#x27;color:red&#x27;&gt;谢谢你的狂神说Java系列课程&lt;/p&gt;&quot;, true); //附件 helper.addAttachment(&quot;1.jpg&quot;, new File(&quot;&quot;)); helper.addAttachment(&quot;2.jpg&quot;, new File(&quot;&quot;)); helper.setTo(&quot;24736743@qq.com&quot;); helper.setFrom(&quot;1710841251@qq.com&quot;); javaMailSender.send(mimeMessage); &#125;&#125; 整合Redis与缓存SpringDataRedisSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis 提供了对不同Redis客户端的整合（Lettuce和Jedis）, SpringBData默认使用Lettuce 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： API 返回值类型 说明 redisTemplate.opsForValue() ValueOperations 操作String类型数据 redisTemplate.opsForHash() HashOperations 操作Hash类型数据 redisTemplate.opsForList() ListOperations 操作List类型数据 redisTemplate.opsForSet() SetOperations 操作Set类型数据 redisTemplate.opsForZSet() ZSetOperations 操作SortedSet类型数据 redisTemplate 通用的命令 快速入门SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单： 首先导入依赖: 12345678910111213141516 &lt;!--redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--common-pool 数据库连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--Jackson依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; springboot配置文件: 1234567891011spring: redis: host: 192.168.150.101 port: 6379 password: 123321 lettuce: pool: max-active: 8 #最大连接 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100ms #连接等待时间 测试代码: 12345678910@SpringBootTestclass SpringDataRedisApplicationTests &#123; @Autowired private RedisTemplate&lt;String, String&gt; redisTemplate; @Test void String() &#123; redisTemplate.opsForValue().set(&quot;name&quot;, &quot;顾北&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;)); &#125;&#125; 数据序列化SerializerRedisTemplate可以接收任意Object作为值写入Redis： 只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的： 缺点： 可读性差 内存占用较大 我们可以自定义RedisTemplate的序列化方式，代码如下： 在com.项目名xxx.redis.config包下创建: 12345678910111213141516171819202122@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123; // 创建RedisTemplate对象 RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); // 设置连接工厂 template.setConnectionFactory(connectionFactory); // 创建JSON序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 设置Key的序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // 设置Value的序列化 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); // 返回 return template; &#125;&#125; 整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。 为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间 这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。 省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用： 123456789101112131415161718192021@SpringBootTestclass SpringDataRedisApplicationTests &#123; // 使用 StringRedisTemplate @Autowired private StringRedisTemplate redisTemplate; @Test void String() throws JsonProcessingException &#123; // 使用 jackson 库 解析 JSON ObjectMapper objectMapper = new ObjectMapper(); User user = new User(&quot;南城&quot;,20); // 讲 Java对象序列化成 JSON后插入 String jsonStr = objectMapper.writeValueAsString(user); redisTemplate.opsForValue().set(&quot;user:200&quot;,jsonStr); // 讲 JSON 字符串取出来后反序列化成Java对象 final String s = redisTemplate.opsForValue().get(&quot;user:200&quot;); User o = objectMapper.readValue(s,User.class); System.out.println(o); &#125;&#125; 最后小总结： RedisTemplate的两种序列化实践方案： 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，手动把对象序列化为JSON 读取Redis时，手动把读取到的JSON反序列化为对象 Hash结结构和其他结构操作Hash结构时需要注意: api 不是类似原生的Redis命令风格设计,而是按照Java的Map操作api进行设计的 而其他结构如: List ,Set 等则和原生Redis命令类似 12345678910@Testvoid testHash()&#123; HashOperations&lt;String, Object, Object&gt; hashOperations = redisTemplate.opsForHash(); hashOperations.put(&quot;user:400&quot;,&quot;name&quot;,&quot;北笙&quot;); hashOperations.put(&quot;user:400&quot;,&quot;age&quot;,&quot;18&quot;); Map map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;北笙&quot;); map.put(&quot;age&quot;,&quot;17&quot;); hashOperations.putAll(&quot;user:400&quot;,map);&#125; Redis缓存如果我们想通过Redis讲接口的数据进行缓存, Sring为我们提供了一个非常方便的方案Spring Cache: 注: 一下操作已经是默认配置好并连接好Redis环境 首先我们要在程序启动类中使用注解@EnableCaching开启缓存功能: 12345678@SpringBootApplication@EnableCaching //开启缓存public class BikeServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(BikeServerApplication.class, args); &#125;&#125; 在需要缓存的接口方法的类上打上注解@CacheConfig: 该注解主要属性有： 缓存名称：cacheNames，对应value或者cacheNames,命名空间, 即Redis的键名前缀 缓存管理器名称：cacheManager，对应cacheManager, 对应的一些配置信息 KeyGenerator的名称集合：keyGenerator，对应keyGenerator 要需要缓存的接口方法打上注解@Cacheable: 该注解的主要属性有: 缓存名称：value，可集体抽取为@CacheConfig的cacheNames，或者单独写，必填 键名：key，可以为空，可使用 SpEL 表达式编写，如果为空，则按照方法的所有参数进行组合 缓存条件：condition，可以为空，使用 SpEL 编写，返回 true 或 false，为 true 才进行缓存, 例如: unless = &quot;#result==null&quot; ,表示当接口放回null时, 不进行缓存 一个实现了缓存的接口的UserController类如下所示: 123456789101112@RestController@CacheConfig(cacheNames=&quot;bike_server:cache-list&quot;)public class UserController &#123; @RequestMapping(&quot;/getAllUser&quot;) @Cacheable(key = &quot;&#x27;user&#x27;&quot;) public Result getAllUser()&#123; // 代码逻辑... // 返回结果 &#125; // 其他接口方法...&#125; 其他缓存注解补充:上述所示的基本功能就已经实现了, 除此之外,我们可以根据不同情况选中如下的多种缓存方案: @CachePut与@Cacheable基本相同区别是: @CachePut：这个注释可以确保方法被执行，同时方法的返回值也被记录到缓存中。 @Cacheable：当重复使用相同参数调用方法时，方法本身不会被调用，而是直接从缓存中找到结果并返回。也就是说@Cacheable一次缓存，不再更新。@CachePut次次缓存，一直更新 @CacheEvict主要属性有： 键名：key，可以为空，可使用 SpEL 表达式编写，如果为空，则按照方法的所有参数进行组合 缓存条件：condition，可以为空，使用 SpEL 编写，返回 true 或 false，为 true 才进行缓存 缓存名称：value，可集体抽取为@CacheConfig的cacheNames，或者单独写，必填 是否清空所有缓存：allEntries，缺省为 false，指定为 true 是否在方法执行前就清空：beforeInvocation，缺省为 false，指定为 true 12345@CacheEvict(key = &quot;&#x27;findByBatchId_&#x27;+ #detailId + &#x27;_&#x27; + #batchId &quot;)public void updateByBatchId(Long detailId, String batchId) &#123; batchHistoryRepository.updateByBatchId(detailId,batchId);&#125; @Caching为自定义的组合缓存规则, 主要属性有： @Cacheable的组合：cacheable，默认{} @CachePut的组合：put，默认{} @CacheEvict的组合：evict，默认{} 123456789@Caching(evict = &#123; @CacheEvict(key = &quot;&#x27;findByDocInfo_&#x27;+ #docVO.bussNo + &#x27;_&#x27;+ #docVO.category&quot;), @CacheEvict(key = &quot;&#x27;selectByDocDetailId_&#x27;+ #docVO.id&quot;), @CacheEvict(key = &quot;&#x27;findByDocDetailId_&#x27;+ #docVO.id &quot;) &#125;) public void updateFileSort(DocVO docVO, DocDetailVO detailVO) &#123; impDocFileRepository.updateFileSort(detailVO.getId(),detailVO.getSort()); &#125; 序列化与缓存时间配置我们讲数据写入Redis默认是使用jdk的默认序列化方式, 在Redis中看到的就是一串乱码, 通常情况下,为了兼容性可读性,我们会把数据序列化成json格式再写入Redis. 为此我们需要编写一个配置类来修改一些配置, 特别需要注意: 我们在设置序列化方式时, 需要配置RedisTemplate的序列化方式, ==如果使用``@Cacheable注解来进行缓存,还需要对RedisCacheManager`的序列化方式同样也要修改,(本人亲自踩坑实践过)==, 配置类如下所示: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Configurationpublic class RedisConfig &#123; // 修改RedisTemplate的序列化方式,注意只修改这个并不能影响到@Cacheable注解的序列化方式 @Bean public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(factory); // 设置键（key）的序列化方式为stringSerializer StringRedisSerializer stringSerializer = new StringRedisSerializer(); redisTemplate.setKeySerializer(stringSerializer); redisTemplate.setHashKeySerializer(stringSerializer); // 设置值（value）的序列化方式为json序列化器 redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.afterPropertiesSet(); return redisTemplate; &#125; @Bean CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofMinutes(2)) // 其他命名空间的过期时间 /* 设置键的序列化方式... 一般键都是字符串,可以省略 */ .serializeKeysWith(RedisSerializationContext.SerializationPair .fromSerializer(new StringRedisSerializer()))// /* 设置值的序列化方式, 不设置就会使用jdk默认的序列化方式 */ .serializeValuesWith(RedisSerializationContext.SerializationPair .fromSerializer(new GenericJackson2JsonRedisSerializer())); Map&lt;String, RedisCacheConfiguration&gt; configurationMap = new HashMap&lt;&gt;(); //此处可以自定义缓存空间的缓存的过期时间，可以根据自己实际情况进行设置，也可以不设置，用统一过期时间 configurationMap.put(&quot;bike_server:cache-list&quot;, config.entryTtl(Duration.ofSeconds(200))); RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(factory); return RedisCacheManager.builder(redisCacheWriter) .initialCacheNames(configurationMap.keySet()) .withInitialCacheConfigurations(configurationMap) .cacheDefaults(config) .build(); &#125;&#125; 热部署与监控热部署在开发时期，经常修改内容并测试，大量手动重复【重启服务】操作。将spring-boot-devtools引入项目后，只要classpath路径下的文件发生了变化，项目就会自动重启，这极大地提高了项目的开发速度。 ==经过本人测试, 效果一般,勉强能接受, 相当于文件改动后若干秒后自动启动,也可能是本人电脑不好== 参考连接: SpringBoot实现热部署两种方式！ - 知乎 (zhihu.com) 添加依赖项: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 使用快捷键：Ctr l + Alt + Shift + / 调出 Registry 窗口,勾选 compiler.automake.allow.when.app.running 选项。 监控应用启动：我们需要对应用程序的基本信息、运行状况进行实时监控，以便了解程序是否健康。 硬盘使用状况，内存使用状况，CPU使用状况等等… 数据库链接状况，网络连接状况，线程使用状况等等… 于此同时：我们还需要收集应用程序的运行情况，对一些关键数据进行统计分析。 **解决方案: ** 使用第三方工具+自定义工具类+日志系统，封装所需要的内容，然后对外暴露。 SpringBoot 提供了相关组件 Actuator。 SpringBoot ActuatorActuator 是 Spring Boot自带的一个组件，包含许多附加功能，可在您将应用程序投入生产 时帮助您监视和管理应用程序。 包括：Bean加载情况、环境变量、日志信息、线程信息等等，使用非常简单。 使用步骤： 添加Actuator的起步依赖即可使用 增加配置可启用更多功能 pom.xml: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; application.yaml 12345678910management: endpoint: health: show-details: always #配置健康端点开启所有详情信息，默认是不显示 shutdown: enabled: true #开启远程关闭功能 endpoints: web: exposure: include: &#x27;*&#x27; #设置开放所有web相关的端点信息 随后输入: https://localhost:8081/actuator , 主机名,端口号自定义, + /actuator, 返回了一个JSON, JSON的信息包含了一些监控信息的url, 如下是一些说明: 路径 描述 /beans 描述应用程序上下文里全部的Bean，以及它们的关系 /env 获取全部环境属性 /env/{name} 根据名称获取特定的环境属性值 /health 报告应用程序的健康指标，这些值由HealthIndicator的实现类提供 /info 获取应用程序的定制信息，这些信息由info打头的属性提供 /mappings 描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系 /metrics 报告各种应用程序度量信息，比如内存用量和HTTP请求计数 /metrics/{name} 报告指定名称的应用程序度量值 /trace 提供基本的HTTP请求跟踪信息(时间戳、HTTP头等) SpringBoot AdminSpring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。 Spring Boot Admin 有两个角色，客户端(Client)和服务端(Server)。 应用程序作为Spring Boot Admin Client向Spring Boot Admin Server注册 , Spring Boot Admin Server 通过图形化界面方式展示Spring Boot Admin Client的监控信息 启动服务端:注意!! 服务端和客户端应该是两个项目, 为了避免端口冲突 新建项目: 导入依赖项: 12345&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt; 在启动类使用@EnableAdminServer 12345678@SpringBootApplication@EnableAdminServerpublic class SpringbootAdminServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootAdminServerApplication.class, args); &#125;&#125; 访问该项目可以看到一个可视化管理界面: 注册客户端:添加依赖: 12345&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt; 修改application.yaml配置: 1234567891011121314151617# 增加如下配置spring: boot: admin: client: url: http://localhost:9000 # 服务端地址#-- 以下是SpringBoot Actuator配置management: endpoint: health: show-details: always #配置健康端点开启所有详情信息，默认是不显示 shutdown: enabled: true #开启远程关闭功能 endpoints: web: exposure: include: &#x27;*&#x27; #设置开放所有web相关的端点信息 随后再次刷新访问服务端项目(本例中是: http://localhost:9000/) 项目打包发布SpringBoot项目有两种打包部署方式: 打包成jar, 内置Tomcat, 使用java 打包好的文件名.jar部署 打包成war, 部署到Tomcat上 推荐打包成jar 包 Jar方式打包 参考 玩转 Spring Boot 应用篇（项目打包、发布） (qq.com) 如果是在Idea下的项目, 并且是用Maven构建, 只需要点击Idea右边的Maven选项工具, 选择 生命周期 选项下的package , 打包可以检查一下项目结构: 打包好的结构 Jar项目包结构: SpringBoot项目打包后的项目结构（以jar包为例） - 飞蛇在水 - 博客园 (cnblogs.com) 1234根目录 |-- BOOT-INF |-- classes |-- lib |-- META-INF |-- org BOOT-INF 目录 classes 目录中存放项目代码对应的 .class文件 lib 目录中存放项目相关的依赖包，依赖包以 jar包 的方式存放（jar文件中存放jar文件，有个专门称呼叫 “FatJar” META-INF 存放清单文件，其内容描述当前可执行 jar 包的基本信息 其中，有两个主要的描述信息： Main-Class 描述 jar包 的入口文件（main 方法所在的类） Spring 框架固定是 org.springframework.boot.loader.JarLauncher 定义完此属性后，一定要有一个换行 Start-Class 描述自定义 main 方法的全称 org 存放了一些打包 SpringBoot 项目后的相关启动类 由于 SpringBoot 基于管理及安全性的考虑，打包使用 “项目代码与依赖包分离” 的方式（不同于以前将所有依赖包中的 .class 文件与项目的 .class 文件合并到一起的方式），因此打包后的 jar/war 包中依然包含了依赖的 jar 包，不符合 jar包 的规范，依赖的 jar包 无法通过默认的加载器进行加载 为了规避 jar文件规范，SpringBoot 使用自定义加载器去加载整个项目，于是入口就不再是编写项目时的 main 方法，而是使用 org.springframework.boot.loader.JarLauncher 类，在启动的时候创建自定义加载器去加载项目中的所有类 因此，打包后的 SpringBoot 项目，只有 org 文件夹中的类的类加载器是 AppClassLoader ，BOOT-INF 文件夹中的类和依赖包的加载器是 LaunchedURLClassLoader war包的结构跟jar包结构差不多，只是多了几个目录（如 “WEB-INF/” 等）。 Jar包启动 常见问题: 无法访问静态资源: 检查pom.xml文件, 如果有如下内容, 请把他删掉, 就可以了 123456789101112131415161718192021222324&lt;!-- 包含的资源 --&gt;&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.yml&lt;/include&gt; &lt;include&gt;**/*.yaml&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.txt&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.yml&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.tld&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 报错: There are test failures. 这是因为测试方法有报错的, 忽略测试环境即可, 不影响打包部署. 打包以后运行时,找不或者无法加载主类 修改maven的配置文件:pom.xml 部署启动 https://www.cnblogs.com/xiaoqi/p/6955288.html 打包成jar包后, 使用JDK的命令启动即可 1java -jar xxx.jar 该命令有一些命令参数,可以覆盖application.yaml配置文件的内容启动: --server.port=端口号 指定端口号启动 -Dspring.config.location=配置文件带路径文件名 例如: 12345# 通过80端口启动java -jar xxx.jar --server.port=80# 通过当前目录下的 aaa配置文件启动java -jar -Dspring.config.location=./aaa.yaml xxx.jar 后台启动: 用上述方式启动后断开连接, SringBoot应用就会停止运行, 这时我们可以用如下命令进行后台运行, 断开连接也不会停止, 只能通过查询端口号找到对应进程来结束进程停止应用 1nohup java -jar xxx.jar &gt;log.out 2&gt;&amp;1 &amp; 该命令在后台启动一个Java进程，并将其标准输出和错误流重定向到名为”log.out“的文件中。”nohup“命令确保即使用户注销或终端会话结束，进程仍将继续运行。命令末尾的“＆”符号也将进程发送到后台。 数字1和2分别代表标准输出和标准错误输出。使用“2&gt;&amp;1”将标准错误输出重定向到与标准输出相同的文件中。这意味着命令的所有输出都将被写入到”log.out”文件中。 war包需要修改maven的配置文件pom.xml: 需要配置spring-boot-maven-plugin插件,web启动器移除默认内嵌tomcat依赖 加入servlet-api避免编译失败 SpringBoot应用启动类继承SpringBootServletInitializer【表示配置web.xml】 1234567891011121314151617&lt;packaging&gt;war&lt;/packaging&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 支持https, 生成SSL证书 (100条消息) JDK生成HTTPS证书_ JDK 能自带生成SSL功能. 首先, 进入JDK安装目录下的bin目录下 (推荐使用管理员权限, windos用管理员权限打开cmd进入), 输入如下命令: 1keytool -genkey -alias tomcathttps -keyalg RSA -keysize 2048 -keystore bank.p -validity 365 • -genkey 表示要创建一个新的密钥。 • -alias 表示 keystore 的别名。 • -keyalg 表示使用的加密算法是 RSA， 一种非对称加密算法． • -keysize 表示密钥的长度． • -keystore 表示生成的密钥存放位直。 • -validity 表示密钥的有效时间，单位为天 讲该证书文件拷贝到SpringBoot的根目录下(推荐这样, 也可以自定义,默认会找 项目名\\证书文件名的路径), 本案例中放到了如下位置: 随后在application.yaml文件添加配置 123456server: port: 8081 ssl: key-store: src\\main\\resources\\bank.p # 证书的带路径文件名 key-alias: tomcathttps key-store-password: 123456 # 刚才我们通过jdk输入命令生成时的自定义的口令密码 随后启动项目, 就是 Https协议了 Swagger(未测,api文档生成器) 了解Swagger的概念及作用 了解前后端分离 在springboot中集成swagger Swagger简介解决 首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险； 早些年：指定word计划文档； 前后端分离： 前端测试后端接口：postman 后端提供接口，需要实时更新最新的消息及改动 Swagger 号称世界上最流行的API框架 Restful Api 文档在线自动生成器 =&gt; API 文档 与API 定义同步更新 直接运行，在线测试API 支持多种语言 （如：Java，PHP等） 官网：https://swagger.io/ SpringBoot集成SwaggerSpringBoot集成Swagger =&gt; springfox，两个jar包 Springfox-swagger2 springfox-swagger-ui 使用Swagger 要求：jdk 1.8 + 否则swagger2无法运行 步骤： 新建一个SpringBoot-web项目 添加Maven依赖（注意：2.9.2版本之前，之后的不行） 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 编写HelloController，测试确保运行成功！ 要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger 1234@Configuration //配置类@EnableSwagger2// 开启Swagger2的自动配置public class SwaggerConfig &#123; &#125; 访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面； 配置Swagger Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。 1234@Bean //配置docket以配置Swagger具体参数public Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2);&#125; 可以通过apiInfo()属性配置文档信息 1234567891011121314//配置文档信息private ApiInfo apiInfo() &#123; Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;); return new ApiInfo( &quot;Swagger学习&quot;, // 标题 &quot;学习演示如何配置Swagger&quot;, // 描述 &quot;v1.0&quot;, // 版本 &quot;http://terms.service.url/组织链接&quot;, // 组织链接 contact, // 联系人信息 &quot;Apach 2.0 许可&quot;, // 许可 &quot;许可链接&quot;, // 许可连接 new ArrayList&lt;&gt;()// 扩展 );&#125; Docket 实例关联上 apiInfo() 1234@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());&#125; 重启项目，访问测试 http://localhost:8080/swagger-ui.html 看下效果； 配置扫描接口 构建Docket时通过select()方法配置怎么扫描接口。 12345678@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(&quot;nuc.ss.swagger.controller&quot;)) .build();&#125; 重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类 除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式： 1234567basePackage(final String basePackage) // 根据包路径扫描接口any() // 扫描所有，项目中的所有接口都会被扫描到none() // 不扫描接口// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation) 除此之外，我们还可以配置接口扫描过滤： 12345678910@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;)) // 配置如何通过path过滤,即这里只扫描请求以/ss开头的接口 .paths(PathSelectors.ant(&quot;/ss/**&quot;)) .build();&#125; 这里的可选值还有 1234any() // 任何请求都扫描none() // 任何请求都不扫描regex(final String pathRegex) // 通过正则表达式控制ant(final String antPattern) // 通过ant()控制 配置Swagger开关 通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了 12345678910@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问 .select() .apis(RequestHandlerSelectors.basePackage(&quot;nuc.ss.swagger.controller&quot;)) .paths(PathSelectors.ant(&quot;/ss/**&quot;)) .build();&#125; 如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？ 12345678910111213141516@Beanpublic Docket docket(Environment environment) &#123; // 设置要显示swagger的环境 Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;); // 判断当前是否处于该环境 // 通过 enable() 接收此参数判断是否要显示 boolean b = environment.acceptsProfiles(of); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(b) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;)) .paths(PathSelectors.ant(&quot;/ss/**&quot;)) .build();&#125; 可以在项目中增加配置文件 dev测试环境 1server.port=8081 项目运行结果 pro测试环境 1server.port=8082 项目运行结果 配置API分组 如果没有配置分组，默认是default。通过groupName()方法即可配置分组： 123456@Beanpublic Docket docket(Environment environment) &#123; return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()) .groupName(&quot;狂神&quot;) // 配置分组 // 省略配置....&#125; 重启项目查看分组 如何配置多个分组？配置多个分组只需要配置多个docket即可： 123456789101112@Beanpublic Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);&#125;@Beanpublic Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);&#125;@Beanpublic Docket docket3()&#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);&#125; 重启项目查看即可 实体配置 新建一个实体类 123456789101112131415161718192021222324//@Api(&quot;注释&quot;)@ApiModel(&quot;用户实体&quot;)public class User &#123; @ApiModelProperty(&quot;用户名&quot;) private String username; @ApiModelProperty(&quot;密码&quot;) private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 只要这个实体在请求接口的返回值上（即使是泛型），都能映射到实体项中： 123456789101112131415@RestControllerpublic class HelloController &#123; // /error默认错误请求 @GetMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125; //只要我们的接口中，返回值中存在实体类，他就会被扫描到Swagger中 @PostMapping(&quot;/user&quot;) public User user() &#123; return new User(); &#125;&#125; 重启查看测试 注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。 @ApiModel为类添加注释 @ApiModelProperty为类属性添加注释 总结： 我们可以通过Swagger给一些比较难理解的接口或者属性，增加注释信息 接口文档实时更新 可以在线测试 Swagger是一个优秀的工具，几乎所有大公司都有使用它 【注意点】：在正式发布的时候，关闭Swagger！！！ 出于安全考虑 而且节省内存 常用注解Swagger的所有注解定义在io.swagger.annotations包下 下面列一些经常用到的，未列举出来的可以另行查阅说明： Swagger注解 简单说明 @Api(tags = “xxx模块说明”) 作用在模块类上 @ApiOperation(“xxx接口说明”) 作用在接口方法上 @ApiModel(“xxxPOJO说明”) 作用在模型类上：如VO、BO @ApiModelProperty(value = “xxx属性说明”,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(“xxx参数说明”) 作用在参数、方法和字段上，类似@ApiModelProperty 我们也可以给请求的接口配置一些注释 在HelloController控制类中的接口添加api接口注释 123456789101112131415@RestControllerpublic class HelloController &#123; ...... @ApiOperation(&quot;Hello控制接口&quot;) @GetMapping(&quot;/hello&quot;) public String hello2(@ApiParam(&quot;用户名&quot;) String username) &#123; return &quot;hello&quot; + username; &#125; @ApiOperation(&quot;get测试&quot;) @GetMapping(&quot;/get&quot;) public User hello2(@ApiParam(&quot;用户&quot;) User user) &#123; return user; &#125;&#125; 进行try it out测试 测试结果 总结： 这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！ 相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。 Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。 拓展：其他皮肤我们可以导入不同的包实现不同的皮肤定义： 1、默认的 访问 http://localhost:8080/swagger-ui.html 12345&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 2、bootstrap-ui 访问 http://localhost:8080/doc.html 123456&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt; 3、Layui-ui 访问 http://localhost:8080/docs.html 123456&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt; &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt;&lt;/dependency&gt; 我这个测试没成功(Layui-ui) 4、mg-ui 访问 http://localhost:8080/document.html 123456&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;&lt;dependency&gt; &lt;groupId&gt;com.zyplayer&lt;/groupId&gt; &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt;&lt;/dependency&gt; SpringSecurity(未测,安全框架)1、在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。 2、市面上存在比较有名的：Shiro，Spring Security ！ 简介:Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。 1、Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。 2、Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求 3、从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。 4、怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。 5、Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。 用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。 用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。 10、对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。 在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。 在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。 测试环境搭建新建一个初始的springboot项目web模块，thymeleaf模块 , 导入静态资源 静态资源下载: 链接：https://pan.baidu.com/s/1URaFmN6rt2AzDOwVogWBNQ 提取码：bruc 编写个控制器测试一下 123456789101112131415161718192021222324252627282930package nuc.ss.controller;@Controllerpublic class RouterController &#123; @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;) public String index() &#123; return &quot;index&quot;; &#125; @RequestMapping(&quot;/toLogin&quot;) public String toLogin() &#123; return &quot;views/login&quot;; &#125; @RequestMapping(&quot;/level1/&#123;id&#125;&quot;) public String level1(@PathVariable(&quot;id&quot;) int id) &#123; return &quot;views/level1/&quot; + id; &#125; @RequestMapping(&quot;/level2/&#123;id&#125;&quot;) public String level2(@PathVariable(&quot;id&quot;) int id) &#123; return &quot;views/level2/&quot; + id; &#125; @RequestMapping(&quot;/level3/&#123;id&#125;&quot;) public String level3(@PathVariable(&quot;id&quot;) int id) &#123; return &quot;views/level3/&quot; + id; &#125;&#125; 测试实验环境是否OK！ 首页和登陆页 详情页 SpringSecurity使用Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！ 记住几个类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。 “认证”（Authentication） 身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。 身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。 “授权” （Authorization） 授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。 这个概念是通用的，而不是只在Spring Security 中存在。 认证和授权目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能 引入 Spring Security 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 编写 Spring Security 配置类 参考官网：https://spring.io/projects/spring-security 查看我们自己项目中的版本，找到对应的帮助文档：https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5 servlet-applications 8.16.4 1234567891011@EnableWebSecuritypublic class Config extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .apply(customDsl()) .flag(true) .and() ...; &#125;&#125; 编写基础配置类 1234567891011121314package nuc.ss.config;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@EnableWebSecurity// 开启WebSecurity模式public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; super.configure(http); &#125;&#125; 定制请求的授权规则 12345678910111213//链式编程@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; // 首页所有人都可以访问，功能也只有对应有权限的人才能访问到 // 请求授权的规则 http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);&#125; 测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！ 在configure()方法中加入以下配置，开启自动配置的登录功能！ 1234// 开启自动配置的登录功能// /login 请求来到登录页// /login?error 重定向到这里表示登录失败http.formLogin(); 测试一下：发现，没有权限的时候，会跳转到登录的页面！ 查看刚才登录页的注释信息；我们可以定义认证规则，重写configure的另一个方法 1234567891011121314// 认证，springboot 2.1.x 可以直接使用// 密码编码： PasswordEncoder@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //这些数据正常应该中数据库中读 auth.inMemoryAuthentication() .withUser(&quot;kuangshen&quot;).password(&quot;123456&quot;).roles(&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;guest&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;);&#125; 测试，我们可以使用这些账号登录进行测试！发现会报错! 原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码 1234567891011121314// 认证，springboot 2.1.x 可以直接使用// 密码编码： PasswordEncoder// 在spring Secutiry 5.0+ 新增了很多加密方法@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //这些数据正常应该中数据库中读 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;);&#125; 权限控制和注销 开启自动配置的注销的功能 12345678//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //.... //开启自动配置的注销的功能 // /logout 注销请求 http.logout();&#125; 我们在前端，增加一个注销的按钮，index.html 导航栏中 1234&lt;!--注销--&gt;&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt; &lt;i class=&quot;sign-out icon&quot;&gt;&lt;/i&gt; 注销&lt;/a&gt; 我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？ 12// 注销成功来到首页http.logout().logoutSuccessUrl(&quot;/&quot;); 测试，注销完毕后，发现跳转到首页OK 我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？ 我们需要结合thymeleaf中的一些功能 sec：authorize=&quot;isAuthenticated()&quot;:是否认证登录！来显示不同的页面 添加一下Maven依赖: 123456&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 修改我们的前端页面,导入命名空间 12&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;&gt; 修改导航栏，增加认证判断 12345678910111213141516171819202122232425&lt;!--登录注销--&gt;&lt;div class=&quot;right menu&quot;&gt; &lt;!--如果未登录--&gt; &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt; &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt; &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录 &lt;/a&gt; &lt;/div&gt; &lt;!--如果已登录--&gt; &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt; &lt;a class=&quot;item&quot;&gt; &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 用户名：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt; 角色：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt; &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt; &lt;i class=&quot;sign-out icon&quot;&gt;&lt;/i&gt; 注销 &lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面； 但是点击注销产生问题 , 版本问题 整合包4（springsecurity4） , 报404 整合包5（springsecurity5）（不算问题，需要点击确定，才能回到首页） 解决问题： 它默认防止csrf跨站请求伪造，因为会产生安全问题 将请求改为post表单提交 在spring security中关闭csrf功能http.csrf().disable(); 再次点击注销按钮之后（直接退出到首页） 我们继续将下面的角色功能块认证完成！ 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--菜单根据用户的角色动态的实现--&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;&gt; &lt;div class=&quot;ui raised segment&quot;&gt; &lt;div class=&quot;ui&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;&gt; &lt;div class=&quot;ui raised segment&quot;&gt; &lt;div class=&quot;ui&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;&gt; &lt;div class=&quot;ui raised segment&quot;&gt; &lt;div class=&quot;ui&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 再次测试一下 记住我现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单 开启记住我功能 1234567//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;//。。。。。。。。。。。 //开启记住我功能: cookie,默认保存两周 http.rememberMe();&#125; 我们再次启动项目测试一下 ,发现登录页多了一个记住我功能 , 我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！ 思考：如何实现的呢？其实非常简单 我们可以查看浏览器的cookie, 我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！ 定制登陆页面现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？ 在刚才的登录页配置后面指定 loginpage 123456789protected void configure(HttpSecurity http) throws Exception &#123; //...... // 没有权限默认会到登录页面,需要开启登录的页面 // /login页面 http.formLogin().loginPage(&quot;/toLogin&quot;); //......&#125; 然后前端也需要指向我们自己定义的 login请求 12345&lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt; &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/toLogin&#125;&quot;&gt; &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录 &lt;/a&gt;&lt;/div&gt; 我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post: 在 loginPage()源码中的注释上有写明 这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！ 12345678910111213protected void configure(HttpSecurity http) throws Exception &#123; //...... // 没有权限默认会到登录页面,需要开启登录的页面 // /login页面 http.formLogin() .usernameParameter(&quot;username&quot;) .passwordParameter(&quot;password&quot;) .loginPage(&quot;/toLogin&quot;) .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求 //......&#125; 在登录页增加记住我的多选框 1&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我 后端验证处理！ 12345protected void configure(HttpSecurity http) throws Exception &#123; //...... //开启记住我功能: cookie,默认保存两周,自定义接收前端的参数 http.rememberMe().rememberMeParameter(&quot;remember&quot;);&#125; 完整配置代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nuc.ss.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;// AOP:拦截器@EnableWebSecurity // 开启WebSecurity模式public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; //链式编程 //授权 @Override protected void configure(HttpSecurity http) throws Exception &#123; // 首页所有人都可以访问，功能也只有对应有权限的人才能访问到 // 请求授权的规则 http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;); // 没有权限默认会到登录页面,需要开启登录的页面 // /login页面 http.formLogin() .usernameParameter(&quot;username&quot;) .passwordParameter(&quot;password&quot;) .loginPage(&quot;/toLogin&quot;) .loginProcessingUrl(&quot;/login&quot;); //注销,开启了注销功能,跳到首页 http.logout().logoutSuccessUrl(&quot;/&quot;); // 防止网站工具：get，post http.csrf().disable();//关闭csrf功能，登录失败肯定存在的原因 //开启记住我功能: cookie,默认保存两周,自定义接收前端的参数 http.rememberMe().rememberMeParameter(&quot;remember&quot;); &#125; // 认证，springboot 2.1.x 可以直接使用 // 密码编码： PasswordEncoder // 在spring Secutiry 5.0+ 新增了很多加密方法 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //这些数据正常应该中数据库中读 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;); &#125;&#125; 分布式(待学)分布式理论什么是分布式系统？在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”； 分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。 分布式系统（distributed system）是建立在网络之上的软件系统。 首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。 Dubbo文档随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。 在Dubbo的官网文档有这样一张图 单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。 缺点： 1、性能扩展比较难 2、协同开发问题 3、不利于升级维护 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。 缺点：公用模块无法重复利用，开发性的浪费 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。 RPCRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。 也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数； 推荐阅读文章：https://www.jianshu.com/p/2accc2840a1b RPC基本原理 RPC两个核心模块：通讯，序列化。 DubboApache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 dubbo官网 http://dubbo.apache.org/zh-cn/index.html 1.了解Dubbo的特性 2.查看官方文档 dubbo基本概念 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo环境搭建点进dubbo官方文档，推荐我们使用Zookeeper 注册中心 什么是zookeeper呢？可以查看官方文档 Window下安装zookeeper 下载zookeeper ：地址， 我们下载3.6.1， 最新版！解压zookeeper 下载带bin的 运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件； 可能遇到问题：闪退 ! 解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。 修改zoo.cfg配置文件 将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。 注意几个重要位置： dataDir=./ 临时数据存储的目录（可写相对路径） clientPort=2181 zookeeper的端口号 修改完成后再次启动zookeeper 使用zkCli.cmd测试 ls /：列出zookeeper根下保存的所有节点 报错别着急，多试几次就好了，我试了三次o(╥﹏╥)o，看报错信息 create –e /kuangshen 123：创建一个kuangshen节点，值为123 get /kuangshen：获取/kuangshen节点的值 我们再来查看一下节点：ls / window下安装dubbo-admin dubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。 我们这里来安装一下： 1、下载dubbo-admin 地址 ：https://github.com/apache/dubbo-admin/tree/master 2、解压进入目录 修改 dubbo-admin\\src\\main\\resources \\application.properties 指定zookeeper地址 12345678910server.port=7001spring.velocity.cache=falsespring.velocity.charset=UTF-8spring.velocity.layout-url=/templates/default.vmspring.messages.fallback-to-system-locale=falsespring.messages.basename=i18n/messagespring.root.password=rootspring.guest.password=guestdubbo.registry.address=zookeeper://127.0.0.1:2181 3、在项目目录下打包dubbo-admin 1mvn clean package -Dmaven.test.skip=true 第一次打包的过程有点慢，需要耐心等待！直到成功！ 4、执行 dubbo-admin\\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar 1java -jar dubbo-admin-0.0.1-SNAPSHOT.jar 【注意：zookeeper的服务一定要打开！】 执行完毕，我们去访问一下 http://localhost:7001/ ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root； 登录成功后，查看界面 安装完成！ 总结： zookeeper :注册中心 dubbo-admin:是一 个监控管理后台-查看我们注册了哪些服务，哪些服务被消费了（可以不用） Dubbo: jar包 SpringBoot + Dubbo + zookeeper框架搭建1. 启动zookeeper ！ 2. IDEA创建一个空项目； 3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可 4.项目创建完毕，我们写一个服务，比如卖票的服务； 编写接口 12345package nuc.ss.service;public interface TicketService &#123; public String getTicket();&#125; 编写实现类 12345678package nuc.ss.service;public class TicketServiceImpl implements TicketService &#123; @Override public String getTicket() &#123; return &quot;《狂神说Java》&quot;; &#125;&#125; 5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可 6.项目创建完毕，我们写一个服务，比如用户的服务； 编写service 12345package nuc.ss.service;public interface UserService &#123; //我们需要去拿去注册中心的服务&#125; 需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？ 服务提供者1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包 我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包 123456&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt; zookeeper的包我们去maven仓库下载，zkclient； 123456&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; 【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖； 1234567891011121314151617181920212223&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 2、在springboot配置文件中配置dubbo相关属性！ 12345678server.port=8001#当前应用名字dubbo.application.name=provider-server#注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181#扫描指定包下服务dubbo.scan.base-packages=nuc.ss.service 3、在service的实现类中配置服务注解，发布服务！注意导包问题 12345678910111213package nuc.ss.service;import org.apache.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;@Service //可以被扫描到，在项目一启动就自动注册到注册中心@Component //使用Dubbo后尽量不要用Service注解public class TicketServiceImpl implements TicketService &#123; @Override public String getTicket() &#123; return &quot;《狂神说Java》&quot;; &#125;&#125; 逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！ 4、运行测试 服务消费者1、导入依赖，和之前的依赖一样； 12345678910111213141516171819202122232425262728293031323334353637&lt;!--dubbo--&gt;&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--zookeeper--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 2、配置参数 123456server.port=8002#当前应用名字dubbo.application.name=consumer-server#注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181 3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同； 4. 完善消费者的服务类 123456789101112131415161718package nuc.ss.service;import org.apache.dubbo.config.annotation.Reference;import org.springframework.stereotype.Service;@Service //注入到容器中public class UserService &#123; // 想拿到provider-server提供的票，要去注册中心拿到服务 @Reference //引用，Pom坐标，可以定义路径相同的接口名 TicketService ticketService; public void bugTicket()&#123; String ticket = ticketService.getTicket(); System.out.println(&quot;在注册中心买到&quot;+ticket); &#125;&#125; 5. 测试类编写； 1234567891011121314@SpringBootTestpublic class ConsumerServerApplicationTests &#123; @Autowired UserService userService; @Test public void contextLoads() &#123; userService.bugTicket(); &#125;&#125; 启动测试1. 开启zookeeper 2. 打开dubbo-admin实现监控【可以不用做】 3. 开启服务者 4. 消费者消费测试，结果： 监控中心 ： ok , 这就是SpingBoot + dubbo + zookeeper实现分布式开发的应用，其实就是一个服务拆分的思想；","categories":[{"name":"Java系列","slug":"Java系列","permalink":"https://lqy679.github.io/categories/Java%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"JavaSE进阶","slug":"javaSE进阶","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T08:03:37.555Z","comments":true,"path":"2020/01/01/javaSE进阶/","link":"","permalink":"https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/","excerpt":"文件类与IO流File类构造方法(并不真正创建文件):File(Stirng filename): 其中的参数是文件名,默认放在当前程序同一目录File(Stirng 路径, String filename):Fiel(String dir ,Stirng filemane): 其dir指目录注意: 注意区别相对路径(相对于src)和绝对路径(磁盘目录)","text":"文件类与IO流File类构造方法(并不真正创建文件):File(Stirng filename): 其中的参数是文件名,默认放在当前程序同一目录File(Stirng 路径, String filename):Fiel(String dir ,Stirng filemane): 其dir指目录注意: 注意区别相对路径(相对于src)和绝对路径(磁盘目录) 常用方法:1.boolean createNewFile() 创建一个文件 此方法返回true，如果指定的文件不存在，并已成功创建。如果该文件存在，该方法返回false。 2.long length() 测量文件长度(单位是字节)3.boolean isFile() 判断文件是否是文件而不是目录4.boolean exists() 判断文件是否存在5.String getParent() 获取文件的父目录6.String getAbsolutePath() 获取文件的绝对路径7.boolean delete() 删除文件 创建文件: 1234567891011121314151617181920212223package 文件类与IO流.creat_file;import java.io.File;import java.io.IOException;public class Create_file &#123; public static void main(String args[]) throws IOException&#123; File file = new File(&quot;src\\\\&quot;, &quot;aa.txt&quot;); //只创建文件对象不能创建文件,需要调用方法 //文件构造方法,第一个参数是路径(绝对路径或者相对路径如相对路径),第二个参数是文件名(需加后缀) /* 运行可执行文件 * Runtime 类 * 用此类的静态方法创建一个对象 * 调用 exec (String 命令或者可执行文件路径) * */ File note = new File(&quot;E:\\\\1.txt&quot;); System.out.println(&quot;文件是否创建成功&quot;+file.createNewFile()); System.out.println(&quot;文件是否删除成功&quot;+note.delete()); System.out.println(note.getAbsolutePath()); System.out.println(note.getParent()); &#125;&#125; InputStream,OutputStream,字节流IO流字节流主要是用于处理文件(如图片,视频音乐等),因为这些文件都采用二进制来存储 文件字节输入输出流1.输入输出都是相对与程序来说的:即输入流是从外部获取数据到程序,输出流是程序输出数据到外部2.输入输出流在使用后都要关闭,先用的后关,后用的先关 构造方法将文件字节流绑定到文件 1.FileInputStream(String 文件名):2.FileInputStream(File 文件对象):1.FileOutputStream(File 文件对象): 将文件字节输出流绑定到文件2.FileOutputStream(String 文件名):3.FileOutputStream(File 文件对象, boolean append): 第二个参数设置是否追加,默认是重写4.FileOutputStream(File 文件对象, boolean append): 常用方法:输入流方法:1.int read() 从源中每次读取一个字节的数据,并返回字节(0~255), 读到文件末尾返回-12.int read(byte[] b) 从源中读取b.length个字符到b字节数组中,返回实际读取的字节数 ,读到文件末尾返回-13.int read(byte[] int off, int len) 从源中读取 len个字节到字节数组b中,并返回实际读取的字节数, 参数off指定从数组的某个位置开始存放读取的数组4.void close() 关闭流,如果不关闭,有可能绑定的资源不允许另一个程序操作绑定的资源 输出流方法:1.void write(int n) 每次向绑定的资源中写入一个字节n2.void write(byte b[]) 每次向绑定的资源中写入一个字节数组3.void write(byte[] b , int, off ,int len) 每次向从字节数组中的off位置开始向绑定资源中写入len个字节4.void close()总结: 由于字节流是以字节为单位进行数据处理,但汉字是以多个字节储存的,所以用字节流处理中文就会出现乱码现象,所以在处理汉字时用字符流进行处理 InputStreamReader,InputStreamWriter,字符IO流字符流主要用于处理汉字时出现乱码问题的 1.构造方法: 12InputStreamReader(InputStream in, String charsetName) ; //创建一个指定字符集的输入流,常用来解决中文乱码问题OutputStreamWriter(OutputStream out, String charsetName) //创建一个指定字符集的输出流 文件字符输入输出流构造方法字符输入流:FileReader(Stirng 文件名); FileReader(File 文件对象); 字符输出流:FileWriter(String 文件名); FileWriter(File 文件对象);FielWriter(Sring 文件名, boolean append): FileWriter(File 文件名, boolean append);常用的方法和字节流基本一致,注意!!! 但对于Writer 的write() 方法将数据首先写入缓冲区,每当缓冲区溢出时内容才会被自动写入绑定资源,如果关闭流缓冲区内容也会被立刻写入,==也可以调用flush()方法立刻写入==总结: 字节流主要用于图片，视频等二进制的文件,字符流用于文本文件 读写文件: 123456789101112131415161718192021222324252627package 串实验;import java.io.File;import java.io.FileReader;import java.io.IOException;public class Test_String &#123; public static void main(String[] args) throws IOException &#123; // 绑定文件对象,注意: 此文件已经存在 File file = new File(&quot;src/串实验/readme.txt&quot;); // 获取文件字符输入流 FileReader in = new FileReader(file); char[] chars = new char[1024]; // 将读取的内容放入字符数组 in.read(chars); in.close(); String str = new String(chars); System.out.println(&quot;读取到的文件内容为:&quot;+str); // 绑定文件输出流 FileWriter out = new FileWriter(file,true); // 设置为追加模式的文件输出流 out.write(&quot;\\n这是追加内容呀!&quot;); // 以追加的方式想文件输出内容 out.flush(); // 立即刷新缓存区, 刷新的话输出流不关闭之前是不会 &#125;&#125; 缓冲流ButteredReader和ButteredWriter用于增强流的读写能力 构造方法ButteredReader(Reader in);ButteredWriter(Writer out); 常用方法:1.String readLine(): 一次读取一行数据2.void writeLine(): 一次写入一行数据 序号化和反序列化序列化:将对象转换成字节流反序列化: 将字节流转换成对象构造方法:ObjectInputStream(InoutStream in): 创建一个输入对象的字节流,参数 in 是要绑定的字节流或者是字节流的子类 **ObjectOutputStream(OutputSream out):**创建一个输出对象的字节流,其中参数out是要绑定的字节流或者是其子类 常用方法:1.void writeObject(Object object): 将对象写入对象所绑定的输出流中2.Object readObject() 将输入流中的对象读取出来并且返回 Serializble接口 (可序列化接口)在使用writeObject(Object object)方法将对象序列化时,要序列化的对象必须实现Serializble接口将对象设置成可序列化状态, 12345678910111213public class Test&#123; public static void mian()&#123; //创建文件输出流,为写入对象做准备 FileOutputStream file_out =new FileOutputStream(new File(E:\\\\1.txt)); //创建对象流将文件流file_out绑定 ObjectOutputStream o_out = new ObjectOutputStream(file_out); //将猫对象序列化写入文件 o_out.writeObject(new Cat()); &#125;&#125; //猫对象,注意要实现接口Serializbleclass Cat implements Serializble&#123;&#125; IO之Propertest类与配置文件读取properties文件介绍 在开发项目时,项目通常会依赖一些中间件,这些中间件的配置不是硬编码写在代码中,而是使用配置文件方式存储常用配置文件有以下几种: properties文件: SpringBoot应用都有应用此配置文件 xml文件: 如MyBattis的配置文件 JSON文件 properties文件通常采用键值对存储,key=value 12server.port=8081spring.application.name=order-api Properties类的使用 Properties类的介绍Properties类表示一组持久存储的属性,属性由属性名和属性值组成.Properties可以保存到流(以流的方式写入)或者从流中加载,属性列表中每个键及其对应的值都是字符串Properties可以当成Map集合使用,但是一般不会这样做 常用方法:1234properties.getProperty(String key) //根据键值获取属性properties.load(InputStream inStream) //根据输入流(一般是properties文件的输入流)加载文件内容properties.propertyNames() //获取 key的集合properties.store(OutputStream out, String comments) //向文件中写入内容 Properties文件读取当Properties文件放在项目下时,properties文件会随着java程序在编译生成字节码时一起打包在同一个目录下,故可以通过类加载器来获取文件流进而读取文件内容 1234567891011//从类加载器加载加载文件,由于在生成字节码时Properties文件会随着java文件编译被一起打包到同一目录下,故可以通过类加载器读取到文件 InputStream in =PropertiesDemo01.class.getClassLoader().getResourceAsStream(&quot;application.properties&quot;); //创建properties对象通过加载properties文件的输入流来加载文件内容 Properties properties = new Properties(); //Properties对象加载的文件流 properties.load(in); //取出所有的属性名(key)集合 Set&lt;String&gt; propertySet = properties.stringPropertyNames(); for(String key:propertySet)&#123; //遍历集合中的key System.out.println(key+&quot;:&quot;+properties.getProperty(key)); &#125; 如文件中含有中文,出现乱码问题则改为字符流 1InputStreamReader in = new InputStreamReader(PropertiesDemo01.class.getClassLoader().getResourceAsStream(&quot;application.properties&quot;),&quot;utf8&quot;); Properties文件写入12345Properties properties = new Properties();properties.setProperty(&quot;user&quot;,&quot;root&quot;);properties.setProperty(&quot;password&quot;,&quot;123456&quot;);FileOutputStream out = new FileOutputStream(new File(&quot;src/test.properties&quot;));properties.store(out,&quot;注释&quot;); 集合 概念: 对象的容器,定义了对多个对象进行操作的常用方法,可实现数组的功能 与数组的区别: (1) 数组长度固定,集合长度不固定 (2) 数组可以存储基本数据类型和引用类型,集合只能存储引用类型(但是基本数据类型可以装箱转换) Collection集合体系(并非实际结构,只表示大致关系) 常用方法 boolean add(Object obj) 在集合尾部添加一个对象 boolean addAll(Collection c) 将一个集合的所有对象添加到此集合中 void clear() 清空此集合中所有对象 boolean remove(Object o) 移除此集合中的o对象 Object[] toArray() 将集合中的所有元素以数组形式返回 boolean isEmpty() 判断此集合是否为空 boolean contains(Object o) 判断此集合中是否包含o对象 boolean equals(Object o) 判断此集合是否与o对象具有相同的引用 int size() 返回此集合中元素个数 Iterator iterator()方法: 获取当前集合的迭代器 迭代器的使用以及方法: boolean hasNext()方法:当迭代器的下一位置不为null时,返回true,否则返回false (即判断下一次集合中是否还有元素) Object next()方法: 获得迭代器位置下移,返回下移后的元素 void remove()方法:删除迭代器所指向的元素(注意:在迭代过程中只能用此方法删除元素) List接口**特点:**有序,有下标,元素可重复 常用方法(除了Collection原有的方法外) void add(int index,Object obj): 在列表的指定位置添加元素(第一个元素的下标为0) void addAll(int index, Collection c) :从指定位置开始将c中所有元素添加到列表中 Object get(int index):放回指定下表的元素 int indexOf(Object o):放回指定元素的索引,不存在返回-1 Objcet remove(int index):移除指定下标的元素 void removeRange(int fromIndex,int toIndex):含头不含尾的移除指定下标到指定下标的元素 Object set(int index,Object o):将指定索引位置的对象替换为o Object[] toArray():按照列表中元素的顺序返回包含列表所有元素的数组 ListIterator ListIterator():返回列表的列表迭代器 ListIterator常用方法(相比较于Iterator新增):(1)boolean hasPrevious():逆向遍历,如果前一个有元素则返回true,否则返回false(2)Object previous():迭代器指针前移,返回前移后的元素(3)int NextIndex():返回对next()调用后返回元素的索引(4)int PreviousIndex():返回对previous()调用后的返回元素的索引(5)void set(Object o):将迭代器指针所指向的位置的元素替换为o(6)void add(Object) ArrayList数组列表实现类 实现结构:使用数组结构实现 特点: 查询快,修改慢 LinkedList链表实现类 实现结构:双向链表实现 特点:查询慢,修改快 Vector向量实现类(不推荐用) 特点: 线程安全,但是运行效率低,有更好的代替 Set接口特点:无序,无下标,不可重复元素 常用方法(与Collection基本一致) **int HashCode()*获取哈希码值关于哈希码: 如果两个对象具有相同的引用(即equals的返回值为true),则哈希码一定相同,但哈希码相同,对象不一定具有相同的引用 * boolean equals(Object o),判断是否是同一个对象(如果该类没有重写此方法的的话) 迭代器(没有ListIterator迭代器)的使用以及方法: boolean hasNext()方法:当迭代器的下一位置不为null时,返回true,否则返回false (即判断下一次集合中是否还有元素) Object next()方法: 获得迭代器位置下移,返回下移后的元素 void remove()方法:删除迭代器所指向的元素(注意:在迭代过程中只能用此方法删除元素) HashSet哈希集合实现类 实现结构:采用数组+链表+(JDK1.8之后加入红黑树) 特点:元素唯一,根据哈希码HashCode和equals()方法和equals()方法来去重 TreeSet树集合实现类 实现结构:红黑树 特点:(1) 基于排序来去重按顺序存储(2) 实现了SortedSet接口,对集合元素自动排序(3) 元素对象的类型必须实现Comparable接口,指定排序规则(4) 通过CompareTo()方法来确定是否为重复元素 要求:元素必须是可以比较的,即实现Comparable接口或使用TreeSet(Comparator com)构造器来创建集合为集合添加比较器ps:(1)Compareable接口:只有一个int ComparaTo(E o)方法,调用对象和参数比较,一般来说,调用者大于参数则返回正数,小于则返回负数,等于返回0(2)Comparator接口: 只有一个int compara(E o1,E o2)方法 1234567public class Student implements Comparable&lt;Student&gt;&#123; //实现接口的所有抽象方法 public int comparaTo(Student o)&#123; //比较规则 reutrn 整数; &#125;&#125; 12345678//创建自定义比较器的树集合TreeSet&lt;Student&gt; treeSet = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;()&#123; //实现接口的所有抽象方法 public int compara(Student o1,Student o2)&#123; //自定义的比较规则 return 整数; &#125;&#125;); Map&lt;K,V&gt;集合体系 常用方法: **V get(Object key):**根据参数的键值返回对用的Value **V put(K key,V value)**向集合中加入键值对 **void putAll(Map&lt;K,V&gt;)**将参数中的Map集合添加 Set keySet():将Map集合中的键以Set的形式返回 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 将Map集合中的键值对整体以Set集合的形式返回 Collection values():将Map集合中的Value以Collection集合的形式返回 V remove(Object key) boolean containsKey() boolean containsValue() int size() boolean isEmpty() 重要嵌套接口和遍历 遍历方式:(1) 遍历Map可通过keySet()转化成键的Set集合遍历 1234for(Set&lt;V&gt; key:map.entrySet())&#123;//打印Key以及对应的Value System.out.println(key+&quot;----&quot;+map.get(key));&#125; (2) 通过entrySet()转化成键值对(Map.Entry)Set集合对来遍历 123456//获得map的Entry 集合Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = map.entrySet();for(Map.Entry&lt;K,V&gt; entry:entrySet)&#123;//打印键值对 System.out.println(entry);&#125; 其中通过键值对来遍历效率要更高,因为通过键集合来遍历需要遍历两次 Map嵌套接口Entry&lt;K,V&gt;:该类是Map集合的一个内部接口,表示Map的一个键值对,该接口提供了一些方法可以得到对应map集合的一下key或者value,以及修改Key对应的Value如: V **setValue(V value)**方法,将此键对应下的值替换为参数的Value HashMap集合 特点:(1) JDk1.2版本,线程不安全(不同步),运行效率高,允许null作为Key或Value的值(2) 存储结构:哈希表(数组+链表+JDK1.8加入红黑树),去重依据:根据Key的equals()和HasCode() 源码分析:(1)属性: 初始容量,扩容因子(*指的当集合内元素个数&gt;集合的容量扩容因子 的时候,集合的的容量会扩大至原来的2倍*)* 12345678 // 当添加一个元素时,初始容量为1&lt;&lt;4即16,不存在元素容量为0,便于节省空间static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //集合的最大容量static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认的扩容因子为0.75static final int TREEIFY_THRESHOLD = 8; //JDK1.8 , 当链表的长度大于8时,调整为红黑树static final int MIN_TREEIFY_CAPACITY = 64; //JDk1.8,当链表的长度大于8时,并且元素个数大于64时,调整为红黑树static final int UNTREEIFY_THRESHOLD = 6; //JDK1.8 ,当链表的长度小于6时,调整为链表transient Node&lt;K,V&gt;[] table;//哈希表中的(链表)数组 (2) 构造器: 1234567891011121314151617//无参构造:默认扩容因子为0.75,不过刚创建好时 table是null,size是0public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; //指定初始容量和扩容因子的构造器public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; (3) 方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//put(K key,V value)方法public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);//hash方法用来确定位置 &#125;//put方法中调用的putVal方法final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果集合中还未添加元素,则调用调用resize()方法重置,为集合分配初始容量(即16) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) //如果集合为空,则为创建一个Node加入数组中 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold)//如果集合的元素个数已经超过了扩容阈值(扩容因子*集合容量),则重新分配集合容量,为原来的2倍 resize(); afterNodeInsertion(evict); return null; &#125; HashSet与HashMap的关系的通过查看源码可发现,HashSet实际上就是使用了HashMap的结构,只不过Value为null 123456public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125;public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; Hashtable集合特点: JDK1.0版本,线程安全,运行效率低,不允许null作为Key或者Value重要子类:Properties:要求key,value都是String,通常用于配置文件的读取 TreeMap集合 特点:实现了SortedMap接口,可以对key自动排序 存储结构:采用红黑树,去重规则是根据compara(Objcect o1,Object o2)即元素自身的比较器或元素的ComparaTo(Object o)方法即使元素实现了comparabale接口 TreeMap与TreeSet的关系通过查看源码,可发现TreeSet实际上是调用了TreeHap来实现的 123456public TreeSet() &#123; this(new TreeMap&lt;&gt;()); &#125; public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; Collections工具类 概念:集合工具类,定义了除了存取以外的集合常用方法 常用方法: public static void sort(List list)//升序排列(元素必须实现Comparable接口) public static void reverse(List list) //反转元素集合顺序 public static void shuffle(List list) //随机重置集合元素的顺序 public static int binarySearch(List list , T object)//二分查找(前提元素已经是排序好的),返回索引值 public static void copy(List copy_list,List list)//复制,不过两个参数的元素个数必须相同 补充扩展:(1) 当把数组转换成集合时,该转化的集合是一个受限集合,不能添加或者删除元素 12String[] names = &#123;&quot;zhan&quot;,&quot;wenwen&quot;&#125;;List&lt;Stirng&gt; list = Arrays.asList(names); //此集合不能添加或者删除元素 (2) 把基本类型数组转化成集合时,需要注意由于基本类型数组也是引用类型数据,故转化后的集合只有一个元素(即该基本数据类型数组) 123456int [] nums = &#123;100,200,300&#125;;List&lt;Integer&gt; list = Arrays.asList(nums); //错误!!!! int[] 并不等同于IntegerList&lt;int[]&gt; list = Arrays.asList(nums);//此集合只要一个元素,该元素是一个数组,nums/*********或者修改为如下所示*****************/Integer[] nums = &#123;100,200,300&#125;;List&lt;Integer&gt; list = Arrays.asList(nums); //此集合包含三个元素,都是Integer对象 多线程线程概述: 线程是CPU的基本调度单位,进程是操作系统的基本调度的单位,一个进程由一个或者多个线程组成 在同一个进程中的线程资源共享,但是进程之间相互独立 线程抢占式执行 线程的组成: (1)时间片: 操作系统(OS)会为每个线程分配执行时间(2)运行数据: 堆空间:存储线程中使用的对象,多个线程可以共享堆中的对象 栈空间:存储线程中使用的局部变量,每个线程都有拥有独立的栈 创建线程1.继承Thread类创建线程,并且重写run()方法: 12345public class MyThread extends Thread&#123; void run()&#123; //这里写该线程要执行的操作 &#125;&#125; 实现接口runnable 1234567891011121314151617public class Myrunnable implement Runnable&#123; void run()&#123; //需要执行的操作 &#125;&#125;class MyTread &#123; public static void main()&#123; //使用Thread的有参构造器来创建线程 Thread thread1 = new Thread(new Myrunnable()); //也可不实现Runnable,直接使用匿名内部类 Thread tread2 = new Thread(new Runnable()&#123; run()&#123; //匿名类创建的线程的操作 &#125; &#125;); &#125;&#125; 构造方法:1.**Thread():**无参构造2.**Thread(Runnable run):**有参构造,**绑定的接口Runnable的线程,执行方法由Runnble提供,**降低耦合性3.**Thread(String name):**参数代表创建线程时将其命名4.**Thread(Runnable run,String name):**绑定接口,并且将其线程命名 常用方法: 1.void start():启动线程,注意!thread.start()与thread.run()有本质区别,虽然有时候执行结果是一样的 2.static Thread currentThread(): 获得当前线程 3.Stirng getId():获得线程ID,每个线程ID是唯一的且由OS提供,不能更改 3.Srting getName(): 获得线程的名称,线程名称可以自定义 线程的优先级(Priority):线程的优先级为1-10,默认为5,优先级越高,表示获得CPU的机会越多设置优先级的方法:线程对像.setPriority(int newPriority),其中的参数表示设置的优先级线程的4(6)种状态:注:线程的运行结束时间片到期不代表线程销毁,run()方法执行完毕线程才真正销毁;某个线程的run()方法还没结束但是时间片到期了,其他线程也能抢占CPU进而执行 常用方法:(1)启动void start():启动线程,注意!thread.start()与thread.run()有本质区别,虽然有时候执行结果是一样的 (2)sheep休眠:线程时间片用完后就休息(等待)一段时间再争取static void sleep(long 等待毫秒数):,时间片每用完一次就休息一会 (3)yield放弃(避让):主动放弃争取本次时间片让给其他线程机会,回到就绪状态进行下一次的时间片的争取**static void yield():**主动将当前线程放弃 (4)join加入:在一个线程中加入另一个线程后,当前线程会进入堵塞状态,等待加入的线程执行完以后再执行当前线程final void join():,如addThread.join(),代表在当前线程中加入addThread线程 线程属性前台线程守护线程(即后台线程)守护线程即为前台线程服务的线程 方法:void setDaemon(true):,前台线程注意:当前台线程结束后,守护线程无论是否执行完毕都会自动结束,java中的垃圾回收器就算一个守护线程 线程安全问题描述:多个线程共同操作同一空间,会出现数据丢失的情况当多个线程并发访问临界资源,如果破坏原子操作,可能会出现数据不一致 共享资源: 即共享资源,一次仅允许一个线程使用才能保证其正确性 原子操作: 不可分割的多部操作,被视为一个整体,其顺序和步骤不可打乱或者缺省例子: 123456789101112131415161718192021222324252627282930public class Thread_safe &#123; private static int index = 0; public static void main(String[] args) throws InterruptedException &#123; //共享资源 String[] s = new String[5]; //线程a Thread a = new Thread(new Runnable()&#123; @Override public void run() &#123; //原子操作 s[index++] = &quot;hello&quot;; &#125; &#125;,&quot;a&quot;); //线程b Thread b = new Thread(new Runnable()&#123; @Override public void run() &#123; //原子操作 s[index++] = &quot;world&quot;; &#125; &#125;,&quot;b&quot;); a.start(); b.start(); /*加入线程是保证a,b,线程完毕执行完毕在执行主线程的打印语句 */ a.join(); b.join(); System.out.println(Arrays.toString(s)); &#125;&#125; 在没有发生安全问题时的输出结果应该为:[world, hello, null, null, null]或[hello, world, null, null, null],发生安全问题后则结果为:[world, null, null, null, null]或[world, null, null, null, null] 常见的Java线程安全类:如StringButter,Hashtble,Vector等synchronized 关键字的使用在使用synchronized添加锁时一定要注意是否是同一个对象锁,不可使用new 创建一个对象锁如: 1234/*注意!这样的锁没意义,每次都会创建一个新的锁对象*/synchronized(new Object())&#123;//原子操作&#125; (1)synchronized(){代码块}:,同步代码块,给代码块添加锁**(2)synchronized 方法(){}:**修饰为同步方法(注意:当同步方法为非静态方法时,锁对象是this,当是静态方法时锁对象是类即 类.class) 线程通信(堵塞线程以及唤醒线程)通过synchronized可以对方法和代码块上锁,同样的也可以通过锁对象调用waitin()方法来将线程加入等待队列(加入等待队列的线程无法抢夺CPU,直到使用notify()方法将其唤醒)从而释放该线程锁占用的锁,使得其他线程有机会抢夺CPU 常用方法:注意:调用这几个方法的对象都是锁1.锁对象.wait():将线程持有的锁释放,线程加入等待队列,等待队列的线程不能参与CPU的争夺2.notify():(1)随机唤醒等待队列的一个线程,唤醒的线程不一定只是有争夺CPU的机会并不一定能夺得CPU;(2)唤醒的线程执行时将从wait()处开始执行3.notifyAll():唤醒等待队列的全部线程 常见问题:假设有四个线程:两个存钱线程(晨晨,明明),两个取钱线程(冰冰,莉莉),要求有银行卡里没钱时不能取钱,银行卡里有钱时不能存钱 问题1:标记没进行二次判断加入在判断时使用如下代码进行存钱的操作 123456789101112131415161718public synchronized void subMonney(int m)&#123; //如果没钱 if(!flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; this.monney -= m; System.out.println(Thread.currentThread().getName()+&quot;取出&quot;+m+&quot;剩余:&quot;+this.monney); //修改标记 flag = false; //唤醒线程 this.notifyAll(); &#125; 例如:当两个取钱线程处于等待队列时,晨晨执行成功,修改了余额标记,唤醒莉莉接着莉莉开始执行,执行成功后,唤醒了冰冰,即使已经修改了标记,但是方法中的if语句已经执行完毕,不会再次判断,而是直接从this.wait()语句之后开始执行,于是导致再次进行了取钱操作导致余额变成了负数导致程序与预期不一样解决方案:将if换成while可以多次判断 问题2: 全部陷入等待队列导致死锁例如:前两次执行了取钱操作均失败,都进入等待队列第三次晨晨存钱成功,修改标记,唤醒冰冰第四次明明存钱失败,释放锁,进入等待队列第五次晨晨存钱失败,释放锁,进入等待队列第六次冰冰取钱成功,修改标记,唤醒莉莉**(问题所在,当唤醒的是功能相同的线程时,最终都两个取钱线程操作失败都进入等待队列形成死锁)**第七次莉莉取钱失败,释放锁进入等待队列第八次冰冰也取钱失败释放锁进入等待队列解决方案:将notify()方法替换成notifyAll()唤醒全部线程 高级线程线程池线程池:即线程的容器 常用APIExecutor:线程池的顶级接口ExecutorService:线程池服务接口,用于管理线程池Executos,线程池工厂类,用于创建线程池 ExecutorService的常用方法submit(Runnable task):向线程池提交任务shutdown():关闭线程池,如果不关闭程序不会停止 Executors的常用方法(1)创建固定大小的线程池: staitc newFixedThreadPool(int 个数)(2)创建缓存线程池:static newCachedThreadPool() 12345678910111213/*常见的创建线程池并使用的格式如下*/ExecutorService es = Executors.newFixedThreadPool(n); //n为线程个数//创建缓存线程池ExecutorService es2 = Executors.newCachedThreadPool();Runnablme task = new Runnable()&#123; void run()&#123; //线程执行任务 &#125;&#125;;//提交任务es.submit(task);//关闭线程池es.shutdown(); Callable接口和Future接口Callable接口:使用方法和Runable接口类似,其实现方法是call()方法,与run()方法的区别:call()方法可以抛出异常声明和拥有返回值,而run()方法都不可以但由于Thread的构造方法中没有Callable接口的参数,故没法直接绑定到线程 1234567891011//使用匿名内部类创建callable上转型对象Callable&lt;V&gt; callable = new Callable&lt;V&gt;()&#123; &lt;V&gt; call()&#123; //执行语句 &#125;&#125;/*无法直接添加线程故需要使用FutureTask&lt;V&gt;类(此类实现了Runnable接口和Future接口)进行转换*/FutureTask&lt;V&gt; task = new FutureTask&lt;V&gt;(callable);/* 由于FutureTask&lt;T&gt;实现了Runnable接口故可以添加到线程中*/Thread th = new Thread(task); 注: 不过线程池的submit()方法可以直接添加Callable接口对象 Future接口:Future接口表示执行任务的结果,如ExecutorSerVice中的submit()方法的返回类型就是Future常见方法:get():获取future对象的结果故常见写法如下: 1234567891011121314//创建线程池ExecutorService es = Executors.newCachedThreadPool();//创建Future&lt;V&gt;对象接收线程池的接收结果Future&lt;Integer&gt; future = es.submit(new Callable&lt;Integer&gt;()&#123; public Integer call()throws Exception&#123; int sum=0; for(int i=1;i&lt;=100;i++)&#123; sum+=i; &#125; return sum; &#125;&#125;);//打印获取结果 System.out.println(future.get()); 线程的同步和异步**同步(有等待):**形容一次方法的调用,同步一旦开始,必须等待该方法返回才能继续.**异步(无等待):**形容一次方法调用,异步一旦开始,像是一次消息传递,调用者告知后立刻返回.两者竞争时间片,并发执行. Lock接口ReentrantLock(实现类,即重入锁)功能与synchronized类似JDK5加入与synchronized比较,显示定义,需要手动释放,结构更灵活,功能更强大,性能更优越区别:synchronized采用悲观锁,而Lock采用乐观锁(乐观锁通俗说就是不堵塞其他线程假设不会冲突,如果冲突就不断重试) ReentrantReadWriteLock(读写锁):可分别分配读锁和写锁互斥规则: 写-写,互斥堵塞 读-写,互斥,读堵塞写,写堵塞读 读-读,不互斥,不堵塞 1234567//创建读写锁ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();//分配读锁ReadLock readlock = rwl.ReadLock();//分配写锁WriteLock writelock = rwl.WriteLock();/*读写锁的获取锁的方式和释放锁的方式和重入锁一致 */ ReentrantReadLock 读锁可并发执行,即允许多个线程同时拿到读锁 ReentantWriteLock 写锁不可并发执行,一次只允许一个线程获得写锁 注解与反射注解Annotation如: @Override Annotation的作用: 不是程序本身,对程序做出解释 可以被其他程序读取 Annotation的格式 以@注解名在代码中存在,可以有参数值,例如:@SuppressWarmings(value=”unchecked”) Annotation可以作用在method,fleld(字段),TYPE(类型),package,class,上面,相当于给他们添加了额外的辅助信息,我们可以通过反射机制编程实现对这些元数据的访问 内置注解 @Override:定义在java,.lang.Override中,此注解用于修饰方法中,表示这个方法是要覆盖父类方法的 Deprecated: 此注解可以修饰方法,类,属性,表示已经过时,不推荐使用,通常是危险的或者是有更好的替代 @SuppressWarmings:用于抑制编译器的警告信息,与前两个注解不同,此注解必须要有参数,参数是已经定义好的 元注解元注解用于对其他注解的定义修饰 @Target:用于描述注解的使用范围 @Retention:表示需要在什么级别保留该注解信息,用于描述注解的声明周期(source&lt;class&lt;runntime) @Document:说明该注解被包含在javadoc中 @Inherited:说明子类可以继承父类的中的该注解JDk中@Override注解的源码 123456//定义此注解的使用范围@Target(ElementType.METHOD)//定义此注解的生命周期@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 自定义注解 自定义注解的格式:public @注解名{定义内容} 其中每一个(抽象)方法实际上是声明了一个配置参数 可以通过default来声明参数的默认值 如果只要一个参数成员,一般参数名为value,因为只有一个参数且名为value时使用可隐式赋值参数 注解元素必须要有值 12345678910111213//自定义注解@Target(Element.METHOD)@Retention(RetentionPolicy.SOURCE)public @myAnnotation&#123; //注解参数: 参数类型+参数名(); String name() default &quot;&quot;;&#125;class Test&#123;//如果参数没有默认值,就必须给参数赋值 @myAnnotation(&quot;自定义的注解&quot;) public Test()&#123; &#125;&#125; 返回值类型只能是参数的类型(返回值只能是Class,String,enum) Reflection反射机制动态VS静态语言 动态语言:是指在运行是可以改变其结构的语言,像新的函数,对象,甚至代码可以被引进.如JavaScript,PHP,Python,C#等 静态语言:与动态语言相对应,运行时结构不能改变的语言,如: C C++,Java(但是java也有一定的动态性,可利用反射机制获得类似动态语言的特性) 反射机制提供的功能 在运行时判断一个对象所属的类 在运行时构造一个任意类的对象 在运行时判断一个类具有的属性和方法 在运行时获取泛型信息 在运行时调用任意一个对象的属性和方法 在运行时处理注解 生成动态代理 反射的优缺点 优点:可以实现动态创建对象和编译,具有很大的灵活性 缺点:对性能有影响,使用反射基本上是一种解释操作,我们可以告诉JVM,我们希望做什么并且他满足我们的要求,这类操作总是慢于我们相同的操作 Class 类一个类只有一个Class对象,并且类在加载后由系统创建,类的结构信息会封装在Class对象中 在加载完类之后,在堆内存区中就产生了一个Class类型的对象(一个类中只有一个Class对象),这个对象包含了完整的类结构信息,我们可以通过这个Class对象看到类的结构,这个对象就像一面镜子,通过这个镜子看到类的结构,我们形象的称之为:反射 创建对象的方式: 正常方式: (1)引入包类名称 (2)通过new 实例化 (取得实例化对象) 反射方式 (1)实例化对象 (2) getClass()方法 (3)得到完整的”包类名称”(即获得一个Class 对象)获得Class对象的几种常用方式:方式一:通过对象.getClass()方式二:通过Class.forName(“包类名”)方式三:通过类名.class 常用方法 static Class forName(String name) 返回指定类名的Class对象 Class newInstance() 调用构造器返回Class对象的实例 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class[] getInterface() ClassLoader getClassLoader() 返回该类的类加载器 类的加载过程(1)Load:类的加载:将类的Class文件读入内存,并为之创建一个Class文件,此过程由类加载器完成(2)Link:类的链接:将类的二进制数据合并到JRE中 **验证:**确保加载的类的信息符合JVM规范,没有安全问题 准备: 正式为静态变量分配内存并设置初始值,这些内存都在方法区中分配 **解析:**虚拟机常量池的符号引用(常量名)替换为直接引用(地址)的过程 (3)Initialize:类的初始化:JVM负责对类进行初始化 执行类构造器()方法的过程,类构造器()方法是由编译期自动收集所有类变量的赋值动作和静态代码块的语句合并产生的(此类构造器与对象的构造器即构造方法不是同一个东西) 当初始化一个类时,如果返现其父类还未初始化会先初始化父类 JVM会保证一个类的构造器的()方法在多线程环境中被正确加锁和同步如: 123456789101112131415161718public class ClassLoader &#123; public static void main(String[] args) &#123; new A(); System.out.println(&quot;m=&quot;+A.m); &#125;&#125;class A&#123;/*(2)在类的链接完毕后JVM会将类进行初始化,自动将所有的类变量和静态代码块按代码顺序收集整合,故按顺序执行赋值语句, m=100,m=200*/ static &#123; m = 100; System.out.println(&quot;A类静态代码块&quot;); &#125;/*(1)实际上下面这条语句的执行在两个过程,首先在类的链接过程中执行 static int m=0,即正式为m分配内存,并且为其设置初始值0 */ static int m = 200; public A() &#123; System.out.println(&quot;A类的无参构造&quot;); &#125;&#125; 输出结果:A类静态代码块A类的无参构造m=200 什么时候会发生类的初始化? 类的主动引用(一定会发生类的初始化):-&gt; 当虚拟机启动,先初始化main()方法所在的类-&gt; new 一个类的对象-&gt; 调用类的静态成员和静态方法(除了final常量)-&gt; 使用java.lang.reflect包的方法对类进行反射调用-&gt; 当初始化一个类,如果其类的父类没有被初始化,则会先初始化他的父类 类的被动引用(不会发生类的初始化):-&gt; 当访问一个静态域时,只有真正声明这个域的类才会被初始化,如:当通过子类引用父类的静态变量,不会导致子类初始化Son.m //其中m为父类的类变量,但是父类初始化-&gt; 通过数组定义类引用,不会触发此类的初始化-&gt; 引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了) 类加载器类加载器作用是用来把类装载进内存.JVM规定了如下类型的加载器 引导类加载器:用C++编写,是JVM自带的加载器,负责java平台核心库的装载,该类无法直接获取 扩展类加载器:负责jre/lib/ext目录下的jar包或者指定目录下的jar包装装入工作库 系统类加载器: 负责java-classpath或者-D java.class.path所指的目录下的类与jar包装入工作,是最常用的加载器测试代码: 123456789101112131415 //获取系统类加载器ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();System.out.println(systemClassLoader);//获取系统类加载器的父类加载器--&gt;拓展类加载器ClassLoader parent = systemClassLoader.getParent();System.out.println(parent);//获取扩展类的父类加载器--&gt;根加载器(用C++编写)ClassLoader root = parent.getParent();System.out.println(root);//测试当前类的加载器是哪个加载器ClassLoader classLoader = TestLoader.class.getClassLoader();System.out.println(classLoader);//获取JDK内置类的加载器ClassLoader jdkLoader =Object.class.getClassLoader(); System.out.println(jdkLoader); 运行结果:jdk.internal.loader.ClassLoaders$AppClassLoader@2077d4de 系统类加载器jdk.internal.loader.ClassLoaders$PlatformClassLoader@3830f1c0 扩展类加载器null 由于是根加载器,即引导类加载器,无法获取,所以为空jdk.internal.loader.ClassLoaders$AppClassLoader@2077d4de 用户自定义的类也是由系统类加载器加载null JDK内置类的加载器也是根加载器 获取类的结构通过反射能获取到类的结构有: Field(属性) Method Constructor(构造方法) Annotation SuperClass Interface 123456789101112131415Field[] fields = c1.getFields(); //获得public 的属性Field[] fields2 = c1.getDeclaredFields(); //获的全部属性Field[] fields = c1.getFields(); //获得public 的属性Field[] fields2 = c1.getDeclaredFields(); //获的全部属性//获得指定属性的值//Field name = c1.getField(&quot;name&quot;); //获得public 的属性Field name = c1.getDeclaredField(&quot;name&quot;); //获得全部//获得方法Method[] methods = c1.getMethods(); //获取所所有的public方法,包括父类的Method[] methods2 = c1.getDeclaredMethods(); //只获得自己的全部方法//获得指定方法,提供方法名和参数Method met = c1.getMethod(&quot;getName&quot;, null);Method met2 = c1.getMethod(&quot;setName&quot;, String.class);Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors(); //获得所有的public 构造器Constructor&lt;?&gt; constrcutor = c1.getConstructor(String.class,String.class); //获得指定的构造器 即不带有Declared的只能获取public 的,带有Declared自己所拥有的(不包括父类) 反射动作有了类的Class对象,就可以: (1)构造对象 有无参数构造: 调用Class对象的newInstance()方法-&gt; 类必须有无参构造方法-&gt; 无参构造方法的访问权限必须足够 没有无参构造:步骤如下: (1)通过Class类的getDeclareConstructot(Class …paremeterTypes)取得指定Constructor对象, (2)Constrcutor对象调用new Instance()方法 1234567 //获得Class对象 Class&lt;User&gt; c1 = User.class;//构造一个对象User user1 = c1.getDeclaredConstructor().newInstance();//newInstance()方法过时,本质是调用了无参构造//调用有参构造Constructor&lt;User&gt; constructors = c1.getDeclaredConstructor(String.class,int.class);User user2 = (User) constructors.newInstance(&quot;雯雯&quot;,1234); (2)调用普通方法 首先获取通过Class对象获取到Method对象,然后Method调用invoke(方法所在的对象,实参列表)方法 1234567Constructor&lt;User&gt; constructors = c1.getDeclaredConstructor(String.class,int.class); User user2 = (User) constructors.newInstance(&quot;雯雯&quot;,1234); //通过反射调用普通方法 Method getName = c1.getDeclaredMethod(&quot;getName&quot;); System.out.println(getName.invoke(user2)); Method setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class); setName.invoke(user2, &quot;丽丽&quot;) (3) 操作属性 首先通过Class对象获取Field对象,Field对象调用Set(字段所在属性类的对象,字段的值)方法 1234567//通过反射操作属性 User user3 =(User) c1.getDeclaredConstructor().newInstance(); //创建对象 Field name = c1.getDeclaredField(&quot;name&quot;); //不能直接访问,需要设置访问权限开放 name.setAccessible(true); name.set(user3, &quot;潇潇&quot;); System.out.println(user3.getName()); 设置可访问权限 Constructor Method Field 都有一个setAccessible(boolean flage)方法,默认情况下是false,即使访问权限不开放,private修饰的成员是不可见的,但设置为true之后,将开放访问权限,使得哪怕是private成员也可见(频繁使用反射建议开放) 性能对比:普通方式&gt;反射(开放权限)&gt;反射(不开放权限) 反射获取注解与ORM(对像关系映射)**对象关系映射:**将实体类映射成一个表,其中 类和表结构对应 属性和字段对应 对象和记录对应 (重点)反射获取注解注解的做作用域对象调用getAnnotation(Class Element)方法 123456789101112131415161718192021222324252627282930313233343536//定义类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface Table&#123; String value();&#125;//定义属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface TableField&#123; String columnName(); String type(); int length();&#125;//实体类@Table(value = &quot;db_student&quot;)public class Student &#123; @TableField(columnName = &quot;db_No&quot;,type = &quot;int&quot;, length = 10) private int stuNo; @TableField(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;, length = 10) private String name; @TableField(columnName = &quot;db_age&quot;,type = &quot;int&quot;, length = 10) private int age; &#125;/********************************************************/Class&lt;Student&gt; c1 = Student.class; //获得类的注解 Table table =(Table) c1.getAnnotation(Table.class); //获得name属性的注解 Field f1 = c1.getDeclaredField(); //先获得字段对象 TableField name = f1.getAnnotation(TableField.class); //通过字段对象获取注解 //获得注解的值 name.columnName(); name.type(); name.length(); 反射操作泛型(1) java采用泛型擦除的机制来引入泛型,Java中泛型仅仅是给编译器javac使用的,确保数据的安全性和免去强制转换类型的机制,但是,一旦编译完成,所有和泛型有关的类型全部擦除如: 123List&lt;String&gt; list1 = new ArrayList();List&lt;Integer&gt; list2 = new ArrayList();System.out.println(list1.getClass()==list2.getClass()); //结果为true (2) 通过反射操作这些类型,java新增了ParamerterizedType,GenericArrayType,TypeVariable和WildcardType几种类型代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 ParamerterizedType: 表示参数化类型,即泛型 GenericArrayType: 表示泛型或者引用类型变量的数组 TypeVariable:是各种类型变量的公共父接口 WildcardType:代表一种通配符的类型表达式 1234567891011121314//获得Class对象方法 Method m1 = Test.class.getMethod(&quot;test01&quot;,Map.class,List.class); //Class[] parameterTypes = m1.getParameterTypes(); //获得参数类型数组,元素为形参的类型(无类型参数) Type[] parameterTypes= m1.getGenericParameterTypes(); //获得通用的参数类型数组,元素为形参的类型(有类型参数) for (Type parameterType : parameterTypes) &#123;//遍历方法的每个参数类型 System.out.println(&quot;#方法的参数类型为:&quot;+parameterType); if(parameterType instanceof ParameterizedType) &#123; //如果参数为泛型参数 //获得真实参数类型 Type[] actualTypeArguments = ((ParameterizedType) parameterType).getActualTypeArguments(); for (Type type : actualTypeArguments) &#123; System.out.println(&quot;*参数的类型参数为:&quot;+type); &#125; &#125; &#125; Lambda表达式1. Lambda表达式的简介1.1. Lambda表达式的概念lambda表达式， 是Java8的一个新特性， 也是Java8中最值得学习的新特性之一。 lambda表达式， 从本质来讲， 是一个匿名函数。 可以使用使用这个匿名函数， 实现接口中的方法。对接口进行非常简洁的实现， 从而简化代码。 1.2. Lambda表达式的使用场景通常来讲， 使用lambda表达式， 是为了简化接口实现的。 关于接口实现， 可以有很多种方式来实现。 例如： 设计接口的实现类、 使用匿名内部类。 但是lambda表达式， 比这两种方式都简单。 1234567891011/*** @Author 千锋大数据教学团队* @Company 千锋好程序员大数据* @Date 2020/4/* @Description*/public class Program &#123; public static void main(String[] args) &#123; // 无参、无返回值的函数式接口 interfaceImpl();&#125; 1234567 private static void interfaceImpl() &#123; // 1. 使用显式的实现类对象 SingleReturnSingleParameter parameter1 = new Impl(); // 2. 使用匿名内部类实现 SingleReturnSingleParameter parameter2 = newSingleReturnSingleParameter() &#123; @Override 1.3. Lambda表达式对接口的要求虽然说， lambda表达式可以在一定程度上简化接口的实现。 但是， 并不是所有的接口都可以使用lambda表达式来简洁实现的。 lambda表达式毕竟只是一个匿名方法。 当实现的接口中的方法过多或者多少的时候， lambda表达式都是不适用的。 lambda表达式，只能实现 函数式接口 。 1.4. 函数式接口1.4.1. 基础概念如果说， 一个接口中， 要求实现类 必须 实现的抽象方法， 有且只有一个！ 这样的接口， 就是函数式接口。 12345 public int test(int a) &#123; return a * a;&#125; //使用lambda表达式实现 SingleReturnSingleParameter parameter3 = a -&gt; a * a; 123456789101112131415161718192021222324252627282930313233343536// 这个接口中， 有且只有一个方法， 是实现类必须实现的， 因此是一个函数式接口interface Test1 &#123; void test();&#125;// 这个接口中， 实现类必须要实现的方法， 有两个！ 因此不是一个函数式接口interface Test2 &#123; void test1(); void test2();&#125;// 这个接口中， 实现类必须要实现的方法， 有零个！ 因此不是一个函数式接口interface Test3 &#123;&#125;// 这个接口中， 虽然没有定义任何的方法， 但是可以从父接口中继承到一个抽象方法的。 是一个函数式接口interface Test4 extends Test1 &#123;&#125;// 这个接口， 虽然里面定义了两个方法， 但是defualt方法子类不是必须实现的。// 因此， 实现类实现这个接口的时候， 必须实现的方法只有一个! 是一个函数式接口。interface Test5 &#123; void test5(); default void test() &#123;&#125;&#125;// 这个接口中的 toString 方法， 是Object类中定义的方法。// 此时， 实现类在实现接口的时候， toString可以不重写的！ 因为可以从父类Object中继承到！// 此时， 实现类在实现接口的时候， 有且只有一个方法是必须要重写的。 是一个函数式接口！interface Test6 &#123; void test6(); String toString();&#125;@FunctionalInterfaceinterface FunctionalInterfaceTest &#123; void test();&#125; 1.4.2. @FunctionalInterface是一个注解 , 用在接口之前 ,判断这个接口是否是一个函数式接口。 如果是函数式接口， 没有任何问题。如果不是函数式接口，则会报错。 功能类似于 @Override。 1.4.3. 系统内置的若干函数式接口Predicate T boolean 123IntPredicate: 参数int， 返回值 booleanLongPredicate: 参数 long， 返回值 booleanDoublePredicate: 参数 double， 返回值 boolean Consumer T void 123IntConsumer: 参数int， 返回值 voidLongConsumer: 参数 long， 返回值 voidDoubleConsumer: 参数 double， 返回值 void Function&lt;T, R&gt; T R 123456789IntFunction&lt;R&gt;: 参数 int， 返回值 RIntToDoubleFunction: 参数 int， 返回值 doubleIntToLongFunction: 参数 int， 返回值 longLongFunction&lt;R&gt;: 参数 long， 返回值 RLongToIntFunction: 参数 long， 返回值 intLongToDoubleFunction: 参数 long， 返回值doubleDoubleFunction&lt;R&gt;: 参数 double， 返回值 RDoubleToIntFunction: 参数 double， 返回值 intDoubleToLongFunction: 参数 double， 返回值long Supplier 无 T 1234BooleanSupplier: 参数无， 返回值 booleanIntSupplier: 参数无， 返回值 intLongSupplier: 参数无， 返回值 longDoubleSupplier: 参数无， 返回值 double UnaryOperator T T 123IntUnaryOperator: 参数 int， 返回值 intLongUnaryOperator: 参数 long, 返回值 longDoubleUnaryOperator: 参数 double, 返回值 double BinaryOperator 12345IntBinaryOperator: 参数 int, int， 返回值 intLongBinaryOperator: 参数 long, long， 返回值longDoubleBinaryOperator: 参数 double, double， 返回值 double BiPredicate&lt;L, R&gt; L,R BiConsumer&lt;T, U&gt; BiFunction&lt;T, U, R&gt; 2. Lambda表达式的语法2.1. Lambda表达式的基础语法lambda表达式， 其实本质来讲， 就是一个匿名函数。 因此在写lambda表达式的时候， 不需要关心方法名是什么。实际上， 我们在写lambda表达式的时候， 也不需要关心返回值类型。我们在写lambda表达式的时候， 只需要关注两部分内容即可： 参数列表 和 方法体 lambda表达式的基础语法： 参数部分： 方法的参数列表， 要求和实现的接口中的方法参数部分一致， 包括参数的数量和类型。 方法体部分： 方法的实现部分， 如果接口中定义的方法有返回值， 则在实现的时候， 注意返回值的返回。 -&gt;: 分隔参数部分和方法体部分。 123(参数)-&gt; &#123;方法体&#125;； 1234567public class Syntax &#123; public static void main(String[] args) &#123; // 1. 无参、无返回值的方法实现 NoneReturnNoneParameter lambda1 = () -&gt; &#123; System.out.println(&quot;无参、无返回值方法的实现&quot;);&#125;; lambda1.test(); 12345 // 2. 有参、无返回值的方法实现 NoneReturnSingleParameter lambda2 = (int a) -&gt; &#123; System.out.println(&quot;一个参数、无返回值方法的实现: 参数是 &quot; + a);&#125;; lambda2.test(10); 123456 // 3. 多个参数、无返回值方法的实现 NoneReturnMutipleParameter lambda3 = (int a, int b) -&gt; &#123; System.out.println(&quot;多个参数、无返回值方法的实现: 参数a是 &quot; + a + &quot;, 参数b是 &quot; + b);&#125;; lambda3.test(10, 20); 2.2. Lambda表达式的语法进阶在上述代码中， 的确可以使用lambda表达式实现接口， 但是依然不够简洁， 有简化的空间。 2.2.1. 参数部分的精简参数的类型123456由于在接口的方法中，已经定义了每一个参数的类型是什么。 而且在使用lambda表达式实现接口的时候， 必须要保证参数的数量和类型需要和接口中的方法保持一致。 因此， 此时lambda表达式中的参数的类型可以省略不写。注意事项：如果需要省略参数的类型， 要保证： 要省略， 每一个参数的类型都必须省略不写。 绝对不能出现， 有的参数类型省略了， 有的参数类型没有省略。 参数的小括号如果方法的参数列表中的参数数量 有且只有一个 ，此时，参数列表的小括号是可以省略不写的。注意事项:只有当参数的数量是一个的时候， 多了、少了都不能省略。省略掉小括号的同时， 必须要省略参数的类型。123456 // 4. 无参、有返回值的方法的实现 SingleReturnNoneParameter lambda4 = () -&gt; &#123; System.out.println(&quot;无参、有返回值方法的实现&quot;); return 666;&#125;; System.out.println(lambda4.test()); 123456 // 5. 一个参数、有返回值的方法实现 SingleReturnSingleParameter lambda5 = (int a) -&gt; &#123; System.out.println(&quot;一个参数、有返回值的方法实现: 参数是 &quot; + a); return a * a;&#125;; System.out.println(lambda5.test(9)); 123456789 // 6. 多个参数、有返回值的方法实现 SingleReturnMutipleParameter lambda6 = (int a, int b) -&gt; &#123; System.out.println(&quot;多个参数、有返回值的方法实现: 参数a是 &quot; + a + &quot;, 参数b是 &quot; + b); return a * b;&#125;; System.out.println(lambda6.test(10, 20));&#125;&#125; 12345// 多个参数、无返回值的方法实现NoneReturnMutipleParameter lambda1 = (a, b) -&gt; &#123;System.out.println(&quot;多个参数、无返回值方法的实现: 参数a是 &quot; + a + &quot;, 参数b是 &quot; + b);&#125;; 2.2.2. 方法体部分的精简方法体大括号的精简当一个方法体中的逻辑， 有且只有一句的情况下， 大括号可以省略。123return的精简如果一个方法中唯一的一条语句是一个返回语句， 此时在省略掉大括号的同时， 也必须省略掉return。 3. 函数引用函数引用： 引用一个已经存在的方法， 使其替代lambda表达式完成接口的实现。 lambda表达式是为了简化接口的实现的。 在lambda表达式中， 不应该出现比较复杂的逻辑。 如果在lambda表达式中出现了过于复杂的逻辑， 会对程序的可读性造成非常大的影响。 如果在lambda表达式中需要处理的逻辑比较复杂， 一般情况会单独的写一个方法。 在lambda表达式中直接引用这个方法即可。或者， 在有些情况下， 我们需要在lambda表达式中实现的逻辑， 在另外一个地方已经写好了。此时我们就不需要再单独写一遍， 只需要直接引用这个已经存在的方法即可。 12345678// 有一个参、无返回值的方法实现NoneReturnSingleParameter lambda2 = a -&gt; &#123; System.out.println(&quot;一个参数、无返回值方法的实现: 参数是 &quot; + a);&#125;;// 有多个参数、无返回值的方法实现NoneReturnSingleParameter lambda2 = a -&gt; System.out.println(&quot;一个参数、无返回值方法的实现: 参数是 &quot; + a);SingleReturnMutipleParameter lambda3 = (a, b) -&gt; a + b; 3.1. 静态方法的引用语法： 类::静态方法 注意事项: 在引用的方法后面，不要添加小括号。引用的这个方法,参数（数量、类型） 和 返回值，必须要跟接口中定义的一致。 3.2. 非静态方法的引用语法：对象::非静态方法 注意事项:在引用的方法后面， 不要添加小括号。引用的这个方法， 参数（数量、类型） 和 返回值， 必须要跟接口中定义的一致。 示例:1234567891011121314151617181920public class Syntax1 &#123; // 静态方法的引用 public static void main(String[] args) &#123; // 实现一个多个参数的、一个返回值的接口 // 对一个静态方法的引用 // 类::静态方法 SingleReturnMutipleParameter lambda1 = Calculator::calculate; System.out.println(lambda1.test(10, 20));&#125; private static class Calculator &#123; public static int calculate(int a, int b) &#123; // 稍微复杂的逻辑：计算a和b的差值的绝对值 if (a &gt; b) &#123; return a - b;&#125; return b - a;&#125;&#125;&#125; 1234567public class Syntax2 &#123; public static void main(String[] args) &#123; // 对非静态方法的引用，需要使用对象来完成 SingleReturnMutipleParameter lambda = newCalculator()::calculate; System.out.println(lambda.test(10, 30));&#125; 123456 private static class Calculator &#123; public int calculate(int a, int b) &#123; return a &gt; b? a - b : b - a;&#125;&#125;&#125; 3.3. 构造方法的引用使用场景 如果某一个函数式接口中定义的方法， 仅仅是为了得到一个类的对象。 此时我们就可以使用构造方法的引用， 简化这个方法的实现。 语法: 类名::new注意事项:可以通过接口中的方法的参数,区分引用不同的构造方法。示例 12345678910111213public class Syntax3 &#123; private static class Person &#123; String name; int age; public Person() &#123; System.out.println(&quot;一个Person对象被实例化了&quot;);&#125; public Person(String name, int age) &#123; System.out.println(&quot;一个Person对象被有参的实例化了&quot;); this.name = name; this.age = age;&#125;&#125; 12345 @FunctionalInterface private interface GetPerson &#123; // 仅仅是希望获取到一个Person对象作为返回值 Person test();&#125; 123 private interface GetPersonWithParameter &#123; Person test(String name, int age);&#125; 12345 public static void main(String[] args) &#123; // lambda表达式实现接口 GetPerson lambda = Person::new; // 引用到Person类中的无参构造方法，获取到一个Person对象 Person person = lambda.test(); 12345 GetPersonWithParameter lambda2 = Person::new; // 引用到Person类中的有参构造方法，获取到一个Person对象 lambda2.test(&quot;xiaoming&quot;, 1);&#125;&#125; 3.4. 对象方法的特殊引用如果在使用lambda表达式，实现某些接口的时候。 lambda表达式中包含了某一个对象， 此时方法体中， 直接使用这个对象调用它的某一个方法就可以完成整体的逻辑。 其他的参数， 可以作为调用方法的参数。 此时， 可以对这种实现进行简化。 123456public class Syntax &#123; public static void main(String[] args) &#123; // 如果对于这个方法的实现逻辑，是为了获取到对象的名字 GetField field = person -&gt; person.getName(); // 对于对象方法的特殊引用 GetField field = Person::getName; 123// 如果对于这个方法的实现逻辑，是为了给对象的某些属性进行赋值SetField lambda = (person, name) -&gt; person.setName(name);SetField lambda = Person::setName; 12345 // 如果对于这个方法的实现逻辑，正好是参数对象的某一个方法 ShowTest lambda2 = person -&gt; person.show(); ShowTest lambda2 = Person::show;&#125;&#125; 123interface ShowTest &#123; void test(Person person);&#125; 123interface SetField &#123; void set(Person person, String name);&#125; 123interface GetField &#123; String get(Person person);&#125; 12class Person &#123; private String name; 123 public void setName(String name) &#123; this.name = name;&#125; 123 public String getName() &#123; return name;&#125; 12public void show() &#123; &#125; 4. Lambda表达式需要注意的问题这里类似于局部内部类、匿名内部类，依然存在闭包的问题。如果在lambda表达式中，使用到了局部变量，那么这个局部变量会被隐式的声明为 final。 是一个常量， ==不能修改值。== 5. Lamb da表达式的实例5.1. 线程的实例化123Thread thread = new Thread(() -&gt; &#123; // run()方法体&#125;); 5.2. 集合的常见方法12ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();Collections.addAll(list, &quot;千锋&quot;, &quot;大数据&quot;, &quot;好程序员&quot;, &quot;严选&quot;, &quot;高薪&quot;); 5.3. 集合的流式编程12345678// 按照条件进行删除list.removeIf(ele -&gt; ele.endsWith(&quot;.m&quot;));// 批量替换list.replaceAll(ele -&gt; ele.concat(&quot;!&quot;));// 自定义排序list.sort((e1, e2) -&gt; e2.compareTo(e1));// 遍历list.forEach(System.out::println); 12ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();Collections.addAll(list, &quot;千锋&quot;, &quot;大数据&quot;, &quot;好程序员&quot;, &quot;严选&quot;, &quot;高薪&quot;); 网络编程1.1概述计算机网络:计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 网络编程的目的:无线电台,传播交流信息,数据交换,通信 需要做什么: 如何准确定位网络上的一台主机 192.168.16.124:端口 找到了这个主机,如何传传输数据Java web: 网页编程 B/S网络编程: TCP/IP C/S 1.2网络通信的要素如何实现网络的通信?通信的地址: IP 端口 规则:网络通信的协议TCP/IP参考模型 小结: 网络编程的有两个主要问题 如何准确的定位网络上的一台或者多态计算机 找到主机后如何进行通信 网络编程中的要素 IP和端口号 网络通信协议:TCP UDP IPip地址:InteAddress 唯一定位一台网络上的计算机 127.0.0.1 :本机localhost ip地址的分类 ipv4/ipv6 **IPV4 **: 127.0.0.1,由4个字节组成,0-255 IPV6: 2409:8a5c:4027:bd50:4168:a92e:8054:524b ,128位,8个16进制数的4位数整数 公网(互联网)-私网(局域网)如：192.168.xxx.xxx 域名,为了方便记忆,实际上就是ip地址 端口(Prot)端口表示计算机上的一个程序的进程 不同的进程有不同的端口号!用来区分软件 端口被规定 0-65535 单个协议下端口号不能冲突 端口分类: 公用端口 0-1024 http:80 https:443 ftp: 21 Telent:23 程序注册端口 Tomcat: 8080 MySQL: 3306 Oracle : 1521 动态,私有端口查看所有端口 [cmd命令]查看指定端口所被占用的进程id(PID) [cmd命令] 通信协议网络通信协议: 速率,传输码率,代码结构,传输控制问题: 太繁杂,于是有了分层的概念套接字Socket = 端口Prot + IP地址其中,IP地址用来标识网络上的唯一的一台计算机,而端口是用来唯一标识程序的进程 TCP/IP协议:实际上是一组协议两个重要的协议 TCP:用户传输协议 UDP:用户输出报协议 TCP和UDP对比TCP:相当于打电话 链接,稳定 三次握手,四次挥手 123456789最少需要三次握手,保证稳定链接!A : 滴滴B : 在A : 在干嘛?四次挥手A : 我要断开了B : 我知道你要断开了B : 你确定要断开了嘛A : 我真的要断开! 客户端,服务端 传输完成,释放链接,效率低 UDP:相当于发短息 不连接,不稳定 客户端,服务端:没有明确的界限 不管对方是否接受,都能发送 TCP实现简单通信 12345678910111213141516171819202122232425262728293031323334353637//服务端public class TcpServer &#123; public static void main(String[] args) throws Exception&#123; Socket socket = null; ServerSocket server = null; InputStream in = null; ByteArrayOutputStream out = null; try &#123; //创建一个程序端口服务 server = new ServerSocket(4444); while(true) &#123; //创建一个接受server 服务的链接socket socket = server.accept(); // 建立服务链接的输入流 in = socket.getInputStream(); //字节数组输出流 out = new ByteArrayOutputStream(); int len; //缓冲数组 byte[] buffer = new byte[1024]; //输入流的数据读取,即服务链接的数据,放入buffer中 while((len = in.read(buffer))!=-1) &#123; //输出流写入buffer的数据 out.write(buffer, 0, len); &#125; //打印输出流中的数据 System.out.println(out.toString()); &#125; &#125;finally &#123; out.close(); in.close(); socket.close(); server.close(); &#125; &#125;&#125; 123456789101112131415//客户端public class TcpClient &#123; public static void main(String[] args) throws Exception&#123; OutputStream out = null; //建立一个端口服务链接 Socket socket = new Socket(&quot;127.0.0.1&quot;, 4444); //创建一个服务链接的输出流 out = socket.getOutputStream(); //向服务链接中输出信息 out.write(&quot;你好,Tcp!&quot;.getBytes()); //关闭流 out.close(); socket.close(); &#125;&#125; UDP发短信,只需要知道地址,不需要建立链接 1234567891011121314151617181920public class Receive &#123; //接收端 public static void main(String[] args) throws Exception &#123; InetAddress ip = InetAddress.getByName(&quot;localhost&quot;);// DatagramSocket socket = new DatagramSocket(9090,ip); //注意:用于接收的套接字也不要加IP,有IP地址的是用于发送的 DatagramSocket socket = new DatagramSocket(9090); //DatagramPacket packet = new DatagramPacket(buf, buf.length, InetAddress.getLocalHost(), 9090); //创建用于接收的数据包,注意! 不要端口和IP byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, buf.length); socket.receive(packet); System.out.println(&quot;发送者的地址为:&quot;+packet.getSocketAddress()); System.out.println(&quot;接受到的信息为:&quot;+new String(buf)); socket.close(); &#125;&#125; 123456789101112131415public class Send &#123; //发送端 public static void main(String[] args) throws Exception &#123; InetAddress ip = InetAddress.getLocalHost(); //注意:发送端的套接字不要和接受端端口一致,否则会造成端口占用 DatagramSocket socket = new DatagramSocket(9999); //创建用于用于发送的数据包,需要提供发送的地址和端口号 byte[] buf = &quot;你好!udp&quot;.getBytes(); DatagramPacket packet = new DatagramPacket(buf,buf.length,ip,9090); socket.send(packet); socket.close(); &#125;&#125;","categories":[{"name":"Java系列","slug":"Java系列","permalink":"https://lqy679.github.io/categories/Java%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"数据结构","slug":"数据结构","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T09:19:33.123Z","comments":true,"path":"2020/01/01/数据结构/","link":"","permalink":"https://lqy679.github.io/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"数据结构2.入门概述2.1线性表的概念所谓线性表,就是讲数据排列成一条长线的结构,如:顺序表,数组,链表,栈,队列","text":"数据结构2.入门概述2.1线性表的概念所谓线性表,就是讲数据排列成一条长线的结构,如:顺序表,数组,链表,栈,队列 **非线性结构:**树,堆,图等 3.数组数组是一种线性结构,他用一组连续的内存空间,来存储一组具有相同数据类型的数据 3.1 特性:随机访问劣势:数组插入删除操作效率非常低 3.2 逻辑结构和物理结构3.2.1 数组元素的访问计算机给每个内存单元都分配了一个地址,通过地址来访问其数据,因此要访问数组中的某个元素时,,首先要经过一个寻址公式计算要访问的元素在内存中的地址. 1a[i] = baseAddress + i * dataTypesize 3.2.2 数组下标为什么从0 开始从数组的存储的内存模型上来看,”下标”最切确的定义应该是“偏移(offset)”,如果用array来表示数组的首地址,array[0]也就是偏移为0的位置,也就是首地址,array[k]就表示偏移k个type_size的位置,所以计算array[k]的内存地址只需要用这个公式 1array[k]_address = base_address+k*type_size 如果从1开始,那么计算就会变为 1array[k]_address = base_address+k*type_size 对于CPU来说,就多了一次减法指令 3.3 数组的特点3.3.1 高效的随机访问数组元素的访问是通过下标来访问的,计算机通过首地址和寻址公式能够很快的找到我们想要访问元素 3.3.1 低效插入和删除由于数据是一段连续的内存空间,因此插入和删除操作会变得非常低效 插入 比如在a[i] (假设a[i]不是最后一个元素)的元素后面插入一个数据,这时只能将a[i]后面的元素都往后挪一位 优化方案:如果数组中存储的数据是没用规律的,数组只是被当作一个存储数据的集合,在这种情况下,如果要在第i个位置插入数据,为了避免大规模数据的搬移,可以直接在最后添加一个元素,然后把原来第i个位置的数据放到最后面,将插入的数据放到第i个位置 删除 如果要删除第i个元素,为了数组的连续性,也需要搬移数据(将要删除的元素的后面的元素往前移) 优化方案:在某些特定场景下,不一定非得追求数组在的数据的连续性,如果我们将多次删除操作集中在一起执行,效率就会相对提高 如:假设数组a[6]中有6个元素,a1,a2,a3,a4,a5,a6,现在我们依次要删除a1,a2这两个元素 为了避免a3,a4,a5,a6.这些数据搬移两次,我们可以先记录下已经删除的数据,每次删除操作并不是真正的搬移数据,只是记录数据被删除,当数组没有更多的空间存储数据时,在触发执行一次真正的删除操作(搬移数据),这样就大大减少了数据搬移 就有点类似JVM的标记清楚垃圾回收的核心思想,还有windows操作系统的回收站功能 3.4 数组的应用针对数组类型,很多语言都提供了容器类,如java的ArrayList,C++STL中的vector ArrayList最大优势就是可以将很多数组操作的细节封装起来,比如数组的插入,删除时需要搬移数据等,另外他还有一个优势,就是支持动态扩容,数组本身在定义的时候需要预先指定大小,因为需要分配连续的内存空间,如果我们申请了大小为10 的数组,当第11个数组需要存储时,我们就需要重新分配一块更大的空间,将原来的数据复制过去,然后将新的数据插入.而ArrayList已经帮我们现实好了,当空间不足时,会自动扩容 4.链表概念链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 链表的类型1. 单链表 习惯上:把第一个结点叫做头结点,最后一个结点叫做尾结点 链表的增删操作(高效率)链表在实现插入和删除操作时,并不需要搬移数据,只需将指针的指向更改就可以了 查找操作(低效率)链表无法实现像数组一样随机查找,即使当我们想查找第k个元素时,只能从头结点开始遍历 2.循环链表循环链表与单链表相比,循环链表在尾结点指向头结点 3.双向链表 4.双向循环链表 5.栈和队列栈概念:栈是一种先进后出的数据结构,限定仅在表尾进行插入删除操作的线性表,允许插入和删除的一端称为栈顶(top) ,另一端称为栈尾(bottom),简称LIEF结构 栈的操作: 入栈(Push):栈的插入数据的操作 出栈(Pop): 栈的删除数据操作 进栈出栈的变化形式假设进栈顺序为123 第一种:1,2,3进, 3,2,1 出 第二种:1进1出,2进2出,3进3出 (也就是进一个出一个) 123 第三种:213 (2出栈,1出栈,3进栈再出栈) 第四种:132 (1进栈出栈,2进栈,3进栈,3出栈,2出栈) 第五种:231 (1进栈,2进栈,2出栈,3进栈,3出栈,1出栈) 不过不会出现312的情况,因为3出栈意味着,1和2都已经进栈了,而不可能1会比2先出栈 栈的作用以及应用实际上递归就是运用到了栈的数据结构,**每次递归一次(自己调用自己),就相当于一次进栈操作,**最后达到终止条件,就开始出栈 栈的实现(待写) 递归**概念:**程序调用自身的编程技巧称为递归（ recursion）。递归作为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。 ==即使自己调用自己== 应用:如求1+2+3…+100 不使用循环而使用递归得Java代码如下所示 1234567891011package Test;public class 递归测试 &#123; public static void main(String[] args) &#123; System.out.println(ff(100)); &#125; static int ff(int x) &#123; if(x==1) return 1; return ff(x-1)+x; &#125;&#125; 递归问题:(1)堆栈溢出时间和空间消耗比较大。每一次函数调用都需要在内存栈中分配空间以保存参数，返回地址以及临时变量，而且往栈里面压入数据和弹出都需要时间。每个进程的栈容量是有限的。由于递归需要系统堆栈，所以空间消耗要比非递归代码要大很多。而且，如果递归深度太大，可能系统撑不住。 (2)重复计算另外递归会有重复的计算。递归本质是把一个问题分解为多个问题，如果这多个问题存在重复计算，有时候会随着n成指数增长。斐波那契的递归就是一个例子。 12345678910111213141516package Test;public class 递归测试 &#123; public static void main(String[] args) &#123; System.out.println(ff(8)); &#125; //非波那契数列 //1,1,2,3,5,8,13,21.... static int ff(int x) &#123; if(x==1||x==2) return 1 ; return ff(x-1) + ff(x-2) ; &#125;&#125; 如上图所示,ff(3)就是重复计算了,故为了避免出现重复计算的问题,我们可以==通过一个数据结构(散列表)来保存已经求解过的ff(k),当递归调用到了ff(k)时,我们先检查一下是否求解过了,如果已经求解了直接重散列表中返回== 递归与循环递归与循环非常相似,==循环都能转换成递归,但递归不一定能写成循环==,因为递归会有重复堆栈溢出,重复计算,空间复杂度和时间复杂度过大的风险,但某些情况下(如斐波那契数列,汉诺塔等),用递归更好. 如下例子: 1234567891011121314151617181920212223package Test;public class 递归测试 &#123; public static void main(String[] args) &#123; System.out.println(f1(100)); System.out.println(f2(100)); &#125; //递归 static int f1(int x) &#123; if(x==1) return 1 ; return f1(x-1)+x ; &#125; //转换成循环 static int f2(int x) &#123; int sum = 0; for(int i =1;i&lt;=100;i++) &#123; sum = sum + i ; &#125; return sum ; &#125;&#125; 复杂度分析时间复杂度:在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，==不包括这个函数的低阶项和首项系数。==使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况(常见的时间复杂度有:O(1) O(n) O(n2) O(log n)) 时间复杂度分析方法:1.代码循环最多原则大O表示法只表示一种变化趋势,公式中的低阶和常数系数并不左右增长趋势,因此可以忽略 2.加法原则比如有如下代码: 1234567891011121314151617181920212223242526272829int sum(int x)&#123; //常量级 忽略 int sum_1 = 0; int p = 1; //即使循环了100次,也是属于常量级,忽略 for(;p&lt;=100;++p)&#123; sum_1 = sum_1 + p; &#125; //常量级忽略 int sum_2 = 0; int q = 1; // 复杂度:O(n) for(;q&lt;n;++q)&#123; sum_2 = sum_2 + q; &#125; //常量级,忽略 int sum_3 = 0; int i = 1; int j = 1; //嵌套循环,O(n*n) for(;i&lt;=n;i++)&#123; j = 1; for(;j&lt;=n;j++)&#123; sum_3 = sum+i*j; &#125; &#125; return sum_1+sum_2+sum_3 ;&#125;//T(n) = O(n)+O(n*n) = O(n*n) 3.乘法原则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 常见的时间复杂度分析:O(log n)如下代码: 123456789public void test1(int n)&#123; int i = 1; while(i&lt;n)&#123; i = i*2 ; //代码1 &#125;&#125;/* 设代码执行次数为x ,则当 2^x = n 时退出循环*/ 故解得 x = log2 n,又由于因为对数有换底公式,所以问题规模可简化成 O (log n) O(nlog n)如下代码: 1234567891011121314public void test2(int n)&#123; for(int i = 0;i&lt;n;i++)&#123; test1(n); &#125;&#125;public void test1(int n)&#123; int i = 1; while(i&lt;n)&#123; i = i*2 ; //代码1 &#125;&#125;//根据乘法原则可知,此算法的时间复杂度为 O(nlog n) 空间复杂度空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。 12345678void print(int n)&#123; int i = 0; //开辟的空间随着问题规模n而增大,所以 空间复杂度为 O(n) int[] a = new int[n]; for(;i&lt;n;i++)&#123; System.out.println(a[i]); &#125;&#125; 排序算法评判算法好坏的的标准 时间复杂度 空间复杂度 算法稳定性 注:所谓稳定性就是指若数据存在值相同的元素,经过排序后,相等元素之间元素之间的先后顺序不变 冒泡排序:冒泡排序就是遍历n-1次(n为数据个数),每次遍历都两两相邻比较,将较大者交换,每次遍历冒泡后都会将最大值给交换到后面 视频演示网站: https://visualgo.net/zh/sorting 12345678910111213141516171819202122232425import java.util.Arrays;public class 冒泡排序 &#123; public static void main(String[] args) &#123; int[] array = &#123;1,3,33,4,2,8,7&#125; ; System.out.println(Arrays.toString(bubbleSort(array))); &#125;//冒泡排序static int[] bubbleSort(int[] array) &#123; //循环,实际上最后一次不需要再进行交换了 for(int i = 0;i&lt;array.length-1;i++) &#123; //每一次都把最大的顶大上去 for(int j = 0;j&lt;array.length-1-i ; j++) &#123; if(array[j]&lt;array[j+1]) &#123; int temp = array[j] ; array[j] = array[j+1]; array[j+1] = temp ; &#125; &#125; &#125; return array; &#125;&#125; 时间复杂度: **最好情况是正序的时候,时间复杂度是O(n),**最坏情况下即逆序,时间复杂度是O(n2) 空间复杂度: 由于只涉及到数据交换,所以空间复杂度是O(1) 插入排序:插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法 [1] 。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动 [2] 。 总结:将数据分成两组,以此遍历后面的数据,与前面的一组比较,选择合适的位置插入 如下代码通过交换位置插入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package 排序;import java.util.Arrays;public class 插入排序 &#123; public static void main(String[] args) &#123; int [] arr = &#123;6,5,4,3,2,1&#125; ; System.out.println(Arrays.toString(insertionSort1(arr))); &#125; // 遍历插缝搬移元素实现(待写) static int[] insertionSort2(int[] arr) &#123; int length = arr.length; for(int i = 1;i&lt;length;i++) &#123; //如果前面一个大于后面的 if(arr[i-1]&gt;arr[i]) &#123; int j = i ; int temp = arr[j] ; //当前面的数大于当前的数时,数组元素后移 while(j&gt;0&amp;&amp;arr[j-1]&gt;temp) &#123; //数组元素往后移 arr[j] = arr[j-1] ; j--; &#125; arr[j] = temp ; &#125; &#125; return arr; &#125; // 交换实现 static int[] insertionSort1(int[] arr) &#123; int length = arr.length; if(length&lt;=1) &#123; return arr; &#125; for(int i=1;i&lt;length;i++) &#123; //有序序列的最后一个元素 int prveIndex = i-1; // 无序序列第一个元素小于前一个元素时 while(prveIndex&gt;=0&amp;&amp;arr[prveIndex]&gt;arr[prveIndex+1]) &#123; int temp =arr[prveIndex] ; arr[prveIndex] = arr[prveIndex+1] ; arr[prveIndex+1] = temp ; prveIndex--; //if(prveIndex&lt;0) break ; //可通过短路实现 &#125; &#125; return arr; &#125;&#125; 时间复杂度: 在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为 最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为 平均来说，A[1..j-1]中的一半元素小于A[j]，一半元素大于A[j]。插入排序在平均情况运行时间与最坏情况运行时间一样，是输入规模的二次函数 [1] 。 空间复杂度: 插入排序的空间复杂度为常数阶 稳定性: 如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变，即它们的位置保持不变，通俗地讲，就是两个相同的数的相对顺序不会发生改变，则该算法是稳定的；如果排序后，数据的相对次序发生了变化，则该算法是不稳定的。关键词相同的数据元素将保持原有位置不变，所以该算法是稳定的 [5] 。 选择排序:选择排序即每次都选出后续元素的最小值,以此排放,即第一次选出最小的放在最前面,第二次选出第二小的放在第二位,以此类推 注:原来的第一位将与最小值的位置交换位置避免丢失数据 1234567891011121314151617181920212223242526272829303132333435363738package 排序;import java.util.Arrays;public class 选择排序 &#123; public static void main(String[] args) &#123; int [] arr = &#123;4,6,1,7,8&#125;; System.out.println(Arrays.toString(selectSort(arr))); &#125; static int[] selectSort(int[] arr) &#123; int length = arr.length; if(length&lt;=1) return arr; //遍历数组位置 for(int i = 0;i&lt;length-1;i++) &#123; //假设当前值是最小值 int min = arr[i] ; //j代表当前元素的后一个元素索引 int j = i+1 ; //设置一个标志flag,用于记录最小值的索引 int flag = i ; //遍历寻找最小值 for(;j&lt;length;j++) &#123; if(arr[j]&lt;min) &#123; min = arr[j] ; flag = j ; &#125; &#125; //将最小值与当前遍历的位置元素交换 int temp = arr[i]; arr[i] = min ; arr[flag] = temp; &#125; return arr; &#125; &#125; 时间复杂度: 选择排序的交换操作介于 0 和 (n - 1)次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+…+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。 空间复杂度:O(1) 稳定性: 由于要交换位置,所以可能导致相同值的位置不一样,故是不稳定 归并(分治)排序即将一个数组逐渐拆分,最后每个数组只剩下一个元素,然后两两按顺序合并成一个新数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package 排序;import java.util.Arrays;public class 归并排序 &#123; public static void main(String[] args) &#123; int [] arr1 = &#123;1,7,3,2,6,9&#125; ; int [] arr2 = &#123;1,4,5&#125; ; System.out.println(Arrays.toString(mergeSort(arr1))); &#125; static int[] mergeSort(int[] arr) &#123; // 数组长度为1时直接返回 if(arr.length&lt;2) &#123; return arr; &#125; //将数组平均拆分成两个数组 int mid = arr.length/2; int[] left = Arrays.copyOfRange(arr, 0, mid) ; //复制数组 int[] right = Arrays.copyOfRange(arr, mid, arr.length) ; //复制数组 //返回合并的数组 return merge(mergeSort(left), mergeSort(right)); //递归拆分直到每个数组只有一个元素 &#125; //合并成一个有序数组 static int[] merge(int[] left ,int[] right) &#123; int[] newArr = new int[left.length+right.length] ; int lIndex = 0; int rIndex = 0; //遍历合并数组 for(int i=0;i&lt;newArr.length;i++) &#123; //如果左边的数组已经排完,则合并数组之后的元素等于右边剩余的元素 if(lIndex==left.length) &#123; newArr[i] = right[rIndex++]; &#125; //和上面同理 else if(rIndex==right.length) &#123; newArr[i] = left[lIndex++]; &#125; //左右数组比较,小的放入合并数组,同时放入后的数组索引后移 else if(left[lIndex]&lt;right[rIndex]) &#123; newArr[i] = left[lIndex++] ; &#125; //和上面同理 else &#123; newArr[i] = right[rIndex++] ; &#125; &#125; return newArr; &#125; &#125; 时间复杂度: O(n log n)归并排序,可分为两个过程,即拆分,和合并(排序),其中拆分是不随着问题规模n变大而影响的,即为常数级,可忽略,主要是看合并过程, 如图所示,总共需要进行 log2 n 次合并,因为对于满二叉树来说, 设二叉树的层次为 x ,则叶子数目为 2x -1 , 则可求得满二叉树的层次为 x = log2 n +1 ,但是到最后一层已经是结果了,就不需要再遍历了 所以,**总共需要进行 log2 n 次合并 ,**而每次合并需要O(n),故时间复杂度为 O (n log n) 空间复杂度: O(n)由于需要开辟一个与原来的数组等长的数组来临时存放,故 O(n) 稳定性:归并排序是稳定的 快速排序(待写)计数排序计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。 [1] 当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(nlog(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(nlog(n)), 如归并排序，堆排序） 即将序列分到若干个桶里,其中设桶的编号为序列的最大值,桶中的值代表该数据在原始序列中出现了多少次,例如编号为5的桶,值为3,即使原序列中有值为5的值,且有5个, 比如 2,5,3,5,6,7,5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package 排序;import java.util.Arrays;public class 计数排序 &#123; public static void main(String[] args) &#123; int [] arr = &#123;6,8,5,7,2,7,7,7,7&#125; ; System.out.println(Arrays.toString(CountSort2(arr))); &#125;/* * 即桶排序的特殊情况: * 将序列分为最大值个桶,每个值放入与桶编号相同的桶里,若有相同的,则桶的元素+1 */ static int[] CountSort(int[] arr) &#123; if(arr.length&lt;2) &#123; return arr ; &#125; int max = arr[0]; for(int i=1;i&lt;arr.length;i++) &#123; if(arr[i]&gt;max) &#123; max = arr[i] ; &#125; &#125; //由于下标是最大值,所以长度应该是最大值+1 int[] bucket = new int[max+1] ; for(int i=0;i&lt;arr.length;i++) &#123; //遍历到匹配的桶,则桶的结果+1 bucket[arr[i]]++; &#125; //将桶元素取出来 int index = 0; for(int i=0;i&lt;bucket.length;i++) &#123; //遍历桶 for(int j = 0;j&lt;bucket[i];j++) &#123; //判断需要桶中的数据有几个 arr[index++] = i ; &#125; &#125; return arr; &#125; //与上面的从桶中取出数据的方式不一样 static int[] CountSort2(int[] arr) &#123; int max = arr[0]; for(int i=1;i&lt;arr.length;i++) &#123; if(arr[i]&gt;max) &#123; max = arr[i] ; &#125; &#125; //放进桶中 int[] bucket = new int[max+1] ; for(int i = 0;i&lt;arr.length;i++) &#123; bucket[arr[i]]++; //计数 &#125; int index = 0; for(int i =0;i&lt;bucket.length;i++) &#123; while(bucket[i]!=0) &#123; //当i号桶有元素(即不为0) arr[index++] = i; bucket[i]--; //取出一个减一个 &#125; &#125; return arr; &#125;&#125; 时间复杂度:O(n+k) 其中k是整数的范围(如序列的最大值是1000,则k为1000) 空间复杂度:O(n+k) 稳定性计数排序是稳定的 桶排序(待写)二分查找二分查找又叫做折半查找 如下代码分别使用了递归和循环来实现二分查找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package 查找;public class 简单的二分查找 &#123; public static void main(String[] args) &#123; int[] arr = new int[7]; arr[0] = 2; arr[1] = 4; arr[2] = 5; arr[3] = 7; arr[4] = 8; arr[5] = 12; arr[6] = 17; int value = 2; System.out.println(&quot;查找值为:&quot;+value+&quot;在数组中的下标为:&quot;+binarySearch(arr,value)); System.out.println(&quot;查找值为:&quot;+value+&quot;在数组中的下标为:&quot;+binarySearch2(arr,value,0,arr.length-1)); &#125; static int binarySearch(int[] arr,int value) &#123; //左边界 int lIndex = 0 ; //右边界 int rIndex = arr.length-1; while(lIndex&lt;=rIndex) &#123; int mid = (lIndex+rIndex)/2 ; //查找值在中间值的左边 if(value&lt;arr[mid]) &#123; //rIndex = mid; 注意:这样是错误的,因为每次都重复查找了arr[mid] rIndex = mid -1; &#125; //查找值在中间值的右边 else if(value&gt;arr[mid]) &#123; //注意: lIndex = mid 这样是错误的,每次会重复查找相同的arr[mid],导致死循环 lIndex = mid+1; &#125; //当查找值等于中间值 else &#123; return mid ; &#125; &#125; return -1; &#125; //递归实现二分查找 static int binarySearch2(int[] arr,int value,int lIndex,int rIndex) &#123; if(lIndex&gt;rIndex) &#123; return -1; &#125; int mid = (lIndex+rIndex)/2; if(value==arr[mid]) &#123; return mid; &#125; else if(value&lt;arr[mid]) &#123; return binarySearch2(arr, value, lIndex, mid-1); &#125; else if(value&gt;arr[mid]) &#123; return binarySearch2(arr, value, mid+1, rIndex); &#125; return -1; &#125;&#125; 需求1:查找第一个重复值如果查找的值有重复值,则查找到第一个重复值的下标 自己也可实现一下查找最后一个重复值 123456789101112131415161718192021222324252627282930313233343536373839404142package 查找;public class 二分查找第一个重复值 &#123; public static void main(String[] args) &#123; int[] arr = new int[7]; arr[0] = 2; arr[1] = 7; arr[2] = 7; arr[3] = 7; arr[4] = 7; arr[5] = 12; arr[6] = 17; int value = 7; System.out.println(&quot;查找值为:&quot;+value+&quot;在数组中的下标为:&quot;+binarySearch_same(arr,value)); &#125; static int binarySearch_same(int[] arr,int value) &#123; int lIndex = 0; int rIndex = arr.length-1; while(lIndex&lt;=rIndex) &#123; int mid = (lIndex+rIndex)/2; if(value==arr[mid]) &#123; if(mid==0||value!=arr[mid-1]) &#123; return mid; &#125; else &#123; //如果前面有重复值 rIndex = mid-1; &#125; &#125; else if(value&lt;arr[mid]) &#123; rIndex = mid-1; &#125; else if(value&gt;arr[mid])&#123; lIndex = mid+1; &#125; &#125; return -1; &#125;&#125; 需求2:相近值查找序列中的值大于等于查找值的下标 可自己实现查找系列中小于等于查找值的下标 123456789101112131415161718192021222324252627282930313233343536373839404142package 查找;/* * 查找序列中大于等于查找值的第一个元素的下标 */public class 二分查找近似值 &#123; public static void main(String[] args) &#123; int[] arr = new int[7]; arr[0] = 2; arr[1] = 4; arr[2] = 7; arr[3] = 9; arr[4] = 13; arr[5] = 15; arr[6] = 17; int value = 10; System.out.println(&quot;查找值为:&quot;+value+&quot;在数组中的下标为:&quot;+binarySearch_near(arr,value)); &#125; static int binarySearch_near(int[] arr,int value) &#123; int lIndex = 0; int rIndex = arr.length-1; while(lIndex&lt;=rIndex) &#123; int mid = (lIndex+rIndex)/2; //查找值在中间值的左边时 if(value&lt;=arr[mid]) &#123; //如果value小于于等于第一个元素或者value大于中间值的前一个元素的时候 if(mid==0||value&gt;arr[mid-1]) &#123; return mid; &#125; //中间值的前一个元素也大于等于value时 else &#123; rIndex = mid-1; &#125; &#125; //查找值在中间值的右边时 else &#123; lIndex = mid+1; &#125; &#125; return -1; &#125;&#125; 散列表(了解即可)散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。 散列冲突及解决方案散列表应用哈希算法介绍6.树(重点)树型结构是一类非常重要的非线性数据结构，其中以树和二叉树最为常用。在介绍二叉树之前，我们先简单了解一下树的相关内容 树的相关概念**结点的高度:结点到叶子结点的最长路径(边数),所有叶子结点的高度为0 ** (从下往上) 结点的深度:根结点到这个结点所经历的边的个数,所以根的深度为0 (从上往下) 结点的层数:结点的深度+1 (因为没有0层的说法,所以根是一层) 度:结点的分支数(如叶子结点的度数为0) 森林:是指m(m&gt;=0)颗互不相交的树的集合 树的性质 参考文章 https://www.cnblogs.com/little-whilte/p/14612800.html ==（1）总结点数=总度数和（分支数）+1=n0+n1+n2+~~总度数和+1：== 解释:除根节点外，每个结点都是一个分支，分支数=总度数和(每个结点的度数的和)，所以总结点个数=总度数和（分支数）+1 n0+n1+n2+~~:n0为叶子结点个数，各级结点个数之和=总结点个数 树的存储结构(待补充) 双亲表示法: 孩子表示法 孩子兄弟表示法 二叉树定义:最多只有两个子结点的树叫做二叉树,左子树右子树是有顺序的,不能颠倒,即使只有一颗子树,也区分左右子树 (二叉查找) 二叉树的五种基本形态 空二叉树 只有一个根结点的二叉树 根结点只有左子树 根结点只有右子树 根结点既有左子树又有右子树 特殊的二叉树满二叉树即所有分结点都有左子树和右子树 完全二叉树对二叉树的每个结点按顺序进行编号,与满二叉树进行对比,没有编号空档的树就完全二叉树,同理可以,满二叉树一定是完全二叉树,但完全二叉树不一定是满二叉树 斜树只有左子树或者右子树的二叉树 二叉树的性质性质一:在二叉树的第i层==至多有2^(i-1)个结点==(i&gt;=1) 解释:第一层1个,第二层2个,第三层4个 ……. 性质二:深度为k的二叉树==至多有2^k - 1 个结点== 解释: 只有有一层,一个结点 有两层,1+2 = 3 = 2^2 - 1个 有三层,1+2+4 = 2^3 - 1 = 7个结点 有四层, 1+2+4+8 = 2^4 - 1 = 15 个结点 ……. 性质三:n0 = n2 + 1 (即叶子结点数 = 度为二的结点数 + 1 ) 解释: 根据树的性质: 树结点总数n = 总分支数 + 1 总分支数 = ==n1*1 + n2* 2== (其中n1,n2分别为度为1的结点数和度为2的结点数 ) 此外 ==n = n0 + n1 + n2== , 联立等式: n0 + n1 + n2 = 0*n0 + 1* n1 + 2* n2 , ==得 n0 = n2 + 1== ​ 7.图Graph(重点)图的定义:图是由顶点(Vertex)和边(Edge)构成的,记为 G = (V,E), 根据图的边是否有方向区分有向图和无向图, 图的相关概念:顶点的出度和入度顶点所关联的边的个数称为该顶点的度,此外,有向图的度又分为出度和入度 邻接点和端点:若一条边链接了A,B两个顶点,则称A,B互为邻接点,此外,有向图还有起始端点和终止端点,出边邻接点和入边邻接点 完全图:任意顶点之间存在一条边(有向图为两条)的图称为完全图,有 n(n-1)/2条边 带权图稠密图和稀疏图子图路径和路劲长度路径长度是指**:经过边的数目** 回路和环连通图,连通分量关结点和重连通图图的存储结构:邻接矩阵存储方法非带权图: 分析1：无向图的邻接矩阵是对称的； 分析2：顶点i的度=第i行（列）中1的个数； 特别：完全图的邻接矩阵中，对角元素为0，其余1。 带权图:","categories":[{"name":"计算机基础理论","slug":"计算机基础理论","permalink":"https://lqy679.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"第三方支付接口调用系列","slug":"第三方接口调用系列","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-25T09:10:07.700Z","comments":true,"path":"2020/01/01/第三方接口调用系列/","link":"","permalink":"https://lqy679.github.io/2020/01/01/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E7%B3%BB%E5%88%97/","excerpt":"支付宝支付接口由于正式功能需要拥有营业执照和网站备案才能正常使用,所以如下将以不需要营业执照和备案的沙箱开发环境在电脑版网站进行演示, 查看沙箱环境说明传送门: 支付宝开放平台 (alipay.com) , 进入之后应该这样如图所示 , 随后点击 沙箱工具 , 下载沙箱版支付宝,后续测试会用到","text":"支付宝支付接口由于正式功能需要拥有营业执照和网站备案才能正常使用,所以如下将以不需要营业执照和备案的沙箱开发环境在电脑版网站进行演示, 查看沙箱环境说明传送门: 支付宝开放平台 (alipay.com) , 进入之后应该这样如图所示 , 随后点击 沙箱工具 , 下载沙箱版支付宝,后续测试会用到 随后在点击 左边的沙箱账号, 在安卓手机安装好沙箱版支付宝后, 需要登陆沙箱账号来使用, 需要注意登陆的是买家账号, 还可以对买家账号的余额信息进行修改, 然后先将此网页保留,等会还有用 获取SDK&amp;Demo官方提供了一个JDK1.6 + Tomcat环境运行的JavaWeb程序Demo, 这里直接贴出传送门,也可以去支付宝开发平台执行寻找 官方文档: SDK &amp; Demo 获取 - 支付宝文档中心 (alipay.com) 下载传动门: 点我直接下载 此Demo是一个javaWeb项目, 用eclipse或者ieda打开均可, 注意阅读readme.txt 修改配置类打开解压好的Deme文件夹, 在src/com.alipay.config下, 有一个配置类AliPay, 内容如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.alipay.config;import java.io.FileWriter;import java.io.IOException;/* * *类名：AlipayConfig *功能：基础配置类 *详细：设置帐户有关信息及返回路径 *修改日期：2017-04-05 *说明： *以下代码只是为了方便商户测试而提供的样例代码，商户可以根据自己网站的需要，按照技术文档编写,并非一定要使用该代码。 *该代码仅供学习和研究支付宝接口使用，只是提供一个参考。 */public class AlipayConfig &#123; //↓↓↓↓↓↓↓↓↓↓请在这里配置您的基本信息↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ // 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号 public static String app_id = &quot;********&quot;; // 商户私钥，您的PKCS8格式RSA2私钥 public static String merchant_private_key = &quot;MIIEvgIBADANBgkqhkiG9w0BAQE&quot;; // 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥。 public static String alipay_public_key = &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCg&quot;; // 服务器异步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 public static String notify_url = &quot;http://localhost:8080/alipay_demo/notify_url.jsp&quot;; // 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 public static String return_url = &quot;http://localhost:8080/alipay_demo/return_url.jsp&quot;; // 签名方式 public static String sign_type = &quot;RSA2&quot;; // 字符编码格式 public static String charset = &quot;utf-8&quot;; // 支付宝网关 public static String gatewayUrl = &quot;https://openapi.alipaydev.com/gateway.do&quot;; // 支付宝网关 public static String log_path = &quot;E:\\\\Code\\\\第三方开发者相关\\\\alipay.trade.page.pay-JAVA-UTF-8&quot;;//↑↑↑↑↑↑↑↑↑↑请在这里配置您的基本信息↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ /** * 写日志，方便测试（看网站需求，也可以改成把记录存入数据库） * @param sWord 要写入日志里的文本内容 */ public static void logResult(String sWord) &#123; FileWriter writer = null; try &#123; writer = new FileWriter(log_path + &quot;alipay_log_&quot; + System.currentTimeMillis()+&quot;.txt&quot;); writer.write(sWord); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 我们还要根据之前打开的沙箱环境说明网页 支付宝开放平台 (alipay.com) , 查看对应的配置信息, 服务器异步通知页面路径不用管,这个需要公网ip, 页面跳转同步页面路径自行定位到项目的return_url.jsp文件,其他基本上不用改 至此,配置就已经结束了 启动Demo修改好以后, 想正常JavaWeb项目一下,通过Tomcat启动即可, 如下所示便是启动成功了 随后根据自己需要定制修改Demo即可 Demo简单介绍首页index.jsp, 包含四个表单, 分别对应四大功能, 每个表单都会跳转到对应的JSP页面, 对应的JSP则会包含对应的逻辑代码,直接将JSP的逻辑代码转换成自己需要的业务代码即可 根据Demo自定义代码我根据Demo结合自己需要制定了自己的接口代码 , 注意,配置类基本上通过Demo跑通后不怎么需要改,根据自己项目改一下return_url配置项即可 引入依赖注: 官方的Demo项目已经自动导入Jar包了 个人推荐使用Maven引入 123456&lt;!-- https://mvnrepository.com/artifact/com.alipay.sdk/alipay-sdk-java --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;4.35.37.ALL&lt;/version&gt; &lt;/dependency&gt; 付款付款表单传参:12345678910111213&lt;html &gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;支付测试页面&lt;/h2&gt;&lt;form method=&quot;post&quot; action=&quot;/AliPay&quot; target=&quot;_blank&quot; &gt; &lt;input type=&quot;text&quot; name=&quot;WIDtotal_amount&quot; placeholder=&quot;付款金额&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;WIDsubject&quot; placeholder=&quot;订单名称&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;WIDbody&quot; placeholder=&quot;商品描述(可选)&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;确定付款&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 付款接口:支付宝官方付款接口接收正确参数后, 返回的result 是一个html文本,其内容是一个官方的支付页面,支付操作(如二维码)均在该网页上, 所以我们要将其内容输出成网页,才能进行付款 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package my_api;import javax.servlet.*;import java.io.IOException;import java.util.*;import com.alipay.api.*;import com.alipay.api.request.AlipayTradePagePayRequest;import config.AlipayConfig;@WebServlet(name = &quot;AliPay&quot;, value = &quot;/AliPay&quot;)public class AliPay extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获得初始化的AlipayClient AlipayClient alipayClient = new DefaultAlipayClient( AlipayConfig.gatewayUrl, AlipayConfig.app_id, AlipayConfig.merchant_private_key, &quot;json&quot;, AlipayConfig.charset, AlipayConfig.alipay_public_key, AlipayConfig.sign_type); //设置请求参数 AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest(); alipayRequest.setReturnUrl(AlipayConfig.return_url); // 支付完成后跳转页面的url alipayRequest.setNotifyUrl(AlipayConfig.notify_url); // 异步通知的url //商户订单号，商户网站订单系统中唯一订单号，必填 String out_trade_no = String.valueOf(new Date().getTime()); //付款金额，必填 String total_amount = new String(req.getParameter(&quot;WIDtotal_amount&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); //订单名称，必填 String subject = new String(req.getParameter(&quot;WIDsubject&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); //商品描述，可空 String body = new String(req.getParameter(&quot;WIDbody&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); // 传递 JSON 字符串 alipayRequest.setBizContent(&quot;&#123;\\&quot;out_trade_no\\&quot;:\\&quot;&quot;+ out_trade_no +&quot;\\&quot;,&quot; + &quot;\\&quot;total_amount\\&quot;:\\&quot;&quot;+ total_amount +&quot;\\&quot;,&quot; + &quot;\\&quot;subject\\&quot;:\\&quot;&quot;+ subject +&quot;\\&quot;,&quot; + &quot;\\&quot;body\\&quot;:\\&quot;&quot;+ body +&quot;\\&quot;,&quot; + &quot;\\&quot;product_code\\&quot;:\\&quot;FAST_INSTANT_TRADE_PAY\\&quot;&#125;&quot;); //请求 String result = null; try &#123; /* result的内容是一个html文本,即一个支付宝官方支付页面 */ result = alipayClient.pageExecute(alipayRequest).getBody(); &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); &#125; resp.setContentType(&quot;text/html;charset=utf-8&quot;); resp.getWriter().write(result); &#125;&#125; 支付通知接口在支付页面完成支付支付后会携带订单信息去请求return_url配置好的url , 所以我return_url配置的是我自己定义的接口的url 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package my_api;import com.alipay.api.AlipayApiException;import com.alipay.api.internal.util.AlipaySignature;import config.AlipayConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;import java.io.IOException;import java.util.*;@WebServlet(name = &quot;AliPayReturn&quot;, value = &quot;/AliPayReturn&quot;)public class AliPayReturn extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取支付宝GET过来反馈信息 Map&lt;String,String&gt; params = new HashMap&lt;String,String&gt;(); Map&lt;String,String[]&gt; requestParams = req.getParameterMap(); for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext();) &#123; String name = (String) iter.next(); String[] values = (String[]) requestParams.get(name); String valueStr = &quot;&quot;; for (int i = 0; i &lt; values.length; i++) &#123; valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + &quot;,&quot;; &#125; //乱码解决，这段代码在出现乱码时使用 valueStr = new String(valueStr.getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); params.put(name, valueStr); &#125; boolean signVerified = false; //调用SDK验证签名 try &#123; signVerified = AlipaySignature.rsaCheckV1( params, AlipayConfig.alipay_public_key, AlipayConfig.charset, AlipayConfig.sign_type); &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); &#125; //——请在这里编写您的程序（以下代码仅作参考）—— if(signVerified) &#123; String out_trade_no = new String(req.getParameter(&quot;out_trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); String trade_no = new String(req.getParameter(&quot;trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); String total_amount = new String(req.getParameter(&quot;total_amount&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); System.out.println(&quot;支付成功!&quot;); System.out.println(&quot;商家订单号 out_trade_no:&quot;+ out_trade_no); System.out.println(&quot;支付宝交易号 trade_no:&quot;+ trade_no); System.out.println(&quot;付款金额 total_amount:&quot;+ total_amount); &#125;else &#123; System.out.println(&quot;验签失败...&quot;); &#125; resp.setContentType(&quot;text/html;charset=utf-8&quot;); resp.getWriter().write(&quot;支付已完成,此时业务逻辑应该是重定向回付费后的页面&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 支付成功的实例这里遍历打印出支付成功通知传过来的参数来一下: 1234567891011121314//获取支付宝GET过来反馈信息 Map&lt;String,String&gt; params = new HashMap&lt;String,String&gt;(); Map&lt;String,String[]&gt; requestParams = req.getParameterMap(); System.out.println(&quot;===============================================&quot;); for (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext();)&#123; String keyName = iter.next(); String[] values = requestParams.get(keyName); System.out.print(keyName+&quot;: &quot;); for (String value : values) &#123; System.out.print(value+&quot;, &quot;); &#125; System.out.println(); &#125; 打印结果: 123456789101112charset: utf-8, out_trade_no: 1677242216894, method: alipay.trade.page.pay.return, total_amount: 100.00, sign: AIYTkBcPJ5EFyEP1bcThtZlKgR5FmkH5sLtLTwPLpFnBfJ3HixGT5b4TVJMUb9dzsJ8q+0kTqlySqe84dya0YHjGPJiLxdYJE51/5J+J8Dgm/C+OYkFIhF1xRMTrMSacfqTJJKF7drdAlIg3e1NUsqmtzwOFYxH0dClakcG/LUTh6bOvtKZcLPLEWCx11Z/ZKrOri8g8yLkhfgUO534aMr2mcehOv4QKcD+lhiJoGzuFXjP5gt7gc7snNBL1NR6OKyjSjWQltcOqlFpn+U3sdgQe1vBWcUCEuTnB9Wz0i3EZz6DAAFo7fNVqLpiTNlT56aRwRnCcqoK03Hc2c7ACbA==, trade_no: 2023022422001417350505702109, auth_app_id: 2021000122608700, version: 1.0, app_id: 2021000122608700, sign_type: RSA2, seller_id: 2088621995225195, timestamp: 2023-02-24 20:38:40, 交易查询交易查询传参:1234567&lt;h3&gt;交易信息查询&lt;/h3&gt;&lt;i&gt;支付宝交易号和商家订单号二选一即可&lt;/i&gt;&lt;form action=&quot;/Trade_Query&quot; method=&quot;get&quot; target=&quot;_blank&quot;&gt; out_trade_no&lt;input type=&quot;text&quot; name=&quot;out_trade_no&quot; placeholder=&quot;商家订单号&quot;&gt; &lt;br&gt; trade_no:&lt;input type=&quot;text&quot; name=&quot;trade_no&quot; placeholder=&quot;支付宝交易号&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;&lt;/form&gt; 交易查询接口官方交易查询接口接收正确参数后会返回一个JSON,详情请参考本节 响应参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package my_api;@WebServlet(name = &quot;Trade_Query&quot;, value = &quot;/Trade_Query&quot;)public class Trade_Query extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获得初始化的AlipayClient AlipayClient alipayClient = new DefaultAlipayClient( AlipayConfig.gatewayUrl, AlipayConfig.app_id, AlipayConfig.merchant_private_key, &quot;json&quot;, AlipayConfig.charset, AlipayConfig.alipay_public_key, AlipayConfig.sign_type); //设置请求参数 AlipayTradeQueryRequest alipayRequest = new AlipayTradeQueryRequest(); //商户订单号，商户网站订单系统中唯一订单号 String out_trade_no = new String(req.getParameter(&quot;out_trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); //支付宝交易号 String trade_no = new String(req.getParameter(&quot;trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); //请二选一设置 alipayRequest.setBizContent(&quot;&#123;\\&quot;out_trade_no\\&quot;:\\&quot;&quot;+ out_trade_no +&quot;\\&quot;,&quot;+&quot;\\&quot;trade_no\\&quot;:\\&quot;&quot;+ trade_no +&quot;\\&quot;&#125;&quot;); //请求 String result = null; try &#123; result = alipayClient.execute(alipayRequest).getBody(); &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); &#125; //输出 System.out.println(result); resp.setContentType(&quot;application/json&quot;); resp.getWriter().write(result); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 响应参数:1234567891011121314151617181920212223&#123; &quot;alipay_trade_query_response&quot;: &#123; &quot;code&quot;: &quot;10000&quot;, // 网关返回码,1wan表示成功, &quot;msg&quot;: &quot;Success&quot;, &quot;buyer_logon_id&quot;: &quot;oeh***@sandbox.com&quot;, // 买家支付宝账号 &quot;buyer_pay_amount&quot;: &quot;0.00&quot;, // 买家实付金额(不包括优惠等),沙箱环境为 0 &quot;buyer_user_id&quot;: &quot;2088722008317354&quot;, // 买家在支付宝的用户id &quot;buyer_user_type&quot;: &quot;PRIVATE&quot;, //买家用户类型。CORPORATE:企业用户；PRIVATE:个人用户。 &quot;invoice_amount&quot;: &quot;0.00&quot;, //可以给用户开具发票的金额, 沙箱环境(dev)环境为0 &quot;out_trade_no&quot;: &quot;1676906953829&quot;, // 商家订单号 &quot;point_amount&quot;: &quot;0.00&quot;, // 积分支付的金额 &quot;receipt_amount&quot;: &quot;0.00&quot;, // 商户账户能够实际收到的金额 dev环境为0 &quot;send_pay_date&quot;: &quot;2023-02-20 23:30:02&quot;, // 订单发起日期 &quot;total_amount&quot;: &quot;0.02&quot;, // 订单金额(单位: 元) &quot;trade_no&quot;: &quot;2023022022001417350505699289&quot;, // 支付宝交易号 &quot;trade_status&quot;: &quot;TRADE_SUCCESS&quot; /* 交易状态: WAIT_BUYER_PAY（交易创建，等待买家付款）、TRADE_CLOSED（未付款交易超时关闭，或支付完成后全额退款）、TRADE_SUCCESS（交易支付成功）、TRADE_FINISHED（交易结束，不可退款） */ &#125;, &quot;sign&quot;: &quot;E//n8ZmikaeWLp92XUsn5YYxPEsReVB3BhLD1RSzJOXFK4B/LyIwPhO6iRqnDNi7HJf8zPy6eyYgbe7KEqlQjKHweJK9QjCqzxyghqGPCg94Y5S0xCJQgCKG0muvqJDBBeO+xmdPD4o4FIaXIUajQrLj+2A18QC36BEhCZ35eLYOnYZPdnjQ5PT6WiM3p7cY26YA37LL+WD0Vf2aqWRHdqyDUOaGqw/xyHsCnFCtXf+kms3dfl19fmGLbvlALZ3r4+kHfc99BhnatEfJqGnZIBs85Ibm55eg6x9QIPMgTJzXjM13LVUU4VuIEHdp7bmEMWurOGV60Wua6RFTAaZAXg==&quot;&#125; 退款传参表表单:12345678910111213&lt;h3&gt;退款&lt;/h3&gt;&lt;form action=&quot;/Refund&quot; method=&quot;post&quot; target=&quot;_blank&quot;&gt; &lt;i&gt; 商家订单号和支付宝订单号二选一,退款金额必选(且小于订单交易金额), 如果需要分批退款需要填写退款请求号 &lt;/i&gt; &lt;br&gt; out_trade_no: &lt;input type=&quot;text&quot; name=&quot;out_trade_no&quot; placeholder=&quot;商家订单号(二选一)&quot;&gt; &lt;br&gt; trade_no: &lt;input type=&quot;text&quot; name=&quot;trade_no&quot; placeholder=&quot;支付宝交易号(二选一)&quot;&gt; &lt;br&gt; refund_amount:&lt;input type=&quot;text&quot; name=&quot;refund_amount&quot; placeholder=&quot;退款金额(必填)&quot;&gt; &lt;br&gt; out_request_no:&lt;input type=&quot;text&quot; name=&quot;out_request_no&quot; placeholder=&quot;退款请求号(按需填写)&quot;&gt; &lt;br&gt; refund_reason:&lt;input type=&quot;text&quot; name=&quot;refund_reason&quot; placeholder=&quot;退款原因(选填)&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;退款&quot;&gt;&lt;/form&gt; 退款接口注: 经测试,在dev环境下分批退款功能并不好用, 不建议在dev环境下使用分批退款功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package my_api;@WebServlet(name = &quot;Refund&quot;, value = &quot;/Refund&quot;)public class Refund extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获得初始化的AlipayClient AlipayClient alipayClient = new DefaultAlipayClient( AlipayConfig.gatewayUrl, AlipayConfig.app_id, AlipayConfig.merchant_private_key, &quot;json&quot;, AlipayConfig.charset, AlipayConfig.alipay_public_key, AlipayConfig.sign_type); //设置请求参数 AlipayTradeRefundRequest alipayRequest = new AlipayTradeRefundRequest(); //商户订单号，商户网站订单系统中唯一订单号 String out_trade_no = new String(req.getParameter(&quot;out_trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); //支付宝交易号 String trade_no = new String(req.getParameter(&quot;trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); //请二选一设置 //需要退款的金额，该金额不能大于订单金额，必填 String refund_amount = new String(req.getParameter(&quot;refund_amount&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); //退款的原因说明 String refund_reason = new String(req.getParameter(&quot;refund_reason&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); //标识一次退款请求，同一笔交易多次退款需要保证唯一，如需部分退款，则此参数必传 String out_request_no = new String(req.getParameter(&quot;out_request_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); alipayRequest.setBizContent(&quot;&#123;\\&quot;out_trade_no\\&quot;:\\&quot;&quot;+ out_trade_no +&quot;\\&quot;,&quot; + &quot;\\&quot;trade_no\\&quot;:\\&quot;&quot;+ trade_no +&quot;\\&quot;,&quot; + &quot;\\&quot;refund_amount\\&quot;:\\&quot;&quot;+ refund_amount +&quot;\\&quot;,&quot; + &quot;\\&quot;refund_reason\\&quot;:\\&quot;&quot;+ refund_reason +&quot;\\&quot;,&quot; + &quot;\\&quot;out_request_no\\&quot;:\\&quot;&quot;+ out_request_no +&quot;\\&quot;&#125;&quot;); //请求 String result = null; try &#123; result = alipayClient.execute(alipayRequest).getBody(); &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); &#125;// System.out.println(result); resp.setContentType(&quot;application/json&quot;); resp.getWriter().write(result); &#125;&#125; 响应参数123456789101112131415&#123; &quot;alipay_trade_refund_response&quot;: &#123; &quot;code&quot;: &quot;10000&quot;, // 网关响应码,1xxx表示请求成功,4xxx参数不合法或业务失败 &quot;msg&quot;: &quot;Success&quot;, &quot;buyer_logon_id&quot;: &quot;oeh***@sandbox.com&quot;, &quot;buyer_user_id&quot;: &quot;2088722008317354&quot;, &quot;fund_change&quot;: &quot;Y&quot;, // 为&quot;Y&quot;表示退款成功，为&quot;N&quot;或无此字段值返回时需进一步确认退款状态 &quot;gmt_refund_pay&quot;: &quot;2023-02-21 09:44:52&quot;, // 退款发起时间 &quot;out_trade_no&quot;: &quot;1676943777596&quot;, // 退款的商家订单号 &quot;refund_fee&quot;: &quot;120.00&quot;, // 退款金额 &quot;send_back_fee&quot;: &quot;0.00&quot;,//本次商户实际退回金额,获取此参数需传参 refund_detail_item_list,dev环境为0 &quot;trade_no&quot;: &quot;2023022122001417350505699565&quot; // 退款的支付宝交易号 &#125;, &quot;sign&quot;: &quot;d/Jg3gCWCPQTBZUGEXaiTDR4IB4hcyEZuUMPPswgERImQiuykeQAelAzWAWCU9zhxfVtaTHkl/ksSw4cVLhjX+UWqN+mWdy0bjlHTphFPy0Ko2sidCNuUgJkg7TlgVPFn20OVBlyL70WfmErIQW8pSWXXNPS/0OUUxS28ZXFk+abvdGUko2lTeJZlnyZvOwpEagFV+wItt2KoJJPF+v9==&quot;&#125; 交易关闭这里需要注意一下, 只有当用户扫码以后支付宝才认为该订单才已经创建(无论是否输入密码),而不是从打开支付页面就认为是创建订单了 ,关闭交易需要提供商户订单号或者支付宝交易号二选一 经测试,dev环境下即使成功提交了关闭交易的请求,但是支付页面任然不会关闭,简而言之,dev环境下不好使 交易关闭接口1234567891011121314151617181920212223242526272829303132333435363738package my_api;@WebServlet(name = &quot;Trade_Close&quot;, value = &quot;/Trade_Close&quot;)public class Trade_Close extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获得初始化的AlipayClient AlipayClient alipayClient = new DefaultAlipayClient( AlipayConfig.gatewayUrl, AlipayConfig.app_id, AlipayConfig.merchant_private_key, &quot;json&quot;, AlipayConfig.charset, AlipayConfig.alipay_public_key, AlipayConfig.sign_type); //设置请求参数 AlipayTradeCloseRequest alipayRequest = new AlipayTradeCloseRequest(); //商户订单号，商户网站订单系统中唯一订单号 String out_trade_no = new String(req.getParameter(&quot;out_trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); //支付宝交易号 String trade_no = new String(req.getParameter(&quot;trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); //请二选一设置 alipayRequest.setBizContent(&quot;&#123;\\&quot;out_trade_no\\&quot;:\\&quot;&quot;+ out_trade_no +&quot;\\&quot;,&quot; +&quot;\\&quot;trade_no\\&quot;:\\&quot;&quot;+ trade_no +&quot;\\&quot;&#125;&quot;); //请求 String result = null; try &#123; result = alipayClient.execute(alipayRequest).getBody(); &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); &#125; resp.setContentType(&quot;application/json&quot;); resp.getWriter().write(result); &#125;&#125; 响应参数:关闭成功示例: 123456789&#123;&quot;alipay_trade_close_response&quot;: &#123;&quot;code&quot;: &quot;10000&quot;,&quot;msg&quot;: &quot;Success&quot;,&quot;out_trade_no&quot;: &quot;1676947748103&quot;,&quot;trade_no&quot;: &quot;2023022122001417350505699903&quot;&#125;,&quot;sign&quot;: &quot;DIQo8C7PQqqDSpFDgffXlKZkUT4HNNCFU+JU7IPWAfC/96vSp3u8IAdLK28AQF+irg8IE71HSQGKAYOQzQV2zJ9tCQgZ6Ar6KXT62WsOx3H6C+9U2VhVYXxZ6T2fZKo0lpAmfV5ceTk3TLtG9SDu5X05eshL2/jrafbF0zIsKi6rQYzjWvA6Ckql9ykDV4oMnSkqwnFoOLvqS1/WCVsrwahzjGImygd4TP5fMdjMtdsFhabKBLOR4y1jwizBQmEY/il1Rrvc8FEwl+Kj3ALzB37WX8bR5xpLAF4qoQwN6Aa5SyFjsWduU6w0jceDIiLAmTNDh39BbGDJEHYwZhEmwA==&quot;&#125; 关闭失败示例: 例如打开支付页面,但是用户并未扫码支付, 只要用户没扫码,支付宝就不会创建订单 12345678910&#123; &quot;alipay_trade_close_response&quot;: &#123; &quot;code&quot;: &quot;40004&quot;, &quot;msg&quot;: &quot;Business Failed&quot;, &quot;sub_code&quot;: &quot;ACQ.TRADE_STATUS_ERROR&quot;, &quot;sub_msg&quot;: &quot;当前交易状态不支持此操作&quot;, &quot;out_trade_no&quot;: &quot;1676939500345&quot; &#125;, &quot;sign&quot;: &quot;kxvgo7aQ0w+kNIpEhSz8yrND2AdVOjwfLFunzKTpMYozPcviiqUh3z18ToWlWxTFEd2lYv+/IKFzZtyrChRuq447FIISsbTvGNRplnlEyi712vDIF1ttVuCFcYmx+3Pm/eq0s5MaWZ9q8M+t0uywdU0IAlSJDrzjEusd/XdbZBzsOKdrBAcQgsy8vmhV9X6JuSyoHg8QgQi0GHGfO//WIaGrmLVLJXCYfjfg0Shftv5ShgchBBDBf1wQgWty7WCZTqOUIE54Pyq8Rni2GLMjq2N6zRSwbulbRihoHxGqC9rE5chxL8/+yCdi9SsuwuoXj86pqj7s851TAET72oDt6A==&quot;&#125;","categories":[{"name":"第三方服务接口调用","slug":"第三方服务接口调用","permalink":"https://lqy679.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"}],"tags":[]},{"title":"编译原理","slug":"编译原理","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T09:13:00.065Z","comments":true,"path":"2020/01/01/编译原理/","link":"","permalink":"https://lqy679.github.io/2020/01/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","excerpt":"编译原理 参考引用: 编译原理：编译过程概述 - 牛犁heart - 博客园 (cnblogs.com) 【编译原理】编译的过程_Imutaku的博客-CSDN博客-编译原理 编译与解释计算机程序设计语言通常分为机器语言、汇编语言和高级语言三类。高级语言需要翻译成机器语言才能执行，而翻译的方式分为两种，一种是编译，另一种是解释。下面会总结编译和解释的区别。","text":"编译原理 参考引用: 编译原理：编译过程概述 - 牛犁heart - 博客园 (cnblogs.com) 【编译原理】编译的过程_Imutaku的博客-CSDN博客-编译原理 编译与解释计算机程序设计语言通常分为机器语言、汇编语言和高级语言三类。高级语言需要翻译成机器语言才能执行，而翻译的方式分为两种，一种是编译，另一种是解释。下面会总结编译和解释的区别。 产物不同: 编译（Compile）:的过程是把整个源程序代码翻译成另外一种代码，翻译后的代码等待被执行或者被优化等等，发生在运行之前,产物是另一份代码(目标代码,如.exe文件,依赖于机器)。运行时并不需要编译器参与,故执行效率较高,速度较快 解释（Interpret）:的过程是把源程序代码一行一行的读懂，然后一行一行的执行，发生在运行时，产物是运行结果。运行时需要解释器参与,故执行效率较低,速度较慢 所以，编译和解释的输入都是源程序代码（有可能是源码，字节码等等），但是输出是不同的。有一张图可以比较形象的解释他们的区别： 编译型语言和解释型语言语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式。理论上，任何编程语言都可以是编译型或解释型的。但是，会根据其主流实现方式来把语言分为“编译型语言”和“解释型语言”。 C/C++/C#等都是编译型语言。以C语言为例，源代码被编译之后生成中间文件（.o和.obj），然后用链接器和汇编器生成机器码，也就是一系列基本操作的序列，机器码最后被执行生成最终动作。 Lisp/R/Python等都是解释型语言。 其实许多编程语言同时采用编译器与解释器来实现，这就包括Python，Java等，先将代码编译为字节码，在运行时再进行解释。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已 。 **总结:**编译和解释的过程上的区别：编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。 编译和解释结果上的区别：编译的话会把输入的源程序翻译生成为目标代码，并存下来（无论是存在内存中还是磁盘上），后续执行可以复用；解释的话则是把源程序中的指令逐条解释，不生成也不存下目标代码，后续执行没有多少可复用的信息。 编译的过程被隐藏的过程 预处理（Prepressing）- 展开宏定义（处理#define，#include），删除注释，添加行号和文件名标识。生成.i 预处理文件 编译（Compilation）- 词法分析、语法分析、语义分析、优化。预处理+编译用ccl完成。生成.s 汇编代码文件 汇编（Assembly）- 把汇编代码转成机器可执行的指令，不需要做指令优化。用汇编器as 完成。生成.o 目标文件(object file) 链接（Linking）- 用链接器ld完成。 值得注意的是: 在编译器中: “生成n中间代码” 和 “优化” 这个两个过程不是必需的 在解释器中: “优化” 和 “生成目标代码” 这两个过程不是必需的* 词法分析（Lexical Analysis）将字符串转换为Token的这个过程就叫做词法分析 , 词法分析的主要任务是把源文件的字符流转换成==记号流== 源代码进入扫描器，用有限状态机 把源代码的字符分割成Token。Token 一般包括关键字、标识符、字面量、特殊符号。 同时，扫描器也会完成其他工作，例如将标识符放到符号表，将数字、字符串常量放到文字表等。 lex，可以根据用户描述好的词法规则，来进行词法扫描的，词法扫描器。 语法分析（Syntactic Analysis）语法分析： 需要让编译器想理解自然语言一样，理解它的语法结构, 检查有没有语法错误 如 缺少分号, if - else 不匹配, 括号不匹配, 使用了保留字作为变量名等 , 语法分析的主要任务是根据语法规则识别出记号流的结构(短语,句子),并构造一棵正确反映结构的==语法树==比如说：“我喜欢又聪明又勇敢的你”，它的语法结构可以表示成下面这样的树状结构。 在编译器里，语法分析阶段会把Token串，转换成一个体现语法规则的/树状的数据结构，这个数据结构就叫做抽象语法树(AST, Abstract Syntax Tree) 语义分析（Semantic Analysis）语义分析的重要特点：做上下文相关的分析 。 完成静态语义分析（编译时确定的语义是静态的，运行时确定的是动态的，编译器只能完成静态语义分析）。==静态语义分析一般包括声明和类型的匹配、类型转换==等。 例如，在语法分析得到的ST中，可能出现两个指针做乘法；在经过语义分析后，判定这是不合法的。 动态语义是运行时出现的语义问题，例如将0作为除数。这是不能被编译器检查到的。 经过语义分析后，ST的所有节点被标识了类型，对于隐式转换的，会插入相应转换节点。语义分析器还会对符号表中的符号类型也做更新。 中间代码生成（Intermediate Representation）中间代码IR,是处于源代码和目标代码之间的一种表示形式。 中间代码的表现形式有: 后缀式(逆波兰式) , 三元式(三地址码) , 四元式 , 树 等形式 中间代码IR非常接近目标代码，但是==IR与目标机器和运行时环境无关==（目标代码依赖于目标机器,中间代码不依赖） 使用IR有多个原因： 是很多解释型的语言，可以直接执行 IR，比如 Python 和 Java。这样的话，编译器生成 IR 以后就完成任务了，没有必要生成最终的汇编代码。 在生成代码的时候，需要做大量的优化工作。而很多优化工作没必要基于汇编代码来做，而是可以IR,用统一的算法来完成。 优化（Optimization）为什么需要优化工作呢？ 是源语言和目标语言有差异 程序员写的代码不是最优的，而编译器会帮忙纠正 采用中间代码来编写优化算法的好处，是可以把大部分的优化算法，写成与具体 CPU 架构无关的形式，从而大大降低编译器适配不同 CPU 的工作量。并且，如果采用像 LLVM 这样的工具，我们还可以让多种语言的前端生成相同的中间代码，这样就可以复用中端和后端的程序了。 生成目标代码注意: 分配寄存器的工作也在此阶段进行 编译器最后一个阶段的工作，是生成高效率的目标代码，也就是汇编代码。这个阶段，编译器也有几个重要的工作。 第一，是要选择合适的指令，生成性能最高的代码。 第二，是要优化寄存器的分配，让频繁访问的变量（比如循环变量）放到寄存器里，因为访问寄存器要比访问内存快 100 倍左右。 第三，是在不改变运行结果的情况下，对指令做重新排序，从而充分运用 CPU 内部的多个功能部件的并行计算能力。","categories":[{"name":"计算机基础理论","slug":"计算机基础理论","permalink":"https://lqy679.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"设计模式","slug":"设计模式","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T09:18:07.059Z","comments":true,"path":"2020/01/01/设计模式/","link":"","permalink":"https://lqy679.github.io/2020/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"设计模式面向对象设计原则常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。 设计原则名称 设计原则简介 单一职责原则（Single Responsibility Principle, SRP） 类的职责要单一，不能将太多的职责放在一个类中 开闭原则（Open-Closed Principle, OCP） 软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能 里氏代换原则（Liskov Substitution Principle, LSP） 在软件系统中，一个可以接受基类(父类)对象的地方必然可以接受一个子类对象 依赖倒转原则（Dependency Inversion Principle, DIP） 要针对抽象层编程，而不要针对具体类编程 接口隔离原则（Interface Segregation Principle, ISP） 使用多个专门的接口来取代一个统一的接口 合成复用原则（Composite Reuse Principle, CRP） 在系统中应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系 迪米特法则（Law of Demeter, LoD） 一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互 共同封闭 指因某个原因而需要修改的所有类,都应封闭在一个包里,一个变化若对一个封闭包中的类产生影响,则将对该包中的所有类产生影响,而对其他包则不造成任何影响 共同重用 指一个包中的所有类应该是共同重用的,即如果重用了包中的一个类,那么就要重用包中所有类","text":"设计模式面向对象设计原则常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。 设计原则名称 设计原则简介 单一职责原则（Single Responsibility Principle, SRP） 类的职责要单一，不能将太多的职责放在一个类中 开闭原则（Open-Closed Principle, OCP） 软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展其功能 里氏代换原则（Liskov Substitution Principle, LSP） 在软件系统中，一个可以接受基类(父类)对象的地方必然可以接受一个子类对象 依赖倒转原则（Dependency Inversion Principle, DIP） 要针对抽象层编程，而不要针对具体类编程 接口隔离原则（Interface Segregation Principle, ISP） 使用多个专门的接口来取代一个统一的接口 合成复用原则（Composite Reuse Principle, CRP） 在系统中应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系 迪米特法则（Law of Demeter, LoD） 一个软件实体对其他实体的引用越少越好，或者说如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互 共同封闭 指因某个原因而需要修改的所有类,都应封闭在一个包里,一个变化若对一个封闭包中的类产生影响,则将对该包中的所有类产生影响,而对其他包则不造成任何影响 共同重用 指一个包中的所有类应该是共同重用的,即如果重用了包中的一个类,那么就要重用包中所有类 设计模式简介设计模式总共分为三大类,共计23种设计模式,四大类为: 创建型模式 结构型模式 行为型模式 J2EE设计模式 常见设计模式创建型模式工厂模式定义创建对象的接口,让其子类自己决定实例化哪一个工厂类,工厂模式使其创建过程延迟到子类进行 介绍:意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 优点: 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点: 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 实现:我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。 FactoryPatternDemo 类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 抽象工厂模式围绕一个超级工厂创建其他工厂.该超级工厂又称为其它工厂的工厂. 在抽象工厂模式中,接口是负责创建一个相关对象的工厂,不需要显式指定他们的类.每个生成的工厂都能按照工厂模式提供对象 介绍:意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 注意事项：产品族难扩展，产品等级易扩展。 实现:我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。 AbstractFactoryPatternDemo 类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。 单例模式此模式涉及到一个单一的类,该类负责创建自己对象,同时确保只有单个对象被创建.这个类提供了一种访问其唯一的对象的方式,可以直接访问,不需要实例化该类的对象 注意: 单例类只能有一个实例 单例类必须创建自己的唯一实例 单例类必须给所以其他对象提供这一实例 介绍:意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个班级只有一个班主任。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现:注意构造函数私有的,我们将创建一个SingleObject类有它的私有构造函数何本身的一个静态实例. SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo 类使用 SingleObject 类来获取 SingleObject 对象。 建造者模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 介绍:意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 实现:我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。 我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。 然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo 类使用 MealBuilder 来创建一个 Meal。 原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能.它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 介绍:意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 主要解决：在运行期建立和删除原型。 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。 关键代码： 1、实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。 应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。 优点： 1、性能提高。 2、逃避构造函数的约束。 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。 实现:我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。PrototypePatternDemo 类使用 ShapeCache 类来获取 Shape 对象。 结构型模式适配器模式适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。 介绍:意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 如何解决：继承或依赖（推荐）。 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 实现:有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。 默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。 我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。 我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们*需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。* AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo 类使用 AudioPlayer 类来播放各种格式。 桥接模式桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。 介绍:意图：将抽象部分与实现部分分离，使它们都可以独立的变化。 主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。 何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。 如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。 关键代码：抽象类依赖实现类。 应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。 优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。 实现:我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo 类使用 Shape 类来画出不同颜色的圆。 java代码实现: 创建桥接实现接口 DrawAPI.java 123public interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125; 创建实现了 DrawAPI 接口的实体桥接实现类。 RedCircle.java 1234567public class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: red, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125; GreenCircle.java 1234567public class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: green, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125; 使用 DrawAPI 接口创建抽象类 Shape.java。 1234567public abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw(); &#125; 创建实现了 Shape 抽象类的实体类。 Circle.java 1234567891011121314public class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;&#125; 使用 Shape 和 DrawAPI 类画出不同颜色的圆。 BridgePatternDemo.java 123456789public class BridgePatternDemo &#123; public static void main(String[] args) &#123; Shape redCircle = new Circle(100,100, 10, new RedCircle()); Shape greenCircle = new Circle(100,100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); &#125;&#125; 过滤器模式过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 实现:我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo 类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。 组成模式组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。 介绍:意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。 关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。 优点： 1、高层模块调用简单。 2、节点自由增加。 缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。 注意事项：定义时为具体类。 实现:我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo 类使用 Employee 类来添加部门层次结构，并打印所有员工。 装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。 介绍:意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。 何时使用：在不想增加很多子类的情况下扩展类。 如何解决：将具体功能职责划分，同时继承装饰者模式。 关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。 应用实例： 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。 注意事项：可代替继承。 实现:我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。 RedShapeDecorator 是实现了 ShapeDecorator 的实体类。 DecoratorPatternDemo 类使用 RedShapeDecorator 来装饰 Shape 对象。 创建一个接口：Shape.java 123public interface Shape &#123; void draw();&#125; 创建实现接口的实体类。Rectangle.java 1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Shape: Rectangle&quot;); &#125;&#125; Circle.java 1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Shape: Circle&quot;); &#125;&#125; 创建实现了 Shape 接口的抽象装饰类。ShapeDecorator.java 1234567891011public abstract class ShapeDecorator implements Shape &#123; protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape)&#123; this.decoratedShape = decoratedShape; &#125; public void draw()&#123; decoratedShape.draw(); &#125; &#125; 创建扩展了 ShapeDecorator 类的实体装饰类。RedShapeDecorator.java 12345678910111213141516public class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); &#125; @Override public void draw() &#123; decoratedShape.draw(); setRedBorder(decoratedShape); &#125; private void setRedBorder(Shape decoratedShape)&#123; System.out.println(&quot;Border Color: Red&quot;); &#125;&#125; DecoratorPatternDemo.java使用 RedShapeDecorator 来装饰 Shape 对象。 123456789101112131415161718public class DecoratorPatternDemo &#123; public static void main(String[] args) &#123; Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); //Shape redCircle = new RedShapeDecorator(new Circle()); //Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(&quot;Circle with normal border&quot;); circle.draw(); System.out.println(&quot;\\nCircle of red border&quot;); redCircle.draw(); System.out.println(&quot;\\nRectangle of red border&quot;); redRectangle.draw(); &#125;&#125; 外观模式外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 介绍:意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。 如何解决：客户端不与系统耦合，外观类与系统耦合。 关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。 应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。 优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。 缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。 注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。 实现:我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。 ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo 类使用 ShapeMaker 类来显示结果。 享元模式享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。 介绍:意图：运用共享技术有效地支持大量细粒度的对象。 主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 何时使用： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。 如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。 关键代码：用 HashMap 存储这些对象。 应用实例： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。 优点：大大减少对象的创建，降低系统的内存，使效率提高。 缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。 注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。 实现:我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。 ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。 FlyWeightPatternDemo 类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。 创建一个接口Shape.java。 123public interface Shape &#123; void draw();&#125; 创建实现接口的实体类Circle.java。 12345678910111213141516171819202122232425262728public class Circle implements Shape &#123; private String color; private int x; private int y; private int radius; public Circle(String color)&#123; this.color = color; &#125; public void setX(int x) &#123; this.x = x; &#125; public void setY(int y) &#123; this.y = y; &#125; public void setRadius(int radius) &#123; this.radius = radius; &#125; @Override public void draw() &#123; System.out.println(&quot;Circle: Draw() [Color : &quot; + color +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius); &#125;&#125; 创建一个工厂ShapeFactory.java，生成基于给定信息的实体类的对象。 12345678910111213141516import java.util.HashMap; public class ShapeFactory &#123; private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;(); public static Shape getCircle(String color) &#123; Circle circle = (Circle)circleMap.get(color); if(circle == null) &#123; circle = new Circle(color); circleMap.put(color, circle); System.out.println(&quot;Creating circle of color : &quot; + color); &#125; return circle; &#125;&#125; FlyweightPatternDemo.java使用该工厂，通过传递颜色信息来获取实体类的对象。 123456789101112131415161718192021222324public class FlyweightPatternDemo &#123; private static final String colors[] = &#123; &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; &#125;; public static void main(String[] args) &#123; for(int i=0; i &lt; 20; ++i) &#123; Circle circle = (Circle)ShapeFactory.getCircle(getRandomColor()); circle.setX(getRandomX()); circle.setY(getRandomY()); circle.setRadius(100); circle.draw(); &#125; &#125; private static String getRandomColor() &#123; return colors[(int)(Math.random()*colors.length)]; &#125; private static int getRandomX() &#123; return (int)(Math.random()*100 ); &#125; private static int getRandomY() &#123; return (int)(Math.random()*100); &#125;&#125; 代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 介绍:意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 实现:我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。 ProxyPatternDemo 类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。 创建一个接口Image.java 123public interface Image &#123; void display();&#125; 创建实现接口的实体类: RealImage.java 123456789101112131415161718public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123; System.out.println(&quot;Displaying &quot; + fileName); &#125; private void loadFromDisk(String fileName)&#123; System.out.println(&quot;Loading &quot; + fileName); &#125;&#125; 代理类:ProxyImage.java 1234567891011121314151617public class ProxyImage implements Image&#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display() &#123; if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125; 当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。ProxyPatternDemo.java 123456789101112public class ProxyPatternDemo &#123; public static void main(String[] args) &#123; Image image = new ProxyImage(&quot;test_10mb.jpg&quot;); // 图像将从磁盘加载 image.display(); System.out.println(&quot;&quot;); // 图像不需要从磁盘加载 image.display(); &#125;&#125;","categories":[{"name":"计算机基础理论","slug":"计算机基础理论","permalink":"https://lqy679.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"计算机网络","slug":"计算机网络","date":"2020-01-01T10:57:32.000Z","updated":"2023-02-22T09:16:02.811Z","comments":true,"path":"2020/01/01/计算机网络/","link":"","permalink":"https://lqy679.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"计算机网络1.计算机网络定义计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备通过通信线路链接起来,实现资源共享和信息传统 2.计算机网络的组成","text":"计算机网络1.计算机网络定义计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备通过通信线路链接起来,实现资源共享和信息传统 2.计算机网络的组成 资源子网:提供软件资源和硬件资源 通信子网:提供信息交换的网络结点和通信线路 3.计算机网络类型3.1按拓扑类型分类 星型结构 树形结构 总线型结构 环形结构 网状结构 3.2按范围分类 LAN(局域网):如校园网 MAN(城域网):如一个城市的网络 WAN(广域网):如一个国家的网络 *补充: * PAN个人区域网 Internet互联网 3.3 按传输方式分类(1)有线网络IEEE802.3 (2)无线网络IEE802.11 WLAN(无线局域网) WPAN(无线个人区域网) 4.计算机网络体系结构4.1传输方式 单工:只能单方向传输的工作模式 双工:在同一时间内,线路上只能允许一个方向的数据通过 全双工:双方可以同时进行数据通信 4.2传输对象 单播:一对一 多播:一对多 广播:一对all 4.3数据交换 电路交换:整个报文从头到尾连续的传输 报文交换:整个报文先传送道相邻结点,全部存储下来查找转发,再转发到下一个结点 分组交换:将一个报文分成多个分组,传送到相邻结点,再查找转发到下一个结点 5.通信协议和体系结构网络协议三要素: 语法 语义 时序 5.1 OSI 7层参考模型 网络设备详解:交换机,集线器,网桥,路由器,网关的区别 下层为上层服务 物理层:单位为bit,利用传送介质为通信结点之间的建立 两种信号:数字信号,模拟信号 设备:,中继器,集线器(多个中继器的集合) 编码和调制 编码:将信号转换成数字信号 调制:将信号转换成模拟信号 传输介质 双绞线 制作标准: 568B:橙白橙,绿白蓝,蓝白绿,棕白棕 568A:13调换,26调换 光纤 同轴电缆 无线 物理层-香农公式与奈式准则香农公式(重点)香农（Shannon）提出并严格证明了“在被高斯白噪声干扰的信道中，计算最大信息传送速率C公式”： ==C=W log 2(1+S/N)。==式中： C是最大信息传送速率(bps,比特每秒) W是信道带宽（赫兹,Hz）， S是信道内所传信号的平均功率（瓦）， N是信道内部的高斯噪声功率（瓦）。 **香农公式中的S/N是为信号与噪声的功率之比，为无量纲单位。(如果没分贝单位的信噪比可直接代入上式)**如：S/N=1000（即，信号功率是噪声功率的1000倍） 但是，当讨论信噪比时，常以分贝（dB）为单位。公式如下： 例题:电话系统的典型参数是信道带宽为3000Hz,信噪比为30dB,则该系统最大数据传输速率是多少? 30dB = 10log 2 (S/N) 则S/N = 1000 , c = 3000 x log2(1000+1) 约等于 = 30000bps 即 30kb/s 奈式准则奈奎斯特(Nyquist)推导出在理想低通(无噪声,带宽受限)下的最高码元传输速率的公式:理想低通信道的最高码元传输速率 = 2W Baud 上式就是著名的奈氏准则.奈氏准则的另一种表达方法是:每赫带宽的理想低通信道的最高码元传输速率是每秒2个码元. ==理想低通信道下的极限数据传输速率 c = 2W log2 V (单位:b/s)== 其中: W 为信道带宽.单位为Hz, V 为几种码元或者离散电平数目 注:奈式准则给出了码元传输速率的限制,但没用对信息传输速率给出限制,所以要想提高数据的传输速率就必须设法使每个码元携带更多个比特信息量,这就需要采用多元制的调制方法 例题: 数据链路层:单位:帧,建立在物理层的基础上,提供结点到结点之间的服务,采取差错控制和流量控制的方法实现网络互联 寻址依据:Mac地址,硬件地址,由网卡决定,全球唯一 设备:网桥, 交换机(多个网桥的集合) 帧的概念帧:数据链路层的协议数据单元 帧的组成 帧头:源mac地址,目的mac地址,类型 数据 帧尾:校验 以太网数据帧中的mac和LLCMAC:物理地址,用于对接网络层 LLC:逻辑控制访问,用于对接物理层 局域网中的设备集线器(Hub)–物理层:把对接收到的信号进行整形放大,以扩大网络的传输距离,同时在把所有结点集中到以他为中心的节点上 **交换机(Swtich)—数据链路层:**是一种用于电(光)信号转发的网络设备,他可以为接入交换机的任意两个网络提供独享的电信号通路 **网桥:**两个接口,可链接两个冲突域 数据链路层-通信协议 **冲突域:**采用物理协议,只能发生在同一网段,如交换机同一端口属于一个冲突域 广播域: 采用数据链路协议,可跨网段发生,如同一台交换域属于广播域 注:同一中冲突共享带宽 vlan(虚拟局域网)是一个物理LAN(局域网)在逻辑上划分为多个广播域的通信技术,vlan内的主机可以直接通信,而vlan间不能直接通信,从而将广播报文限制在一个vlan内 优点及目的: 划分广播域–减少垃圾数据 增强局域网的安全性 提高健壮性 灵活构建工作组 划分vlan方式: 基于端口,有三种模式, Access(只允许通过一个vlan) Trunk(允许通过多个vlan) Hybrid 基于子网 基于Mac地址 基于协议 基于匹配策略 CRC循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。 CSMA/CDPPP点对点协议（Point to Point Protocol，PPP）为在点对点连接上传输多协议数据包提供了一个标准方法。PPP 最初设计是为两个对等节点之间的 IP 流量传输提供一种封装协议。在 TCP-IP 协议集中它是一种用来同步调制连接的数据链路层协议（OSI模式中的第二层），替代了原来非标准的第二层协议，即 SLIP。除了 IP 以外 PPP 还可以携带其它协议，包括 DECnet 和 Novell 的 Internet 网包交换（IPX）。 网络层(提供路由,网络互联):数据的基础单位 : 数据包 单位:分组 ,提供点到点之间的通信,提供路由功能,实现拥塞控制,网络互联等功能 寻址依据:ip地址,IP地址由网络拓扑结构决定,根据ARP(地址解析协议,将ip映射到mac地址)来实现寻址 作用:实现两个端系统之间的数据透明,链接的建立,保持和终止等,他提供服务使传输层不需要了解网络中的数据传输和交换技术 设备:路由器 网络层-ip协议 ARP(地址解析协议): RARP(反地址解析协议) ICMP(网络控制报文协议) IGMP(网络组管理协议) 网络层-IP地址ip地址由网络拓扑结构决定,是IP协议提供的一种同一地址格式,他为互联网上的每一个网络每一台主机分配一个逻辑地址,以此来屏蔽物理地址(Mac)的差异 ip地址组成:4个字节,32位组成,一般用点分法十进制表示 IP地址组成IP地址由网络号和主机号组成 网络号:标识某一个网段的地址 主机号:标识某一个台设备的地址 **子网掩码:**和IP地址配套使用,用于区分IP地址的网络号和主机号 子网掩码中网络号为全1,主机号全0 ip地址分类 A类默认子网掩码为255.0.0 .0 B类默认子网掩码为255.255.0.0 C类默认子网掩码为255.255.255.0 特殊地址: 网络地址:主机号全为0不可用 广播地址:主机号全为1不可用 回环地址:127.0.0 IP地址类型以及规模 A类地址,用于大规模网网段,可容纳127(2^7 -1)个网段,每个网段课容纳16777214台主机 B类地址,用于中型网段,可容纳16384(2^14 - 1)个网段,每个网段可容纳65534台主机 C类地址,用于小型网段,可分配2097151个网段,每个网段容纳254台主机 子网划分(重点)划分子网时会将原来地址的主机号划分成网络号(子网号) 比如,192.168.1.0 24(24代表前24位为网络号) 192.168.1. 0000 0000 ,后8位位主机号,此网段可容纳254(2^8-2)台主机 192.168.1.0 25 ,两者是不一样的,后者将前者原本的主机号再次进行划分形成了两个子网 子网一:192.168.1.==0==000 0000 ,该子网可容纳主机数为126(2^7-2) 子网二:192.168.1.==1==000 0000 ,该子网可容纳主机数为126(2^7-2) 网络层-路由路由:路由是指分组从源到目的地时,决定端到端路径的网络范围的进程,路由是指导报文,转发的路径信息,通过路由可以确认转发ip报文的路径 **路由器:**网络层的基本设备,负责数据转发,一个端代表一个网段,路由器中存放着通往网段各个网段的表格,即路由表 **网关(Gateway):**又称网间连接器,协议转换器,用于两个高层协议不同网络互连,网关,既可以用于广域网互连,也可以用于局域网互连 路由的方式: 直连路由:直连路由是由链路层协议发现的，一般指去往路由器的接口地址所在网段的路径，直连路由无需手工配置，只要接口配置了网络协议地址同时管理状态、物理状态和链路协议均为UP时，路由器能够自动感知该链路存在，接口上配置的IP网段地址会自动出现在路由表中且与接口关联，并动态随接口状态变化在路由表中自动出现或消失。 静态路由:静态路由是由网络管理员根据网络拓扑，使用命令在路由器上配置的路由，这些静态路由信息指导报文发送，静态路由方式也无需路由器进行计算，但它完全依赖于网络管理员的手动配置。 补充一下，默认路由是一种特殊的静态路由,网络管理管理员手工配置了默认路由后，当路由表中与目的地址之间没有匹配的表项时路由器将把数据包发送给默认网关。 (一般用于小型变化不大的网络) 动态路由:动态路由是指路由器能够自动地建立自己的路由表，且能根据网络拓扑状态变化进行动态调整。动态路由机制依赖于对路由表的维护以及路由器间动态的路由信息交换。路由器间的路由信息交换是基于路由协议实现的，交换路由信息的最终目的是通过路由表找到“最佳”路由。 (一般用于大型网络) 动态路由协议:待补充传输层(建立链接进行可靠通信,端到端):数据基本单位: 数据报 提供端与端(端口号)之间的之间的数据传输协议,实现对数据进行控制和操作的功能,服务于应用层 负责维护两个结点之间的会话建立维护和断开,以及数据的交换 端口号:在一台计算机中,每个应用程序对应一个端口号 常见端口号: FTP(文件传输协议): 21 , 20 数据口端口号: 20 控制口端口号: 21 (电子邮箱传输协议,发送邮件): SMTP协议, 发送邮件端口号: 25 , POP3(邮局协议版本3,**接收邮件,客户端接收后服务器删除邮件)端口号: 110 ; ** IMAP4,客户端接收邮件后服务器也不删除, 端口:143 , TFTP(简单文件传输协议): 69 HTTP(超文本传输协议): 80 HTTPS(超文本安全传输协议): 443 DNS(域名解析服务器): 53 DHCP(动态主机配置协议):68 TomCat服务器: 8080 SNMP(简单网络管理协议): 161 TELNET(远程登陆): 23 传输层-两个重要协议:TCP,UDPTCP(传输控制协议):==一次http请求过程: 在通常情况下,服务端返回给浏览器数据成功后就断开链接了无需等待浏览器解析页面 ; 除非在请求头进行特殊设置才会一直保持链接== TCP是TCP/IP体系中较为复杂的协议,是传输层中最重要的协议. 特点: 面向连接的传输层协议 面向字节流 提供可靠的交付服务 提供全双工通信 三次握手(建立链接)与四次挥手(解除链接)参考文章:https://blog.csdn.net/weixin_45393094/article/details/104965561 TCP三次握手:①首先 Client 端发送连接请求报文 ②Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。 ③Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。 为什么要进行三次握手? 1、在第一次通信过程中，A向B发送信息之后，B收到信息后可以确认自己的收信能力和A的发信能力没有问题。 2、在第二次通信中，B向A发送信息之后，A可以确认自己的发信能力和B的收信能力没有问题，但是B不知道自己的发信能力到底如何，所以就需要第三次通信。 3、在第三次通信中，A向B发送信息之后，B就可以确认自己的发信能力没有问题。 4、 小结：3次握手完成两个重要的功能，==既要双方做好发送数据的准备工作(双方都知道彼此已准备好)==，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 TCP四次挥手建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。 //过程描述 A：“任务处理完毕，我希望断开连接。” B：“哦，是吗？请稍等，我准备一下。” 等待片刻后……(可能是因为B数据还没传输完) B：“我准备好了(B已经把数据传输完毕)，可以断开连接了。” A：“好的，谢谢合作。” 为什么连接的时候是三次握手，关闭的时候却是四次握手？ ①因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。②但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。③==只有等到我Server端所有的报文都发送完了==，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 UDP(用户数据报协议)应用场景:主要是对数据完整性要求不高的场景 特点: UDP是无连接的(无须对方答复即可传输) 尽最大努力交付(不一定可靠) 面向报文没有拥塞控制 开销较小效率较高 会话层:利用传输层提供的服务，使应用建立和维持会话，并能使会话获得同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于传送大的文件极为重要。 表示层:用于处理交互数据的表示方式**,例如格式的转换,数据的加密和解密,数据压缩和恢复等功能** 应用层:使用应用层序通过网络服务,为用户服务 应用层-常见协议DNS(域名系统)域名结构:每个域名用逗号隔开,如www.baidu.com, 三级域名,二级域名,顶级域名 一个域名对应一个ip,但是一个ip可以有多个域名(即可通过多个域名找到同一个网站) 域名的迭代查询和递归查询: **递归查询:**如果本地DNS服务器无法解析域名的IP，则本地DNS服务器向其他根DNS服务器发出查询请求。递归查询返回的==查询结果只有 IP地址 和 无法查询的报错 两种可能。== 迭代查询：当根DNS服务器收到本地DNS服务器发出的迭代查询请求报文时，返回的结果是 ==IP地址或是顶级DNS服务器地址==，而本地DNS服务器再向顶级DNS服务器查询。顶级服务器一是如此，直到最后得到解析的IP地址或报错，本地DNS服务器再把报错还给查询主机。 总的来说，递归查询是 客户端只发起一次请求，返回结果只有查询成功或失败；迭代查询会返回最佳查询点或主机地址。 DHCP(动态主机配置协议)DHCP协议: 指的就是由服务器控制一段IP地址范围,客户机登陆服务器时就可以自动获得服务器分配得ip地址和子网掩网, 端号: 68","categories":[{"name":"计算机基础理论","slug":"计算机基础理论","permalink":"https://lqy679.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"软件工程","slug":"软件工程","date":"2020-01-01T10:57:32.000Z","updated":"2023-03-06T02:59:52.868Z","comments":true,"path":"2020/01/01/软件工程/","link":"","permalink":"https://lqy679.github.io/2020/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","excerpt":"软件工程UML统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。 类图","text":"软件工程UML统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。 类图 转载自:(19条消息) 通俗易懂教你画类图_Java追求者的博客-CSDN博客_类图怎么画 类图是以反映类的结构(属性,操作)以及类之间的关系为主要目的,描述了软件系统的结构,是一种静态建模方法 如屠所示表示一个用户类User, 属性有 uid ,name, age ,birthday 类的内容:第一层：类的名称，如果是抽象类，则就用斜体显示。 第二层：字段和属性。 第三层：方法。 前面的符号表示访问修饰符： “+” 表示public “-“ 表示private “#”表示protected “~”表示只对同一个包内的其他类可见, 类之间的关系:继承(泛化)关系： 三角形 + 实线鸟也有生命这种属性，也有新陈代谢和繁殖的行为。 ==代码实现: 即Java中父类子类之间的继承关系,关键字extend== 实现关系：三角形 + 虚线大雁可以各种各样的飞翔方式。 ==代码实现: 即 Java中的接口与实现类 ,关键字 implements== 关联关系： 实线箭头企鹅需要知道气候的变化，需要了解气候规律 关联关系:==强调的是被引用关联的其它类型实例要作为本类的字段属性==(静态或非静态) 具体代码实现: 一个类中的用其他类作为自己的类的成员变量 依赖关系： 虚线箭头动物需要依赖氧气和水进行生存。 依赖关系只是在==本类方法内部使用到某类而已，严格来说不是这个类的一部分==。 具体代码实现: 一个类中需要调用其他类的方法(服务)从而需要用到其他类的对象(注意:并不是作为的成员变量)** ==值得一提的是: 组合关系 和 聚合关系 是 关联 的两种表现形式== 组合关系： 实心的菱形 + 实线箭头心脏是人==不可或缺的一部分==。 代码实现: 在构造器中自己new 对象 聚合关系（包含关系）： 空心的菱形 + 实线箭头人在人群这个集合里面,但人群里==多一个人少一个人无所谓,并不是不可或缺的==。 代码实现: 在构造器中通过形数传入一个对象 对象图 摘抄至 五大部分讲透UML对象图 - 知乎 (zhihu.com) 对象是类的实例，是一个封装了状态和行为的实体。对象通过其类型、名称和状态区别于其他对象而存在。 对象名：在矩形框的顶端显示。类型：具体的类目状态：由对象的所有属性以及运行时的当前值组成。表示法：在对象名后跟一个冒号加上类型名，并且使用下划线与类进行区分。 对象图与类图的区别: 用例图 [期末考]用例图是被称为参与者的外部用户所能观察到的系统功能的模型图,用例图列出系统中的用例和系统外的参与者,并显示哪个参与者参与了哪个用例执行 组成部分: 参与者 参与者（Actor）是指存在于系统外部并直接与系统进行交互的人、系统、子系统或类的外部实体的抽象。每个参与者可以参与一个或多个用例，每个用例也可以有一个或多个参与者。 在用例图中使用一个人形图标来表示参与者，参与者的名字写在人形图标下面。 参与者间的的关系 由于参与者实质上也是类，所以它拥有与类相同的关系描述，即参与者与参与者之间主要是泛化关系（或称为“继承”关系）。泛化关系的含义是把某些参与者的共同行为提取出来表示成通用行为，并描述成超类。泛化关系表示的是参与者之间的一般/特殊关系，在UML图中，使用带空心三角箭头的实线表示泛化关系。 系统边界 在项目开发过程中，边界是一个非常重要的概念。这里说的系统边界是指系统与系统之间的界限。通常我们所说的系统可以认为是由一系列的相互作用的元素形成的具有特定功能的有机整体。 系统同时又是相对的，一个系统本身又可以是另一个更大系统的组成部分，因此，系统与系统之间需要使用系统边界进行区分开来。我们把系统边界以外的同系统相关联的其他部分，称之为系统环境。 表示形式:关联关系:关系说明：表示参与者与用例之间的关系 表示方法：带箭头的实线，箭头指向用例。 举例说明：用户登录系统 归纳（泛化）关系关系说明：表示参与者与参与者之间、用例与用例之间的关系。**==类似Java中的继承==,一个用例可以被特别列举为一个或多个子用例，这被称为用例泛化。** 表示方法：带空心箭头的实线，箭头指向被泛化（被继承）的用例，即基础用例/父用例。（注意：泛化关系的箭头不是指向被泛化，而是指向被继承。泛化和继承是不同的方向。泛化是从下到上的抽象过程，继承是从上到下，从一般到特殊的过程。） 举例说明：VIP会员和普通用户，归纳为用户；账号登录与微信登录，也可归纳为登录系统。 包含关系关系说明：表示用例与用例之间的关系，其中**==执行基础用例前必须执行被包含用例==,一个用例（基础用例）的行为包含了另一个用例（包含用例）的行为。** 表示方法：虚线箭头+&lt;include&gt;字样，==箭头指向被包含的用例== 举例说明：用户在账号登录过程中，包括输入账号、输入密码、确认登录等操作 拓展关系关系说明：表示用例与用例之间的关系；用于拓展用例对基础用例的增强；**==拓展用例是在特定条件出现时(不是必须执行的)，才会被执行的用例(不同于之包含关系的必须执行)==。** 表示方法：虚线箭头+&lt;extend&gt;字样，==箭头指向被扩展的用例（即基础用例）== 举例说明：用户在登录过程中忘记了密码 时序图 参考自:UML序列图总结_西安楚凡科技有限公司 - 企业级UML2.x建模工具 | 应用生命周期管理工具 | 需求管理工具| 中国最专业的UML解决方案提供商 (trufun.net) 序图更多只是一种叫法，平常我们所说的顺序图、序列图也是在称呼它。时序图是基于交互的对象行为建模，是 UML 用于描述对象之间信息的交互过程的方法，是描述对象间协作关系的模型。 时序图用于捕获系统运行中对象之间有时间顺序的交互，是由生命线和消息组成。 时序图将交互关系表示为一个二维图。纵向是时间轴，时间沿竖线向下延伸。横向轴代表了在协作中各独立对象的类元角色。类元角色用生命线表示。当对象存在时，角色用一条虚线表示，当对象的过程处于激活状态时，生命线是一个双道线。消息用从一个对象的生命线到另一个对象生命线的箭头表示。箭头以时间顺序在图中从上到下排列。 序列图中涉及的元素：生命线:生命线名称可带下划线。当使用下划线时，意味着序列图中的生命线代表一个类的特定实例。 同步消息:发送人在它继续之前，将等待同步消息响应。 异步消息: 在发送方继续之前，无需等待响应的消息。 注释:折页角的内容就是注释内容 约束:约束的符号很简单；格式是: [Boolean Test] 组合片段:组合片段用来解决交互执行的条件及方式。它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。 常用的组合片段有： 抉择（Alt）: 抉择用来指明在两个或更多的消息序列之间的互斥的选择，相当于经典的if..else..。 抉择在任何场合下只发生一个序列。 可以在每个片段中设置一个临界来指示该片段可以运行的条件。else 的临界指示其他任何临界都不为 True 时应运行的片段。如果所有临界都为 False 并且没有 else，则不执行任何片段。 选项（Opt）:包含一个可能发生或不发生的序列 循环（Loop）:片段重复一定次数。 可以在临界中指示片段重复的条件。 并行（Par）: 其他常用的图数据流图(DFD) [期末考] 数据流图，简称DFD，是SA方法(结构化分析方法)中用于表示系统逻辑模型的一种工具，它以图形的方式描绘数据在系统中流动和处理的过程，由于它只反映系统必须完成的逻辑功能，所以它是一种功能模型。 下图是一个飞机机票预订系统的数据流图，它反映的功能是：旅行社把预订机票的旅客信息 (姓名、年龄、单位、身份证号码、旅行时间、目的地等)输入机票预订系统。系统为旅客安排航班，打印出取票通知单(附有应交的账款)。旅客在飞机起飞的前一天凭取票通知单交款取票，系统检验无误，输出机票给旅客。 基本图形符号数据流图有四种基本图形符号： 箭头: 表示数据流； 〇：圆或椭圆，表示加工； = ：双杠，表示数据存储； □：方框，表示数据的源点或终点。 (1) 数据流。数据流是数据在系统内传播的路径，因此由一组成分固定的数据组成。如订票单由旅客姓名、年龄、单位、身份证号、日期、目的地等数据项组成。由于数据流是流动中的数据，所以必须有流向，除了与数据存储之间的数据流不用命名外，数据流应该用名词或名词短语命名。 (2)加工(又称为数据处理)。对数据流进行某些操作或变换。每个加工也要有名字，通常是动词短语，简明地描述完成什么加工。在分层的数据流图中，加工还应编号。 (3)数据存储(又称为文件)，指暂时保存的数据，它可以是数据库文件或任何形式的数据组织。 (4)数据源点或终点，是本软件系统外部环境中的实体(包括人员、组织或其他软件系统)，统称外部实体。一般只出现在数据流图的顶层图。 注意事项: ①命名。不论数据流、数据存储还是加工，合适的命名使人们易于理解其含义。 ②画数据流而不是控制流。数据流反映系统“做什么”，不反映“如何做”，因此箭头上的数据流名称只能是名词或名词短语，整个图中不反映加工的执行顺序。 ③一般不画物质流。数据流反映能用计算机处理的数据，并不是实物，因此对目标系统的数据流图一般不要画物质流。 ④每个加工至少有一个输入数据流和一个输出数据流，反映出此加工数据的来源与加工的结果。 ⑤编号。如果一张数据流图中的某个加工分解成另一张数据流图时，则上层图为父图，直接下层图为子图。子图及其所有的加工都应编号。 数据字典数据字典是指对数据的数据项,数据结构,数据流,数据存储,处理逻辑,外部实体等进行定义和描述,其目的是对数据流图中的各个元素作出详细的说明.数据字典的条目有数据流,数据项,数据存储,基本加工(注: 不包括外部实体). ER图在数据库设计中很常用 数据词典 引用自:数据字典 - 静悟生慧 - 博客园 (cnblogs.com) 数据字典是描述数据的信息集合，是对系统中使用的所有数据元素的定义的集合。通常一般用户是无法修改数据字典的，只有程序维护人员有编辑、修改数据字典的权限在开发的程序中，数据字典可以帮助开发人员理解各个数据项目的类型、数值和它们与现实世界中的对象的关系 常用字段与示例: 字段 描述 数据类型 约束 实体关系图(ER图) 参考自:(20条消息) ER图（实体关系图）怎么画？_亿图图示的博客-CSDN博客_er图怎么画 E-R图又称实体关系图，是一种提供了实体，属性和联系的方法，用来描述现实世界的概念模型。通俗点讲就是，当我们理解了实际问题的需求之后，需要用一种方法来表示这种需求，概念模型就是用来描述这种需求。 例如: E-R图中的基本元素: 实体:实际问题中客观存在的并且可以相互区别的事物称为实体。实体是现实世界中的对象，可以具体到人，事，物。比如：上图中的饭卡、学生、办公室、食堂、超市。 属性:实体所具有的某一个特性称为属性，在E-R图中属性用来描述实体。比如上图中的学生，可以用“姓名”、“院系”、“班级”、“手机号”进行属性描述。 实体集:具有相同属性的实体的集合称为实体集。例如：全体学生就是一个实体集，（983573，李刚，男，2000/12/12）是学生实体集中的一个实体。 实体型:具有相同的特征和性质的实体一定有相同的属性，用实体名及其属性名集合来抽象和刻画同类实体称为实体型，其表示格式为：实体名（属性1，属性2，……） 键:在描述实体集的所有属性中，可以唯一标识每个实体的属性称为键。键也是属于实体的属性，作为键的属性取值必须唯一且不能“空置”。比如：不重复的学生号，就可以作为学生的“键”。 联系:世界上任何事物都不是孤立存在的，事物内部和事物之间都有联系的，实体之间的联系通常有3种类型：一对一联系，一对多联系，多对多联系。 作图规范:1）矩形框：表示实体，在框中记入实体名。 2）菱形框：表示联系，在框中记入联系名 3）椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名(主键)，则在其名称下划一下划线。 4）连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N，M。) 系统流程图 参考自:系统建模之程序流程图|系统流程图|数据流图 - 千千寰宇 - 博客园 (cnblogs.com) 系统流程图用于描绘系统物理模型，表达数据在系统各个部件之间（程序、文件、数据库、表格、人工过程等）流动的情况。 系统流程图是概括的描绘系统物理模型的工具。 它的基本思想是用图形符号以黑盒子形式描绘系统里面的每个具体部件(程序、文件、数据库、表格、人工过程等），表达数据在系统各个部件之间流动的情况。 而不是对数据加工处理的过程，他是物理数据流图而不是程序流程图。 样例: 某生鲜品牌有一个前置仓，存放其业务配送所需的各种生鲜，前置仓的各种生鲜的数量及其库存量临界值等数据记录在前置仓主文件上，当前置仓中生鲜数量发生变化时，应更改库存文件。 若某种生鲜的库存量少于库存临界值，则立即报告采购部门以便订货，规定每天向采购部门送一份采购报告。 用系统流程图的符号进行解释生鲜的发放和接受称为变更记录，由键盘输入到计算机中。 系统中库存清单程序对变更记录进行处理，更新存储在磁盘上的库存清单主文件，并且把必要的订货信息记录写在联机存储上。 最后，每天由报告生成程序读一次联机存储，并且打印出订货报告。 形成系统流程图: 系统结构图(未知) 参考:(20条消息) 【软件工程】结构图（SC）——期末复习用_程序鸡的博客-CSDN博客_sc图 程序流程图 参考:流程图的画法 - 鸢凛 - 博客园 (cnblogs.com) 符号意义 选择结构(if else , switch)为鼓励居民节约用水，自来水公司采取按用水量阶梯式计价的办法，居民应交水费y（元） ​ 与月用水量x（吨）的关系如下，请编写程序实现水费的计算。 ​ 流程图如下所示: 循环结构 for循环: 题目：本题要求编写程序，计算表达式 1 + 2 + 3 + … + 100 的值。 N-S图(盒图) [期末考] 参考:N-S图（盒图）详解（附案例） - 知乎 (zhihu.com) 顺序结构:所有语句顺序执行，先执行A后执行B 条件结构:如果条件P成立，执行A，否则执行B 多分支结构:P=1的时候，执行A1，P=2的时候，执行A2，依次类推； 循环结构:当型(while)先判断后执行，当P1**==先判断在执行==,条件成立的情况下，反复执行A语句**，直到P1条件不成立为止 直到型(do.. while或until)先执行后判断，当P1条件不成立的情况下，反复执行A语句，**==先执行(A语句),再判断==,直到P1条件成立为止(条件满足不再循环)**(注意这与代码不一样,直到满足条件就不循环了,代码do...while满足会循环的) 案例:(1)求1到5所有整数相乘的乘积 注: 图画错了,应该是 t = t * i (2) 输入三角形三边长，判断三遍构成的是等边，等腰，还是一般三角形 PAD图 [期末考]PAD图（Problem Analysis Diagram），由日本日立公司1973年发明以后，已得到一定程度的推广。它用二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易。它既克服了传统的流程图不能清晰表现程序结构的缺点，又不像N-S图那样受到把全部程序约束在一个方框内的限制，这就是其优势所在。 几种结构表示 案例:请根据下列伪码画出对应的PAD图。 12345678910定义变量:i=7,S=0DO WHILE i&lt;=1000IF(i被7整除)THENS=S+i输出:iENDIFi=i+1ENDDO输出:S PAD图如图所示: N-S图转换为PAD图 转换后的PAD图","categories":[{"name":"计算机基础理论","slug":"计算机基础理论","permalink":"https://lqy679.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"}],"tags":[]},{"title":"Vue使用","slug":"vue使用","date":"2020-01-01T10:57:32.000Z","updated":"2023-04-13T04:00:50.834Z","comments":true,"path":"2020/01/01/vue使用/","link":"","permalink":"https://lqy679.github.io/2020/01/01/vue%E4%BD%BF%E7%94%A8/","excerpt":"Vue2(使用)Vue初识1、什么是MVVMMVVM（Model-View-ViewModel）是一种软件设计模式，由微软WPF（用于替代WinForm，以前就是用这个技术开发桌面应用程序的）和Silverlight（类似于Java Applet，简单点说就是在浏览器上运行WPF）的架构师Ken Cooper和Ted Peters开发，是一种简化用户界面的事件驱动编程方式。由John Gossman（同样也是WPF和Sliverlight的架构师）与2005年在他的博客上发表。","text":"Vue2(使用)Vue初识1、什么是MVVMMVVM（Model-View-ViewModel）是一种软件设计模式，由微软WPF（用于替代WinForm，以前就是用这个技术开发桌面应用程序的）和Silverlight（类似于Java Applet，简单点说就是在浏览器上运行WPF）的架构师Ken Cooper和Ted Peters开发，是一种简化用户界面的事件驱动编程方式。由John Gossman（同样也是WPF和Sliverlight的架构师）与2005年在他的博客上发表。 MVVM源自于经典的MVC（Model-View-Controller）模式。MVVM的核心是ViewModel层，负责转换Model中的数据对象来让数据变得更容易管理和使用。其作用如下： 该层向上与视图层进行双向数据绑定 向下与Model层通过接口请求进行数据交互 MVVM已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的MVVM框架有Vue.js，Anfular JS 2、为什么要使用MVVMMVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大好处 低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。可复用：你可以把一些视图逻辑放在一个ViewModel里面，让很多View重用这段视图逻辑。独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewMode），设计人员可以专注于页面设计。可测试：界面素来是比较难以测试的，而现在测试可以针对ViewModel来写。 ViewView是视图层，也就是用户界面。前端主要由HTML和css来构建，为了更方便地展现ViewModel 或者Model 层的数据，已经产生了各种各样的前后端模板语言，比如FreeMarker、Thymeleaf 等等，各大MVVM 框架如Vue.js，AngularJS，EJS 等也都有自己用来构建用户界面的内置模板语言。 ModelModel是指数据模型， 泛指后端进行的各种业务逻辑处理和数据操控， 主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的接口规则 ViewModelViewModel是由前端开发人员组织生成和维护的视图数据层。在这一层， 前端开发者对从后端获取的Model数据进行转换处理， 做二次封装， 以生成符合View层使用预期的视图数据模型。 需要注意的是View Model所封装出来的数据模型包括视图的状态和行为两部分， 而Model层的数据模型是只包含状态的 比如页面的这一块展示什么，那一块展示什么这些都属于视图状态(展示)页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为(交互)视图状态和行为都封装在了View Model里。这样的封装使得View Model可以完整地去描述View层。由于实现了双向绑定， View Model的内容会实时展现在View层， 这是激动人心的， 因为前端开发者再也不必低效又麻烦地通过操纵DOM去更新视图。 MVVM框架已经把最脏最累的一块做好了， 我们开发者只需要处理和维护View Model， 更新数据视图就会自动得到相应更新，真正实现事件驱动编程。 View层展现的不是Model层的数据， 而是ViewModel的数据， 由ViewModel负责与Model层交互， 这就完全解耦了View层和Model层， 这个解耦是至关重要的， 它是前后端分离方案实施的重要一环。 Vue概述Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库（如: vue-router: 跳转，vue-resource: 通信，vuex:管理）或既有项目整合 Vue官网：https://cn.vuejs.org/ 在MVVM架构中，是不允许数据和视图直接通信的，只能通过ViewModel来通信，而ViewModel就是定义了一个Observer观察者 ViewModel能够观察到数据的变化，并对视图对应的内容进行更新ViewModel能够监听到视图的变化，并能够通知数据发生改变至此，我们就明白了，Vue.js就是一个MVVM的实现者，他的核心就是实现了DOM监听与数据绑定 模板语法模板语法又叫插值语法,大胡子语法, 如: 1&#123;&#123;数据&#125;&#125; 括号中的数据可以写 js表达式, 和 data属性的内容,还有vm的computed(vm实例的一个配置项),其中,html标签中的文本内容叫做模板 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt; &lt;!-- Vue 数据代理: 在页面中&#123;&#123;name&#125;&#125; 实际上获取到的值,应该是 data()&#123; return &#123;school:&quot;广科师&quot;,major:&quot;软件工程&quot;&#125;; &#125; 原理: 在new 一个Vue实例时, 我们将构造器Vue(&#123;对象&#125;)中的参数对象称为 opintion , 其中参数对象的 data属性 会成为 vue实例的生成一个名为 _data的属性(此时依然没有 涉及到数据代理,属于赋值的关系),即实际上js整个作用域中真实存在的只有 _data属性(这个属性的类型是对象) 随后为了编码方便,vue实例又生成代理_data对象的属性值的属性 --&gt;&lt;body&gt;&lt;!-- 并且可以在 html 标签的文本内容中 可以用 &#123;&#123;&#125;&#125; 引入属性值 data&#123;&#123;&#125;&#125; ,中可以写 js表达式, 和 data属性的内容其中,html标签中的文本内容叫做模板 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;学校名称:&#123;&#123;school&#125;&#125;&lt;/h2&gt; &lt;h2&gt;专业名称:&#123;&#123;major&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: &quot;#root&quot;, data()&#123; return &#123;school:&quot;广科师&quot;,major:&quot;软件工程&quot;&#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; VM配置属性vm( 即ViewModel )对象负责对Model成进行交互, 对视图层进行控制管理 其构造方法 Vue(Object obj); ,其中的参数是一个对象,对象的属性包括了vue对象的一些基本信息 vm的对象有如下这些: el 绑定Dom用来将vm绑定dom容器,并且一一对应(一般是根容器) 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;初识vue&lt;/title&gt; &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt; 1. hello &#123;&#123;name&#125;&#125;! 时间戳:&#123;&#123;new Date()&#125;&#125; &lt;/div&gt; &lt;!-- 这个div不会解析,因为唯一绑定原则,并且按照dom加载顺序解析 --&gt; &lt;div class=&quot;div1&quot;&gt; 2. hello &#123;&#123;name&#125;&#125;! &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.Vue.config.productionTip = false //设置为 false 以阻止 vue 在启动时生成生产提示。 // 创建 vue 对象 new Vue(&#123; el: &quot;.div1&quot;, // 绑定 dom &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; data 数据属性data用于存放vm对象的数据, 有两种写法: 对象式和函数式,一般我们推荐用函数式写法 对象式写法(不推荐): 1234567891011&lt;script&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: &quot;#root&quot;, data:&#123; school:&quot;xxxxx&quot;, major:&quot;软件工程&quot; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 函数式写法 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;学校名称:&#123;&#123;school&#125;&#125;&lt;/h2&gt; &lt;h2&gt;专业名称:&#123;&#123;major&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: &quot;#root&quot;, data()&#123; return &#123;school:&quot;xxx&quot;,major:&quot;软件工程&quot;&#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; Vue中的数据代理 Vue 数据代理: 在页面中 实际上获取到的值,应该是 data(){ return {school:”广科师”,major:”软件工程”}; } 原理: 在new 一个Vue实例时, 我们将构造器Vue({对象})中的参数对象称为 opintion , 其中参数对象的 data属性 会成为 vue实例的生成一个名为 _data的属性(此时依然没有涉及到数据代理,属于赋值的关系),即实际上js整个作用域中真实存在的只有 _data属性(这个属性的类型是对象)随后为了编码方便,vue实例又生成代理_data对象的属性值的属性 methods 方法(事件处理)methods里可为vm对象新建多个方法,一般用于事件绑定 methods配置的函数最终都会被vm管理,并且不要使用箭头函数,否则this将会变成 window , 默认是指向vm或组件实例 注意: 当事件函数名带括号时如果不写$event就无法获取(只写函数名能获取则可以)到事件对象event 如 f() 即如果无须指定参数,且想用 event请直接写函数名即可 基本事件处理:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;!-- 事件的基本使用: 1.使用命令 v-on:事件名=&quot;事件函数名&quot; 来绑定事件,通常可以将v-on简写为@ 需要回调和指定参数的话 @事件名: &quot;事件函数(@event,参数)&quot; 2. 事件的回调需要配置在methods中, 最终会在vm上 3.methods配置的函数最终都会被vm管理,并且不要使用箭头函数,否则this将会变成 window , 默认是指向vm或组件实例 注意: 当事件函数名带括号时如果不写$event就无法获取(只写函数名能获取则可以)到 事件对象event 如 f() 即如果无须指定参数,且想用 event请直接写函数名即可 --&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;你好!欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;!-- &lt;button v-on:click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; --&gt; &lt;!-- 简写形式: --&gt; &lt;button type=&quot;button&quot; @click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; &lt;!-- 外部传参,且保留event, 注意: @event 相当于vue的关键字 --&gt; &lt;button type=&quot;button&quot; @click=&quot;showInfo2($event,&#x27;data&#x27;)&quot;&gt;点我提示信息(传参)&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false ; const vm = new Vue(&#123; el:&quot;#root&quot;, data()&#123; return &#123;name:&quot;Vue&quot;&#125; &#125;, methods:&#123; showInfo(event)&#123; console.log(event.target); alert(&quot;欢迎学习vue&quot;); &#125;, showInfo2(event,num)&#123; console.log(event.target); console.log(num); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 键盘事件处理vue为了方便开发,给常用的按键起了别名,我们可以通过 @按键事件.别名 来绑定特定案件(可以使用多个按键, 如 @keyup.ctrl.y) 按键事件:keydwon即当 键 按下去时触发(组合键不可用) , keyup当 键 松起时触发 每个按键都有一个代号 可以通过 event对象的keyCode属性查看到, 注: 2022-2-9 keyCode已经弃用, 采用 key属性替换 1.常用别名 回车 enter 删除 delete (捕获删除键和退格键) 退出 esc 空格 space 换行 tab (注意:由于会切换焦点,故只能配合keydwon使用) 方向键: 上 up 下 dwon 左 left 右 right 2.系统修饰按键(用法特殊): ctrl alt shift meta(徽标键) (1) 配合 keyup使用: 按下修饰键的同时再按下其他键,随后其他键才能触发 (2) 配合 keydwon使用: 正常触发 3.Vue未提供的别名的按键,可以使用原始key值去绑定,但要注意键名是组合的单词的时候需要转为kebab-case 如 大写锁定键 CapsLock 应该写为 @keyup.caps-lock = 事件函数名 4.自定义按键别名 Vue.config.keyCodes.自定义别名 = 键码 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 键盘事件 使用别名 --&gt; 按回车打印&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; @keyup.ctrl=&quot;print&quot;/&gt; &lt;/div&gt; &lt;!-- js键盘事件知识补充: keydown 当按键按下时就触发 (组合键没法用) keyup 当按钮按下后并且松开时触发 每个案件都有一个代号 可以通过 event对象的keyCode属性查看到, 注: 2022-2-9 keyCode已经弃用 采用 key属性替换 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el:&quot;#root&quot;, methods:&#123; print(event)&#123; // console.log(&quot;键盘代号:&quot;,event.keyCode); // 通过回车打印文本框的值 // if(event.keyCode!=13)&#123; // return // &#125; console.log(&quot;按键:&quot;,event.key); console.log(event.target.value); &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件修饰符常用的事件修饰符(修饰符可以连续使用多个如 @click.stop.prevent): 1.prevent 阻止默认事件(常用) 2.stop 阻止事件冒泡 (常用) , 事件冒泡是指 当子元素与父元素有相同的事件时, 当子元素触发后父元素也会触发 3.once 事件只触发一次(常用) 4.capture 使用事件的捕获模式, 也就是事件处理在获取阶段就进行处理 浅谈事件的捕获与冒泡: js事件分为了捕获和冒泡两个阶段, 捕获阶段是由外往内的,冒泡阶段是由外往内的 , 其中,是先进行了事件捕获,再进行事件冒泡的, 不过最后处理事件是在冒泡阶段完成 ​ 5.self 只有event.target 是当前操作的元素时才触发事件, 场景假设: 当 div里有一个按钮, 两者同时存在click事件,但是div触发事件的回调的 event.target 是button 6.passive 事件默认行为 为立即执行, 无需等待事件回调执行完毕, 例如有个 a标签,点击事件绑定了有 alert语句的事件函数, 使用此修饰符将会 立即跳转而不等待弹窗 computed 计算计算属性和方法有点类似,但是为了解耦, 所以引入了计算属性, 虽然也写成方法形式, 不过计算属性是有值的, 他的值就是方法的返回值 此外还需要注意使用计算属性时不能加括号(因为是代表一个值) , 可以在插值语法中使用 计算属性有三种写法如下所示: 注意: 简写的时候没有set()也就意味着是没法修改的, 并且由于他还是属性,使用计算属性时不能加括号 1234567891011121314151617181920212223242526272829303132333435 &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: &quot;#root&quot;, data: &#123; fristname3: &quot;枫&quot;, lastname3: &quot;叶&quot;, &#125;, // 完整写法: computed: &#123; /* fullNname: &#123; set() &#123; ..... &#125; get() &#123; console.log(&quot;get被调用!&quot;); // vue 做了优化,此时 get函数的this是指向vue实例的 return this.fristname3 + &quot;-&quot; + this.lastname3; &#125; &#125; */ // 简写: 将计算属性写成一个函数,返回的值即是计算属性的值 /* fullName:function()&#123; console.log(&quot;get被调用!&quot;); return this.fristname3 + &quot;-&quot; + this.lastname3; &#125;, */ // 最简写法: fullName() &#123; console.log(&quot;get被调用!&quot;); return this.fristname3 + &quot;-&quot; + this.lastname3; &#125; &#125; &#125;);&lt;/script&gt; watchd 监视 (异步计算)监视属性与计算属性非常类似, 当一般计算时通常使用,computed计算属性, 但涉及到异步运算, 就用 watch 监视属性来间接实现 两者区别如下: 1.computed能完成的,watchd都能完成 2.watch能完成的, computed不一定能完成, 比如异步操作 两个重要的小原则: 1.所有被vue管理的函数, 最好写成,普通函数,这样this指向的是 vue或组件实例对象 2.所有不被vue管理的函数(如:定时器的回调函数,ajax的回调函数等), 最好写成箭头函数,这样 this 才可以指向 vm 或组件实例 如下面的例子: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h4&gt;使用计算属性computed实现&lt;/h4&gt; 姓:&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; v-model=&quot;fristname3&quot; /&gt; &lt;br&gt;&lt;br&gt; 名:&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; v-model=&quot;lastname3&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;span&gt;全名: &#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;h4&gt;使用监听属性&lt;/h4&gt; 姓:&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; v-model=&quot;fristname2&quot; /&gt; &lt;br&gt;&lt;br&gt; 名:&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; v-model=&quot;lastname2&quot; /&gt; &lt;br&gt;&lt;br&gt; &lt;span&gt;全名: &#123;&#123;fullName2&#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: &quot;#root&quot;, data: &#123; fristname3: &quot;枫&quot;, lastname3: &quot;叶&quot;, fristname2: &quot;张&quot;, lastname2: &quot;三&quot;, // 监听属性需要使用 fullName2:&quot;张-三&quot; &#125;, computed:&#123; fullName()&#123; // 这样没法达到效果是 因为: fullName没有返回语句返回出去给他 setTimeout(()=&gt;&#123; return this.fristname3+&quot;-&quot;+this.lastname3; &#125;,1000); // 假如在这里加上一个 return 依然没有效果, 会直接返回 // return this.fristname3+&quot;-&quot;+this.lastname3; &#125; &#125;, watch:&#123; fristname2(newValue)&#123; // 注意,此时箭头函数的this是指向 vm // 要使用箭头函数 是因为 setTimeOut()不是 vm管理的函数, // 其普通函数默认回调函数的this指向:window,使用箭头函数后this 才会指向 vm setTimeout(()=&gt;&#123; this.fullName2 = newValue +&quot;-&quot;+this.lastname2; &#125;,1000) &#125;, lastname2(newValue)&#123; this.fullName2 = this.fristname2 + &quot;-&quot; + newValue; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 简写形式:注意: 简写形式不能开启 deep 等配置项时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;今天天气真&#123;&#123;info&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;charWheather&quot;&gt;改变天气&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &quot;#root&quot;, data: &#123; isHost: false &#125;, computed: &#123; info() &#123; return this.isHost ? &quot;凉爽&quot; : &quot;炎热&quot;; &#125; &#125;, methods: &#123; charWheather() &#123; this.isHost = !this.isHost &#125; &#125;, watch:&#123; // &quot;isHost&quot;:&#123; // // immediata:true, // // 当监测的属性(如 isHost)改变时调用 handler ,他有两个参数 可获得监测属性的改变值 // handler(newValue,oldValue)&#123; // console.log(&quot;调用了handler!&quot;,newValue,oldValue); // &#125; // &#125; /* 简写 */ isHost(newValue,oldValue)&#123; console.log(&quot;调用了handler!&quot;,newValue,oldValue); &#125; &#125;, // 写法二 // vm.$watch(&quot;isHost&quot;, &#123; // handler(newValue, oldValue) &#123; // // immediata:true, //是否未等监测值改变就执行 handler // // 当监测的属性(如 isHost)改变时调用 handler ,他有两个参数 可获得监测属性的改变值 // console.log(&quot;调用了handler!&quot;, newValue, oldValue); // &#125; // &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 深度检测(监测对象内容变化)深度监视: vue中watch默认不监视对象内部值的改变 配置 deep:true 可以监测对象内部值改变 备注: vue 自身监测对象内部值的改变,但 vue 提供的watch默认不可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;今天天气真&#123;&#123;info&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;charWheather&quot;&gt;改变天气&lt;/button&gt; &lt;hr&gt; &lt;h3&gt;a的值:&#123;&#123;number.a&#125;&#125;&lt;/h3&gt; &lt;h3&gt;b的值:&#123;&#123;number.b&#125;&#125;&lt;/h3&gt; &lt;button type=&quot;button&quot; @click=&quot;add_a&quot;&gt;a+1&lt;/button&gt; &lt;button type=&quot;button&quot; @click=&quot;add_b&quot;&gt;b+1&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false; const vm = new Vue(&#123; el: &quot;#root&quot;, data: &#123; isHost: false, number: &#123; a:1, b:2 &#125; &#125;, computed: &#123; info() &#123; return this.isHost ? &quot;凉爽&quot; : &quot;炎热&quot;; &#125; &#125;, methods: &#123; charWheather() &#123; this.isHost = !this.isHost &#125;, add_a()&#123; this.number.a++; &#125;, add_b()&#123; this.number.b++; &#125; &#125;, watch:&#123; &quot;isHost&quot;:&#123; // immediata:true, // 当监测的属性(如 isHost)改变时调用 handler ,他有两个参数 可获得监测属性的改变值 handler(newValue,oldValue)&#123; // console.log(&quot;调用了handler!&quot;,newValue,oldValue); &#125; &#125;, // 注意: 多级结构需注意由于 key 是字符串类型的,要加引号 &quot;number.a&quot;:&#123; handler(newValue,old)&#123; console.log(&quot;a改变了&quot;,newValue,old); &#125; &#125;, // 如果监测 number,默认只会监测 a b 的地址是否改变, a b 的值改变监测number监测不到 // 开启 deep 深度监测 可解决上述问题 &quot;number&quot;:&#123; deep:true, // 深度监测 handler(newValue,old)&#123; console.log(&quot;number改变了&quot;); &#125; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; filters过滤器我们可以在VM中配置过滤来对一些数据进行格式化, 在插值语法中结合管道符使用过滤器进行过滤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;过滤器&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h4&gt;now时间戳:&#123;&#123;time&#125;&#125;&lt;/h4&gt; &lt;!-- 将 time 作为默认参数传入过滤器,只有默认参数时不需要括号, 有多个参数,需省略默认参数,即如果有两个参数,只需写 timeFilter(pra2), time依然传递,还可以传递pra2 此外,过滤器后面再接一个 管道符 还可以进行串联 --&gt; &lt;h4&gt;局部过滤器:&#123;&#123;time|timeFilter&#125;&#125;&lt;/h4&gt; &lt;h4&gt;全局过滤器:&#123;&#123;time|timeFilter2&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;script&gt;// 封装转换时间格式的方法Date.prototype.Format = function (fmt) &#123;var o = &#123; &quot;M+&quot;: this.getMonth() + 1, //月份 &quot;d+&quot;: this.getDate(), //日 &quot;h+&quot;: this.getHours(), //小时 &quot;m+&quot;: this.getMinutes(), //分 &quot;s+&quot;: this.getSeconds(), //秒 &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度 &quot;S&quot;: this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt;&#125;/**************** Vue 开始工作 ********************************************/ Vue.config.productionTip = false;// 注意:全局过滤器需要在 new vue实例前配置好 Vue.filter(&quot;timeFilter2&quot;,(value)=&gt;&#123; return new Date(value).Format(&#x27;yyyy-MM-dd hh:mm:ss&#x27;); &#125;); let vm = new Vue(&#123; el :&quot;#root&quot;, data :&#123;time:new Date().getTime()&#125;, filters:&#123; timeFilter(value)&#123; return new Date(value).Format(&#x27;yyyy-MM-dd hh:mm:ss&#x27;); &#125; &#125;, &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 全局过滤器:我们还可以配置全局过滤器(在整个Vue项目中都可以使用) , 不过需要注意,全局过滤器要在实例化Vue配置 1234567891011121314// 注意:全局过滤器需要在 new vue实例前配置好 Vue.filter(&quot;timeFilter2&quot;,(value)=&gt;&#123; return new Date(value).Format(&#x27;yyyy-MM-dd hh:mm:ss&#x27;); &#125;); let vm = new Vue(&#123; el :&quot;#root&quot;, data :&#123;time:new Date().getTime()&#125;, filters:&#123; timeFilter(value)&#123; return new Date(value).Format(&#x27;yyyy-MM-dd hh:mm:ss&#x27;); &#125; &#125;, &#125;); directives 自定义指令在vue里设置配置项 directives 值可以是函数和对象, 如果是函数,则可以有两个默认参数 function(element,binding) . 其中,binding是一个对象,存在一些关于使用指令时的属性: expression: “10” 表达式,也就是指令等号里的内容 value: 10 表达式的值 modifiers: {} name: “big” 指令的名字(不带v-) rawName: “v-big” 指令全称 **一. 当使用函数式时, 该函数调用的时机是: ** 1.当指令与元素成功绑定后(即使最开始加载时); 2.指令所在的模板被修改时(模板包括了差值语法和指令语法) 注意:这与methods和其他指令等内置的不同,他们是依赖数据改变才会改变,其原因是底层做了复用优化 二. 使用对象式时, 我们可以通过三个钩子函数来具体化调用时机 bind(element,binding): 指令与模板绑定时调用 inserted(element,binding):指令所在元素被插入页面时调用 update(element,binding): 指令所在模板被重新解析 具体使用: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;!-- 如下案例将演示 创建一个自定义指令 v-big 将一个值扩大10倍 用法: 在vue里设置配置项 directives 值可以是函数和对象 如果是函数,则可以有两个默认参数 function(element,binding) 其中,binding是一个对象,存在一些关于使用指令时的属性:expression: &quot;10&quot; 表达式,也就是指令等号里的内容modifiers: &#123;&#125; name: &quot;big&quot; 指令的名字(不带v-)rawName: &quot;v-big&quot; 指令全称value: 10 表达式的值 --&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;自定义指令v-big&lt;/h2&gt; &lt;h3&gt;这是一个值n:&#123;&#123;n&#125;&#125;&lt;/h3&gt; &lt;h3 v-big=&quot;n&quot;&gt;使用自定义的指令v-big&#123;&#123;n&#125;&#125;&lt;/h3&gt; &lt;button type=&quot;button&quot; @click=&quot;n++&quot;&gt;n++&lt;/button&gt; &lt;br&gt; &lt;h2&gt;自定义一个指令v-fbing,使文本框自动获取焦点,并且获得2*n的值&lt;/h2&gt; n :&lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false; let vm = new Vue(&#123; el :&quot;#root&quot;, data :&#123; n :1, &#125;, directives:&#123; // big函数何时会被调用? // 1.当指令与元素成功绑定后(即使最开始加载时); // 2.指令所在的模板被修改时(模板包括了差值语法和指令语法) // 注意:这与methods和其他指令等内置的不同,他们是依赖数据改变才会改变,其原因是底层做了复用优化 big(element,binding)&#123; console.log(element,binding); element.innerText =&quot;使用自定义指令v-big &quot;+ binding.value * 10; &#125;, /************对象式:*********************/ // 实际上, 函数式就是 bind函数与update函数结合 // 下面这几个经常被称为钩子 fbind:&#123; // 指令与模板绑定时调用 bind(element,binding)&#123; console.log(&quot;bind&quot;); element.value = 2*binding.value; &#125;, // 指令所在元素被插入页面时调用 inserted(element,binding)&#123; // 获取焦点 element.focus(); console.log(&quot;update&quot;); &#125;, // 指令所在模板被重新解析 update(element,binding)&#123; console.log(&quot;update&quot;); element.value = 2*binding.value; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; components 组件 组件就是 js+css+html片段,可以复用,组件可以看作vm的子类, 一般简称组件的实例对象为vc , 组件可以嵌套组件 Vue中使用组件的三大步骤: 一.定义组件(创建组件):分为单文件组件(常用)和非单文件文件组件 ,非单文件组件使用Vue.extend(&#123;配置&#125;) 组件的配置项和vm里的配置项基本一致,只不过data要写成方法的形式, ==并且不能写el配置==,因为组件由vm管理,由vm中的el决定在哪个容器 单文件组件定义,例如 School.vue 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 组件的结构 --&gt;&lt;template&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h3&gt;学校:&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;地址:&#123;&#123;address&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;show&quot;&gt;点我提示信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 组件交互 --&gt;&lt;script&gt; // 模块化导出, 默认导出一个文件只可以有一个,此外还有分别导出和统一导出 // 使用默认导出的时候比较简单 export default &#123; name:&quot;school&quot;, //为了更好在开发者工具显示 data() &#123; return &#123; name:&quot;广科师&quot;, address:&quot;广西来宾&quot; &#125; &#125;, methods:&#123; show()&#123; alert(&quot;欢迎学习Vue!&quot;); &#125; &#125; &#125;&lt;/script&gt;&lt;!-- 组件的样式 --&gt;&lt;style&gt; .demo&#123; background-color: aquamarine; &#125;&lt;/style&gt; **非单文件组件定义:**在使用了Vue的html文件中,定义主键student 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;组件基本使用&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 第三步: 编写组件标签 --&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; &lt;script&gt;// 注册组件: // Vue.component(student); // (第一步)创建组件let student = Vue.extend(&#123; template:`&lt;div&gt; &lt;h3&gt;姓名:&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;年龄:&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;/div&gt;`, data()&#123; return &#123; name:&quot;神奈川&quot;, age: &quot;18&quot; &#125; &#125;&#125;);let vm = new Vue(&#123; el :&quot;#root&quot;, // (第二步)注册组件 局部注册 components:&#123; student &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二.注册组件:可分为局部注册和全局注册 局部注册: 使用 new Vue(&#123;&#125;)的components配置项 123456let vm = new Vue(&#123; el :&quot;#root&quot;, components:&#123; student &#125; &#125;); 全局注册: Vue.component(&quot;组件名&quot;,组件变量) 123// 组件定义...// 注册组件Vue.component(student); 三.使用组件: 写组件标签&lt;组件名&gt;&lt;组件名/&gt; , 假如已经定义注册了名为student的组件 1&lt;student&gt;&lt;/student&gt; 组件的注意点1.关于组件名: ​ 一个单词组成: 首字母可大写可小写 ​ 多个单词组成: kebab-case写法:使用-链接,如 my-school CamelCase写法:MySchool (需要Vue脚手架支持) 备注: 组件名尽量回避html标签名,此外,使用的组件标签名一定与注册时的名字一致, 可在组件中配置name属性,但这仅仅影响开发者工具中的名字 2.关于组件标签 第一种,使用正常的双标签如: &lt;组件名&gt;&lt;/组件名&gt; 第二种,使用单标签 &lt;组件名/&gt; 备注: 不使用脚手架的情况下,使用单标签组件会导致后续组件不能渲染 props 传递数据在vm或者组件中配置props属性可以用于父组件向子组件传递数据 (即组件通信) 传送数据:当需要向子组件传送数据时, 一般是在组件标签通过添加标签属性来传递参数(数据) , 注: 这个参数可以是 变量或者函数 形如: 1&lt;组件名 参数名 = &quot;值&quot;&gt;&lt;组件名&gt; 注意,参数的 值 必须用双引号包裹(语法规则) ,若需要传递组件的data数据, 或者js表达式, 可以使用v-bind指令来实现, 不过我们一般用其简写形式:, 此外如果有特殊需要甚至可以使用双向绑定 v-mode 1234&lt;!-- 简写形式: --&gt;&lt;组件名 :参数名 = &quot;值&quot;&gt;&lt;组件名&gt;&lt;!-- 不简写 --&gt;&lt;组件名 v-bind:参数名 = &quot;值&quot;&gt;&lt;组件名&gt; 接收使用数据:一般是子组件接收数据, 所以需要给接收数据的组件实例对象需要配置props属性,配置的方式有很多种, 有数组式,和对象式(参数约束) 子组件接收到数据后,会变成vm的属性,可通过vm直接访问,也可以直接在插值语法中使用 1props:[&quot;参数名1&quot;,&quot;参数名2...&quot;] 注意! props中的元素(即参数名)一定要和传递的设置的参数名对应得上 对象式: 123456789101112131415161718// 限定类型props&#123; 参数名1: 数据类型(Sting,Number等), 参数名2: String, 参数名3: Number, 参数名4: Boolean,&#125;// 完整性约束(必要性,默认值)props&#123; 参数名1:&#123; type: 数据类型, required: true &#125;, 参数名2:&#123; type: 数据类型, default: 12 &#125;&#125; 样例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;组件基本使用&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; &lt;script&gt;Vue.config.productionTip = false;// 定义子组件const son = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;子组件&lt;/h2&gt; &lt;h3&gt;参数1:&#123;&#123;pram&#125;&#125;&lt;/h3&gt; &lt;h3&gt;参数2:&#123;&#123;pram2&#125;&#125;&lt;/h3&gt; &lt;/div&gt;`, name:&quot;son&quot;, props:[&quot;pram&quot;,&quot;pram2&quot;]&#125;);// 定义父组件const father = Vue.extend(&#123; template:` &lt;div&gt; &lt;h3&gt;父组件&lt;/h3&gt; &lt;son pram=&quot;props传递的普通字符串&quot; :pram2=&quot;name&quot;&gt;&lt;/son&gt; &lt;/div&gt;`, name:&quot;father&quot;, data()&#123; return &#123; name:&quot;父组件data中的name&quot;, &#125; &#125;, components:&#123; son &#125;&#125;);// 在Vue中注册父组件let vm = new Vue(&#123; el :&quot;#root&quot;, components:&#123; father &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 指令为了开发方便,Vue为我们提供了一些常用操作的基本指令,可在html标签中使用 内置指令v-bind我们已经成功创建了第一个Vue应用！看起来这跟渲染一个字符串模板非常类似， 但是Vue在背后做了大量工作。现在数据和DOM已经被建立了关联， 所有东西都是响应式的。我们在控制台操作对象属性，界面可以实时更新!我们还可以使用**v-bind来绑定元素的属性! v-bind还有一个简写形式, 可用:直接代替** 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--view层 模板--&gt;&lt;div id=&quot;app&quot;&gt; &lt;span v-bind:title=&quot;message&quot;&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt;&lt;/div&gt;&lt;!--导入vue.js--&gt;&lt;script src=&quot;https://v2.vuejs.org/js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm=new Vue(&#123; el:&quot;#app&quot;, // Model:数据 data:&#123; message:&quot;hello,vue!!&quot; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-model Vue双向绑定1、什么是双向绑定 Vue.js是一个MVVM框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是Vue.js的精髓之处了。 值得注意的是，我们所说的数据双向绑定，一定是对于UI控件来说的，非UI控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用vuex，那么数据流也是单项的，这时就会和双向数据绑定有冲突。 2、为什么要实现数据的双向绑定在Vue.js 中，如果使用vuex，实际上数据还是单向的，之所以说是数据双向绑定，这是用的UI控件来说，对于我们处理表单，Vue.js的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项，方便跟踪；局部性数据流使用双向，简单易操作。 3、在表单中使用双向数据绑定你可以用v-model指令在表单 &lt;input&gt;、&lt;textarea&gt;及&lt;select&gt;元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但v-model本质上不过是语法糖。它负责监听户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 注意：v-model会忽略所有元素的value、checked、selected特性的初始值而总是将Vue实例的数据作为数据来源，你应该通过JavaScript在组件的data选项中声明 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;双向绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;文本：&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&#123;&#123;message&#125;&#125;&lt;!-- 文本：&lt;textarea type=&quot;text&quot; cols=&quot;30&quot; rows=&quot;10&quot; v-model=&quot;message&quot;&gt;&lt;/textarea&gt;&#123;&#123;message&#125;&#125; --&gt; 性别： &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; v-model=&quot;checked&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; v-model=&quot;checked&quot;&gt;女&lt;p&gt;选中了：&#123;&#123;checked&#125;&#125;&lt;/p&gt; 下拉框 &lt;select v-model=&quot;acc&quot; name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;value:&#123;&#123;acc&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script src=&quot;https://v2.vuejs.org/js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &#x27;123&#x27; &#125;, &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：v-model表达式的初始值未能匹配任何选项，元系将被渲染为“未选中”状态。 在iOS中， 这会使用户无法选择第一个选项，因为这样的情况下，iOS不会触发change事件。因此，更推荐像上面这样提供一个值为空的禁用选项。 表单数据收集 若是：&lt;input type=&quot;text&quot;/&gt;，则v-model收集的是value值 ​ 若是：&lt;input type=&quot;radio&quot;/&gt;，则v-model收集的是value值 ​ 若是：&lt;input type=&quot;checkbox&quot;/&gt; ​ 1.没有配置input的value属性，那么收集的的就是checked（勾选 or 未勾选，是布尔值） ​ 2.配置input的value属性: ​ (1).v-model的初始值是非数组，那么收集的的就是checked（勾选 or 未勾选，是布尔值） ​ (2).v-model的初始值是数组，那么收集的的就是value组成的数组 ​ 备注: v-model的三个修饰符: ​ lazy: 失去焦点再收集数据 ​ number: 输入字符串转为有效数字 ​ trim: 输入首尾空格过滤 样例如下所示: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;收集表单数据&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;form @submit.prevent=&quot;submit&quot;&gt; 账号：&lt;input type=&quot;text&quot; v-model=&quot;userInfo.account&quot;&gt; &lt;br/&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt; &lt;br/&gt;&lt;br/&gt; 性别：男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt; 女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot;&gt; &lt;br/&gt;&lt;br/&gt; 爱好：抽烟 &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;smoke&quot;&gt; 喝酒 &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;drink&quot;&gt; 开车 &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;drive&quot;&gt; &lt;br/&gt;&lt;br/&gt; 所属校区：&lt;select v-model=&quot;userInfo.city&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt; &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;wuhan&quot;&gt;武汉&lt;/option&gt; &lt;/select&gt; &lt;br/&gt;&lt;br/&gt; 其他信息：&lt;textarea v-model=&quot;userInfo.other&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt; &lt;input v-model=&quot;userInfo.agree&quot; type=&quot;checkbox&quot;&gt;阅读并接受&lt;a href=&quot;http://www.atguigu.com&quot;&gt;《用户协议》&lt;/a&gt; &lt;br/&gt;&lt;br/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; &gt; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; userInfo:&#123; account:&#x27;&#x27;, password:&#x27;&#x27;, sex:&#x27;&#x27;, hobby:[], city:&#x27;&#x27;, other:&#x27;&#x27;, agree:false, &#125; &#125;, methods:&#123; submit()&#123; console.log(this.userInfo) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-if，v-else 和 v-show123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h3 v-show=&quot;isHiden1&quot;&gt;使用v-show隐藏 原生js display:none&lt;/h3&gt; &lt;button type=&quot;button&quot; @click=&quot;Cut_hiden(1)&quot;&gt;v-show隐藏/显示&lt;/button&gt; &lt;template v-if=&quot;isHiden2&quot;&gt; &lt;h3 &gt;使用v-if隐藏 直接删除dom(注意会影响结构)&lt;/h3&gt; &lt;p&gt;&lt;i&gt;扩展:可以使用template标签配合v-if(但是不能使用 v-show)使用包裹不会影响结构,使用div包裹会结构&lt;/i&gt;&lt;/p&gt; &lt;/template&gt; &lt;button type=&quot;button&quot; @click=&quot;Cut_hiden(2)&quot;&gt;v-if隐藏/显示&lt;/button&gt; &lt;!-- 条件渲染除了有 v-if 还有 , v-else-if , v-else 逻辑与一般编程语言的 if 语句逻辑相同 --&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: &quot;#root&quot;, data: &#123; isHiden1: true, isHiden2: true &#125;, methods: &#123; Cut_hiden(type) &#123; if (type == 1) &#123; this.isHiden1 = !this.isHiden1; &#125; else &#123; this.isHiden2 = !this.isHiden2; &#125; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 测试： 1、在浏览器上运行，打开控制台!2、在控制台输入vm.ok=false然后回车，你会发现浏览器中显示的内容会直接变成NO 注：使用v-*属性绑定数据是不需要双花括号&#123;&#123;&#125;&#125;包裹的 v-else-if v-if v-else-if v-else 注：===三个等号在JS中表示绝对等于（就是数据与类型都要相等） v-for类似 js 的 for in 以及for of , for in 与 for of 的区别是: for in 遍历的是key,适合遍历对象(拿到属性名),也可以遍历数组(拿到索引值) for of 遍历的是 value 适合遍历数组,(不过在js中不可遍历对象,因为对象没有迭代器) 此外还可以遍历次数 和字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;使用 v-for=&quot;(value,index) in persons&quot; 遍历 &lt;/h3&gt; &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;index&quot;&gt; &lt;!-- v-for p in persons 也行,这样不返回索引值 --&gt; 名字:&#123;&#123;p&#125;&#125; - 年龄: &#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;br/&gt; &lt;h3&gt;使用 v-for=&quot;(value,key) of obj&quot; 遍历 &lt;/h3&gt; &lt;li v-for=&quot;(val,k) of obj&quot; :key=&quot;k&quot;&gt; &#123;&#123;val&#125;&#125; ,&#123;&#123;k&#125;&#125; &lt;/li&gt; &lt;!-- 此外还可以遍历次数 和字符串 --&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: root, data:&#123; persons:[ &#123;id:&quot;001&quot;,name:&quot;张三&quot;,age:18&#125;, &#123;id:&quot;002&quot;,name:&quot;李四&quot;,age:23&#125;, &#123;id:&quot;003&quot;,name:&quot;王五&quot;,age:19&#125;, ], obj :&#123; key1:&quot;value1&quot;, key2:&quot;value2&quot;, key3:&quot;value3&quot;, &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 补充: Vue检测数组中元素改变是通过检测js中几个原生方法的调用还判断数组是否改变的, 假如修改数组不是通过这几个原生方法则Vue无法响应数组的改变 shift() : 移除头端第一个元素 unshift(元素) : 在头端添加元素 push(元素) : 相当于入栈,在尾部追加 pop() : 相当于出栈, 在尾部删除 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;使用 v-for=&quot;(value,index) in persons&quot; 遍历 &lt;/h3&gt; &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;index&quot;&gt; &lt;!-- v-for p in persons 也行,这样不返回索引值 --&gt; 名字:&#123;&#123;p&#125;&#125; - 年龄: &#123;&#123;index&#125;&#125; &lt;/li&gt; &lt;br/&gt; &lt;h3&gt;使用 v-for=&quot;(value,key) of obj&quot; 遍历 &lt;/h3&gt; &lt;li v-for=&quot;(val,k) of obj&quot; :key=&quot;k&quot;&gt; &#123;&#123;val&#125;&#125; ,&#123;&#123;k&#125;&#125; &lt;/li&gt; &lt;!-- 此外还可以遍历次数 和字符串 --&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: root, data:&#123; persons:[ &#123;id:&quot;001&quot;,name:&quot;张三&quot;,age:18&#125;, &#123;id:&quot;002&quot;,name:&quot;李四&quot;,age:23&#125;, &#123;id:&quot;003&quot;,name:&quot;王五&quot;,age:19&#125;, ], obj :&#123; key1:&quot;value1&quot;, key2:&quot;value2&quot;, key3:&quot;value3&quot;, &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Key原理可通过:key来绑定遍历的关键字,只有选择正确的关键字才不会出现dom错位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;index作为key&lt;/h3&gt; &lt;button type=&quot;button&quot; @click=&quot;add_per(1)&quot;&gt;添加一个老刘&lt;/button&gt; &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt; 名字:&#123;&#123;p.name&#125;&#125; - 年龄: &#123;&#123;p.age&#125;&#125; &lt;input type=&quot;text&quot;/&gt; &lt;/li&gt; &lt;hr&gt; &lt;h3&gt;index作为key&lt;/h3&gt; &lt;button type=&quot;button&quot; @click=&quot;add_per(2)&quot;&gt;添加一个老刘&lt;/button&gt; &lt;li v-for=&quot;(p,index) of persons2&quot; :key=&quot;p.id&quot;&gt; 名字:&#123;&#123;p.name&#125;&#125; - 年龄: &#123;&#123;p.age&#125;&#125; &lt;input type=&quot;text&quot;/&gt; &lt;/li&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: root, data:&#123; persons:[ &#123;id:&quot;001&quot;,name:&quot;张三&quot;,age:18&#125;, &#123;id:&quot;002&quot;,name:&quot;李四&quot;,age:23&#125;, &#123;id:&quot;003&quot;,name:&quot;王五&quot;,age:19&#125;, ], // 对照组 persons2:[ &#123;id:&quot;001&quot;,name:&quot;张三&quot;,age:18&#125;, &#123;id:&quot;002&quot;,name:&quot;李四&quot;,age:23&#125;, &#123;id:&quot;003&quot;,name:&quot;王五&quot;,age:19&#125;, ], &#125;, methods:&#123; add_per(type)&#123; if(type==1)&#123; this.persons.unshift(&#123;id:&quot;004&quot;,name:&quot;老刘&quot;,age:25&#125;); &#125; else&#123; this.persons2.unshift(&#123;id:&quot;004&quot;,name:&quot;老刘&quot;,age:25&#125;); &#125; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 列表过滤:如下是实现了一个模糊搜索的列表过滤 知识补充: Array.filter() 它创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意：filter()不会对空数组进行检测、不会改变原始数组 语法:Array.filter(function(currentValue, indedx, arr), thisValue) 其中，函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留；函数的第一个参数 currentValue 也为必须，代表当前元素的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;列表过滤(watch实现)&lt;/h3&gt; 模糊搜索:&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; placeholder=&quot;请输入名字&quot;/&gt; &lt;br&gt; &lt;li v-for=&quot;(p,index) of filterPersons&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125; - &#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;h3&gt;列表过滤(computed实现)&lt;/h3&gt; 模糊搜索:&lt;input type=&quot;text&quot; v-model=&quot;keyword2&quot; placeholder=&quot;请输入名字&quot;/&gt; &lt;br&gt; &lt;li v-for=&quot;(p,index) of key_person&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125; - &#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: root, data:&#123; persons:[ &#123;id:&quot;001&quot;,name:&quot;马冬梅&quot;,age:32&#125;, &#123;id:&quot;002&quot;,name:&quot;周冬雨&quot;,age:18&#125;, &#123;id:&quot;003&quot;,name:&quot;周杰伦&quot;,age:26&#125;, &#123;id:&quot;004&quot;,name:&quot;温兆伦&quot;,age:27&#125; ], // 搜索关键字 keyword:&quot;&quot;, // 过滤后的数据 filterPersons:[], persons2:[ &#123;id:&quot;01&quot;,name:&quot;马冬梅&quot;,age:32&#125;, &#123;id:&quot;02&quot;,name:&quot;周冬雨&quot;,age:18&#125;, &#123;id:&quot;03&quot;,name:&quot;周杰伦&quot;,age:26&#125;, &#123;id:&quot;04&quot;,name:&quot;温兆伦&quot;,age:27&#125; ], // 搜索关键字 keyword2:&quot;&quot;, &#125;, methods:&#123; &#125;, computed:&#123; key_person()&#123; return this.persons2.filter((p)=&gt;&#123; return p.name.indexOf(this.keyword2) !== -1 &#125;) &#125; &#125;, watch:&#123; keyword:&#123; immediate:true, handler(newValue)&#123; /* Array.filter() 用法 它创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意：filter()不会对空数组进行检测、不会改变原始数组 语法:Array.filter(function(currentValue, indedx, arr), thisValue) 其中，函数 function 为必须，数组中的每个元素都会执行这个函数。且如果返回值为 true，则该元素被保留； 函数的第一个参数 currentValue 也为必须，代表当前元素的值。 */ return this.filterPersons = this.persons.filter((p)=&gt;&#123; // indexOf() 判断一个字符串是否包含参数字符串,返回匹配值的首字符索引,不存在返回 -1 // 并且每个数组都包含空串 // console.log(&quot;过滤器的this是:&quot;,this); //this 因为是箭头函数指向父级上下问,即 vm return p.name.indexOf(newValue) !== -1; &#125;) &#125; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 列表排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h3&gt;列表过滤(computed实现)&lt;/h3&gt; 模糊搜索:&lt;input type=&quot;text&quot; v-model=&quot;keyword2&quot; placeholder=&quot;请输入名字&quot;/&gt; &lt;br&gt; &lt;li v-for=&quot;(p,index) of filPerson&quot; :key=&quot;p.id&quot;&gt; &#123;&#123;p.name&#125;&#125; - &#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;br&gt; &lt;button type=&quot;button&quot; @click=&quot;sortType = 1&quot;&gt;按年龄升序&lt;/button&gt; &lt;button type=&quot;button&quot; @click=&quot;sortType = 2&quot;&gt;按年龄降序&lt;/button&gt; &lt;button type=&quot;button&quot; @click=&quot;sortType = 0&quot;&gt;复原&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; var vm = new Vue(&#123; el: root, data:&#123; persons2:[ &#123;id:&quot;01&quot;,name:&quot;马冬梅&quot;,age:32&#125;, &#123;id:&quot;02&quot;,name:&quot;周冬雨&quot;,age:18&#125;, &#123;id:&quot;03&quot;,name:&quot;周杰伦&quot;,age:26&#125;, &#123;id:&quot;04&quot;,name:&quot;温兆伦&quot;,age:27&#125; ], // 搜索关键字 keyword2:&quot;&quot;, sortType:0, // 0 原顺序 , 1 升序 , 2降序 &#125;, methods:&#123; &#125;, computed:&#123; filPerson()&#123; let arr = this.persons2.filter((p)=&gt;&#123; return p.name.indexOf(this.keyword2) !== -1 &#125;); // 判断排序类型 if(this.sortType)&#123; arr.sort((p1,p2)=&gt;&#123; return this.sortType === 1 ? (p1.age-p2.age):(p2.age-p1.age); &#125;); // 补充 js 中 array.sort(function(a,b)&#123;如果是return a-b就升序,否则降序&#125; &#125; return arr ; &#125; &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-on 事件绑定v-on监听事件 , 事件有Vue的事件、和前端页面本身的一些事件!我们这里的click是vue的事件，可以绑定到Vue中的methods中的方法事件! 此外v-on还有一个简写形式: 可直接用@代替v-on 注意: 当给元素(html标签)绑定好事件后, 即使组件销毁后, 元素绑定的事件依然存在 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;!-- 在这里我们使用了v-on绑定了click事件，并指定了名为sayHi的方法 --&gt; &lt;button v-on:click=&quot;sayHi&quot;&gt;click me&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://v2.vuejs.org/js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &#x27;狂神说java&#x27; &#125;, methods: &#123; //方法必须定义在vue 的Methods对象中 sayHi: function () &#123; //this 在方法里指向当前Vue实例 alert(this.message); &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-text 和 v-html两者底层都是innerHtml或InnerText,会覆盖原来的内容 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;内置指令&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;解析数据&lt;/h2&gt; &lt;h3 v-text=&quot;inText&quot;&gt;&lt;/h3&gt; &lt;h3 v-html=&quot;inHtml&quot;&gt;&lt;/h3&gt; &lt;p&gt;注意:两者底层都是innerHtml或InnerText,会覆盖原来的内容&lt;/p&gt; let vm = new Vue(&#123; el :&quot;#root&quot;, data :&#123; inText :&quot;v-text将数据解析成普通文本(推荐使用)&quot;, inHtml :&quot;&lt;a href=&#x27;#&#x27;&gt;v-html能将数据解析成html标签&lt;/a&gt;&quot;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-cloak , v-once , v-oncev-cloak:v-cloak在vue加载后会清除,通常配合css属性选择器使用 使用场景:比如在vue还没加载时,会将vue未解析的内容显示出来可以使用属性选择器[v-cloak]{display:none}将其隐藏,随后vue加载后会把v-cloak属性清除随后解析内容 v-once:v-once只解析一次,随后就变成静态内容,不会再响应数据变化 v-pre:v-pre 使用后vue不解析使用此指令的东西\\ 应用场景:能提高效率,静态内容使用此指令,vue能直接跳过从而避免逐一解析影响性能 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;内置指令&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;br&gt; &lt;h2&gt;v-cloak在vue加载后会清除,通常配合css属性选择器使用&lt;/h2&gt; &lt;p&gt;使用场景:比如在vue还没加载时,会将vue未解析的内容显示出来 可以使用属性选择器[v-cloak]&#123;display:none&#125;将其隐藏,随后vue加载后会把v-cloak属性清除 随后解析内容 &lt;/p&gt; &lt;br&gt; &lt;h2&gt;v-once只解析一次,随后就变成静态内容,不会再响应数据变化&lt;/h2&gt; &lt;h3 v-once&gt;使用v-once后:&#123;&#123;n&#125;&#125;&lt;/h3&gt; &lt;h3&gt;不使用v-once&#123;&#123;n&#125;&#125;&lt;/h3&gt; &lt;button type=&quot;button&quot; @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;br&gt; &lt;h2&gt;v-pre 使用后vue不解析使用此指令的东西&lt;/h2&gt; &lt;h3 v-pre&gt;&#123;&#123;n&#125;&#125;&lt;/h3&gt; &lt;p&gt;应用场景:能提高效率,静态内容使用此指令,vue能直接跳过从而避免逐一解析影响性能&lt;/p&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false; let vm = new Vue(&#123; el :&quot;#root&quot;, data :&#123; inText :&quot;v-text将数据解析成普通文本(推荐使用)&quot;, inHtml :&quot;&lt;a href=&#x27;#&#x27;&gt;v-html能将数据解析成html标签&lt;/a&gt;&quot;, n :1, &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义指令通过vm 的directives 配置属性,我们可以定义局部自定义指令,并结合钩子函数选择何时调用,执行什么操作 如需定义全局自定义指令, 可以使用Vue.dereactives(&#123;...&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;!-- 如下案例将演示 创建一个自定义指令 v-big 将一个值扩大10倍 用法: 在vue里设置配置项 directives 值可以是函数和对象 如果是函数,则可以有两个默认参数 function(element,binding) 其中,binding是一个对象,存在一些关于使用指令时的属性:expression: &quot;10&quot; 表达式,也就是指令等号里的内容modifiers: &#123;&#125; name: &quot;big&quot; 指令的名字(不带v-)rawName: &quot;v-big&quot; 指令全称value: 10 表达式的值 --&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;自定义指令v-big&lt;/h2&gt; &lt;h3&gt;这是一个值n:&#123;&#123;n&#125;&#125;&lt;/h3&gt; &lt;h3 v-big=&quot;n&quot;&gt;使用自定义的指令v-big&#123;&#123;n&#125;&#125;&lt;/h3&gt; &lt;button type=&quot;button&quot; @click=&quot;n++&quot;&gt;n++&lt;/button&gt; &lt;br&gt; &lt;h2&gt;自定义一个指令v-fbing,使文本框自动获取焦点,并且获得2*n的值&lt;/h2&gt; n :&lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt; &lt;/div&gt; &lt;script&gt; Vue.config.productionTip = false; let vm = new Vue(&#123; el :&quot;#root&quot;, data :&#123; n :1, &#125;, directives:&#123; // big函数何时会被调用? // 1.当指令与元素成功绑定后(即使最开始加载时); // 2.指令所在的模板被修改时(模板包括了差值语法和指令语法) // 注意:这与methods和其他指令等内置的不同,他们是依赖数据改变才会改变,其原因是底层做了复用优化 big(element,binding)&#123; console.log(element,binding); element.innerText =&quot;使用自定义指令v-big &quot;+ binding.value * 10; &#125;, /************对象式:*********************/ // 实际上, 函数式就是 bind函数与update函数结合 // 下面这几个经常被称为钩子 fbind:&#123; // 指令与模板绑定时调用 bind(element,binding)&#123; console.log(&quot;bind&quot;); element.value = 2*binding.value; &#125;, // 指令所在元素被插入页面时调用 inserted(element,binding)&#123; // 获取焦点 element.focus(); console.log(&quot;update&quot;); &#125;, // 指令所在模板被重新解析 update(element,binding)&#123; console.log(&quot;update&quot;); element.value = 2*binding.value; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ref 属性我们可以在组件标签中或者html标签中添加一个属性值,ref, 它被用来给组件或者元素注册引用信息 在组件中使用, 可以获取到该组件的 vc 实例对象 在html标签中使用, 获取的是dom元素 注: 假如用 html的原生标签属性 id 来标识并获取组件标签, 则会得到将组件解析后的dom元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;ref属性&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;app&gt;&lt;/app&gt; &lt;/div&gt; &lt;script&gt;Vue.config.productionTip = false;// 定义组件let student = Vue.extend(&#123; name: &quot;student&quot;, template:`&lt;div&gt; &lt;h3&gt;子组件的元素&lt;/h3&gt; &lt;h3&gt;姓名:&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;/div&gt;`, data()&#123; return &#123; name:&quot;神奈川&quot;, &#125; &#125;&#125;);// 定义组件const app = &#123; template:`&lt;div&gt; &lt;h2 ref = &quot;f_h3&quot;&gt;父组件&lt;/h2&gt; &lt;student ref = &quot;stu&quot;&gt;&lt;/student&gt; &lt;button @click=&quot;showInfo()&quot;&gt;点我打印信息&lt;/button&gt; &lt;/div&gt;`, components:&#123; student &#125;, methods:&#123; showInfo()&#123; console.log(&quot;dom使用ref属性&quot;,this.$refs.f_h3) console.log(&quot;组件使用ref属性&quot;,this.$refs.stu) &#125; &#125;&#125;let vm = new Vue(&#123; el :&quot;#root&quot;, components:&#123; app &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 插件, 混入(mixin)插件用于拓展功能,插件本质上是一个个暴露的js模块 定义插件:z在js文件中,插件名.js 123456obj.install = function(Vue, options)&#123; // 此处的Vue并不是vm, 而是vm的缔造者,他的原型对象 // 功能代码: 如定义全局过滤器, 全局指令等 Vue.filter(...) Vue.directive(...) Vue.mixin(...)&#125; 使用插件:在实例化vm之前, 1Vue.use(&quot;插件名&quot;) 混入(用到在学)样式绑定1.class样式 写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。 字符串写法适用于：类名不确定，要动态获取。 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。 2. style样式 :style=”{fontSize: xxx}”其中xxx是动态值。 :style=”[a,b]”其中a、b是样式对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;绑定样式&lt;/title&gt; &lt;style&gt; .basic&#123; width: 400px; height: 100px; border: 1px solid black; &#125; .happy&#123; border: 4px solid red;; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg,yellow,pink,orange,yellow); &#125; .sad&#123; border: 4px dashed rgb(2, 197, 2); background-color: gray; &#125; .normal&#123; background-color: skyblue; &#125; .atguigu1&#123; background-color: yellowgreen; &#125; .atguigu2&#123; font-size: 30px; text-shadow:2px 2px 10px red; &#125; .atguigu3&#123; border-radius: 20px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定style样式--对象写法 --&gt; &lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定style样式--数组写法 --&gt; &lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;尚硅谷&#x27;, mood:&#x27;normal&#x27;, classArr:[&#x27;atguigu1&#x27;,&#x27;atguigu2&#x27;,&#x27;atguigu3&#x27;], classObj:&#123; &#x27;atguigu1&#x27;:false, &#x27;atguigu2&#x27;:false, &#125;, styleObj:&#123; fontSize: &#x27;40px&#x27;, color:&#x27;red&#x27;, &#125;, styleObj2:&#123; backgroundColor:&#x27;orange&#x27; &#125;, styleArr:[ &#123; fontSize: &#x27;40px&#x27;, color:&#x27;blue&#x27;, &#125;, &#123; backgroundColor:&#x27;gray&#x27; &#125; ] &#125;, methods: &#123; changeMood()&#123; const arr = [&#x27;happy&#x27;,&#x27;sad&#x27;,&#x27;normal&#x27;] const index = Math.floor(Math.random()*3) this.mood = arr[index] &#125; &#125;, &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 生命周期(钩子函数)每个vm实例对象 (vc组件实例对象) 都有生命周期 , 我们可以在vm配置项中编写对应生命周期函数(一般叫钩子函数) , 可以在特定的时机执行一些逻辑操作 生命周期过程: 钩子函数创建:beforeCreate(): created(): 挂载:beforeMount() mounted() (重要) 更新:beforeUpate(): updated() 销毁:beforeDestory() (重要) destory() 补充:上面的生命周期结构图中有三个生命周期钩子没有体现出来 $nextTick使用 vm中的$nextTick(回调函数)可以在Vue帮我们解析完dom模板后, 在执行回调函数里面的逻辑操作, 可以用于生成输入框并自动获取焦点 路由生命周期钩子路由组件有两个生命周期钩子 , 分别是路由组件被激活时和失活时 组件事件自定义组件事件绑定有两种绑定方式: 通过v-on或简写形式@在组件标签中直接绑定: &lt;组件名 @自定义组件名=&quot;事件函数名&quot;&gt;&lt;/组件名&gt; 注册子组件引用(子组件添加ref属性) , 随后通过父组件的this.$refs.子组件引用值.$on(&quot;自定义组件名&quot;,事件函数) 触发组件事件: 可以在绑定事件的组件中, 通过调用this.$emit(&quot;自定义组件名&quot;,数据)来触发组件事件(注意:此处的this是指向绑定了组件事件的组件实例对象vc,即子组件对象而不是父组件) 如下样例:将演示, 在app组件中,有两个子组件分别是: school 和 student , school组件通过props传递函数来实现向父组件传递数据, 而student组件to通过绑定自定义事件, 调用事件函数来传递数据 父组件:App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;app组件&lt;/h2&gt; &lt;h3&gt;接收参数1:&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;!-- 通过props传递函数,子组件调用函数传递参数 实现子组件向父组件传递数据 --&gt; &lt;School :getSchoolName=&quot;getSchoolName&quot;&gt;&lt;/School&gt; &lt;!-- 通过自定义组件事件,由子组件在触发内置事件时,通过$emit() 触发组件事件,并传递数据 --&gt; &lt;Student @my_event=&quot;getStudentName&quot;&gt;&lt;/Student&gt; &lt;!-- &lt;Student ref=&quot;student&quot;&gt;&lt;/Student&gt; --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import School from &#x27;./components/scholl.vue&#x27;import Student from &#x27;./components/student.vue&#x27;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; name: &quot;姓名&quot;, &#125; &#125;, components: &#123; School, Student &#125;, mounted() &#123; // 定时器... // this.$refs.student.$on(&quot;my_event&quot;,this.getStudentName) // 只执行一次 // this.$refs.student.$once(&quot;my_event&quot;,this.getStudentName) &#125;, methods: &#123; // ES6语法: function(参数1,...参数) 表示参数重载,可以选用多个参数, 多个参数用数组存储 getSchoolName(receiveData,...prarms)&#123; console.log(&quot;父组件接收到了学校的数据:&quot;,receiveData); this.name = receiveData.name &#125;, getStudentName(name)&#123; console.log(&quot;父组件接收到了学生的数据&quot;,name); this.name = name &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#root &#123; background-color: aqua;&#125;&lt;/style&gt; 子组件:school,vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 组件的结构 --&gt;&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2&gt;学校信息:&lt;/h2&gt; &lt;h3&gt;学校:&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;地址:&#123;&#123;address&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;sendSchool()&quot;&gt;通过传递参数向父组件传递信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 组件交互 --&gt;&lt;script&gt; // 模块化导出, 默认导出一个文件只可以有一个,此外还有分别导出和统一导出 // 使用默认导出的时候比较简单 export default &#123; name:&quot;school&quot;, //为了更好在开发者工具显示 data() &#123; return &#123; name:&quot;广科师&quot;, address:&quot;广西来宾&quot; &#125; &#125;, props: [&quot;getSchoolName&quot;], methods: &#123; sendSchool()&#123; this.getSchoolName(&#123;&#x27;name&#x27;:this.name, &quot;address&quot;: this.address&#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;!-- 组件的样式 --&gt;&lt;style scoped&gt; .demo&#123; background-color: rgb(135, 233, 110); padding: 5px; &#125;&lt;/style&gt; 子组件student.vue: 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2&gt;学生信息:&lt;/h2&gt; &lt;h3&gt;姓名:&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;年龄:&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;sendStudentName&quot;&gt;点我向父组件发送数据&lt;/button&gt; &lt;/div &gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;student&quot;, data() &#123; return &#123; name:&quot;神奈川&quot;, age:18 &#125; &#125;, methods: &#123; sendStudentName()&#123; // 触发 组件事件的api: $emit(&quot;自定义组件事件名&quot;,数据) , 其中数据是可选的 this.$emit(&quot;my_event&quot;,this.name) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .demo&#123; background-color: aquamarine; padding: 5px; &#125;&lt;/style&gt; 入口文件: main.js: 12345678import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#root&#x27;) 自定义组件事件解绑通过this.$off(参数)可以解绑事件,this指向需要解绑组件事件的组件实例对象vc,其中该函数有三种重载形式: this.$off(&quot;组件事件名&quot;) : 解绑指定的组件事件, (注意:参数写的是组件事件名, 而不是事件回调名) this.$off([&quot;组件事件名1&quot;,组件事件名2,&quot;组件事件名3&quot;]): 解绑多个组件事件 this.$off() : 解绑所有组件事件 样例: App.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;app组件&lt;/h2&gt; &lt;h3&gt;接收参数1:&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;!-- 通过自定义组件事件,由子组件在触发内置事件时,通过$emit() 触发组件事件,并传递数据 --&gt; &lt;Student @my_event=&quot;getStudentName&quot; @my_event2=&quot;getStudentName2&quot;&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./components/student.vue&#x27;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; name: &quot;姓名&quot;, &#125; &#125;, components: &#123; Student &#125;, mounted() &#123; // 定时器... // this.$refs.student.$on(&quot;my_event&quot;,this.getStudentName) // 只执行一次 // this.$refs.student.$once(&quot;my_event&quot;,this.getStudentName) &#125;, methods: &#123; getStudentName(name)&#123; console.log(&quot;父组件接收到了学生的数据&quot;,name); this.name = name &#125;, getStudentName2()&#123; console.log(&quot;学生组件的第二个事件回调函数&quot;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#root &#123; background-color: aqua;&#125;&lt;/style&gt; 绑定组件事件的组件: Student.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2&gt;学生信息:&lt;/h2&gt; &lt;h3&gt;姓名:&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;年龄:&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;sendStudentName&quot;&gt;点我向父组件发送数据&lt;/button&gt; &lt;br&gt; &lt;button @click=&quot;unbind&quot;&gt;解绑组件事件&lt;/button&gt; &lt;/div &gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;student&quot;, data() &#123; return &#123; name:&quot;神奈川&quot;, age:18 &#125; &#125;, methods: &#123; sendStudentName()&#123; // 触发 组件事件的api: $emit(&quot;自定义组件事件名&quot;,数据) , 其中数据是可选的 this.$emit(&quot;my_event&quot;,this.name) // 触发第二个组件事件 this.$emit(&quot;my_event2&quot;) &#125;, // 解绑组件事件回调函数 unbind()&#123; // 解绑指定事件: this.$off(&quot;my_event2&quot;) // 解绑多个事件, 注意参数为数组类型 // this.$off([&quot;my_event&quot;,&quot;my_event2&quot;]) // 若不写参数, 则默认解绑所有组件事件 // this.$off() &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .demo&#123; background-color: aquamarine; padding: 5px; &#125;&lt;/style&gt; 组件原生事件:组件要想绑定原生事件,只需要加上一个事件修饰符native即可, (因为组件绑定的事件, 默认是自定义事件) 123&lt;组件名 @原生事件名.native=&quot;事件回调函数名&quot;&gt;&lt;/组件名&gt;&lt;!--或--&gt;&lt;组件名 v-on:原生事件名.native=&quot;事件回调函数名&quot;&gt;&lt;/组件名&gt; 注意: 给组件绑定原生事件, 触发时是以组件的最外层模板元素为准的,这也解释了为啥组件的模板为啥只能有一个最外层元素的原因 全局组件事件总线通过全局组件事件,我们可以==实现兄弟组件之间的组件通信==, 其原理是在Vue的原型组件上添加一个属性$bus , 该属性的类型为Vue类型的对象,指向了一个Vue的实例 , 接收数据的组件,通过this.$bus.$on(&quot;全局组件事件名&quot;,事件回调函数)可在组件事件回调函数中接收到数据 发送数据的组件通过this.$bus.$emit(&quot;全局组件事件名&quot;,数据) 则可以触发全局组件事件并且传送数据 如下案例: 通过全局组件事件Student组件向Scholl组件传送数据 1.首先在vm实例中,通过钩子函数添加全局事件总线$bus , 在main.js中 1234567891011121314import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App), beforeCreate()&#123; // 添加 全局事件总线 Vue.prototype.$bus = this &#125;&#125;).$mount(&#x27;#root&#x27;) App.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;app组件&lt;/h2&gt; &lt;School&gt;&lt;/School&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import School from &#x27;./components/scholl.vue&#x27;import Student from &#x27;./components/student.vue&#x27;export default &#123; name: &#x27;App&#x27;, components: &#123; School, Student &#125;,&#125;&lt;/script&gt;&lt;style&gt;#root &#123; background-color: aqua;&#125;&lt;/style&gt; scholl,vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 组件的结构 --&gt;&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2&gt;学校组件&lt;/h2&gt; &lt;h3&gt;学生名:&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;school&quot;, //为了更好在开发者工具显示 data() &#123; return &#123; name:&quot;&quot;, address:&quot;广西来宾&quot; &#125; &#125;, mounted() &#123; this.$bus.$on(&quot;SchoolReceive&quot;,(data)=&gt;&#123; console.log(&quot;School组件接收数据所绑定的全局事件的回调函数:&quot;,data); this.name = data &#125;) &#125;, // 为了不造成耦合, 最好在组件销毁时把其绑定的事件解绑 beforeDestroy() &#123; this.$bus.$off(&quot;SchoolReceive&quot;) &#125;, &#125;&lt;/script&gt;&lt;!-- 组件的样式 --&gt;&lt;style scoped&gt; .demo&#123; background-color: rgb(135, 233, 110); padding: 5px; &#125;&lt;/style&gt; student.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2&gt;学生信息:&lt;/h2&gt; &lt;h3&gt;姓名:&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;年龄:&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;sendStudentName&quot;&gt;向学校组件发送数据&lt;/button&gt; &lt;br&gt; &lt;/div &gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;student&quot;, data() &#123; return &#123; name:&quot;神奈川&quot;, age:18 &#125; &#125;, methods: &#123; sendStudentName()&#123; this.$bus.$emit(&quot;SchoolReceive&quot;,this.name) &#125;, &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .demo&#123; background-color: aquamarine; padding: 5px; &#125;&lt;/style&gt; vue脚手架(CLI)CLI即command line Interface,命令行接口,在使用单文件组件的时候会用到 安装脚手架注意:使用的命令行尽量都使用管理员权限的命令行 脚手架的安装需要node.js环境 node.js安装与配置由于 Node.js 中默认安装了 npm，所以不用额外配置就能在全局命令中使用 npm命令，如果要使用自己安装的 npm 时，如 cnpm ，那么就需要像上面一样添加相应的环境变量然后在cmd或者shell中测试一下是否安装成功了：输入 node -v 与 npm -v node.js修改默认下载地址在node.js下新建两个文件夹如下所示 随后输入命令修改配置: 12npm config set prefix &quot;D:\\node安装目录\\node_global&quot; 注意:目录自行替换 npm config set cache &quot;D:\\node安装目录\\node_cache&quot; 将来全局安装的东西就会跑到这个文件夹的node_modules文件夹里面去了。 配置npm镜像源输入如下命令: 1npm --registry https://registry.npm.taobao.org install express -g 配置环境变量增加系统环境变量NODE_PATH 内容是：D:\\node安装目录\\node安装目录\\node_modules 最后编辑用户变量里的Path，将相应npm的路径改为：D:\\node安装目录\\node_global(以自己路径为主) 至此node.js环境就配置好了 下载脚手架CLI命令 :npm install -g @vue/cli 使用脚手架切换到需要创建项目的目录 创建项目: vue create 项目名 运行项目: npm run serve 项目结构 基本的html页面相关说明 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 兼容IE --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- 开启移动端最理想视图 --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;!-- 引入图标, &lt;%= BASE_URL %&gt;表示脚手架配置处理的路径 --&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;!-- 引入配置的网页标题 --&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- noscript标签当浏览器不支持js的时候才会渲染 --&gt; &lt;noscript&gt; &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 配置修改vue.config.js配置文件在项目的根目录下(没有可以在自己新建) 随后来到vue官网的CLI配置栏目进行查找: 配置参考 | Vue CLI (vuejs.org) VueCli命令与配置速查命令:12345678910vue create 项目名 #在当前目录下创建vue项目npm run serve #启动项目服务npm i vue-router #安装vue路由插件 ,低版本较稳定 npm install vue-router@3.2.0npm i element-ui -S #饿了么UI组件库安装cnpm install sass-loader node-sass --save-dev # 安装SASS加载器npm install axios #安装axios Npm命令解释： npm install moduleName：安装模块到项目目录下 npm install -g moduleName：-g的意思是将模块安装到全局，具体安装到磁盘哪个位置要看npm config prefix的位置 npm install -save moduleName：–save的意思是将模块安装到项目目录下， 并在package文件的dependencies节点写入依赖，-S为该命令的缩写 npm install -save-dev moduleName：–save-dev的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖，-D为该命令的缩写 配置:在vue文件vue.config.js中可以配置一些东西避免一些麻烦 123456789const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave:false, //强烈建议关闭ES语法规范检查,常见问题就是不准用驼峰命名和大写命名 devServer: &#123; port:8081,//端口号 // open:true//自动在浏览器上打开项目 &#125;&#125;) webpack(了解即可)1.什么是Webpack本质上， webpack是一个现代JavaScript应用程序的静态模块打包器（module bundler) 。当webpack处理应用程序时， 它会递归地构建一个依赖关系图（dependency graph) ， 其中包含应用程序需要的每个模块， 然后将所有这些模块打包成一个或多个bundle Webpack是当下最热门的前端资源模块化管理和打包工具， 它可以将许多松散耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分离，等到实际需要时再异步加载。通过loader转换， 任何形式的资源都可以当做模块， 比如Commons JS、AMD、ES 6、CSS、JSON、Coffee Script、LESS等； 伴随着移动互联网的大潮， 当今越来越多的网站已经从网页模式进化到了WebApp模式。它们运行在现代浏览器里， 使用HTML 5、CSS 3、ES 6等新的技术来开发丰富的功能， 网页已经不仅仅是完成浏览器的基本需求； WebApp通常是一个SPA（单页面应用) ， 每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的JS代码，这给前端的开发流程和资源组织带来了巨大挑战。 前端开发和其他开发工作的主要区别，首先是前端基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器的，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载 2.模块化的演进Script标签123&lt;script src = &quot;module1.js&quot;&gt;&lt;/script&gt;&lt;script src = &quot;module2.js&quot;&gt;&lt;/script&gt;&lt;script src = &quot;module3.js&quot;&gt;&lt;/script&gt; 这是最原始的JavaScript文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在window对象中，不同模块的调用都是一个作用域。 这种原始的加载方式暴露了一些显而易见的弊端： 全局作用域下容易造成变量冲突文件只能按照的书写顺序进行加载开发人员必须主观解决模块和代码库的依赖关系在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 CommonsJS服务器端的NodeJS遵循CommonsJS规范，该规范核心思想是允许模块通过require方法来同步加载所需依赖的其它模块，然后通过exports或module.exports来导出需要暴露的接口。 1234require(&quot;module&quot;);require(&quot;../module.js&quot;);export.doStuff = function()&#123;&#125;;module.exports = someValue; 优点： 服务器端模块便于重用NPM中已经有超过45万个可以使用的模块包简单易用缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的不能非阻塞的并行加载多个模块实现： 服务端的NodeJSBrowserify，浏览器端的CommonsJS实现，可以使用NPM的模块，但是编译打包后的文件体积较大modules-webmake，类似Browserify，但不如Browserify灵活wreq，Browserify的前身 ES6模块(vue在使用)EcmaScript 6标准增加了JavaScript语言层面的模块体系定义。ES 6模块的设计思想， 是尽量静态化， 使编译时就能确定模块的依赖关系， 以及输入和输出的变量。Commons JS和AMD模块，都只能在运行时确定这些东西。 123import &quot;jquery&quot;export function doStuff()&#123;&#125;module &quot;localModule&quot;&#123;&#125; 优点: 容易进行静态分析面向未来的Ecma Script标准 缺点: 原生浏览器端还没有实现该标准全新的命令，新版的Node JS才支持 实现: Babel 大家期望的模块 系统可以兼容多种模块风格， 尽量可以利用已有的代码， 不仅仅只是JavaScript模块化， 还有CSS、图片、字体等资源也需要模块化。 3.简单配置价绍创建 webpack.config.js配置文件 entry：入口文件， 指定Web Pack用哪个文件作为项目的入口output：输出， 指定WebPack把处理完成的文件放置到指定路径module：模块， 用于处理各种类型的文件plugins：插件， 如：热更新、代码重用等resolve：设置路径指向watch：监听， 用于设置文件改动后直接打包 服务器代理配置服务代理是用于解决请求跨域问题, 所谓的跨域问题,即违背了同源策略, 即客户端在与服务端进行通信时, 请求头必须保持: 协议名相同 主机名相同 端口号相同 解决跨域问题主要有三种解决方案: 后端设置:后端人员通过设置响应头的cors配置 通过jsonp配置解决跨域, 一般开发中用得少, 需要前后端都进行配置 前端通过通过配置服务代理实现, 其原理是在客户端与服务端之间建立一个代理中介 例如 需要请求/student 的资源, 则只能编写这样的url:localhost:8080/student ,但是实际上提供/student资源的后端服务程序, 使用的5000端口, 即该服务的url为: localhost:5000/student ,这就是经典的跨域问题,如下是代理服务原理图 方法一 在vue.config.js中追加如下配置 12345module.exports = &#123; devServer: &#123; proxy: &#x27;http://localhost:4000&#x27; &#125;&#125; 说明： 优点：配置简单，前端请求资源时可以不加任何前缀。 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。 工作方式：若按照上述配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源） 方法二编写vue.config.js配置具体代理规则： 123456789101112131415161718module.exports = &#123; devServer: &#123; proxy: &#123; &#x27;/api1&#x27;: &#123;// 匹配所有以 &#x27;/api&#x27;开头的请求路径 target: &#x27;http://localhost:5000&#x27;,// 代理目标的基础路径 changeOrigin: true, // 修改请求的 host // 相当于路径映射,即所有以/api开头的请求路径都消除,如请求 /api/student , 请求代理实际上真正请求的是 /student pathRewrite: &#123;&#x27;^/api1&#x27;: &#x27;&#x27;&#125; &#125;, &#x27;/api2&#x27;: &#123;// 匹配所有以 &#x27;/api&#x27;开头的请求路径 target: &#x27;http://localhost:5001&#x27;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125; &#125; &#125; &#125;&#125; 说明： 优点：可以配置多个代理，可以灵活的控制请求是否走代理。 缺点：配置繁琐，前端请求资源时必须加前缀。 附:axious 安装 1npm install axios 浅谈axious与ajax1.区别:axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。axios是ajax (一部分), ajax不止axios。 **扩展:**Promise是异步编程的一种解决方案，可以替代传统的解决方案–回调函数和事件。ES6统一了用法，并原生提供了Promise对象。作为对象，Promise有一下两个特点： （1）对象的状态不受外界影响。 （2）一旦状态改变了就不会在变，也就是说任何时候Promise都只有一种状态。 2.优缺点:ajax：本身是针对MVC的编程,不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务axios：从 node.js 创建 http 请求支持 Promise API客户端支持防止CSRF提供了一些并发请求的接口（重要，方便了很多的操作） 拓展:Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 ajax和axios、fetch的区别 3.实现对比:12345678910111213141516171819202122232425262728 // jquery封装的ajax$.ajax(&#123; url: &#x27;/getUsers&#x27;, type: &#x27;get&#x27;, dataType: &#x27;json&#x27;, data: &#123; //&#x27;a&#x27;: 1, //&#x27;b&#x27;: 2, &#125;, success: function (response) &#123; console.log(response)； &#125; &#125;)//axious封装的ajaxaxios(&#123; url: &#x27;/getUsers&#x27;, method: &#x27;get&#x27;, responseType: &#x27;json&#x27;, // 默认的 data: &#123; //&#x27;a&#x27;: 1, //&#x27;b&#x27;: 2, &#125; &#125;).then(function (response) &#123; console.log(response); console.log(response.data); &#125;).catch(function (error) &#123; console.log(error); &#125;） 4.axious使用:注: axious请求默认都是异步请求 发送get请求: 123456789101112131415161718192021// 为给定 ID 的 user 创建请求axios.get(&#x27;/user?ID=12345&#x27;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 上面的请求也可以这样做axios.get(&#x27;/user&#x27;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 发送post请求: 12345678910axios.post(&#x27;/user&#x27;, &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 并发多个请求: 12345678910function getUserAccount() &#123; return axios.get(&#x27;/user/12345&#x27;);&#125;function getUserPermissions() &#123; return axios.get(&#x27;/user/12345/permissions&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); 请求配置: 这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 详情请查询:axios中文网 123456789101112131415161718192021// 发送 POST 请求axios(&#123; method: &#x27;post&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;);// 获取远端图片axios(&#123; method:&#x27;get&#x27;, url:&#x27;http://bit.ly/2mTM3nY&#x27;, responseType:&#x27;stream&#x27;&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream(&#x27;ada_lovelace.jpg&#x27;))&#125;) .catch(function (error) &#123; console.log(error);&#125;); 配置项有: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&#123; // `url` 是用于请求的服务器 URL url: &#x27;/user&#x27;, // `method` 是创建请求时使用的方法 method: &#x27;get&#x27;, // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &#x27;https://some-domain.com/api/&#x27;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `responseType` 表示服务器响应的数据类型，可以是 &#x27;arraybuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27; responseType: &#x27;json&#x27;, // default // `responseEncoding` indicates encoding to use for decoding responses // Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests responseEncoding: &#x27;utf8&#x27;, // default // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: &#x27;janedoe&#x27;, password: &#x27;s00pers3cret&#x27; &#125;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: &#x27;Fred&#x27; &#125;, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // default // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` defines a UNIX Socket to be used in node.js. // e.g. &#x27;/var/run/docker.sock&#x27; to send requests to the docker daemon. // Only either `socketPath` or `proxy` can be specified. // If both are specified, `socketPath` is used. socketPath: null, // default // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // &#x27;proxy&#x27; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: &#x27;127.0.0.1&#x27;, port: 9000, auth: &#123; username: &#x27;mikeymike&#x27;, password: &#x27;rapunz3l&#x27; &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; slot 插槽也算是一种组件间通信的方式，适用于 父===&gt;子，且传递的是html结构(1).作用：父组件向子组件指定位置中插入html结构(2).分类： 默认插槽：&lt;slot&gt;&lt;/slot&gt; 命名插槽：&lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt; 作用域插槽：后期项目中会讲到(3)使用： 父组件中： ​ &lt;html标签名 slot=插槽名&quot;&gt; &lt;/html标签名&gt; 或 &lt;template slot=&quot;插槽名&quot;&gt;具体html结构&lt;/template&gt; ​ 使用&lt;template&gt;&lt;/template&gt;可用于包裹结构但最后Vue解析模板时不生成多于的dom结构 ​ 此外,如果使用&lt;template&gt;还有另一使用插槽的写法: &lt;template v-slot:插槽名&gt;具体html结构&lt;/template&gt; ​ 子组件中：​ &lt;slot&gt;&lt;/slot&gt; 或 &lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt; 样例: 组件:Category.vue 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;cate&quot;&gt; &lt;h3 class=&quot;bt&quot;&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt; &lt;!-- 默认插槽 --&gt; &lt;!-- &lt;slot&gt;&lt;/slot&gt; --&gt; &lt;!-- 命名插槽(具名插槽)定义 --&gt; &lt;slot name=&quot;youxi&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;meishi&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;movie&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;] &#125;&lt;/script&gt;&lt;style&gt; .cate&#123; width: 240px; height: 300px; background-color: skyblue; &#125; .bt&#123; text-align: center; background-color: yellowgreen; &#125; img&#123; width: 100%; &#125;&lt;/style&gt; App.vue(有错误) 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;cate&quot;&gt; &lt;h3 class=&quot;bt&quot;&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt; &lt;!-- 默认插槽 --&gt; &lt;!-- &lt;slot&gt;&lt;/slot&gt; --&gt; &lt;!-- 命名插槽(具名插槽)定义 --&gt; &lt;slot name=&quot;youxi&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;meishi&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;movie&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;] &#125;&lt;/script&gt;&lt;style&gt; .cate&#123; width: 240px; height: 300px; background-color: skyblue; &#125; .bt&#123; text-align: center; background-color: yellowgreen; &#125; img&#123; width: 100%; &#125;&lt;/style&gt; 作用域插槽(重要)作用域插槽可通过插槽实现子组件向父组件传递数据 在子组件Category.vue文件中,在 插槽标签&lt;slot&gt;&lt;/slot&gt; 绑定数据 , 1&lt;slot :gameArr=&quot;gameArr&quot;&gt;&lt;/slot&gt; 随后在父组件中使用子组件标签放入插槽时,必须用&lt;template&gt;&lt;/template&gt;包裹 , 并且在&lt;template&gt;&lt;/template&gt;定义一个属性slot-scope来接收插槽发送的数据,属性值随意,符合语义即可, 如下所示, 在父组件App.vue文件中: 12345&lt;Category title=&quot;游戏&quot;&gt; &lt;template slot-scope=&quot;slotData&quot;&gt; &lt;!-- &#123;&#123;slotData&#125;&#125; --&gt; &lt;/template&gt;&lt;/Category&gt; 组件通信总结 父组件 -&gt; 子组件: 通过props实现 子组件 -&gt; 父组件: 通过事件回调函数传递参数实现 子组件 -&gt; 父组件: 通过作用域插槽实现 兄弟组件之间通信或者任意组件通信: 通过全局组件事件$bus实现 通过订阅发布第三方库如: Pubsub-js 实现 VuexVuex是一个专门再Vue中实现集中式状态(数据)管理的一个Vue插件, 对Vue应用中多个组件的共享状态进行集中式管理(读/写),也是一种组件间通信方式, 适用于任意组件间通信. Vuex原理 Vuex环境搭建 安装Vue 注意: 目前Vue3已经是默认版本了, 由于Vue3支持Vuex4, Vue2只支持Vuex3 , 所以我们在安装Vuex时倘若是使用的Vue2, 则需要指定Vue版本 123npm i Vuex@3 #指定安装Vuex3版本npm i Vuex # 默认安装只支持Vue3的Vuex4 (1) 项目根目录创建：store/index.js , 注: 此文件夹和文件名都可以自定义,但官方文档是这样 store/index.js文件内容: 123456789101112131415161718192021// 该文件用于创建Vuex核心的 storeimport Vue from &quot;vue&quot;import Vuex from &quot;vuex&quot;// 使用Vuex之前必须先引入VuexVue.use(Vuex)const actions = &#123;&#125;const mutations = &#123;&#125;const state = &#123;&#125;export default new Vuex.Store(&#123; // actions: actions, // mutations: mutations, // state: state // ES6语法: 当对象的key和value重名时,只写一个即可 actions, mutations, state&#125;) **随后在main.js**文件中, 引入配置好的Vuex.store,并且在vm中增加一个store配置项 123456789101112import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// import store from &#x27;./store/index&#x27; 如果store文件只有一个名为index.js的文件,可简写为如下形式:import store from &#x27;./store&#x27;Vue.config.productionTip = false //关闭生产提示new Vue(&#123; el:&#x27;#app&#x27;, store, render:h =&gt; h(App)&#125;) 至此,Vuex的环境就配置完毕 Vuex基本使用首先 在store的index.js中配置好共享状态(数据) 123456789101112131415161718192021// 该文件用于创建Vuex核心的 storeimport Vue from &quot;vue&quot;import Vuex from &quot;vuex&quot;// 使用Vuex之前必须先引入VuexVue.use(Vuex)const actions = &#123;&#125;const mutations = &#123;&#125;//配置数据const state = &#123; sum:0&#125;export default new Vuex.Store(&#123; actions, mutations, state&#125;) 第一步,分发(diapatch)在vc中调用: 12345/* 调用acitons中dispatch方法,有两个参数: 第一个: 我们自己定义的用于处理业务逻辑的方法名, 第二个: 传递的数据 */ this.$store.dispatch(&quot;add&quot;,this.n) 第二步: 提交(commit)在index.js中的actions对象中配置处理业务逻辑的方法,并且在业务逻辑处理方法中 调用context.commit(&quot;数据加工方法名&quot;,数据), 1234567891011121314// 该文件用于创建Vuex核心的 storeimport Vue from &quot;vue&quot;import Vuex from &quot;vuex&quot;// 使用Vuex之前必须先引入VuexVue.use(Vuex)const actions = &#123; add(context,value)&#123; // 配置的方法有两个默认参数: 第一个是 上下文对象, 第二个是传入的值 console.log(&quot;action中配置的add方法被调用:用于处理业务逻辑&quot;,context,value); // 处理完业务逻辑 将数据提交 context.commit(&quot;ADD&quot;,value) &#125;&#125;// 其他store的配置.... 第三步 配置数据加工在index.js文件中, 配置mutations对象的数据加工方法 12345678// 省略其他 store配置const mutations = &#123; // 一般mututions里,只进行数据加工,并且配置的方法名是全大写形式: ADD(state,value)&#123; console.log(&quot;mutations中配置的ADD方法被调用:用于加工数据&quot;); state.sum += value &#125;,&#125; 第四步 获取状态(数据)在vc中, 调用 this.$store.state.数据名即可,以上面为例: 1&#123;&#123;$store.state.sum&#125;&#125; 或 this.$store.state.sum 使用样例:/store/index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 该文件用于创建Vuex核心的 storeimport Vue from &quot;vue&quot;import Vuex from &quot;vuex&quot;// 使用Vuex之前必须先引入VuexVue.use(Vuex)const actions = &#123; add(context,value)&#123; // 配置的方法有两个默认参数: 第一个是 上下文对象, 第二个是传入的值 console.log(&quot;action中配置的add方法被调用:用于处理业务逻辑&quot;,context,value); // 处理完业务逻辑 将数据提交 context.commit(&quot;ADD&quot;,value) &#125;, sub(context,value)&#123; context.commit(&quot;SUB&quot;,value) &#125;, addOdd(context,value)&#123; if(this.state.sum % 2)&#123; context.commit(&quot;ADD&quot;,value) &#125; &#125;, addWait(context,value)&#123; setTimeout(()=&gt;&#123; context.commit(&quot;ADD&quot;,value) &#125;,500) &#125;&#125;const mutations = &#123; // 一般mututions里,只进行数据加工,并且配置的方法名是全大写形式: ADD(state,value)&#123; console.log(&quot;mutations中配置的ADD方法被调用:用于加工数据&quot;); state.sum += value &#125;, SUB(state,value)&#123; state.sum -= value &#125;,&#125;// 在 state 中配置 组件共享(状态)数据const state = &#123; sum:0&#125;export default new Vuex.Store(&#123; actions, mutations, state&#125;) main.js 123456789101112import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// import Vuex from &#x27;./store/index&#x27; 如果store文件只有一个名为index.js的文件,可简写为如下形式:import store from &#x27;./store&#x27;Vue.config.productionTip = false //关闭生产提示new Vue(&#123; el:&#x27;#app&#x27;, store, render:h =&gt; h(App)&#125;) App.vue 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;Count/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Count from &#x27;./components/Count&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123; Count &#125;, &#125;&lt;/script&gt; Count.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt; &lt;!-- 获取 store中的state的数据 --&gt; &lt;h2&gt;当前求和为：&#123;&#123;$store.state.sum&#125;&#125;&lt;/h2&gt; &lt;select v-model.number=&quot;n&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt;&amp;nbsp; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;&amp;nbsp; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;&amp;nbsp; &lt;button @click=&quot;incrementOdd&quot;&gt;奇数再加&lt;/button&gt;&amp;nbsp; &lt;button @click=&quot;incrementAsync&quot;&gt;异步加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Count&#x27;, data()&#123; return &#123; n:1 //n是用户选择的数字 &#125; &#125;, methods:&#123; increment()&#123; /* 调用acitons中dispatch方法,有两个参数: 第一个: 我们自己定义的用于处理业务逻辑的方法名, 第二个: 传递的数据 */ this.$store.dispatch(&quot;add&quot;,this.n) &#125;, decrement()&#123; this.$store.dispatch(&quot;sub&quot;,this.n) &#125;, incrementOdd()&#123; this.$store.dispatch(&quot;addOdd&quot;,this.n) &#125;, incrementAsync()&#123; this.$store.dispatch(&quot;addWait&quot;,this.n) &#125;, &#125; &#125;&lt;/script&gt; getter配置项类似计算属性, 相当于 $state中数据的 计算属性 使用: 在index.js中新增一个配置对象 12345678910111213// ...const getters = &#123; bigSum(state)&#123; return state.sum*10 &#125;&#125; export default new Vuex.Store(&#123; actions, mutations, state, getters&#125;) 使用getters的数据 在vc中: this.$store.getters.方法名 配置映射(四个map方法)==注意: 使用简写形式需要引入对象的模块== 1import &#123;mapState,mapMutations,mapAction &#125; from &#x27;vuex&#x27; // 简写形式需要引入 mapState和mapGetters主要是相当于自动生成 计算属性而避免频繁重复写 this.$store.state.数据, 我们可以在vm或者vc中的computed配置项中使用 123456789101112131415161718192021222324252627282930313233343536/*******************自己定义计算属性(state数据名和 计算属性名 不一致)*****************/ /* he()&#123; return this.$store.state.sum &#125;, ming()&#123; return this.$store.state.name &#125;, *//**********************mapState对象写法:*******************/ //适用于: 需要的 计算属性名 和state中的数据名 不一致 /* ...mapState(&#123; he:&#x27;sum&#x27;, //he控制的是模板中读取的属性，&#x27;sum&#x27;控制的是读取state中的哪个属性 ming:&#x27;name&#x27; &#125;) *//*******************自己定义计算属性(state数据名和 计算属性名 一致)*****************/ /* sum()&#123; return this.$store.state.sum &#125;, name()&#123; return this.$store.state.name &#125;, *//**********************mapState数组写法(推荐):*******************/ //适用于: 需要的 计算属性名 和state中的数据名 一致 ...mapState([&#x27;sum&#x27;,&#x27;name&#x27;]), /**********************自己定义计算机属性获取getters*******************/ /* bigSum()&#123; return this.$store.getters.bigSum &#125; *//**********************mapGetters与上面同理...*******************/ ...mapGetters([&#x27;bigSum&#x27;]) mapAction相当于帮我们避免重复定义方法写this.$store.dispatch(&#39;方法名&#39;,数据),我们可以在vm或者vc中的methods配置项中使用 注意:当我们使用这种方法时,无法像这样传送数据,this.$store.dispatch(&#39;方法名&#39;,数据),则默认传送一个 事件对象 作为参数传递给mutations , 所以我们必须在绑定事件回调函数时指定传参 , 12&lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;&lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt; 用法: 1234567891011121314/***************** 自己定义方法，和actions中对话 **********************/ /* incrementOdd(value)&#123; this.$store.dispatch(&#x27;jiaOdd&#x27;,value) &#125;, incrementAsync(value)&#123; this.$store.dispatch(&#x27;jiaAsync&#x27;,value) &#125;, *//******************* mapActions方法,同样有对象式写法和数组式写法,适用场景也和mapState的一样 *****************/ /* ...mapActions(&#123; incrementOdd:&#x27;jiaOdd&#x27;, incrementAsync:&#x27;jiaAsync&#x27; &#125;) */ ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaAsync&#x27;]) mapMutations相当于帮我们避免重复定义方法写this.$store.commit(&#39;方法名&#39;,数据),我们可以在vm或者vc中的methods配置项中使用 注意:当我们使用这种方法时,无法像这样传送数据,this.$store.commit(&#39;方法名&#39;,数据),则默认传送一个 事件对象 作为参数传递给state, 所以我们必须在绑定事件回调函数时指定传参 , 12&lt;button @click=&quot;jiaOdd(n)&quot;&gt;奇数再加&lt;/button&gt;&lt;button @click=&quot;jiaAsync(n)&quot;&gt;异步加&lt;/button&gt; 用法: 12345678910111213141516/******************* 自己定义方法和 mutations交互 ****************************/ /* increment(value)&#123; this.$store.commit(&#x27;JIA&#x27;,value) &#125;, decrement(value)&#123; this.$store.commit(&#x27;JIAN&#x27;,value) &#125;, *//******************* mapMutations方法和 mutations交互, 同样有对象写法和数组写法,适用场景类似之前的mapState ****/ ...mapMutations(&#123; increment:&#x27;JIA&#x27;, decrement:&#x27;JIAN&#x27;, &#125;), // ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]) 命名空间配置(用到在学)vue-router路由 官方文档:https://router.vuejs.org/guide/ Vue Router是Vue.js官方的路由管理器(类似页面跳转)。它和Vue.js的核心深度集成， 让构建单页面应用变得易如反掌。包含的功能有： 嵌套的路由/视图表 模块化的、基于组件的路由配置 路由参数、查询、通配符 基于Vue js过渡系统的视图过渡效果 细粒度的导航控制 带有自动激活的CSS class的链接 HTML5 历史模式或hash模式， 在IE 9中自动降级 自定义的滚动行为 安装vue-router是一个插件包， 所以我们还是需要用n pm/cn pm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。 npm i vue-router 注:如果使用时 (Vue2只能使用router3版本) 出现问题可安装低版本:npm i vue-router@3 如果在一个模块化工程中使用它，必须要通过Vue.use()明确地安装路由功能： 123import VueRouter from &#x27;vue-router&#x27;Vue.use(VueRouter); 基本使用1.创建组件在components目录下(其他目录也可)创建我们自己编写的组件 Content.vue: 12345678910111213&lt;template&gt; &lt;p&gt;内容区&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // eslint-disable-next-line vue/multi-word-component-names name: &quot;Content&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; Home.vue: 12345678910111213&lt;template&gt; &lt;h2&gt;首页&lt;/h2&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // eslint-disable-next-line vue/multi-word-component-names name: &quot;Home&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 2.新建路由表文件在src目录下，新建一个文件夹：router(用于存放路由配置文件),在里面新建文件index.js(文件名可以任意,但规范是index,这样可以默认加载) index.js: 1234567891011121314151617181920212223242526 /****路由配置*****///引入VueRouer插件import VueRouter from &#x27;vue-router&#x27;//引入组件import Content from &quot;/components/Content&quot;;import Home from &#x27;/components/Home&#x27;;// 配置路由插件并且暴露模块export default new VueRouter(&#123; // 路由配置项,注意名字有个s,是一个数组,数组元素是一个路由对象 //路由对象有三个属性,分别是名字,路径,以及对应的组件 routes:[ // 路由一: &#123; path:&#x27;/content&#x27;, name:&#x27;content&#x27;, component:Content &#125;, &#123; path: &#x27;/home&#x27;, name:&#x27;home&#x27;, component: Home &#125; ]&#125;); 3.配置路由(main.js中)main.js: 12345678910111213141516171819//引入必需模块import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;//引入VueRouter插件与自己写好的路由器import VueRouter from &quot;vue-router&quot;;import router from &#x27;./router&#x27;Vue.config.productionTip = false //关闭生产提示Vue.use(router) //应用Vue路由插件new Vue(&#123; render: h =&gt; h(App), //注册组件,相当于 component:App //配置路由,很重要 router:router, data:&#123; &#125;&#125;).$mount(&#x27;#app&#x27;) //绑定div,相当于:el: &#x27;#app&#x27; 4.使用路由在App.vue中使用路由 &lt;router-link to=&quot;路由路径&quot;&gt;内容&lt;/router-link&gt; 类似&lt;a href=&quot;路径&quot;&gt;内容&lt;/a&gt; , 并且有该标签个属性active-class , 当该路由链接被点击时, 会为class属性追加active-class的属性值, 主要用于点击时高亮效果 &lt;router-view&gt;&lt;/router-view&gt; 用于展示对应路由的组件 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;hr/&gt; &lt;h1&gt;Vue Router&lt;/h1&gt;&lt;!-- 路由链接,相当于html的a标签,to属性相当于href属性,值是之前路由配置好的path--&gt; &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; | &lt;router-link to=&quot;/content&quot;&gt;内容区&lt;/router-link&gt;&lt;!-- 展示路由切换后的视图,不写则不会展示--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Content from &#x27;./components/Content&#x27;import Home from &quot;./components/Home&quot;export default &#123; name: &#x27;App&#x27;, components: &#123; Content, Home &#125;, data()&#123; return &#123; msg:&#x27;hello vue!&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 几个注意点: 路由组件通常存放在pages文件夹, 一般组件通常存放在components文件夹 通过切换,隐藏了的路由组件, 默认是被销毁掉的, 需要的时候再去挂载 每个路由组件都有自己的$route , 里面存储着自己的路由信息 整个应用只有一个router , 可以通过组件的$router属性获取 多级(嵌套)路由多级路由是在一级路由(即使基本路由)的基础上在建立多个路由, 具体用法是: **在配置的路由表文件中, 给需要添加子路由的路由对象配置一个children对象属性 **, 形如: 12345678910111213141516routes:[ &#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&#x27;message&#x27;, component:Message, &#125;, &#123; path:&#x27;news&#x27;, component:News &#125; ] &#125; ] 不过需要注意的是: 子路由的路径最开头不要再加 / , 路由的query参数我们可以在发送路由的时候, 携带query参数 12345678910111213&lt;!-- 路由切换时，携带query参数, 有一般写法和对象写法 --&gt; &lt;!-- `字符串` 是ES6的模板字符串语法, 可以在字串中使用 $&#123;变量名&#125; 插入变量, --&gt; &lt;!-- &lt;router-link :to=&quot;`/home/message/detail/$&#123;msg.id&#125;?title=$&#123;msg.title&#125;&amp;content=$&#123;msg.content&#125;`&quot;&gt;&#123;&#123;msg.title&#125;&#125;&lt;/router-link&gt; --&gt; &lt;!-- 对象写法: --&gt; &lt;router-link :to=&quot;&#123; path: &#x27;/home/message/detail&#x27;, query:&#123; title: msg.title, content: msg.content &#125; &#125;&quot;&gt; &#123;&#123;msg.title&#125;&#125; &lt;/router-link&gt; 注意事项: 一般我们传递的参数是 js变量, 所以要绑定 to属性 即使 :to,无论是对象写法还是一般写法 对象写法时 to属性值同样要用 “” 包裹, 并且对象属性之间别忘了逗号分隔 获取query参数 参数存放路由属性中, 我们可以通过 this.$route.query.参数名获取到对应的参数数据 注: this指向的是 组件实例vc 命名路由接上一节,所谓命名路由,即可以给路由定义个名字, 用路由名代替路由路径, 一般用于路径较长的情况 在路由表配置文件index.js中添加name配置属性 1234567891011121314151617routes:[ &#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; name: &quot;xiaoxi&quot;, path:&#x27;message&#x27;, component:Message, &#125;, &#123; path:&#x27;news&#x27;, component:News &#125; ] &#125; ] 在路由标签中直接写名字即可: 1234&lt;!-- &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt; --&gt;&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; :to=&quot;&#123; name:&#x27;xiaoxi&#x27; &#125;&quot;&gt;Message&lt;/router-link&gt; 并且可以通过可以通过name属性展示多个路由组件 12&lt;router-view name=&quot;h1&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;h2&quot;&gt;&lt;/router-view&gt; 路由的params参数在传递params参数时,需要在路由表中配置参数占位符 /:参数名 12345678910111213141516171819202122232425export default new VueRouter(&#123; routes:[ &#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&#x27;message&#x27;, component:Message, children:[ &#123; name: &quot;xijie&quot;, path:&#x27;detail/:id/:title/:content&#x27;, //声明接收params参数 component:Detail, &#125; ] &#125;, ] &#125;, &#123; path:&#x27;/about&#x27;, component:About &#125; ]&#125;) 在路由标签中,传递params参数: 注意!!! 携带params参数的对象写法,必须配置name属性而不能使用path配置 12345678910111213&lt;!-- 路由携带params参数 --&gt; &lt;!-- `字符串` 是ES6的模板字符串语法, 可以在字串中使用 $&#123;变量名&#125; 插入变量, --&gt; &lt;!-- &lt;router-link :to=&quot;`/home/message/detail/$&#123;msg.id&#125;/$&#123;msg.title&#125;/$&#123;msg.content&#125;`&quot;&gt;&#123;&#123;msg.title&#125;&#125;&lt;/router-link&gt; --&gt; &lt;!-- 注意!!! 携带params参数的对象写法,必须配置name属性而不能使用path配置 --&gt; &lt;router-link :to=&quot;&#123; name: &#x27;xijie&#x27;, params: &#123; id: msg.id, title: msg.title, content: msg.content &#125; &#125; &quot;&gt;&#123;&#123;msg.title&#125;&#125;&lt;/router-link&gt; 路由的props配置为了减少在组件中重复频繁使用this.$route.params或 return this.$route.query, 我们可以在路由表文件中配置props配置给路由组件传递数据 在路由表文件index.js , 添加props配置 1234567891011121314151617181920212223242526272829303132333435363738394041routes:[ &#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&#x27;message&#x27;, component:Message, children:[ &#123; // path:&#x27;detail/:id/:title/:content&#x27;, //声明接收params参数 // path:&#x27;detail&#x27;, //query参数无需声明即可接收 path:&#x27;detail/:id&#x27;, //同时接收params和query，要先声明params component:Detail, name:&#x27;xiangqing&#x27;, /* 三种写法: 只能使用一种 */ // props:&#123;carName:&#x27;马自达·阿特兹&#x27;&#125; //通过props映射自定义的静态数据 /* 用于params传参: */ // props:true //自动映射params参数为props传给路由组件 /* 用于query传参: */ props($route)&#123; //此处接收到的route是vc或vm身上的$route const &#123;id&#125; = $route.params.id const &#123;title,content&#125; = $route.query return &#123; id:$route.params.id, title:$route.query.title, content:$route.query.content &#125; &#125; &#125; ] &#125;, &#123; path:&#x27;news&#x27;, component:News &#125; ] &#125; 随后在组件中配置项中props配置参数名接收即可, 在Detail.vue文件中 12345678910111213141516&lt;template&gt; &lt;ul&gt; &lt;!-- 获取params参数 --&gt; &lt;li&gt;ID：&#123;&#123;id&#125;&#125;&lt;/li&gt; &lt;li&gt;TITLE：&#123;&#123;title&#125;&#125;&lt;/li&gt; &lt;li&gt;CONTENT：&#123;&#123;content&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Detail&#x27;, props:[&#x27;id&#x27;,&#x27;title&#x27;,&#x27;content&#x27;], &#125;&lt;/script&gt; 路由的replace模式浏览器有两种模式: push模式(默认): 即点击链接(路由)后可以后退 replace模式: 类似浏览器的无痕模式, 点击后不发后退 路由开启replace模式只需在路由标签中加上replace属性即可 1&lt;router-link replace class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt; 编程式路由(重要):我们除了可以使用路由标签&lt;router-link&gt;&lt;/router-link&gt;实现组件切换跳转, 还可以通过 this.$router.push(配置对象)或this.$router.replace(配置对象) ,(其中push()和replace()对应了浏览器的两种浏览模式,配置对象的内容就是路由标签中to属性值的对象写法) , 实现组件切换跳转,这种方式就叫编程式路由 123&lt;router-link :to=&quot;`/home/message/detail/$&#123;msg.id&#125;/$&#123;msg.title&#125;/$&#123;msg.content&#125;`&quot;&gt;&#123;&#123;msg.title&#125;&#125;&lt;/router-link&gt;或&lt;router-link replace :to=&quot;`/home/message/detail/$&#123;msg.id&#125;/$&#123;msg.title&#125;/$&#123;msg.content&#125;`&quot;&gt;&#123;&#123;msg.title&#125;&#125;&lt;/router-link&gt; 分别对应以下的js逻辑代码: 123456789101112131415161718// 注: name配置属性代表路由名, 可以用path代替this.$router.push(&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:msg.id, title:msg.title, content:msg.content &#125; &#125;)或this.$router.replace(&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:msg.id, title:msg.title, content:msg.content &#125; &#125;) 缓存路由组件在默认情况下,我们在使用路由切换组件时, 被切换走的组件会被销毁, 我们可以通过使用&lt;keep-alive&gt;&lt;/keep-alive&gt;标签包裹不希望被自动销毁的组件(即缓存组件) 的组件展示区&lt;router-view&gt;&lt;/router-view&gt;来实现缓存路由组件 , &lt;keep-alive&gt;&lt;/keep-alive&gt;有一个include属性名, 不写默认所有路由组件都设置为缓存组件(增加系统开销性能) ,所以一般我们通过设置include属性值指定需要缓存的路由组件 12345678&lt;!-- keep-alive可以让路由组件切换时，不销毁，include的值是组件名!!! --&gt;&lt;keep-alive include=&quot;News&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;!-- 若要设置多个缓存路由组件, 则将include属性值设置为数组即可 --&gt;&lt;keep-alive :include=&quot;[&#x27;组件名1&#x27;,&#x27;组件名2&#x27;,&#x27;组件名3&#x27;]&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 路由组件的两个生命周期当路由组件变成缓存式路由组件时, 我们在切换路由组件时,并不会将被切换掉的组件销毁掉, 故我们现在有如下一个案例: News路由组件和Message组件可以自由切换, 并且News被设置为了缓存式路由组件, 我们在News组件中通过生命周期钩子mounted设置了一个定时用于实现浮动显示一个标题 (欢迎学习Vue) ,但我们在切换到 Message组件时, 打开控制台发现定时器仍然在不断执行, 非常浪费性能 , (即我们想要的最优方案是: 当有定时器的路由组件被切换走时, 我们希望其中的定时器也停掉) 这时,我们可以使用路由组件独有的两个生命周期钩子 : activated():当路由组件被激活展示时 deactivated():当路由组件失活(即被切换走)时 注意: 只有缓存路由组件使用这两个生命周期钩子才有效 案例核心代码: News.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;ul&gt; &lt;!-- 绑定style的属性opacity, ES6语法:结构赋值 --&gt; &lt;li :style=&quot;&#123;opacity&#125;&quot;&gt;欢迎学习Vue ^_^&lt;/li&gt; &lt;li&gt;news001 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt; &lt;li&gt;news002 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt; &lt;li&gt;news003 &lt;input type=&quot;text&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;News&#x27;, data() &#123; return &#123; opacity:1 &#125; &#125;, // mounted()&#123; // this.timer = setInterval(() =&gt; &#123; // console.log(&quot;News的定时器正在运行...&quot;) // this.opacity -= 0.01 // if (this.opacity&lt;0)&#123; // this.opacity = 1 // &#125; // &#125;, 20) // &#125;, // beforeDestroy() &#123; // clearInterval(this.timer) // &#125;, activated() &#123; this.timer = setInterval(() =&gt; &#123; console.log(&quot;News的定时器正在运行...&quot;) this.opacity -= 0.01 if (this.opacity&lt;0)&#123; this.opacity = 1 &#125; &#125;, 20) &#125;, deactivated() &#123; console.log(&quot;News组件失活了&quot;) clearInterval(this.timer) &#125;, &#125;&lt;/script&gt; 路由守卫路由守卫就有点类似拦截器或者后端的路径过滤器 , 主要用于权限控制, 根据配置的位置不同和作用域不同, 分为如下几种: 全局路由守卫前置守卫:由于是全局的,所以全局守卫需要在路由表文件index.js中配置 , 并且不能直接new Router就暴露,因为我们还需要通过配置beforeEach(回调函数)写一些守卫逻辑,随后在暴露 123456789/*三个参数: to,from是对象类型 next是一个方法to: 代表了通过路由守卫的路由要去哪里, 存放着目标路由的 参数,路径和路由名等信息from: 代表了通过路由守卫的路由从哪里来, 存放从哪里来的路由的 参数,路径和路由名等信息*/router.beforeEach((to, from, next) =&gt; &#123; // 每次初始化时被调用, 每次切换路由时被调用 // ... 拦截处理逻辑 // next() // 路由放行,默认会全局拦截不放行&#125;) 假如: 进入/home/news或者/home/message需要校验浏览器本地存储信息, index.js完整信息如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 该文件是Vue中路由器文件，路由器管理着所有路由 */import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import Home from &#x27;../pages/Home.vue&#x27;import About from &#x27;../pages/About.vue&#x27;import Message from &#x27;../pages/Message.vue&#x27;import Detail from &#x27;../pages/Detail.vue&#x27;import News from &#x27;../pages/News.vue&#x27;Vue.use(VueRouter)//创建一个路由器，管理所有的路由const router = new VueRouter(&#123; routes:[ &#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&#x27;message&#x27;, component:Message, children:[ &#123; // path:&#x27;detail/:id/:title/:content&#x27;, //声明接收params参数 // path:&#x27;detail&#x27;, //query参数无需声明即可接收 path:&#x27;detail/:id&#x27;, //同时接收params和query，要先声明params component:Detail, name:&#x27;xiangqing&#x27;, // props:&#123;carName:&#x27;马自达·阿特兹&#x27;&#125; //通过props映射自定义的静态数据 // props:true //映射params参数为props传给路由组件 props(route)&#123; //此处接收到的route是vc或vm身上的$route // console.log(route) const &#123;id&#125; = route.params const &#123;title,content&#125; = route.query return &#123;id,title,content&#125; &#125; &#125; ] &#125;, &#123; path:&#x27;news&#x27;, component:News &#125; ] &#125;, &#123; path:&#x27;/about&#x27;, component:About &#125; ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; // 既可以通过路由的的路径判断也能通过路由名判断 if(to.path ===&quot;/home/news&quot; || to.path ===&quot;/home/message&quot;)&#123; if(localStorage.getItem(&quot;user&quot;) ===&quot;admin&quot;)&#123; next() &#125; else&#123; alert(&quot;权限不足,无法访问!&quot;) &#125; &#125; else&#123; next() &#125;&#125;)//暴露路由器export default router 优化:假如需要给多个路由做授权校验, 上述的写法过于繁琐, 我们可以通过在routes中配置meta属性添加一个标记变量用于标记该路径是否需要校验授权 , (meta 有元数据的意思) 注: to, from是route的衍生对象, 所以在routes中配置的meta属性他们也能拿到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 该文件是Vue中路由器文件，路由器管理着所有路由 */import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import Home from &#x27;../pages/Home.vue&#x27;import About from &#x27;../pages/About.vue&#x27;import Message from &#x27;../pages/Message.vue&#x27;import Detail from &#x27;../pages/Detail.vue&#x27;import News from &#x27;../pages/News.vue&#x27;Vue.use(VueRouter)//创建一个路由器，管理所有的路由const router = new VueRouter(&#123; routes:[ &#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&#x27;message&#x27;, component:Message, meta: &#123;isAuth:true&#125;, children:[ &#123; path:&#x27;detail/:id&#x27;, //同时接收params和query，要先声明params component:Detail, props(route)&#123; //此处接收到的route是vc或vm身上的$route const &#123;id&#125; = route.params const &#123;title,content&#125; = route.query return &#123;id,title,content&#125; &#125; &#125; ] &#125;, &#123; path:&#x27;news&#x27;, component:News, meta: &#123;isAuth:true&#125;, &#125; ] &#125;, &#123; path:&#x27;/about&#x27;, component:About &#125; ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; // Auth 有授权的意思 if(to.meta.isAuth)&#123; if(localStorage.getItem(&quot;user&quot;) ===&quot;admin&quot;)&#123; next() &#125; else&#123; alert(&quot;权限不足,无法访问!&quot;) &#125; &#125; else&#123; next() &#125;&#125;)//暴露路由器export default router 后置路由守卫:后置路由守卫在每次路由切换之后被调用 , 主要用于在切换路由组件之后更改页签名称 ,用法: 1234// 在路由切换之后被调用router.afterEach((to, from) =&gt; &#123; // 处理逻辑&#125;) 使用全局后置路由守卫实现页签标题随路由跳转变化功能案例如下所示: 首先需要借助路由对象的meta属性给每个路由配置标题信息,以备获取 ,随后编写后置守卫的回调逻辑 index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 该文件是Vue中路由器文件，路由器管理着所有路由 */import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import Home from &#x27;../pages/Home.vue&#x27;import About from &#x27;../pages/About.vue&#x27;import Message from &#x27;../pages/Message.vue&#x27;import Detail from &#x27;../pages/Detail.vue&#x27;import News from &#x27;../pages/News.vue&#x27;Vue.use(VueRouter)//创建一个路由器，管理所有的路由const router = new VueRouter(&#123; routes:[ &#123; path:&#x27;/home&#x27;, component:Home, meta: &#123;title:&quot;首页&quot;&#125;, children:[ &#123; path:&#x27;message&#x27;, component:Message, meta: &#123;title:&quot;消息&quot;,isAuth:true&#125;, children:[ &#123; path:&#x27;detail/:id&#x27;, //同时接收params和query，要先声明params component:Detail, name:&#x27;xiangqing&#x27;, mate: &#123;title:&quot;详情&quot;&#125;, props(route)&#123; //此处接收到的route是vc或vm身上的$route // console.log(route) const &#123;id&#125; = route.params const &#123;title,content&#125; = route.query return &#123;id,title,content&#125; &#125; &#125; ] &#125;, &#123; path:&#x27;news&#x27;, component:News, meta: &#123;title:&quot;新闻&quot;, isAuth:true&#125;, &#125; ] &#125;, &#123; path:&#x27;/about&#x27;, component:About, meta: &#123;title:&quot;关于&quot;&#125;, &#125; ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; if(to.meta.isAuth)&#123; if(localStorage.getItem(&quot;user&quot;) ===&quot;admin&quot;)&#123; next() &#125; else&#123; alert(&quot;权限不足,无法访问!&quot;) &#125; &#125; else&#123; next() &#125;&#125;)// 在路由切换之后被调用router.afterEach((to, from) =&gt; &#123; document.title = to.meta.title || &quot;路由守卫Demo&quot;&#125;)//暴露路由器export default router 独享路由守卫:即某个一个路由独有的路由守卫 , 我们需要在index.js中的routes中指定的路由对象中配置 1234567891011121314151617181920212223242526272829303132/* 该文件是Vue中路由器文件，路由器管理着所有路由 */import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27; //import ....Vue.use(VueRouter)const router = new VueRouter(&#123; routes:[ &#123; path:&#x27;/home&#x27;, component:Home, meta: &#123;title:&quot;首页&quot;&#125;, children:[ &#123; path:&#x27;message&#x27;, component:Message, meta: &#123;title:&quot;消息&quot;,isAuth:true&#125;, &#125;, &#123; path:&#x27;news&#x27;, component:News, meta: &#123;title:&quot;新闻&quot;, isAuth:true&#125;, beforeEnter: (to, from, next) =&gt; &#123; /* home/news 独享的路由守卫 */ &#125; &#125; ] &#125;, ]&#125;)//暴露路由器export default router 组件内容路由守卫组件内路由守卫顾名思义就是定义在路由组件中的路由守卫, 有两个: beforeRouteEnter(to,from,next): **当通过路由规则进入组件时执行 ** beforeRouteLeave (to,from,next): 当通过路由规则离开组件时执行 注: 不通过路由规则进入组件即是指使用组件标签展示组件的意思 这两个路由守卫和缓存式路由组件的两个生命周期钩子actived() , deactived()非常类似,但是他们的生命周期顺序是这样: 先经过路由守卫:beforeRouteEnter(to,from,next) 随后挂载组件: mounted() 激活组件:actived() 再经过路由守卫:beforeRouteLeave (to,from,next) 组件失活: deactivated() 测试案例核心代码: About.vue 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;h2&gt;我是About的内容&lt;/h2&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;About&#x27;, mounted() &#123; console.log(&quot;组件被挂载&quot;); &#125;, beforeRouteEnter (to, from, next) &#123; console.log(&quot;组件内路由守卫-&gt;beforeRouterEnter&quot;) next() &#125;, beforeRouteLeave (to, from, next) &#123; console.log(&quot;组件内路由守卫-&gt;beforeRouterLeave&quot;) next() &#125;, activated() &#123; console.log(&quot;关于 组件被激活&quot;); &#125;, deactivated() &#123; console.log(&quot;关于 组件失活&quot;); &#125;, &#125;&lt;/script&gt; 随后点击About路由后,又切换 , 控制台打印出如下结果: 12345组件内路由守卫-&gt;beforeRouterEnter组件被挂载关于 组件被激活组件内路由守卫-&gt;beforeRouterLeave关于 组件失活 路由的两种模式 对于一个url来说,什么是hash值? —- 路径中#后面的内容就是hash值 hash值不会包含在Http请求中, 即 Hash值不会带给服务器 hash模式(默认): 地址中永远带着#号, 不美观 若以后将地址通过第三方手机app分享, 若app校验严格, 则地址会被标记为不合法 兼容性较好 history模式: 地址干净美观 兼容性相较于哈希模式较差 应用部署上线需要后端人员支持, 解决刷新页面服务端404问题 切换模式只需在路由表文件index.js中添加如下配置 1234567891011121314import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;// ...Vue.use(VueRouter)const router = new VueRouter(&#123; mode:&quot;模式名&quot;, routes:[ //... ]&#125;)//暴露路由器export default router UI组件库以ElementUI为例 https://element.eleme.cn/#/zh-CN/ 安装: 1npm i element-ui -S 完整引入:在main.js中 123import ElementUI from &#x27;element-ui&#x27;;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;Vue.use(ElementUI); 随后可以直接使用组件库的样式 按需引入:借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。首先，安装 babel-plugin-component： 12# webpack命令, -D 代表生产依赖npm install babel-plugin-component -D 然后，将 babel.config.js修改如下配置： 123456789101112131415module.exports = &#123; presets: [ &#x27;@vue/cli-plugin-babel/preset&#x27;, [&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false &#125;] ], plugins:[ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125; 接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容： 12345678import &#123; Button, Select &#125; from &#x27;element-ui&#x27;; // 注册组件的全局方式:Vue.component(Button.name, Button); //第二个参数: 用于我们可以给组件进行重命名Vue.component(Select.name, Select);/* 或写为 * Vue.use(Button) * Vue.use(Select) */ axios 在线引入CDN axios官方CDN服务 1234567&lt;!-- 完整版 --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/axios/0.26.1/axios.js&quot;&gt;&lt;/script&gt;&lt;!-- 精简版: --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/axios/0.26.1/axios.min.js&quot;&gt;&lt;/script&gt; 浅谈axious与ajax1.区别:axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。axios是ajax (一部分), ajax不止axios。 **扩展:**Promise是异步编程的一种解决方案，可以替代传统的解决方案–回调函数和事件。ES6统一了用法，并原生提供了Promise对象。作为对象，Promise有一下两个特点： （1）对象的状态不受外界影响。 （2）一旦状态改变了就不会在变，也就是说任何时候Promise都只有一种状态。 2.优缺点:ajax：本身是针对MVC的编程,不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务axios：从 node.js 创建 http 请求支持 Promise API客户端支持防止CSRF提供了一些并发请求的接口（重要，方便了很多的操作） 拓展:Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 ajax和axios、fetch的区别 3.实现对比:12345678910111213141516171819202122232425262728 // jquery封装的ajax$.ajax(&#123; url: &#x27;/getUsers&#x27;, type: &#x27;get&#x27;, dataType: &#x27;json&#x27;, data: &#123; //&#x27;a&#x27;: 1, //&#x27;b&#x27;: 2, &#125;, success: function (response) &#123; console.log(response)； &#125; &#125;)//axious封装的ajaxaxios(&#123; url: &#x27;/getUsers&#x27;, method: &#x27;get&#x27;, responseType: &#x27;json&#x27;, // 默认的 data: &#123; //&#x27;a&#x27;: 1, //&#x27;b&#x27;: 2, &#125; &#125;).then(function (response) &#123; console.log(response); console.log(response.data); &#125;).catch(function (error) &#123; console.log(error); &#125;） 在Vue中使用axios 安装npm i axious 引入并且在Vue原型链中挂载: 在main.js中添加: 12import axios from &#x27;axios&#x27; //引入Vue.prototype.$axios = axios 注意: 在Vue中使用axios时注意回调函数的this指向问题,以便决定是否用箭头函数, 注: axious请求默认都是异步请求 发送get请求: 123456789101112131415161718192021// 为给定 ID 的 user 创建请求this.$axios.get(&#x27;/user?ID=12345&#x27;).then((response)=&gt; &#123; console.log(response);&#125;).catch((error)=&gt;&#123; console.log(error);&#125;);// 上面的请求也可以这样做this.$axios.get(&#x27;/user&#x27;, &#123; params: &#123; ID: 12345 &#125; &#125;).then((response)=&gt; &#123; console.log(response);&#125;).catch((error)=&gt;&#123; console.log(error);&#125;); 发送post请求: 12345678910this.$axios.post(&#x27;/user&#x27;, &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;).then((response)=&gt; &#123; console.log(response);&#125;).catch((error)=&gt;&#123; console.log(error);&#125;); 并发多个请求: 12345678910function getUserAccount() &#123; return axios.get(&#x27;/user/12345&#x27;);&#125;function getUserPermissions() &#123; return axios.get(&#x27;/user/12345/permissions&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); 请求配置:这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 请求参数配置: data是将请求参数放入请求体中,传递的是一个对象 , java后端要通过注解@@RequestBody来接收,接收的参数是一个实体类对象 param是将放入请求头中,传递的是键值对 , java后端要通过注解@RequestParam来接收,接收的参数是对应的参数名 详情请查询:axios中文网 12345678910111213141516171819202122232425262728// 发送 POST 请求axios(&#123; method: &#x27;post&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;).then((response)=&gt; &#123; console.log(response); &#125;).catch((error)=&gt; &#123; console.log(error);&#125;);// 获取远端图片axios(&#123; method:&#x27;get&#x27;, url:&#x27;http://bit.ly/2mTM3nY&#x27;, responseType:&#x27;stream&#x27;&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream(&#x27;ada_lovelace.jpg&#x27;))&#125;) .catch(function (error) &#123; console.log(error);&#125;); 配置项有: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&#123; // `url` 是用于请求的服务器 URL url: &#x27;/user&#x27;, // `method` 是创建请求时使用的方法 method: &#x27;get&#x27;, // default params: &#123;&#125; // 用于携带数据参数,将数据放在请求头上,常用于get请求 data: &#123;&#125; // 也用于携带数据参数, 但是是将数据放在请求体上, 用于post请求 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &#x27;https://some-domain.com/api/&#x27;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `responseType` 表示服务器响应的数据类型，可以是 &#x27;arraybuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27; responseType: &#x27;json&#x27;, // default // `responseEncoding` indicates encoding to use for decoding responses // Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests responseEncoding: &#x27;utf8&#x27;, // default // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: &#x27;janedoe&#x27;, password: &#x27;s00pers3cret&#x27; &#125;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: &#x27;Fred&#x27; &#125;, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // default // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` defines a UNIX Socket to be used in node.js. // e.g. &#x27;/var/run/docker.sock&#x27; to send requests to the docker daemon. // Only either `socketPath` or `proxy` can be specified. // If both are specified, `socketPath` is used. socketPath: null, // default // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // &#x27;proxy&#x27; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: &#x27;127.0.0.1&#x27;, port: 9000, auth: &#123; username: &#x27;mikeymike&#x27;, password: &#x27;rapunz3l&#x27; &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 打包发布及压缩 打包教程参考: vue 打包的方式_vue打包_-CSDN博客 打包命令: 1npm run build 该命令有一些命令配置项: --target lib 指定打包目录 --name 打包后的文件名字 --dest 打包后的文件夹名称 使用 Vue-cli 创建项目:使用脚手架生成的项目是没有config文件夹的，那么就需要我们在根目录下创建一个vue.config.js的文件 而且文件的名称一定要是vue.config.js,在该文件中编辑如下内容: 123456//打包配置文件module.exports = &#123; assetsDir: &#x27;static&#x27;, // 静态资源目录 parallel: false, publicPath: &#x27;./&#x27;, //生产构建为babel提供loader&#125;; 清除生产日志: Vue-Cli4运行npm run build打包时清除console.log的信息_饥饥对饥饥_叽叽复饥饥的博客-CSDN博客 安装插件: npm install babel-plugin-transform-remove-console -D 然后打开项目根目录下的babel.config.js文件, 添加如下代码 1234567891011let transformRemoveConsolePlugin = []//生产环境if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; transformRemoveConsolePlugin = [&#x27;transform-remove-console&#x27;]&#125;module.exports = &#123; &quot;plugins&quot;: [ ...transformRemoveConsolePlugin ]&#125; 再之后运行打包npm run build就发现控制台上的打印已经不见了 使用webpack创建直接在 config 中 index.js 文件下修改 webpack 配置： 1assetsPublicPath: &#x27;./&#x27; 前置知识: JavaScript ES6Vue大量且普遍的使用到了ES6的语法知识, 了解ES6能够提高开发效率和充分了解Vue的相关知识 模块化导入导出: 参考连接: 彻底弄懂Javascript模块导入导出_js导入_码云笔记的博客-CSDN博客 export，import 关键字 export 用于对外输出本模块 import 用于导入模块 js中一切皆对象，所以对象和变量一样可以导出的，并且有两种写法, 常规导出和默认导出(匿名导出) 常规导出1.单个变量导出:123456//a.js 导出一个变量，语法如下export var site = &quot;www.helloworld.net&quot; //b.js 中使用import 导入上面的变量,注意: 这里的 &#123; site &#125; 一定要和导出时的名字一样import &#123; site &#125; from &quot;/.a.js&quot; //路径根据你的实际情况填写console.log(site) //输出： www.helloworld.net 2.导出多个变量123456789101112131415//a.js 中定义两个变量，并导出var siteUrl=&quot;www.helloworld.net&quot;var siteName=&quot;helloworld开发者社区&quot;//将上面的变量导出export &#123; siteUrl ,siteName &#125; // b.js 中使用这两个变量 注意: 这里的 导入变量的名字 一定要和导出时的名字一样import &#123; siteUrl , siteName &#125; from &quot;/.a.js&quot; //路径根据你的实际情况填写console.log(siteUrl) //输出： www.helloworld.netconsole.log(siteName) //输出： helloworld开发者社区 3.导出函数导出函数和导出变量基本一致 1234567891011//a.js 中定义并导出一个函数function sum(a, b) &#123; return a + b&#125;//将函数sum导出export &#123; sum &#125; //b.js 中导入函数并使用import &#123; sum &#125; from &quot;/.a.js&quot; //路径根据你的实际情况填写console.log( sum(4,6) ) //输出： 10 4.导出对象导出对象也是和上面一样的道理, 就不过多赘述了, 接下来讲一下默认导出, 这个比较常用 默认导出(常用)默认导出使用 default export关键字进行导出, 并且每个js文件(模块)中只能导出一个东西(变量,对象或函数), 因为只有一个,所以称为匿名导入, 在导入时就可以自定义名字(区别于常规导入限定名字), 请看下面的例子: 第一种写法: 不接变量名 1234567891011//a.js 中，定义对象并导出, 注意，使用export default 这两个关键字导出一个对象export default &#123; siteUrl:&#x27;www.helloworld.net&#x27;, siteName:&#x27;helloworld开发者社区&#x27;&#125; //b.js 中导入并使用import obj from &#x27;./a.js&#x27; // 这里不一定要写 obj,因为是匿名的不必和导出时一眼console.log(obj.siteUrl) //输出：www.helloworld.netconsole.log(obj.siteName) //输出：helloworld开发者社区 第二种写法: 衔接变量,对象中间可能需要执行一些处理操作 1234567891011121314//a.js 中定义对象，并在最后导出var obj = &#123; siteUrl:&#x27;www.helloworld.net&#x27;, siteName:&#x27;helloworld开发者社区&#x27;&#125; export default obj //导出对象obj //b.js 中导入并使用import obj from &#x27;./a.js&#x27; //路径根据你的实际情况填写console.log(obj.siteUrl) //输出：www.helloworld.netconsole.log(obj.siteName) //输出：helloworld开发者社区 区别对比: 默认导出: 一个文件只能导出一个, 但是导入时名字可以自定义灵活多变 常规导出: 导入时的名字必须和导出时一致, 但是可以从一个文件中导出多个东西","categories":[{"name":"大前端","slug":"大前端","permalink":"https://lqy679.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"python快速入门","slug":"python","date":"2020-01-01T10:57:32.000Z","updated":"2023-03-27T06:52:49.490Z","comments":true,"path":"2020/01/01/python/","link":"","permalink":"https://lqy679.github.io/2020/01/01/python/","excerpt":"python快速入门主要用于自动化方向,不做后端开发 Linux安装:以CentOS 7 为例","text":"python快速入门主要用于自动化方向,不做后端开发 Linux安装:以CentOS 7 为例 安装依赖: 1yum install wget zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make zlib zlib-devel libffi-devel -y 在官网中找到并复制源码链接: 使用wget命令，粘贴复制的下载链接，进行下载并解压 123cd ~ # 切换到 /usr/local/src目录下也行wget https://www.python.org/ftp/python/3.10.4/Python-3.10.4.tgztar -xvf Python-3.10.4.tgz 解压后进如目录进行编译安装: 12345cd Python-3.10.4# --prefix命令代表指定安装目录./configure --prefix=/usr/local/python3.10.4# 编译安装make &amp;&amp; make install 在Linux系统命令行窗口内，直接执行：python 并回车：看到提示版本为我们安装的版本即为安装成功! 更改软链接编译完成后，可以配置软链接，方便快速使用python： 1234# 删除系统自带的老版本(python2)的软链接rm -f /usr/bin/python# 创建软链接ln -s /usr/local/python3.10.4/bin/python3.10 /usr/bin/python ==注意! 创建软链接后，会破坏yum程序的正常使用（只能使用系统自带的python2）== 所以我们需要修改 yum 程序配置, 修改如下两个文件 /usr/bin/yum /usr/libexec/urlgrabber-ext-down 使用vim编辑器，将这2个文件的第一行，讲原来的 1#!/usr/bin/python 修改为: 1#!/usr/bin/python2 特点和简介 python是完全面向对象的语言 函数,模块,数字,字符串等都是对象 支持继承,重载,多重继承 支持重载运算符,泛型设计 拥有强大的标准库, python核心只有: 数字,字符串,列表,字典, 文件等常见类型和函数 三方库丰富 python生态及工具解释器解释器存放在：&lt;Python安装目录&gt;/python.exe 使用解释器运行: 直接在命令行中输入 python 进行 shell 交互 使用 python 带路径的python文件 运行python代码文件 python解释器如今有多种语言实现: Cpython : 官方版本的C语言实现 Jython : 运行在 jvm 的 解释器,用Java实现 IronPython: 运行在.Net 和Mono平台 PyPy : 使用 Python 实现, 支持JIT 即时编译 基础语法Python 语言与 Perl，C 和 Java 等语言有许多相似之处。但是，也存在一些差异。 由于本人已经学习过Java, C 等主流编程语言,所以主要讲差异性: 保留字: and exec not assert finally or break for pass class from print continue global raise def if return del import try elif in while else is with except lambda yield 层次缩进: python中用 缩进 表示层级关系, 每个层次的缩进需要相同 而不像众多编程语言使用 &#123;&#125; 建议在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用 多行语句: Python语句中一般以新行作为语句的结束符。 但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下所示： 123456total = item_one + \\ item_two + \\ item_three# 但语句中包含 [], &#123;&#125; 或 () 括号就不需要使用多行连接符days = [&#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Wednesday&#x27;, &#x27;Thursday&#x27;, &#x27;Friday&#x27;] python引号: Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须是相同类型的。 其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。 python注释: python中单行注释采用 # 开头。python 中多行注释使用三个单引号 &#39;&#39;&#39; 或三个双引号 &quot;&quot;&quot;包裹。 同一行显示多条语句: Python可以在同一行中使用多条语句，语句之间使用分号;分割， 1import sys; x = &#x27;runoob&#x27;; sys.stdout.write(x + &#x27;\\n&#x27;) 打印输出: Python 3.x: 使用print(),输出 , print(&quot;内容&quot;,end=&quot;&quot;)可以实现打印不换行, 默认是换行的 在 Python 2.x中， 可以使用逗号 , 来实现不换行效果： 12345678# -*- coding: UTF-8 -*-print &quot;这是字符串，&quot;, # 末尾添加逗号print &quot;这里的字符串不会另起一行&quot;# print 带括号print (&quot;这是字符串，&quot;), # 末尾添加逗号print (&quot;这里的字符串不会另起一行&quot;) 运算符:Python 语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 算术运算符: 以下假设变量 a=10，变量 b=21： 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 31 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -11 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210 / 除 - x 除以 y b / a 输出结果 2.1 // 取整除 - 向下取接近商的整数 9//2 为 4 , -9//2 为-5 % 取模 - 返回除法的余数 b % a 输出结果 1 ** 幂 - 返回x的y次幂 a**b 为10的21次方 成员运算符: 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 身份运算符: 身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 **id(x) != id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id() 函数用于获取对象内存地址。 is 与 == 区别：is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 1234567891011&gt;&gt;&gt;a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b is a True&gt;&gt;&gt; b == aTrue&gt;&gt;&gt; b = a[:]&gt;&gt;&gt; b is aFalse&gt;&gt;&gt; b == aTrue 逻辑运算: 以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 赋值运算符: 以下假设变量a为10，变量b为20： 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a := 海象运算符，可在表达式内部为变量赋值。Python3.8 版本新增运算符。 在这个示例中，赋值表达式可以避免调用 len() 两次:if (n := len(a)) &gt; 10: print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;) 比较运算符,位运算符, 与其他编程语言一致 运算符优先级: 相同单元格内的运算符具有相同优先级。 运算符均指二元运算，除非特别指出。 相同单元格内的运算符从左至右分组（除了幂运算是从右至左分组）： 运算符 描述 (expressions...),[expressions...], &#123;key: value...&#125;, &#123;expressions...&#125; 圆括号的表达式 x[index], x[index:index], x(arguments...), x.attribute 读取，切片，调用，属性引用 await x await 表达式 ** 乘方(指数) +x, -x, ~x 正，负，按位非 NOT *, @, /, //, % 乘，矩阵乘，除，整除，取余 +, - 加和减 &lt;&lt;, &gt;&gt; 移位 &amp; 按位与 AND ^ 按位异或 XOR ` ` in,not in, is,is not, &lt;, &lt;=, &gt;, &gt;=, !=, == 比较运算，包括成员检测和标识号检测 not x 逻辑非 NOT and 逻辑与 AND or 逻辑或 OR if -- else 条件表达式 lambda lambda 表达式 := 赋值表达式 变量数据类型:变量是存储在内存中的值，这就意味着在创建变量时会在内存中开辟一个空间。 Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 内置的 type() 函数可以用来查询变量所指的对象类型。 多个变量赋值: Python允许你同时为多个变量赋值。例如： 12a = b = c = 1 # 这种写法只有python有, 其他编程语言没有a, b, c = 1, 2, &quot;john&quot; 标准数据类型: Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） Set（集合） Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 数字:数字数据类型用于存储数值。他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。 您也可以使用del语句删除一些对象的引用,相当于手动回收引用。del语句的语法是： 1del var1[,var2[,var3[....,varN]]] Python支持四种不同的数字类型： int（有符号整型） bool float（浮点型） complex（复数） int float complex 10 0.0 3.14j 100 15.20 45.j -786 -21.9 9.322e-36j 080 32.3e+18 .876j -0490 -90. -.6545+0J -0x260 -32.54e100 3e+26J 0x69 70.2E-12 4.53e-7j Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 注意：long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。 Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加. 但可以通过 is 来判断类型。 1234567891011121314&gt;&gt;&gt; issubclass(bool, int) True&gt;&gt;&gt; True==1True&gt;&gt;&gt; False==0True&gt;&gt;&gt; True+12&gt;&gt;&gt; False+11&gt;&gt;&gt; 1 is TrueFalse&gt;&gt;&gt; 0 is FalseFalse 在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。 数学函数 函数 返回值 ( 描述 ) abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换。 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 [round(x ,n]) 返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。 sqrt(x) 返回数字x的平方根。 随机函数 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 [randrange (start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 三角函数 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(xx + yy)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) 将角度转换为弧度 数学常量: pi: 圆周率, e: 数学常量 e，e即自然常数（自然常数） 字符串字符串或串(String)是由数字、字母、下划线组成的一串字符。==python的字串列表(即字符串可看作列表)==有2种取值顺序: 从==右到左索引默认-1开始的==，最大范围是字符串开头 从左到右索引默认0开始的，最大范围是字符串长度少1 截取:如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串(只能从左到右边截取)，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。==截取时到尾下标结束,不包括尾下标元素== 123s = &#x27;abcdef&#x27;print(s[1:5]) #打印结果为: bcdeprint(s[-5:-1]) # bcde Python 列表截取可以接收第三个参数，参数作用是截取的步长，.以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 如果第三个参数为负数表示逆向读取以下实例用于翻转字符串： 123456789 # 翻转字符串 # 假设列表 list = [1,2,3,4], # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) # inputWords[-1::-1] 有三个参数 # 第一个参数 -1 表示最后一个元素 # 第二个参数为空，表示移动到列表末尾 # 第三个参数为步长，-1 表示逆向list1 = [1, 2, 3, &quot;你好&quot;]print(list1[-1::-1]) # [&#x27;你好&#x27;, 3, 2, 1] 运算:星号*是字符复制操作, 加号+是字符串连接运算符。 123str = &quot;abc&quot;print(str + 3) # abc123print(str * 3) # abcabcabc 转义字符在需要在字符中使用特殊字符时，python 用反斜杠\\转义字符。如果**==希望展示原始字符串==(不解析转移字符), 在字符串前加上一个 r 即可, 如:r&#39;\\n&#39; ,会原样输出\\n,不会变成换行** 123456&gt;&gt;&gt; print(&#x27;Ru\\noob&#x27;)Ruoob&gt;&gt;&gt; print(r&#x27;Ru\\noob&#x27;)Ru\\noob&gt;&gt;&gt; 注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。与 C 字符串不同的是，==Python 字符串不能被改变==。向一个索引位置赋值，比如 word[0] = ‘m’ 会导致错误。 常见转义字符如下表 ： 转义字符 描述 (在行尾时) 续行符 \\ 反斜杠符号 &#39; 单引号 &quot; 双引号 \\a 响铃 \\b 退格(Backspace) \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车，将 \\r 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 \\r 后面的内容完全替换完成。 \\f 换页 \\yyy 八进制数，y 代表 0~7 的字符，例如：\\012 代表换行。 \\xyy 十六进制数，以 \\x 开头，y 代表的字符，例如：\\x0a 代表换行 \\other 其它的字符以普通格式输出 字符串格式化:Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。 1print (&quot;我叫 %s 今年 %d 岁!&quot; % (&#x27;小明&#x27;, 10)) 符 号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 格式化操作符辅助指令: 符号 功能 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + ) 在正数前面显示空格 # 在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’) 0 显示的数字前面填充’0’而不是默认的空格 % ‘%%’输出一个单一的’%’ (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。 f-string 模板字符串f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 &#123;&#125; 包起来，它会将变量或表达式计算后的值替换进去，实例如下： 123456789&gt;&gt;&gt; name = &#x27;Runoob&#x27;&gt;&gt;&gt; f&#x27;Hello &#123;name&#125;&#x27; # 替换变量&#x27;Hello Runoob&#x27;&gt;&gt;&gt; f&#x27;&#123;1+2&#125;&#x27; # 使用表达式&#x27;3&#x27;&gt;&gt;&gt; w = &#123;&#x27;name&#x27;: &#x27;Runoob&#x27;, &#x27;url&#x27;: &#x27;www.runoob.com&#x27;&#125;&gt;&gt;&gt; f&#x27;&#123;w[&quot;name&quot;]&#125;: &#123;w[&quot;url&quot;]&#125;&#x27;&#x27;Runoob: www.runoob.com&#x27; 在 Python 3.8 的版本中可以使用 = 符号来拼接运算表达式与结果： 1234567&gt;&gt;&gt; x = 1&gt;&gt;&gt; print(f&#x27;&#123;x+1&#125;&#x27;) # Python 3.62&gt;&gt;&gt; x = 1&gt;&gt;&gt; print(f&#x27;&#123;x+1=&#125;&#x27;) # Python 3.8x+1=2 内置处理函数 序号 方法及描述 1 capitalize() 将字符串的第一个字符转换为大写 2 center(width, fillchar)返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 3 count(str, beg= 0,end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 4 bytes.decode(encoding=”utf-8”, errors=”strict”) Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 5 encode(encoding=’UTF-8’,errors=’strict’) 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ 6 endswith(suffix, beg=0, end=len(string)) 检查字符串是否以 suffix 结束，如果 beg 或者 end 指定则检查指定的范围内是否以 suffix 结束，如果是，返回 True,否则返回 False。 7 expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 8 find(str, beg=0, end=len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 9 index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常。 10 isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False 11 isalpha() 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False 12 isdigit() 如果字符串只包含数字则返回 True 否则返回 False.. 13 islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False 14 isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False 15 isspace() 如果字符串中只包含空白，则返回 True，否则返回 False. 16 istitle() 如果字符串是标题化的(见 title())则返回 True，否则返回 False 17 isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False 18 join(seq) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 19 len(string) 返回字符串长度 20 [ljust(width, fillchar]) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 21 lower() 转换字符串中所有大写字符为小写. 22 lstrip() 截掉字符串左边的空格或指定字符。 23 maketrans() 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 24 max(str) 返回字符串 str 中最大的字母。 25 min(str) 返回字符串 str 中最小的字母。 26 [replace(old, new , max]) 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。 27 rfind(str, beg=0,end=len(string)) 类似于 find()函数，不过是从右边开始查找. 28 rindex( str, beg=0, end=len(string)) 类似于 index()，不过是从右边开始. 29 [rjust(width,, fillchar]) 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 30 rstrip() 删除字符串末尾的空格或指定字符。 31 split(str=””, num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串 32 [splitlines(keepends]) 按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 33 startswith(substr, beg=0,end=len(string)) 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 34 [strip(chars]) 在字符串上执行 lstrip()和 rstrip() 35 swapcase() 将字符串中大写转换为小写，小写转换为大写 36 title() 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) 37 translate(table, deletechars=””) 根据 table 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 38 upper() 转换字符串中的小写字母为大写 39 zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 40 isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 列表ListList（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用 [ ] 标识，是 python 最通用的复合数据类型。 ==列表有着与字符串相同的运算操作:== **截取:**列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。 运算: 连接(+) , 复制(*) 1234list1 = [1, 2, 3, &quot;你好&quot;]list2 = [4.56, 5, &quot;字符串&quot;]print(list1 * 2) # [1, 2, 3, &#x27;你好&#x27;, 1, 2, 3, &#x27;你好&#x27;]print(list1 + list2) # [1, 2, 3, &#x27;你好&#x27;, 4.56, 5, &#x27;字符串&#x27;] 对于列表的修改和访问元素, 可以通过列表名[索引值] 或 列表名[索引值] = 值 进行操作 追加元素可以通过 列表名.append(元素) 进行操作 删除列表元素:可以使用 del 语句来删除列表的的元素，如下实例： 1234list = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000]print (&quot;原始列表 : &quot;, list)del list[2]print (&quot;删除第三个元素 : &quot;, list) 以上实例输出结果： 12原始列表 : [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000]删除第三个元素 : [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 2000] 队列运算python重载了队列之间的加法+运算, 和队列与整数之间的乘法运算* 两队列相加会将两个队列的元素合并为一个新队列 , 队列与整数相乘, 将队列的元素复制整数份 12345l1 = [1, 2, 3]l2 = [4, 5, 6] print(l1 + l2)print(l1 * 3) 结果: 12[1, 2, 3, 4, 5, 6][1, 2, 3, 1, 2, 3, 1, 2, 3] 列表函数&amp;方法函数: 即不需要通过对象可以直接调用的 方法: 需要通过具体的某个对象进行调用 Python包含以下函数: 序号 函数 1 len(list) 列表元素个数 2 max(list) 返回列表元素最大值 3 min(list) 返回列表元素最小值 4 list(seq) 将元组转换为列表 Python包含以下方法: 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort( key=None, reverse=False) 对原列表进行排序 10 list.clear() 清空列表 11 list.copy() 复制列表 Tuple（元组）元组（tuple）与列表类似，元组中的元素类型也可以不相同, 拥有相同的截取,连接复制等操作, 不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。 string、list 和 tuple 都属于 sequence（序列）。 1、与字符串一样，元组的元素不能修改。 2、元组也可以被索引和切片，方法一样。 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。 4、元组也可以使用+操作符进行拼接。 由于元组是不可变数据,所以我们无法对元组的元素进行增,删,改操作 删除元组我们可以使用del语句来删除整个元组，如下实例: 123456tup = (&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000) print (tup)del tupprint (&quot;删除后的元组 tup : &quot;)print (tup) 运行会报错: 12345删除后的元组 tup : Traceback (most recent call last): File &quot;test.py&quot;, line 8, in &lt;module&gt; print (tup)NameError: name &#x27;tup&#x27; is not defined 内置函数 函数 描述 len(tuple) 计算元组元素个数。 max(tuple) 返回元组中元素最大值。 min(tuple) 返回元组中元素最小值。 tuple(iterable) 将可迭代系列转换为元组。 Dictionary（字典）字典（dictionary）是Python中另一个非常有用的内置数据类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典是一种映射类型，字典用 &#123; &#125; 标识，它是一个无序的 键(key) : 值(value) 的集合。键(key)必须使用不可变类型(如:数字,字符串,元组等)。在同一个字典中，键(key)必须是唯一的。 1234567891011dict = &#123;&#125;dict[&#x27;one&#x27;] = &quot;1 - 菜鸟教程&quot;dict[2] = &quot;2 - 菜鸟工具&quot;tinydict = &#123;&#x27;name&#x27;: &#x27;runoob&#x27;,&#x27;code&#x27;:1, &#x27;site&#x27;: &#x27;www.runoob.com&#x27;&#125;print (dict[&#x27;one&#x27;]) # 输出键为 &#x27;one&#x27; 的值print (dict[2]) # 输出键为 2 的值print (tinydict) # 输出完整的字典print (tinydict.keys()) # 输出所有键print (tinydict.values()) # 输出所有值 另外，字典类型也有一些内置的方法，例如 clear()、keys()、values() 等。 字典元素的访问,修改操作也和列表非常类似, 添加元素,则需要保证添加元素的键不重复就行 删除字典元素能删单一的元素也能清空字典，清空只需一项操作。 显式删除一个字典用del命令，如下实例： 12345tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125; del tinydict[&#x27;Name&#x27;] # 删除键 &#x27;Name&#x27;tinydict.clear() # 清空字典del tinydict # 删除字典 字典内置函数&amp;方法函数: 序号 函数及描述 len(dict) 计算字典元素个数，即键的总数。 方法: 序号 函数及描述 1 dict.clear() 删除字典内所有元素 2 dict.copy() 返回一个字典的浅复制 3 dict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 4 dict.get(key, default=None) 返回指定键的值，如果键不在字典中返回 default 设置的默认值 5 key in dict 如果键在字典dict里返回true，否则返回false 6 dict.items() 以列表返回一个视图对象,包含键和值 7 dict.keys() 返回一个视图对象 8 dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9 dict.update(dict2) 把字典dict2的键/值对更新到dict里 10 dict.values() 返回一个视图对象 11 pop(key[,default])] 删除字典 key（键）所对应的值，返回被删除的值。 12 popitem() 返回并删除字典中的最后一对键和值。 集合(Set)集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。基本功能是进行成员关系测试和删除重复元素。可以使用大括号 { } 或者 set() 函数创建集合，注意：**创建一个空集合必须用 set() 而不是 { }**，因为 { } 是用来创建一个空字典。 123456789101112131415161718sites = &#123;&#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Facebook&#x27;, &#x27;Zhihu&#x27;, &#x27;Baidu&#x27;&#125;print(sites) # 输出集合，重复的元素被自动去掉# 成员测试if &#x27;Runoob&#x27; in sites : print(&#x27;Runoob 在集合中&#x27;)else : print(&#x27;Runoob 不在集合中&#x27;)# set可以进行集合运算a = set(&#x27;abracadabra&#x27;)b = set(&#x27;alacazam&#x27;)print(a)print(a - b) # a 和 b 的差集print(a | b) # a 和 b 的并集print(a &amp; b) # a 和 b 的交集print(a ^ b) # a 和 b 中不同时存在的元素 内置方法: 方法 描述 add() 为集合添加元素 pop() 随机移除元素,并将其返回 discard(value) 删除集合中指定的元素, 不存在不会报错 remove(value) 移除指定元素, 不存在会报错 clear() 移除集合中的所有元素 copy() 拷贝一个集合 difference() 返回多个集合的差集 difference_update() 移除集合中的元素，该元素在指定的集合也存在。 intersection() 返回集合的交集 intersection_update() 返回集合的交集。 isdisjoint() 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 issubset() 判断指定集合是否为该方法参数集合的子集。 issuperset() 判断该方法的参数集合是否为指定集合的子集 symmetric_difference() 返回两个集合中不重复的元素集合。 symmetric_difference_update() 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 union() 返回两个集合的并集 update() 给集合添加元素 数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，一般情况下你只需要将数据类型作为函数名即可。Python 数据类型转换可以分为两种： 隐式类型转换 - 自动完成 (就高不就低) 显式类型转换 - 需要使用类型函数来转换 显示类型转换: 12345678x = int(1) # x 输出结果为 1y = int(2.8) # y 输出结果为 2z = int(&quot;3&quot;) # z 输出结果为 3x = float(1) # x 输出结果为 1.0y = float(2.8) # y 输出结果为 2.8z = float(&quot;3&quot;) # z 输出结果为 3.0w = float(&quot;4.2&quot;) # w 输出结果为 4.2 更多内置转换函数 函数 描述 [int(x ,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 [complex(real ,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个 (key, value)元组序列。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 控制结构python 的执行顺序和多数编程语言一样遵循顺序执行 条件判断:Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else。 123456if condition_1: statement_block_1elif condition_2: statement_block_2else: statement_block_3 在 Python 中没有 switch...case 语句，但在 Python3.10 版本添加了 match...case，功能也类似，详见下文。 match…casePython 3.10 增加了 match…case 的条件判断，不需要再使用一连串的 if-else 来判断了。match 后的对象会依次与 case 后的内容进行匹配，如果匹配成功，则执行匹配到的表达式，否则直接跳过，_ 可以匹配一切。 123456789match subject: case &lt;pattern_1&gt;: &lt;action_1&gt; case &lt;pattern_2&gt;: &lt;action_2&gt; case &lt;pattern_3&gt;: &lt;action_3&gt; case _: &lt;action_wildcard&gt; case _: 类似于 C 和 Java 中的 **default:**，当其他 case 都无法匹配时，匹配这条，保证永远会匹配成功。 一个 case 也可以设置多个匹配条件，条件使用 ｜ 隔开: 123... case 401|403|404: return &quot;Not allowed&quot; 循环控制:python中也有其他编程语言都有的 break, continue , 效果都一样,不再赘述 while 语句的一般形式： 12while 判断条件(condition)： 执行语句(statements)…… **while 循环使用 else 语句:**如果 while 后面的判断条件语句为 false 时，则执行 else 的语句块。 1234while &lt;expr&gt;: &lt;statement(s)&gt;else: &lt;additional_statement(s)&gt; for 语句 for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。for循环的一般格式如下： 1234for &lt;variable&gt; in &lt;sequence&gt;: &lt;statements&gt;else: &lt;statements&gt; 整数范围值可以配合 range() 函数使用: 123# 1 到 5 的所有数字：for number in range(1, 6): print(number) range() 函数:range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。 1range(start, stop[, step]) start: 计数从 start 开始。默认是从 0 开始。例如 range(5) 等价于 range(0， 5) stop: 计数到 stop 结束，但不包括 stop。例如：range(0， 5) 是 [0, 1, 2, 3, 4] 没有 5 step：步长，默认为 1。例如：range(0， 5) 等价于 range(0, 5, 1) 如果只提供一个参数，它将生成一个从 0 开始的整数序列，参数为结束值，步长默认为 1 for…else在 Python 中，for…else 语句用于在循环结束后执行一段代码。 1234for item in iterable: # 循环主体else: # 循环结束后执行的代码 当循环执行完毕（即遍历完 iterable 中的所有元素）后，会执行 else 子句中的代码，==注意:如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句。== pass语句Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句 12&gt;&gt;&gt;while True:... pass # 等待键盘中断 (Ctrl+C) 输入输出输出输出格式美化Python两种输出值的方式: 表达式语句和 print() 函数。第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。 str()： 函数返回一个用户易读的表达形式。 repr()： 产生一个解释器易读的表达形式。 str.format():括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。 12&gt;&gt;&gt; print(&#x27;&#123;&#125;网址： &quot;&#123;&#125;!&quot;&#x27;.format(&#x27;菜鸟教程&#x27;, &#x27;www.runoob.com&#x27;))菜鸟教程网址： &quot;www.runoob.com!&quot; 在括号中的数字用于指向传入对象在 format() 中的位置，如下所示： 1234&gt;&gt;&gt; print(&#x27;&#123;0&#125; 和 &#123;1&#125;&#x27;.format(&#x27;Google&#x27;, &#x27;Runoob&#x27;))Google 和 Runoob&gt;&gt;&gt; print(&#x27;&#123;1&#125; 和 &#123;0&#125;&#x27;.format(&#x27;Google&#x27;, &#x27;Runoob&#x27;))Runoob 和 Google 如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。 12&gt;&gt;&gt; print(&#x27;&#123;name&#125;网址： &#123;site&#125;&#x27;.format(name=&#x27;菜鸟教程&#x27;, site=&#x27;www.runoob.com&#x27;))菜鸟教程网址： www.runoob.com 可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 1234567891011&gt;&gt;&gt; import math&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为 &#123;0:.3f&#125;。&#x27;.format(math.pi))常量 PI 的值近似为 3.142。&gt;&gt;&gt; table = &#123;&#x27;Google&#x27;: 1, &#x27;Runoob&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;&gt;&gt;&gt; for name, number in table.items():... print(&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;.format(name, number))...Google ==&gt; 1Runoob ==&gt; 2Taobao ==&gt; 3 如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。最简单的就是传入一个字典, 然后使用方括号 [] 来访问键值 : 123&gt;&gt;&gt; table = &#123;&#x27;Google&#x27;: 1, &#x27;Runoob&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;&gt;&gt;&gt; print(&#x27;Runoob: &#123;0[Runoob]:d&#125;; Google: &#123;0[Google]:d&#125;; Taobao: &#123;0[Taobao]:d&#125;&#x27;.format(table))Runoob: 2; Google: 1; Taobao: 3 旧式字符串格式化% 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf() 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如: 123&gt;&gt;&gt; import math&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为：%5.3f。&#x27; % math.pi)常量 PI 的值近似为：3.142。 因为 str.format() 是比较新的函数， 大多数的 Python 代码仍然使用 % 操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format(). 输入读取键盘输入Python 提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。 input() : 可选参数: 参数类型为字符串,用于在控制台展示提示信息,返回值为一个用户从键盘输入的数据,并且自动转换成字符串类型的 推导式Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。 Python 支持各种数据结构的推导式： 列表(list)推导式 字典(dict)推导式 集合(set)推导式 元组(tuple)推导式 列表推导式格式为： 12345[表达式 for 变量 in 列表] [out_exp_res for out_exp in input_list]或者 [表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition] out_exp_res：列表生成元素表达式，可以是有返回值的函数。 for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。 if condition：条件语句，可以过滤列表中不符合条件的值。 列表推导式:**实例:**过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母 1234names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]# name.upper() 代表将 字符串name转换为大写new_names = [name.upper() for name in names if len(name)&gt;3]print(new_names) # [&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;] 计算 30 以内可以被 3 整除的整数： 12multiples = [i for i in range(30) if i % 3 == 0]print(multiples) #[0, 3, 6, 9, 12, 15, 18, 21, 24, 27] 字典推导式:123&#123; key_expr: value_expr for value in collection &#125;或&#123; key_expr: value_expr for value in collection if condition &#125; **案例: **将列表中各字符串值为键，各字符串的长度为值，组成键值对 123listdemo = [&#x27;Google&#x27;,&#x27;Runoob&#x27;, &#x27;Taobao&#x27;]newdict = &#123;key:len(key) for key in listdemo&#125;print(newdict) # &#123;&#x27;Google&#x27;: 6, &#x27;Runoob&#x27;: 6, &#x27;Taobao&#x27;: 6&#125; 提供三个数字，以三个数字为键，三个数字的平方为值来创建字典： 12dic = &#123;x: x**2 for x in (2, 4, 6)&#125;print(dic) # &#123;2: 4, 4: 16, 6: 36&#125; 集合推导式:123&#123; expression for item in Sequence &#125;或&#123; expression for item in Sequence if conditional &#125; 计算数字 1,2,3 的平方数： 12setnew = &#123;i**2 for i in (1,2,3)&#125;print(setnew) # &#123;1, 4, 9&#125; 判断不是 abc 的字母并输出： 12a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125;print(a) # &#123;&#x27;d&#x27;, &#x27;r&#x27;&#125; 元组推导式元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。元组推导式基本格式： 123(expression for item in Sequence )或(expression for item in Sequence if conditional ) 我们可以使用下面的代码生成一个包含数字 1~9 的元组： 123456&gt;&gt;&gt; a = (x for x in range(1,10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt; # 返回的是生成器对象&gt;&gt;&gt; tuple(a) # 使用 tuple() 函数，可以直接将生成器对象转换成元组(1, 2, 3, 4, 5, 6, 7, 8, 9) 迭代器与生成器迭代是Python最强大的功能之一，是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：**iter()** 和 **next()**。 迭代器创建一个迭代器把一个类作为一个迭代器使用需要在类中实现两个方法 iter() 与 next() 。类都有一个构造函数，Python 的构造函数为 __init()__, 它会在对象初始化的时候执行。 __iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。 __next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。 实例:创建一个返回数字的迭代器，初始值为 1，逐步递增 1： 123456789101112131415161718class MyNumbers: def __iter__(self): self.a = 1 # self相当于Java中的this return self def __next__(self): x = self.a self.a += 1 return x myclass = MyNumbers()myiter = iter(myclass) print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter)) StopIterationStopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。 实例:在 20 次迭代后停止执行： 123456789101112131415161718class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration myclass = MyNumbers()myiter = iter(myclass) for x in myiter: print(x) 生成器在 Python 中，使用了 yield(有点类似C语言的static关键字) 的函数被称为生成器（generator）。跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。 以下实例使用 yield 实现斐波那契数列： 1234567891011121314151617import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1 f = fibonacci(10) # f 是一个迭代器，由生成器返回生成while True: try: print (next(f), end=&quot; &quot;) except StopIteration: sys.exit() 函数python中的函数与大多数编程语言里函数是一个意思,这里简单说一下函数与方法的区别: 两者都差不多的, 只是 一般我们将 类的函数叫做方法 (也能是通过对象调用的函数我们把它称之为方法) 定义一个函数Python 定义函数使用 def 关键字，一般格式如下： 12def 函数名（参数列表）: 函数体 默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。 函数调用注意: 由于python是脚本语言顺序解释执行, 所以==要调用函数之前必须先定义函数== 参数传递:在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的： 可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里==实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃==，不是改变 a 的值，相当于新生成了 a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，==本身la没有动，只是其内部的一部分值被修改了==。 python 函数的参数传递： 不可变类型：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。 可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 参数以下是调用函数时可使用的正式参数类型： 必需参数 关键字参数 默认参数 不定长参数 必需参数:必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 关键字参数:格式: 函数名(参数名 = 值) 关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 12345678def printinfo( name, age ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return #调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; ) 默认参数格式: def 函数名(默认参数名 = 默认值) 调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值： 1234567891011#可写函数说明def printinfo( name, age = 35 ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return #调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; )print (&quot;------------------------&quot;)printinfo( name=&quot;runoob&quot; ) 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下： 1234def functionname([formal_args,] *var_args_tuple ): &quot;函数_文档字符串&quot; function_suite return [expression] 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 123456789def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) for var in vartuple: print (var,end=&quot; &quot;) returnprintinfo( 70, 60, 50 ) 结果: 12输出: 70 60 50 加了两个星号 ** 的参数会以字典的形式导入 12345678def printinfo( arg1, **vardict ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vardict)# 调用printinfo 函数printinfo(1, a=2,b=3) 结果: 123输出: 1&#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 3&#125; 如果单独出现星号 *，则星号后的参数必须用关键字传入： 12345678910&gt;&gt;&gt; def f(a,b,*,c):... return a+b+c... &gt;&gt;&gt; f(1,2,3) # 报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 3 were given&gt;&gt;&gt; f(1,2,c=3) # 正常6&gt;&gt;&gt; 匿名函数Python 使用 lambda 关键字来创建匿名函数。即不再使用 def 语句这样标准的形式定义一个函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 语法: 1lambda [arg1 [,arg2,.....argn]]:expression 实例: 1234sum = lambda arg1, arg2: arg1 + arg2# 调用sum函数print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))print (&quot;相加后的值为 : &quot;, sum( 20, 20 )) return 语句return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None(类似java中的null)。 错误和异常Python 有两种错误很容易辨认：语法错误和异常。 语法错误Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例: 12345&gt;&gt;&gt; while True print(&#x27;Hello world&#x27;) File &quot;&lt;stdin&gt;&quot;, line 1, in ? while True print(&#x27;Hello world&#x27;) ^SyntaxError: invalid syntax 这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号 : 语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。 异常即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。 大多数的异常都不会被程序处理，都以错误信息的形式展现在这里: 123456789101112&gt;&gt;&gt; 10 * (1/0) # 0 不能作为除数，触发异常Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ZeroDivisionError: division by zero&gt;&gt;&gt; 4 + spam*3 # spam 未定义，触发异常Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?NameError: name &#x27;spam&#x27; is not defined&gt;&gt;&gt; &#x27;2&#x27; + 2 # int 不能与 str 相加，触发异常Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: can only concatenate str (not &quot;int&quot;) to str 异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有 ZeroDivisionError，NameError 和 TypeError。错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。 异常处理异常捕捉可以使用 try/except 语句。与Java中 try catch() 语句类似 , 以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。 123456while True: try: x = int(input(&quot;请输入一个数字: &quot;)) break except ValueError: print(&quot;您输入的不是数字，请再次尝试输入！&quot;) 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组 12except (RuntimeError, TypeError, NameError): pass 最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。 12345678910111213import systry: f = open(&#x27;myfile.txt&#x27;) s = f.readline() i = int(s.strip())except OSError as err: print(&quot;OS error: &#123;0&#125;&quot;.format(err))except ValueError: print(&quot;Could not convert data to an integer.&quot;)except: print(&quot;Unexpected error:&quot;, sys.exc_info()[0]) raise try/except…elsetry/except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。 else 子句将在 try 子句==没有发生任何异常的时候执行。== 以下实例在 try 语句中判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句，读取文件内容： 12345678for arg in sys.argv[1:]: try: f = open(arg, &#x27;r&#x27;) except IOError: print(&#x27;cannot open&#x27;, arg) else: print(arg, &#x27;has&#x27;, len(f.readlines()), &#x27;lines&#x27;) f.close() try-finally 语句try-finally 语句无论是否发生异常都将执行最后的代码。与Java类似 raise 抛出异常raise关键字用于抛出异常,和Java的throw类似 raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。 模块Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。 import 语句想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下： 1import module1[, module2[,... moduleN] 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。 搜索路径是一个解释器会先进行搜索的所有目录的列表。要导入模块 support，需要把命令放在脚本的顶端： 1234567import sys print(&#x27;命令行参数如下:&#x27;)for i in sys.argv: print(i) print(&#x27;\\n\\nPython 路径为：&#x27;, sys.path, &#x27;\\n&#x27;) 1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。 2、sys.argv 是一个包含命令行参数的列表。 3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。 from … import 语句Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下： 1from modname import name1[, name2[, ... nameN]] 例如，要导入模块 fibo 的 fib 函数，使用如下语句： 123&gt;&gt;&gt; from fibo import fib, fib2&gt;&gt;&gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377 这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。 from … import * 语句: 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： 1from modname import * 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。 深入理解模块模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。 当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。 还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。**(即 from …… import 语句)** , 例如: 123&gt;&gt;&gt; from fibo import fib, fib2&gt;&gt;&gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377 这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。 这还有一种方法**(from modname import *)，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表 ,这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。** ____name__属性一个模块被另一个程序第一次引入时，其主程序将运行**(也就是说在模块无论被哪种方式引入时,会把该模块文件从头到尾执行一遍)。如果我们想在模块被引入时，要想模块中的某一程序块不执行，我们可以用___name__属性来使该程序块仅在该模块自身运行时执行。** 例如有文件 using_name.py 1234if __name__ == &#x27;__main__&#x27;: print(&#x27;程序自身在运行&#x27;)else: print(&#x27;我来自另一模块&#x27;) test.py 1import using_name 执行文件 1234python using_name.py # 运行using_name.py文件# 输出: 程序自身在运行python test.py# 输出: 我来自另一模块 ==每个模块都有一个__name__属性，当该模块文件被执行时值是’__main__‘时,否则值为:该模块的文件名。== 例如:有模块文件model1.py内容如下: 1234567print(&quot;模块语句打印1&quot;)def ff(): print(&quot;模块1的函数&quot;)print(&quot;模块语句打印2&quot;)print(__name__) test.py 123import model1print(__name__) 当运行test.py文件时 1234模块语句打印1模块语句打印2model1__main__ 包包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。这里给出了一种可能的包结构（在分层的文件系统中）: 1234567891011121314151617181920212223sound/ 顶层包 __init__.py 初始化 sound 包 formats/ 文件格式转换子包 __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ 声音效果子包 __init__.py echo.py surround.py reverse.py ... filters/ filters 子包 __init__.py equalizer.py vocoder.py karaoke.py ... 在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。 用户可以每次只导入一个包里面的特定模块，他必须使用全名去访问: 12import sound.effects.echosound.effects.echo.echofilter(input, output, delay=0.7, atten=4) 还有一种导入子模块的方法是:他不需要那些冗长的前缀，所以他可以这样使用: 12from sound.effects import echoecho.echofilter(input, output, delay=0.7, atten=4) 还有一种变化就是直接导入一个函数或者变量:可以直接使用他的 echofilter() 函数: 1echofilter(input, output, delay=0.7, atten=4) 当使用 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 :exc:ImportError 异常。 如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。 从一个包中导入 *如果我们使用 from sound.effects import * 会发生什么呢？ Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。在 Windows 平台上，我们无法确定一个叫做 ECHO.py 的文件导入为模块是 echo 还是 Echo，或者是 ECHO。为了解决这个问题，我们只需要提供一个精确包的索引。 导入语句遵循如下规则：如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import \\* 的时候就把这个列表中的所有名字作为包内容导入。 文件处理open() 方法Python open() 方法用于打开一个文件，并返回文件对象file。在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。 注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。 open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。,更多参数有: 1open(file, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) file: 必需，带路径的文件（相对或者绝对路径）。 mode: 可选，文件打开模式 buffering: 设置缓冲 encoding: 一般使用utf8 errors: 报错级别 newline: 区分换行符 closefd: 传入的file参数类型 opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。 mode 参数有： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 file对象file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数： 序号 方法及描述 6 file.read(size)从文件读取指定的字节数，如果未给定或为负则读取所有。 7 file.readline(size)读取整行，包括 “\\n” 字符。 12 file.write(str)将字符串写入文件，返回的是写入的字符长度。 13 file.writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 1 file.close()关闭文件。关闭后文件不能再进行读写操作。 2 file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 3 file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 4 file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False 8 file.readlines(sizeint)读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 9 file.seek(offset , whence)移动文件读取指针到指定位置 10 file.tell()返回文件当前位置。 11 file.truncate(size)从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。 实例: 1234print(&quot;\\n&quot;,&quot;=&quot;*10,&quot;蚂蚁庄园动态&quot;,&quot;=&quot;*10)file = open(&#x27;message.txt&#x27;,&#x27;w&#x27;) # 创建或打开保存蚂蚁庄园动态信息的文件file.read(&quot;python写入的文件数据\\n&quot;)# file.close() # 关闭文件对象 with语句打开文件后要及时关闭，如果忘记关闭，可能带来意想不到的问题。另外，如果在文件打开时出现了异常，将导致文件不能关闭。为了更好避免这些问题，可以使用with语句，从而在文件处理时，无论是否出现异常都能保证with语句执行完毕后关闭已打开的文件。 12with expression as target: with-body expression: 用于指定一个表达式，可以是打开文件的open()函数。 target：用于指定一个变量，并且将expression的结果保存到该变量中。 with-body：用于指定with语句体，其中可以是执行with语句后相关的一些操作语句。如果不想执行任何语句，可以直接使用pass语句代替。 123456with open(&#x27;message.txt&#x27;,&#x27;w&#x27;) as file: # 创建或打开保存蚂蚁庄园动态信息的文件 pass print(&quot;\\n 即将显示……\\n&quot;) OS模块os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示： 序号 方法及描述 28 os.listdir(path) 返回path指定的文件夹包含的文件或文件夹的名字的列表。 35 os.mkdir(path , mode) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 45 os.remove(path) 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 46 os.removedirs(path) 递归删除目录。 49 os.rmdir(path) 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 33 os.makedirs(path , mode) 递归文件夹创建函数。如果子目录创建失败或者已经存在，会抛出一个 OSError 的异常，Windows上Error 183 即为目录已经存在的异常错误。 35 os.mkdir(path[, mode]) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 21 os.getcwd() 返回当前工作目录 2 os.chdir(path) 改变当前工作目录 47 os.rename(src, dst) 重命名文件或目录，从 src 到 dst 66 os.replace() 重命名文件或目录。 48 os.renames(old, new) 递归地对目录进行更名，也可以对文件进行更名。 64 os.path 模块 获取文件的属性信息。 65 os.pardir() 获取当前目录的父目录，以字符串形式显示目录名。 实例: 12345678import os, sys# 创建的目录path = &quot;/tmp/home/monthly/daily&quot;os.makedirs( path, 0o777 );print (&quot;路径被创建&quot;) 路径搜索问题常用路径: 12345print(&#x27;__file__:&#x27;, __file__) # 当前运行的绝对路径全脚本文件名print(&#x27;sys.executable:&#x27;, sys.executable) # 执行程序所在路径print(&#x27;sys.argv[0]:&#x27;, sys.argv[0]) # 命令行参数,第一个默认为执行程序名# 当前调用 python 解释器的脚本的目录，也就是你当前的 Python 项目路径print(&#x27;sys.path[0]:&#x27;, sys.path[0]) 常见操作path.join(path,*paths) : 拼接两个路径并且返回(str) path.exists(path) : 判断路径是否存在 path.split(file_path) : 将路径中的最后一个目录或者文件与前面的路径分开 path.abspath(path) : 讲路径转换为绝对路径返回 path.realpath(path):讲路径转换为相对路径返回 path.dirname(path): 获取参数路径的父级路径 作用域Python 中只有==模块（module），类（class）以及函数（def、lambda）才会引入新的作用域==，这一点与其他语言不同,其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问， 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中**(可能会覆盖掉全局变量)** 1234567891011total = 0 # 这是一个全局变量# 可写函数说明def sum( arg1, arg2 ): #返回2个参数的和.&quot; total = arg1 + arg2 # total在这里是局部变量. print (&quot;函数内是局部变量 : &quot;, total) return total #调用sum函数sum( 10, 20 )print (&quot;函数外是全局变量 : &quot;, total) 结果: 12函数内是局部变量 : 30函数外是全局变量 : 0 global 和 nonlocal关键字声明当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal (非局部的)关键字了。 123456789101112num = 1def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num)fun1()print(num)#######################1123123 需要注意的是这种情况下也会用到: 1234567a = 10def test(): # global a # 加上这个就不会报错了 a = a + 1 print(a)test() # 这段代码会报错,错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。 如果要修改嵌套作用域（外层非全局作用域）中的变量则需要 nonlocal 关键字了**，如下实例： 123456789101112def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num)outer()##############100100 面向对象Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。 Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 类的相关操作类定义123456class ClassName: &lt;statement-1&gt; . . . &lt;statement-N&gt; 类对象类对象支持两种操作：属性引用和实例化。 注意: python中没有静态方法和静态属性的概念,凡是关于类的操作都需要实例化一个对象来进行 实例化和Java一样, 都是通过类名方法来创建, 是不过Java 还需要用到 new 关键字 属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样: 123456789101112class MyClass: &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot; i = 12345 def f(self): return &#x27;hello world&#x27; # 实例化类x = MyClass() # 访问类的属性和方法print(&quot;MyClass 类的属性 i 为：&quot;, x.i)print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f()) 构造器类有一个名为 __init__() 的特殊方法（构造方法）,这里与Java不同,Java的构造器是方法名相同的方法;该方法在类实例化时会自动调用 selfself 关键字相当于Java的 this 关键字, 指向类的实例 类的方法在类的内部，使用 def 关键字来定义一个方法，==与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数==，self 代表的是类的实例。 123456789101112131415161718#类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) # 实例化类p = people(&#x27;runoob&#x27;,10,30)p.speak() 继承Python 同样支持类的继承，派生类的定义如下所示: 123456class 子类类名 (父类类名): # 内容... # 如果父类和子类不再同一个命名空间中, 则还需要引入对应模块class 子类类名 (模块名.父类类名): # 内容... 继承了父类的子类如果不写构造器__init__(self), 则会自动调用父类的构造器, 这点与Java的一致 12345678910class A: def __init__(self): print(&quot;A类构造器&quot;)class Son(A): passson = Son()#### 运行结果:A类构造器 如果子类重写了构造器,则不会去自动调用父类的构造器,而是执行自己的构造器, 这一点与Java不一样 123456789101112class A: def __init__(self): print(&quot;A类构造器&quot;)class Son(A): def __init__(self): print(&quot;子类构造器&quot;) son = Son()### 运行结果:子类构造器 想要执行父类构造去则想要通过类名.内容手动调用 1234567891011121314151617class A: a = 0 def __init__(self): self.a = 10 print(&quot;A类构造器&quot;)class Son(A): def __init__(self): A.__init__(self) print(&quot;子类构造器&quot;)son = Son()print(son.a)### 运行结果:A类构造器子类构造器10 多继承Python同样有限的支持多继承形式。多继承的类定义形如下例: 12class 子类类名 (父类1类名,父类2类名,父类3类名): # 内容... ==需要注意圆括号中父类的顺序==，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &#x27;&#x27; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备class speaker(): topic = &#x27;&#x27; name = &#x27;&#x27; def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic)) #多重继承class sample(speaker,student): a =&#x27;&#x27; def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)test.speak() #方法名同，默认调用的是在括号中参数位置排前父类的方法### 运行结果:我叫 Tim，我是一个演说家，我演讲的主题是 Python 方法重写python同样支持方法重写(子类覆盖父类的同名方法) , 我们可以通过super()方法来调用父类被覆盖的方法 以下是 super() 方法的语法: 1super(类名, 对象) 类名一般是 父类类名, 对象一般是子类对象, 在子类的方法体中要调用父类被覆盖的方法则是self 1234567891011class Parent: # 定义父类 def myMethod(self): print (&#x27;调用父类方法&#x27;) class Child(Parent): # 定义子类 def myMethod(self): print (&#x27;调用子类方法&#x27;) c = Child() # 子类实例c.myMethod() # 子类调用重写方法super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法 访问权限:python没有像Java一样的访问修饰符关键字, 只有私有和公开两种权限,而是用双下划线代表私有权限, 只能在类的内部使用 ,不加任何修饰则是公开权限 类的私有属性: __属性名：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 类的私有方法: __方法名 类的专有方法 __init__ : 构造函数，在生成对象时调用 __str__: 相当于Java的toString()方法 __del__ : 析构函数，释放对象时使用 __repr__ : 打印，转换,也相当于Java的toString()方法 __setitem__ : 按照索引赋值 __getitem__: 按照索引获取值 __len__: 获得长度 __cmp__: 比较运算 __call__: 函数调用 __add__: 加运算 __sub__: 减运算 __mul__: 乘运算 __truediv__: 除运算 __mod__: 求余运算 __pow__: 乘方 运算符重载Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下： 12345678910111213141516class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return &#x27;Vector (%d, %d)&#x27; % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print (v1 + v2)### 运行结果:Vector (7, 8) python 进阶pippip 是 Python 包管理工具，该工具提供了对 Python 包的查找、下载、安装、卸载的功能。类似Java的Maven工具,软件包也可以在 https://pypi.org/ 中找到。目前最新的 Python 版本已经预装了 pip。 查看是否已经安装 pip 可以使用以下命令： 1pip --version pip 的一些配置 超详细图解修改pip install默认安装路径的方法_python_脚本之家 (jb51.net) 更改包的默认安装位置查看已经的包的存放目录: 重复安装一次,查看报错信息即可看到安装位置, 如果在在C盘建议修改,修改方法如下: 1python -m site -help 会得到类似如下的一个路径文件: D:\\Environment\\python\\python3.8.1\\lib\\site.py 修改此文件中的内容, 原来内容为: 12USER_SITE = NoneUSER_BASE = None 修改: 12USER_SITE = &quot;D:\\ProgramData\\Anaconda3\\lib\\site-packages&quot; # 包的存放目录USER_BASE = &quot;D:\\ProgramData\\Anaconda3\\Scripts&quot; # pip脚本文件存放目录 更改镜像源:在user目录下新建pip文件夹，里面新建pip.ini文件 , 内容为: 1234[global]index-url=http://mirrors.aliyun.com/pypi/simple/# pip 安装包的目录target=D:/Environment/python/python3.8.1/Lib/site-packages 或者使用 pip命令的 -i 命令选项: 1pip -i http://mirrors.aliyun.com/pypi/simple/ install 包名 常用命令: 123pip install 包名pip uninstall 包名 pip list # 查看已经安装的包 python常见的第三方库网络爬虫: requests-对HTTP协议进行高度封装，支持非常丰富的链接访问功能。 bs4-beautifulsoup4库，用于解析和处理HTML和XML。 lxml-lxml是python的一个解析库，这个库支持HTML和xml的解析，支持XPath的解析方式 PySpider-一个国人编写的强大的网络爬虫系统并带有强大的WebUI。 **Scrapy-**很强大的爬虫框架，用于抓取网站并从其页面中提取结构化数据。可用于从数据挖掘到监控和自动化测试的各种用途 Crawley-高速爬取对应网站的内容，支持关系和非关系数据库，数据可以导出为JSON、XML等 Portia-可视化爬取网页内容 cola-分布式爬虫框架 newspaper-提取新闻、文章以及内容分析 自动化: pywin32-有关Windows系统操作、Office（Word、Excel等）文件读写等的综合应用库 **selenium-**一个调用浏览器的driver，通过这个库可以直接调用浏览器完成某些操作，比如输入验证码，常用来进行浏览器的自动化工作。 appium: 基于selenium的移动端自动化第三方库 openpyxl- 一个处理Microsoft Excel文档的Python第三方库，它支持读写Excel的xls、xlsx、xlsm、xltx、xltm。 PyPDF2-一个能够分割、合并和转换PDF页面的库。 XlsxWriter-操作Excel工作表的文字，数字，公式，图表等 python-docx-一个处理Microsoft Word文档的Python第三方库，它支持读取、查询以及修改doc、docx等格式文件，并能够对Word常见样式进行编程设置。 pdfminer-一个可以从PDF文档中提取各类信息的第三方库。与其他PDF相关的工具不同，它能够完全获取并分析 P D F 的文本数据 数据分析与可视化 matplotlib-Matplotlib 是一个 Python 2D 绘图库，可以生成各种可用于出版品质的硬拷贝格式和跨平台交互式环境数据。Matplotlib 可用于 Python 脚本，Python 和 IPython shell（例如 MATLAB 或 Mathematica），Web 应用程序服务器和各种图形用户界面工具包。” numpy-NumPy 是使用 Python 进行科学计算所需的基础包。用来存储和处理大型矩阵，如矩阵运算、矢量处理、N维数据变换等。 pyecharts-用于生成 Echarts 图表的类库 pandas-一个强大的分析结构化数据的工具集，基于numpy扩展而来，提供了一批标准的数据模型和大量便捷处理数据的函数和方法。 Scipy: 基于Python的matlab实现，旨在实现matlab的所有功能，在numpy库的基础上增加了众多的数学、科学以及工程计算中常用的库函数。 Plotly-Plotly提供的图形库可以进行在线WEB交互，并提供具有出版品质的图形，支持线图、散点图、区域图、条形图、误差条、框图、直方图、热图、子图、多轴、极坐标图、气泡图、玫瑰图、热力图、漏斗图等众多图形 wordcloud-词云生成器 jieba-中文分词模块 其他常用 pydub-支持多种格式声音文件，可进行多种信号处理、信号生成、音效注册、静音处理等 TimeSide-能够进行音频分析、成像、转码、流媒体和标签处理的Python框架 dnspython-DNS工具包 **pygame-**专为电子游戏设计的一个模块 PyQt5-pyqt5是Qt5应用框架的Python第三方库，编写Python脚本的应用界面 PIL(Pillow)-PIL库是Python语言在图像处理方面的重要第三方库，支持图像存储、显示和处理，它能够处理几乎所有图片格式，可以完成对图像的缩放、剪裁、叠加以及向图像添加线条、图像和文字等操作 OpenCV-图像和视频工作库 Py2exe: 将python脚本转换为windows上可以独立运行的可执行程序。 WeRoBot 是一个微信公众号开发框架，也称为的微信机器人框架。WeRoBot可以解析微信服务器发来的消息，并将消息转换成成Message或者Event类型。 机器学习 NLTK-一个自然语言处理的第三方库，NLP领域中常用，可建立词袋模型（单词计数），支持词频分析（单词出现次数）、模式识别、关联分析、情感分析（词频分析+度量指标）、可视化（+matploylib做分析图）等 TensorFlow-谷歌的第二代机器学习系统，是一个使用数据流图进行数值计算的开源软件库。 Keras -是一个高级神经网络 API，用 Python 编写，能够在 TensorFlow，CNTK 或 Theano 之上运行。它旨在实现快速实验，能够以最小的延迟把想法变成结果，这是进行研究的关键。” Caffe-一个深度学习框架，主要用于计算机视觉，它对图像识别的分类具有很好的应用效果 **theano-**深度学习库。它与Numpy紧密集成，支持GPU计算、单元测试和自我验证，为执行深度学习中大规模神经网络算法的运算而设计，擅长处理多维数组。 Scikit-learn-是一个简单且高效的数据挖掘和数据分析工具，它基于NumPy、SciPy和matplotlib构建。Scikit-learn的基本功能主要包括6个部分：分类，回归，聚类，数据降维，模型选择和数据预处理。Scikit-learn也被称为sklearn。 正则表达式Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。re 模块使 Python 语言拥有全部的正则表达式功能。compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。 正则匹配re.match()re.match 尝试==从字符串的起始位置匹配==一个模式，如果==不是起始位置匹配成功的话，match()就返回none。== 函数语法: 1re.match(pattern, string, flags=0) 参数说明: 参数 描述 pattern 正则表达式字符串 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 正则表达式修饰符flags: 修饰符 描述 re.I 使匹配对大小写不敏感 re.S 使 . 匹配包括换行符\\n在内的所有字符 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 re.search()re.search()函数: 扫描==整个字符串==并返回第一个成功的匹配。 re.match与re.search的区别:re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。 参数和用法与re.match()函数一致 re.findall()在字符串中找到正则表达式==所匹配的所有子串，并返回一个列表==，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。 注意： ==match 和 search 是匹配一次 findall 匹配所有。== 语法格式: 123re.findall(pattern, string, flags=0)或pattern.findall(string[, pos[, endpos]]) # pattern为正则表达式对象,通过compile()获得 os 可选参数，指定字符串的起始位置，默认为 0。 endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。 正则表达式对象re.RegexObject: 通过调用re.compile() 返回 RegexObject 对象。 compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() ,findall()等函数使用。当通过正则表达式调用这些方法时, 不再需要传递pattern参数 , compile()语法格式: 1re.compile(pattern[, flags]) pattern : 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和’ # ‘后面的注释 分组若正则匹配成功match(), search()等方法返回一个匹配的Match 对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式的字符串。 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 实例: 123456789str = &quot;2023-01-31学习爬虫&quot;partten = r&quot;(\\d&#123;4&#125;)-(0[1-12]|1[0-2])-(0[1-9]|[1-2]\\d|3[0-1])&quot;res = re.match(partten,str)print(res) # &lt;re.Match object; span=(0, 10), match=&#x27;2023-01-31&#x27;&gt;print(res.group()) # 2023-01-31print(res.group(0)) # 2023-01-31print(res.group(1)) # 2023print(res.group(2)) # 01print(res.group(3)) # 31 正则切割替换替换re模块提供了re.sub()用于替换字符串中的匹配项。语法: 1re.sub(pattern, repl, string, count=0, flags=0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 flags : 编译时用的匹配模式，数字形式。 前三个为必选参数，后两个为可选参数。 切割split 方法将匹配的子串将作为分割符分割字符串后返回列表，它的使用形式如下： 1re.split(pattern, string[, maxsplit=0, flags=0]) 参数: 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 maxsplit 分割次数，maxsplit=1 分割一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 JSON转换Python3 中可以使用 json 模块来对 JSON 数据进行编解码，它包含了两个函数： json.dumps(): 对数据进行编码。 json.loads(): 对数据进行解码。 json.dump(): 在 json 的编解码过程中，Python 的原始类型与 json 类型会相互转换，具体的转化对照如下： Python JSON dict object list, tuple array str string int, float, int- &amp; float-derived Enums number True true False false None null json.load(): JSON 解码为 Python 类型转换对应表： JSON Python object dict array list string str number (int) int number (real) float true True false False null None json.dumps() 与 json.loads() 实例: 123456789101112import json # Python 字典类型转换为 JSON 对象data = &#123; &#x27;no&#x27; : 1, &#x27;name&#x27; : &#x27;Runoob&#x27;, &#x27;url&#x27; : &#x27;http://www.runoob.com&#x27;&#125; json_str = json.dumps(data)print (&quot;Python 原始数据：&quot;, repr(data))print (&quot;JSON 对象：&quot;, json_str) 执行以上代码输出结果为： 12Python 原始数据： &#123;&#x27;url&#x27;: &#x27;http://www.runoob.com&#x27;, &#x27;no&#x27;: 1, &#x27;name&#x27;: &#x27;Runoob&#x27;&#125;JSON 对象： &#123;&quot;url&quot;: &quot;http://www.runoob.com&quot;, &quot;no&quot;: 1, &quot;name&quot;: &quot;Runoob&quot;&#125; 接着以上实例，我们可以将一个JSON编码的字符串转换回一个Python数据结构： 1234567891011121314151617import json # Python 字典类型转换为 JSON 对象data1 = &#123; &#x27;no&#x27; : 1, &#x27;name&#x27; : &#x27;Runoob&#x27;, &#x27;url&#x27; : &#x27;http://www.runoob.com&#x27;&#125; json_str = json.dumps(data1)print (&quot;Python 原始数据：&quot;, repr(data1))print (&quot;JSON 对象：&quot;, json_str) # 将 JSON 对象转换为 Python 字典data2 = json.loads(json_str)print (&quot;data2[&#x27;name&#x27;]: &quot;, data2[&#x27;name&#x27;])print (&quot;data2[&#x27;url&#x27;]: &quot;, data2[&#x27;url&#x27;]) 执行以上代码输出结果为： 1234Python 原始数据： &#123;&#x27;name&#x27;: &#x27;Runoob&#x27;, &#x27;no&#x27;: 1, &#x27;url&#x27;: &#x27;http://www.runoob.com&#x27;&#125;JSON 对象： &#123;&quot;name&quot;: &quot;Runoob&quot;, &quot;no&quot;: 1, &quot;url&quot;: &quot;http://www.runoob.com&quot;&#125;data2[&#x27;name&#x27;]: Runoobdata2[&#x27;url&#x27;]: http://www.runoob.com 如果要处理的是文件: 1234567# 写入 JSON 数据with open(&#x27;data.json&#x27;, &#x27;w&#x27;) as f: json.dump(data, f) # 读取数据with open(&#x27;data.json&#x27;, &#x27;r&#x27;) as f: data = json.load(f) python3 多线程python与Java一样同样支持多线程, 线程可以分为: 内核线程：由操作系统内核创建和撤销。 用户线程：不需要内核支持而在用户程序中实现的线程。 Python3 线程中常用的两个模块为： _thread threading(推荐使用) thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。 快速创建线程: Python中使用线程有两种方式：函数或者用类来包装线程对象。函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下: 1_thread.start_new_thread ( function, args[, kwargs] ) 参数说明: function - 线程函数。 args - 传递给线程函数的参数,他必须是个tuple类型。例如线程名和线程id kwargs - 可选参数。 1234567891011121314151617181920import _threadimport time# 为线程定义一个函数def print_time( threadName, delay): count = 0 while count &lt; 5: time.sleep(delay) # 线程休眠 count += 1 print (&quot;%s: %s&quot; % ( threadName, time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;,time.localtime()) ))# 创建两个线程try: _thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) ) _thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) )except: print (&quot;Error: 无法启动线程&quot;)while 1: pass 线程模块_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。 threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法: run(): 线程执行的行为。 start():启动线程活动。 join([time]): 加入线程, 等待至线程中止。例如在主线程中t1.join() , 即使主线先运行结束,也会等待t1执行完再退出程序,可实现线程同步 isAlive(): 返回线程是否活动的。 getName(): 返回线程名。 setName(): 设置线程名。 创建线程实例化线程类语法个格式: 1t1 = Thread(group=None,target=None, name=None, args=(), kwargs=None, *,daemon=None) 此构造方法中，以上所有参数都是可选参数，即可以使用，也可以忽略。其中各个参数的含义如下： group：指定所创建的线程隶属于哪个线程组（此参数尚未实现，无需调用）； target：指定所创建的线程要调度的目标方法（最常用）,只写方法名即可； args：以元组的方式，为 target 指定的方法传递参数； kwargs：以字典的方式，为 target 指定的方法传递参数； daemon：指定所创建的线程是否为后代线程。 实例: 123456789101112131415161718192021import threadingimport timedef ff1(): print(&quot;这是线程1执行的函数!&quot;, threading.currentThread().name)def ff2(name, delay): count = 8 while count: count -= 1 time.sleep(delay) print(&quot;线程:%s , %s &quot; % (name, time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;, time.localtime())))# 创建线程对象t1 = threading.Thread(target=ff1)t2 = threading.Thread(target=ff2, kwargs=&#123;&quot;name&quot;: &quot;thread-2&quot;, &quot;delay&quot;: 2&#125;)t1.start()t2.start()t1.join()t2.join() 继承线程类通过重写线程类的run()方法也可以创建一个线程 实例: 12345678910111213141516171819202122232425262728293031323334import threadingimport timeclass MyThread(threading.Thread): def __init__(self, threadID, name, delay): threading.Thread.__init__(self) self.name = name self.threadID = threadID self.delay = delay def run(self): print_time(self.name, self.delay)def print_time(name, delay): &quot;&quot;&quot; 打印五次当前时间 @return: &quot;&quot;&quot; count = 0 while count &lt; 5: count += 1 print(&quot;%s:%s&quot; % (name, (time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;, time.localtime())))) time.sleep(delay)t1 = MyThread(1, &quot;thread-1&quot;, 0)t2 = MyThread(2, &quot;thread-2&quot;, 0)t1.start()t2.start()t1.join()t2.join()print(&quot;主线程结束&quot;) 线程安全与锁原子操作 Python 一定要知道的坑—线程安全_51CTO博客_python 线程安全 原子操作（atomic operation），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程。它有点类似数据库中的 事务。 在 Python 的官方文档上，列出了一些常见原子操作 1234567891011L.append(x)L1.extend(L2)x = L[i]x = L.pop()L1[i:j] = L2L.sort()x = yx.field = yD[x] = yD1.update(D2)D.keys() 而==下面这些就不是原子操作== 1234i = i+1L.append(L[-1])L[i] = L[j]D[x] = D[x] + 1 当我们还是无法确定我们的代码是否具有原子性的时候，可以尝试通过 dis 模块里的 dis() 函数来查看 进程锁如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire() 方法和 release() 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下： **实例:**本实例中, 将演示两个线程同时操作count变量自增1000000次, 最后打印的结果均会小于2000000,原因是自增运算不是原子操作所以导致线程不安全, 部分自增操作被覆盖掉了, 但加锁以后就能保证每次都是2000000 12345678910111213141516171819202122232425262728293031323334353637import threadingimport timeclass MyThread(threading.Thread): def __init__(self, threadID, name, delay): threading.Thread.__init__(self) self.name = name self.threadID = threadID self.delay = delay def run(self): print_time(self.name, self.delay)count = 0def print_time(name, delay): &quot;&quot;&quot; 打印五次当前时间 @return: &quot;&quot;&quot; global count for x in range(1000000): threadLock.acquire() count += 1 threadLock.release()t1 = MyThread(1, &quot;thread-1&quot;, 0)t2 = MyThread(2, &quot;thread-2&quot;, 0)threadLock = threading.Lock()t1.start()t2.start()t1.join()t2.join()print(count)print(&quot;主线程结束&quot;) 线程优先队列Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步和优先级。 Queue 模块中的常用方法: Queue.qsize() 返回队列的大小 Queue.empty() 如果队列为空，返回True,反之False Queue.full() 如果队列满了，返回True,反之False Queue.full 与 maxsize 大小对应 Queue.get([block[, timeout]])获取队列，timeout等待时间 Queue.get_nowait() 相当Queue.get(False) Queue.put(item) 写入队列，timeout等待时间 Queue.put_nowait(item) 相当Queue.put(item, False) Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号 Queue.join() 实际上意味着等到队列为空，再执行别的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/python3import queueimport threadingimport timeexitFlag = 0class myThread (threading.Thread): def __init__(self, threadID, name, q): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.q = q def run(self): print (&quot;开启线程：&quot; + self.name) process_data(self.name, self.q) print (&quot;退出线程：&quot; + self.name)def process_data(threadName, q): while not exitFlag: queueLock.acquire() if not workQueue.empty(): data = q.get() queueLock.release() print (&quot;%s processing %s&quot; % (threadName, data)) else: queueLock.release() time.sleep(1)threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;]nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;]queueLock = threading.Lock()workQueue = queue.Queue(10)threads = []threadID = 1# 创建新线程for tName in threadList: thread = myThread(threadID, tName, workQueue) thread.start() threads.append(thread) threadID += 1# 填充队列queueLock.acquire()for word in nameList: workQueue.put(word)queueLock.release()# 等待队列清空while not workQueue.empty(): pass# 通知线程是时候退出exitFlag = 1# 等待所有线程完成for t in threads: t.join()print (&quot;退出主线程&quot;) PyMySQL什么是 PyMySQL？ PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2 中则使用 mysqldb。PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。 安装库 12pip install PyMySQL或 pip3 install PyMySQL 数据库连接实例: 123456789import pymysqlconnect = pymysql.connect( host=&#x27;localhost&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, database=&#x27;testdb&#x27;) 增删改查PyMySQL主要通过调用execute(sql)方法来执行原生sql语句字符串来操作数据库, 此外这个sql字符串还支持使用%d, %s等格式化占位符来进行参数插入 创建表如果数据库连接存在我们可以使用execute()方法来执行sql为数据库创建表 1234567891011121314151617181920212223242526import pymysql # 打开数据库连接db = pymysql.connect(host=&#x27;localhost&#x27;, user=&#x27;testuser&#x27;, password=&#x27;test123&#x27;, database=&#x27;TESTDB&#x27;) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor() # 使用 execute() 方法执行 SQL，如果表存在则删除cursor.execute(&quot;DROP TABLE IF EXISTS EMPLOYEE&quot;) # 使用预处理语句创建表sql = &quot;&quot;&quot;CREATE TABLE EMPLOYEE ( FIRST_NAME CHAR(20) NOT NULL, LAST_NAME CHAR(20), AGE INT, SEX CHAR(1), INCOME FLOAT )&quot;&quot;&quot; cursor.execute(sql) # 关闭数据库连接db.close() 查询操作Python查询Mysql使用操作游标对象cursor的 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。 fetchone(): 该方法获取下一个查询结果集。结果集是一个对象 fetchall(): 接收全部的返回结果集对象. rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。 结果集对象是一个元组, 每个是一行数据 12345cursor.execute(&quot;select * from `users`&quot;)results = cursor.fetchall()print(results)for row_data in results: print(row_data) 运行结果: 1234((1, &#x27;zs&#x27;, &#x27;123456&#x27;, &#x27;zs@sina.com&#x27;), (2, &#x27;lisi&#x27;, &#x27;123456&#x27;, &#x27;lisi@sina.com&#x27;), (3, &#x27;wangwu&#x27;, &#x27;123456&#x27;, &#x27;wangwu@sina.com&#x27;))(1, &#x27;zs&#x27;, &#x27;123456&#x27;, &#x27;zs@sina.com&#x27;)(2, &#x27;lisi&#x27;, &#x27;123456&#x27;, &#x27;lisi@sina.com&#x27;)(3, &#x27;wangwu&#x27;, &#x27;123456&#x27;, &#x27;wangwu@sina.com&#x27;) 数据增删改凡是涉及到==修改的数据的sql (例如插入,删除,更新), 都需要调用db.commit()来提交事务==, 否则会数据会操作不成功 插入数据实例: 使用execute()方法来执行sql, 此外sql 支持使用%s , %d等格式化占位符来处理sql 123456789101112131415161718# 省略导包 , 连接数据库和获取操作游标...# SQL 插入语句sql = &quot;INSERT INTO EMPLOYEE(FIRST_NAME, \\ LAST_NAME, AGE, SEX, INCOME) \\ VALUES (&#x27;%s&#x27;, &#x27;%s&#x27;, %s, &#x27;%s&#x27;, %s)&quot; % \\ (&#x27;Mac&#x27;, &#x27;Mohan&#x27;, 20, &#x27;M&#x27;, 2000)try: # 执行sql语句 cursor.execute(sql) # 执行sql语句 db.commit()except: # 发生错误时回滚 db.rollback() # 关闭数据库连接db.close() 其他的修改,删除数据都是同理,只要修改为对应的SQL即可 事务处理Python DB API 2.0 的事务提供了两个方法 db.commit() 或 db.rollback。 对于支持事务的数据库， 在Python数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务。commit()方法游标的所有更新操作，rollback（）方法回滚当前游标的所有操作。每一个方法都开始了一个新的事务。 错误异常处理DB API中定义了一些数据库操作的错误及异常，下表列出了这些错误和异常: 异常 描述 Warning 当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。 Error 警告以外所有其他错误类。必须是 StandardError 的子类。 InterfaceError 当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。 DatabaseError 和数据库有关的错误发生时触发。 必须是Error的子类。 DataError 当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。 OperationalError 指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。 IntegrityError 完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。 InternalError 数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。 ProgrammingError 程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。 NotSupportedError 不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。 SMTP发送邮件python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。Python创建 SMTP 对象语法如下： 123import smtplibsmtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] ) host: SMTP 服务器主机。 你可以指定主机的ip地址或者域名如:runoob.com，这个是可选参数。 port: 如果你提供了 host 参数, 你需要指定 SMTP 服务使用的端口号，一般情况下SMTP端口号为25。 local_hostname: 如果SMTP在你的本机上，你只需要指定服务器地址为 localhost 即可。 Python SMTP对象使用sendmail方法发送邮件，语法如下： 1SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options] 参数说明： from_addr: 邮件发送者地址。 to_addrs: 字符串列表，收件人地址,一般是邮箱名。 msg: 发送消息 这里要注意一下第三个参数，msg是字符串，表示邮件。我们知道邮件一般由标题，发信人，收件人，邮件内容，附件等构成，发送邮件的时候，要注意msg的格式。这个格式就是smtp协议中定义的格式。 实例: 12345678910111213141516171819202122import smtplibfrom email.mime.text import MIMETextfrom email.header import Header sender = &#x27;from@runoob.com&#x27;receivers = [&#x27;429240967@qq.com&#x27;] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码message = MIMEText(&#x27;Python 邮件发送测试...&#x27;, &#x27;plain&#x27;, &#x27;utf-8&#x27;)message[&#x27;From&#x27;] = Header(&quot;菜鸟教程&quot;, &#x27;utf-8&#x27;) # 发送者message[&#x27;To&#x27;] = Header(&quot;测试&quot;, &#x27;utf-8&#x27;) # 接收者 subject = &#x27;Python SMTP 邮件测试&#x27;message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) try: smtpObj = smtplib.SMTP(&#x27;localhost&#x27;) smtpObj.sendmail(sender, receivers, message.as_string()) print (&quot;邮件发送成功&quot;)except smtplib.SMTPException: print (&quot;Error: 无法发送邮件&quot;) 我们使用三个引号来设置邮件信息，标准邮件需要三个头部信息： From, To, 和 Subject ，每个信息直接使用空行分割。我们通过实例化 smtplib 模块的 SMTP 对象 smtpObj 来连接到 SMTP 访问，并使用 sendmail 方法来发送信息。执行以上程序，如果你本机安装sendmail，就会输出： 邮件发送成功 第三方邮箱如果我们本机没有 sendmail 访问，也可以使用其他服务商的 SMTP 访问（QQ、网易、Google等）。 下面以QQ邮箱举例: 123456789101112131415161718192021222324252627import smtplibfrom email.mime.text import MIMETextfrom email.header import Header# 第三方 SMTP 服务mail_host = &quot;smtp.qq.com&quot; # 设置服务器mail_user = &quot;lqy679@qq.com&quot; # 用户名mail_pass = &quot;*******&quot; # 口令sender = &#x27;318482536@qq.com&#x27; # 发件人邮箱receivers = [&#x27;lqy679@qq.com&#x27;] # 收件人邮件，可设置为你的QQ邮箱或者其他邮箱message = MIMEText(&#x27;Python 邮件发送测试...&#x27;, &#x27;plain&#x27;, &#x27;utf-8&#x27;)message[&#x27;From&#x27;] = Header(&quot;发件人名称&quot;, &#x27;utf-8&#x27;)message[&#x27;To&#x27;] = Header(&quot;收件人名称&quot;, &#x27;utf-8&#x27;)subject = &#x27;Python SMTP 邮件测试&#x27; # 邮箱主题message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;)try : smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) # 25 为 SMTP 端口号 smtpObj.login(mail_user, mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print(&quot;邮件发送成功&quot;)except smtplib.SMTPException: print(&quot;发送失败!&quot;) 发送html邮件Python发送HTML格式的邮件与发送纯文本消息的邮件不同之处就是将MIMEText中_subtype设置为html。具体代码如下： 123456789101112131415161718import smtplibfrom email.mime.text import MIMETextfrom email.header import Header # 设置发件人和收件人.... mail_msg = &quot;&quot;&quot;&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt;&quot;&quot;&quot;message = MIMEText(mail_msg, &#x27;html&#x27;, &#x27;utf-8&#x27;) # 设置邮件内容类似为 htmlmessage[&#x27;From&#x27;] = Header(&quot;菜鸟教程&quot;, &#x27;utf-8&#x27;)message[&#x27;To&#x27;] = Header(&quot;测试&quot;, &#x27;utf-8&#x27;) subject = &#x27;Python SMTP 邮件测试&#x27;message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;)# 后续操作和普通邮件一致 在 HTML 文本中添加图片邮件的 HTML 文本中一般邮件服务商添加外链是无效的，正确添加图片的实例如下所示： 12345678910111213141516171819202122232425262728# 省略了设置发件人和收件人, 发送邮件的代码msgRoot = MIMEMultipart(&#x27;related&#x27;)msgRoot[&#x27;From&#x27;] = Header(&quot;菜鸟教程&quot;, &#x27;utf-8&#x27;)msgRoot[&#x27;To&#x27;] = Header(&quot;测试&quot;, &#x27;utf-8&#x27;)subject = &#x27;Python SMTP 邮件测试&#x27;msgRoot[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) msgAlternative = MIMEMultipart(&#x27;alternative&#x27;)msgRoot.attach(msgAlternative) mail_msg = &quot;&quot;&quot;&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot;&gt;菜鸟教程链接&lt;/a&gt;&lt;/p&gt;&lt;p&gt;图片演示：&lt;/p&gt;&lt;p&gt;&lt;img decoding=&quot;async&quot; src=&quot;cid:image1&quot;&gt;&lt;/p&gt;&quot;&quot;&quot;msgAlternative.attach(MIMEText(mail_msg, &#x27;html&#x27;, &#x27;utf-8&#x27;)) # 指定图片为当前目录fp = open(&#x27;test.png&#x27;, &#x27;rb&#x27;)msgImage = MIMEImage(fp.read())fp.close() # 定义图片 ID，在 HTML 文本中引用msgImage.add_header(&#x27;Content-ID&#x27;, &#x27;&lt;image1&gt;&#x27;)msgRoot.attach(msgImage) 发送带附件的邮件发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。 12345678910111213141516171819202122232425262728293031323334353637import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Header sender = &#x27;from@runoob.com&#x27;receivers = [&#x27;429240967@qq.com&#x27;] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 #创建一个带附件的实例message = MIMEMultipart()message[&#x27;From&#x27;] = Header(&quot;菜鸟教程&quot;, &#x27;utf-8&#x27;)message[&#x27;To&#x27;] = Header(&quot;测试&quot;, &#x27;utf-8&#x27;)subject = &#x27;Python SMTP 邮件测试&#x27;message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) #邮件正文内容message.attach(MIMEText(&#x27;这是菜鸟教程Python 邮件发送测试……&#x27;, &#x27;plain&#x27;, &#x27;utf-8&#x27;)) # 构造附件1，传送当前目录下的 test.txt 文件att1 = MIMEText(open(&#x27;test.txt&#x27;, &#x27;rb&#x27;).read(), &#x27;base64&#x27;, &#x27;utf-8&#x27;)att1[&quot;Content-Type&quot;] = &#x27;application/octet-stream&#x27;# 这里的filename可以任意写，写什么名字，邮件中显示什么名字att1[&quot;Content-Disposition&quot;] = &#x27;attachment; filename=&quot;test.txt&quot;&#x27;message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件att2 = MIMEText(open(&#x27;runoob.txt&#x27;, &#x27;rb&#x27;).read(), &#x27;base64&#x27;, &#x27;utf-8&#x27;)att2[&quot;Content-Type&quot;] = &#x27;application/octet-stream&#x27;att2[&quot;Content-Disposition&quot;] = &#x27;attachment; filename=&quot;runoob.txt&quot;&#x27;message.attach(att2) try: smtpObj = smtplib.SMTP(&#x27;localhost&#x27;) smtpObj.sendmail(sender, receivers, message.as_string()) print (&quot;邮件发送成功&quot;)except smtplib.SMTPException: print (&quot;Error: 无法发送邮件&quot;) 网络爬虫简单爬虫架构: 会用到的第三方库: requests: 发送请求和网页下载 BeautifulSoup/bs4: 用于解析网页 Selenium:用于网页动态下载 requests库这是一个简单易用的python Htpp库,可使用python发送http请求 常用于爬虫中对网页内容的下载; api介绍:Python 内置了 requests 模块，该模块主要用来发 送 HTTP 请求，requests 模块比 urllib 模块更简洁。 requests 方法 方法 描述 delete(url, args) 发送 DELETE 请求到指定 url get(url, params, args) 发送 GET 请求到指定 url head(url, args) 发送 HEAD 请求到指定 url patch(url, data, args) 发送 PATCH 请求到指定 url post(url, data, json, args) 发送 POST 请求到指定 url put(url, data, args) 发送 PUT 请求到指定 url request(method, url, args) 向指定的 url 发送指定的请求方法 参数说明如下: json:参数为要发送到指定 url 的 JSON 对象。 data:参数为要发送到指定 url 的字典、元组列表、字节或文件对象。 args:其他参数，比如 cookies、headers、verify等。 verify:True/False , 是否进行https证书验证,默认是, 需要自己设置证书地址 123456789import requestskw = &#123;&#x27;s&#x27;:&#x27;python 教程&#x27;&#125;# 设置请求头headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;&#125; # params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()response = requests.get(&quot;https://www.runoob.com/&quot;, params = kw, headers = headers) post 方法请求带参数: 格式如下:需要指定参数传值: 1requests.post(url, data=&#123;key: value&#125;, json=&#123;key: value&#125;, args) 实例: 12345# 表单参数，参数名为 fname 和 lnamemyobj = &#123;&#x27;fname&#x27;: &#x27;RUNOOB&#x27;,&#x27;lname&#x27;: &#x27;Boy&#x27;&#125;# 发送请求x = requests.post(&#x27;https://www.runoob.com/try/ajax/demo_post2.php&#x27;, data = myobj) 响应对象上述的请求方法均会返回一个响应头对象, 该对象包含了具体的响应信息如下: 属性或方法 说明 text 返回响应的内容，unicode 类型数据 json() 返回结果的 JSON 对象 (结果需要以 JSON 格式编写的，否则会引发错误) status_code 返回 http 的状态码，比如 404 和 200（200 是 OK，404 是 Not Found） encoding 解码 r.text 的编码方式,默认为ISO-8859-1,中文乱码时我需要将此属性设置为utf-8 headers 返回响应头，字典格式 raise_for_status() 如果发生错误，方法返回一个 HTTPError 对象 request 返回请求此响应的请求对象 apparent_encoding 编码方式 close() 关闭与服务器的连接 content 返回响应的内容，以字节为单位 cookies 返回一个 CookieJar 对象，包含了从服务器发回的 cookie elapsed 返回一个 timedelta 对象，包含了从发送请求到响应到达之间经过的时间量，可以用于测试响应速度。比如 r.elapsed.microseconds 表示响应到达需要多少微秒。 history 返回包含请求历史的响应对象列表（url） reason 响应状态的描述，比如 “Not Found” 或 “OK” is_permanent_redirect 如果响应是永久重定向的 url，则返回 True，否则返回 False is_redirect 如果响应被重定向，则返回 True，否则返回 False iter_content() 迭代响应 iter_lines() 迭代响应的行 links 返回响应的解析头链接 next 返回重定向链中下一个请求的 PreparedRequest 对象 ok 检查 “status_code” 的值，如果小于400，则返回 True，如果不小于 400，则返回 False url 返回响应的 URL BeautifulSoup 中文文档:Beautiful Soup 4.4.0 文档 — Beautiful Soup 4.2.0 中文 文档 python第三方库, 用于解析html文件或者xml文件获取数据 1pip install beautifulsoup4 使用: 将一段文档传入BeautifulSoup 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄. 12345from bs4 import BeautifulSoupsoup = BeautifulSoup(open(&quot;index.html&quot;))soup(&quot;&lt;html&gt;data&lt;/html&gt;&quot;) 对于BeautifulSoup构造方法, 他还可以指定解析器和编码: 123from bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;, from_encoding=&#x27;utf-8&#x27;) 搜索节点其中 返回值soup对象提供了一些我们可以操作html文档dom节点的方法: find_all(name,attrs,string): 返回一个列表, 列表元素为所有匹配的节点tag对象: name: 字符串类型, 表示需要查找的dom节点类型, 比如当name 值为‘a’时,就查找所有的 &lt;a&gt;&lt;/a&gt; attrs:关键字参数, 根据属性查找, 不过需要注意查找属性为class时要转换为class_ string: 关键字参数, 根据html标签的内容查找 12345# 查找网页中所有的&lt;a href=&#x27;/view/123.html&#x27;&gt;&lt;/a&gt;soup.find_all(&#x27;a&#x27;,href=&#x27;/view/123.html&#x27;)# 查找网页中所有的&lt;a href=&#x27;/view/123.html&#x27;&gt;python&lt;/a&gt;soup.find_all(&#x27;a&#x27;, class_=&#x27;btn&#x27;, strng=&#x27;python&#x27;) 此外还可可以使用find(name,attrs,string), 此方法只返回第一个匹配的节点 prettify(): 美化html文档内容 tag节点对象前面说过可以通过soup对象的find_all()或find()获取标签节点对象tag, Tag 对象与XML或HTML原生文档中的tag相同: 1234soup = BeautifulSoup(&#x27;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#x27;)tag = soup.btype(tag)# &lt;class &#x27;bs4.element.Tag&#x27;&gt; name:每个tag都有自己的名字,通过 .name 来获取, 如果改变了tag的name,那将影响所有通过当前Beautiful Soup对象生成的HTML文档, 例如 &lt;a&gt;超链接&lt;/a&gt; 的 name 属性就是 &#39;a&#39; Attributes:一个tag可能有很多个属性. tag &lt;b class=&quot;boldest&quot;&gt; 有一个 “class” 的属性,值为 “boldest” . tag的属性的操作方法与字典相同: 12tag[&#x27;class&#x27;]# u&#x27;boldest&#x27; 也可以直接”点”取所有属性, 比如: .attrs : 12tag.attrs# &#123;u&#x27;class&#x27;: u&#x27;boldest&#x27;&#125; tag的属性可以被添加,删除或修改. tag的属性操作方法与字典一样 多值属性: HTML 4定义了一系列可以包含多个值的属性.在HTML5中移除了一些,却增加更多.最常见的多值的属性是 class (一个tag可以有多个CSS的class). 还有一些属性 rel , rev , accept-charset , headers , accesskey . 在Beautiful Soup中多值属性的返回类型是list: 1234567css_soup = BeautifulSoup(&#x27;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#x27;)css_soup.p[&#x27;class&#x27;]# [&quot;body&quot;, &quot;strikeout&quot;]css_soup = BeautifulSoup(&#x27;&lt;p class=&quot;body&quot;&gt;&lt;/p&gt;&#x27;)css_soup.p[&#x27;class&#x27;]# [&quot;body&quot;] string:字符串常被包含在tag内.Beautiful Soup用 NavigableString 类来包装tag中的字符串,想要获取标签对象tal的文本内容,则需要调用tag.get_text() 1234tag.string# u&#x27;Extremely bold&#x27;type(tag.string)# &lt;class &#x27;bs4.element.NavigableString&#x27;&gt; lxml库lxml和BeautifulSoup类似,都是解析库, 支持html/xml文件的内容解析, 效率高,支持XPath解析方式 XPath,全称是XML Path language,是XML路径语言，是一门在XML文档种查找信息的语言。 XPath表达式 XPath 语法 | 菜鸟教程 (runoob.com) 选取节点 表达式 描述 nodename 选取此节点的所有子节点 / 从当前节点选取直接子节点 // 从当前节点选取子孙节点 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 * 通配符，选择所有元素节点与元素名 @* 选取所有属性 在下面的表格中，我们已列出了一些路径表达式以及表达式的结果： 路径表达式 结果 bookstore 选取 bookstore 元素的所有子节点。 /bookstore 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ bookstore/book 选取属于 bookstore 的子元素的所有 book 元素。 //book 选取所有 book 子元素，而不管它们在文档中的位置。 bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 //@lang 选取名为 lang 的所有属性。 谓语谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果： 路径表达式 结果 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()&lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=’eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price&gt;35.00]//title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 通配符XPath 通配符可用来选取未知的 XML 元素。 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果： 路径表达式 结果 /bookstore/* 选取 bookstore 元素的所有子元素。 //* 选取文档中的所有元素。 //title[@*] 选取所有带有属性的 title 元素。 运算符: 运算符 描述 实例 返回值 or 或 age=10 or age=20 如果age等于10或者等于20则返回true反正返回false and 与 age&gt;19 and age&lt;21 如果age等于20则返回true，否则返回false mod 取余 5 mod 2 1 | 取两个节点的集合 //book | //cd 返回所有拥有book和cd元素的节点集合 + 加 5+4 9 - 减 5-4 1 * 乘 5*4 20 div 除法 6 div 3 2 = 等于 age=10 true != 不等于 age!=10 true &lt; 小于 age&lt;10 true &lt;= 小于或等于 age&lt;=10 true &gt; 大于 age&gt;10 true &gt;= 大于或等于 age&gt;=10 true 轴节点 轴名称 结果 ancestor 选取当前节点的所有先辈（父、祖父等）。 ancestor-or-self 选取当前节点的所有先辈（父、祖父等）以及当前节点本身。 attribute 选取当前节点的所有属性。 child 选取当前节点的所有子元素。 descendant 选取当前节点的所有后代元素（子、孙等）。 descendant-or-self 选取当前节点的所有后代元素（子、孙等）以及当前节点本身。 following 选取文档中当前节点的结束标签之后的所有节点。 following-sibling 选取当前节点之后的所有兄弟节点 namespace 选取当前节点的所有命名空间节点。 parent 选取当前节点的父节点。 preceding 选取文档中当前节点的开始标签之前的所有节点。 preceding-sibling 选取当前节点之前的所有同级节点。 self 选取当前节点。 1.引入解析文本html字符串: 1234567891011from lxml import etreetext = &#x27;&#x27;&#x27;html内容...&#x27;&#x27;&#x27;html=etree.HTML(text) #初始化生成一个XPath解析对象result=etree.tostring(html,encoding=&#x27;utf-8&#x27;) #解析对象输出代码,类似是字节,需要解码print(type(html)) # &lt;class &#x27;lxml.etree._Element&#x27;&gt;print(type(result)) # &lt;class &#x27;bytes&#x27;&gt;print(result.decode(&#x27;utf-8&#x27;)) # html内容... html文件: 123456from lxml import etreehtml=etree.parse(&#x27;test.html&#x27;,etree.HTMLParser()) #指定解析器HTMLParser会根据文件修复HTML文件中缺失的如声明信息result=etree.tostring(html) #解析成字节#result=etree.tostringlist(html) #解析成列表print(result) 2.执行xpath()通过xpath()方法,可以通过xpath来对html进行解析 获取节点:获取所有节点和指定的所有节点,返回的是列表类型 12html.xpath(&#x27;//*&#x27;) #//代表获取子孙节点，*代表获取所有html.xpath(&#x27;//li&#x27;) #获取所有子孙节点的li节点,即使获取所有 li标签 我们知道通过连续的/或者//可以查找子节点或子孙节点，那么要查找父节点可以使用..来实现也可以使用parent::来获取父节点。 匹配节点:属性匹配在选取节点的时候，我们还可以用@符号进行属性过滤。比如，这里如果要选取所有class为item-1的li节点，可以这样实现: 1html.xpath(&#x27;//li[@class=&quot;item-1&quot;]&#x27;) 如果某个属性的值有多个时，我们可以使用contains()函数来获取 通过第一种方法没有取到值(匹配属性必须为aaa的)，通过contains（）就能精确匹配到节点了(匹配属性值包含aaa就行) 1234567891011text = &#x27;&#x27;&#x27;&lt;div&gt; &lt;ul&gt; &lt;li class=&quot;aaa item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;第一个&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;bbb item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&#x27;&#x27;&#x27;html.xpath(&#x27;//li[@class=&quot;aaa&quot;]/a&#x27;)html.xpath(&#x27;//li[contains(@class,&quot;aaa&quot;)]/a&#x27;) 另外我们还可能遇到一种情况，那就是根据多个属性确定一个节点，这时就需要同时匹配多个属性，此时可用运用and运算符来连接使用： 12html.xpath(&#x27;//li[@class=&quot;aaa&quot; and @name=&quot;fore&quot;]/a&#x27;)html.xpath(&#x27;//li[contains(@class,&quot;aaa&quot;) and @name=&quot;fore&quot;]/a&#x27;) 文本匹配:在某些情况下, 我们可能不需要属性来匹配,而是通过标签的本文内容来匹配,可以通过contains（）和text()来实现文本匹配 1234# 定位td标签内容中含有&quot;创建机构&quot;字样的标签//td[contains(text(), &quot;创建机构&quot;)]# 匹配td标签内容中含有&quot;创建机构&quot;字样的下一个td标签(兄弟元素)//td[contains(text(), &quot;创建机构&quot;)]/following-sibling::td[1]/text() # 结果:[某某机构] 轴节点获取:XPath提供了很多节点选择方法，包括获取子元素、兄弟元素、父元素、祖先元素等 1234567esult=html.xpath(&#x27;//li[1]/ancestor::*&#x27;) #获取所有祖先节点result1=html.xpath(&#x27;//li[1]/ancestor::div&#x27;) #获取div祖先节点result2=html.xpath(&#x27;//li[1]/attribute::*&#x27;) #获取所有属性值result3=html.xpath(&#x27;//li[1]/child::*&#x27;) #获取所有直接子节点result4=html.xpath(&#x27;//li[1]/descendant::a&#x27;) #获取所有子孙节点的a节点result5=html.xpath(&#x27;//li[1]/following::*&#x27;) #获取当前子节之后的所有节点result6=html.xpath(&#x27;//li[1]/following-sibling::*&#x27;) #获取当前节点的所有同级节点 URL管理器通常, 一般我们会自己编写一个url管理器来将url 进行管理,比如根据已经爬取和未爬取进行状态管理,下面给出了一个通过python的set集合实现的管理器 123456789101112131415161718192021222324252627282930313233343536373839&quot;&quot;&quot;url 管理器: 通过 两个Set 实现 ord_set 存储已经爬取过的 url new_set 存储还未爬取的 url&quot;&quot;&quot;class UrlManage: def __init__(self): self.new_urls = set() self.ord_urls = set() def add_new_url(self, url): if url is None or len(url) == 0: return if url in self.new_urls or url in self.ord_urls: return try: self.new_urls.add(url) except Exception: print(url, &quot; 添加到new_urls失败!&quot;, Exception) def add_new_urls(self, urls): if urls is None or len(urls)==0: return for url in urls: self.add_new_url(url) def get_new_url(self): if self.has_new_urls() == 0: return None try: url = self.new_urls.pop() self.ord_urls.add(url) except Exception: print(url,&quot;获取失败!&quot;, Exception) return url def has_new_urls(self): return len(self.new_urls) 常见问题&amp;反爬策略:1234requests.exceptions.ProxyError:HTTPSConnectionPool(host=‘xxx.xxx.xxx’, port=443):Max retries exceeded with url: xxxxxxx (Caused by ProxyError(‘Cannot connect to proxy.’, NewConnectionError(’&lt;urllib3.connection.HTTPSConnection object at 0x000001EF209B1D30&gt;: Failed to establish a new connection: [WinError 10060] ==尝试关闭本机代理,关闭梯子等== 状态码418:有反爬策略, 携带客户机请求头信息模拟请求即可 123456header = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &quot; &quot;Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.76 &quot; &#125;resp = requests.get(url, headers=header) 案例:实例-爬虫简单基本结构:本例中将演示爬取博客网站首页的所有文章的标题以及对应的连接 1234567891011121314151617181920212223242526import requestsimport refrom bs4 import BeautifulSoupfrom utils import url_managerroot_url = &quot;http://www.crazyant.net&quot;urls = url_manager.UrlManage()urls.add_new_url(root_url)count = 0while urls.has_new_urls(): curr_url = urls.get_new_url() resp = requests.get(url=curr_url) if resp.status_code != 200: print(&quot;error:status_code!=200!&quot;,curr_url) continue resp.encoding = &quot;utf-8&quot; patten = r&quot;http://www.crazyant.net/\\d+.html&quot; blog_links = re.findall(pattern=patten,string=resp.text) if len(blog_links) != 0: urls.add_new_urls(blog_links) soup = BeautifulSoup(resp.text,&quot;html.parser&quot;) count += 1 print(&quot;success: 标题:%s\\t连接:%s , 计数:%d&quot;%(soup.title.string,curr_url,count)) 真实网站分页数据爬取爬取豆瓣电影Top250 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import timeimport requestsfrom bs4 import BeautifulSoupdef parse_html(html_doc): &quot;&quot;&quot; 输入一个html文档字符串,解析页面数据 @return: 包含所所有解析数据的队列,队列元素是一个由电影数据构成的字典 &quot;&quot;&quot; data_list = [] root_soup = BeautifulSoup(html_doc, &quot;html.parser&quot;) html_items = root_soup.find_all(&quot;div&quot;, class_=&quot;item&quot;) for item in html_items: soup = BeautifulSoup(str(item), &quot;html.parser&quot;) rank = soup.em.string play_link = soup.a[&quot;href&quot;] name = soup.find(&quot;span&quot;, class_=&quot;title&quot;).string grade = soup.find(&quot;span&quot;, class_=&quot;rating_num&quot;).string data_list.append(&#123; &quot;rank&quot;: rank, &quot;name&quot;: name, &quot;grade&quot;: grade, &quot;play_link&quot;: play_link &#125;) return data_listif __name__ == &quot;__main__&quot;: top250_movies_data = [] # 创建分页索引列表 [0,25,50...] pages_indexs = list(range(0, 250, 25)) header = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &quot; &quot;Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.76 &quot; &#125; for page in pages_indexs: url = f&quot;https://movie.douban.com/top250?start=&#123;page&#125;&amp;filter=&quot; time.sleep(0.2) resp = requests.get(url, headers=header) if resp.status_code != 200: print(url, &quot;请求异常:&quot;, resp.status_code) raise Exception else: page_data = parse_html(resp.text) top250_movies_data += page_data for movie in top250_movies_data: time.sleep(0.4) print(movie) 爬取ajax数据本案例中, 将通过2345天气王的历史城市天气数据接口,来爬取天气数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import timeimport requestsfrom bs4 import BeautifulSoupdef html_filter(html_doc): &#x27;&#x27;&#x27; 将html字符串解析并提取数据, 每一天的数据用字典保存, @return:返回一个月每天天气数据的字典列表 &#x27;&#x27;&#x27; month_weather = [] soup = BeautifulSoup(html_doc, &quot;html.parser&quot;) data_list = soup.find_all(&quot;td&quot;) for i in range(0, len(data_list), 6): tempList = data_list[i:i + 7] day_data = &#123; &quot;日期&quot;: tempList[0].string, &quot;最高气温&quot;: tempList[1].string, &quot;最低气温&quot;: tempList[2].string, &quot;天气&quot;: tempList[3].string, &quot;风向&quot;: tempList[4].string, # &quot;空气质量&quot;: tempList[5].contents[0].string &#125; month_weather.append(day_data) return month_weatherdef get_weather(year, month): &#x27;&#x27;&#x27; 根据参数: 年份,月份,获取当月的历史天气数据 @return: 返回一个字典列表,每个字典元素是一天的数据信息 &#x27;&#x27;&#x27; url = &quot;https://tianqi.2345.com/Pc/GetHistory&quot; parm = &#123; &quot;areaInfo[areaId]&quot;: 60623, # 城市编号, 此处是 以永福为例 &quot;areaInfo[areaType]&quot;: 2, &quot;date[year]&quot;: year, &quot;date[month]&quot;: month &#125; resp = requests.get(url, params=parm) if resp.status_code != 200: print(&quot;error:请求失败&quot;, url, resp.status_code) raise Exception resp.encoding = &quot;utf-8&quot; data = resp.json()[&quot;data&quot;] return html_filter(data)if __name__ == &quot;__main__&quot;: for year in range(2018, 2023): for month in range(1, 13): print(&quot;\\n正在爬取:%s年-%s月的天气数据...&quot; % (year, month)) time.sleep(1.5) for t in get_weather(year, month): print(t) 爬取文件,下载文件本案例将爬取图片网站的图片, 并且将爬取到的图片进行下载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsimport refrom bs4 import BeautifulSoupdef html_parser(html_doc): &quot;&quot;&quot; 解析html字符串,返回对应的美女图片的src @param html_doc: 需要解析的html @return: 返回所有美女图片的src列表 &quot;&quot;&quot; soup = BeautifulSoup(resp.text, &quot;html.parser&quot;) ul_dom = soup.find(&quot;ul&quot;, class_=&quot;clearfix&quot;) imgs_dom = ul_dom.find_all(&quot;img&quot;) imgs_src = [] for img in imgs_dom: imgs_src.append(img[&quot;src&quot;]) # img_url = f&quot;https://pic.netbian.com&#123;img_src&#125;&quot; return imgs_srcdef down_imgs(imgs_src): &quot;&quot;&quot; 通过图片网络地址下载图片到本地 @param imgs_src: 图片网络地址 &quot;&quot;&quot; for img_src in imgs_src: img_url = f&quot;https://pic.netbian.com&#123;img_src&#125;&quot; res = requests.get(img_url) if res.status_code != 200: print(&quot;error:&quot;, img_url, &quot;状态码:&quot;, res.status_code) continue regx = r&quot;(\\d+)-(\\w+.jpg)$&quot; string = re.search(regx, img_src) if string is None: print(img_src, &quot;匹配失败&quot;) file_name = string.group() # 以二进制的方式写入 请求图片url 响应的二进制流 with open(f&quot;woman_imgs/&#123;file_name&#125;&quot;, &quot;wb&quot;) as file: try: file.write(res.content) except FileExistsError as e: print(file_name, &quot;写入失败!&quot;) else: print(file_name, &quot;下载成功...&quot;)if __name__ == &quot;__main__&quot;: url = &quot;https://pic.netbian.com/4kmeinv/&quot; for i in range(1, 5): if i != 1: url = f&quot;https://pic.netbian.com/4kmeinv/index_&#123;i&#125;.html&quot; resp = requests.get(url) if resp.status_code != 200: print(url, &quot;请求异常&quot;, resp.status_code) raise Exception resp.encoding = &quot;gbk&quot; print(&quot;\\n====正在爬取第%d页的美女,嘿嘿嘿---&quot; % i) imgs_src = html_parser(resp.text) down_imgs(imgs_src) 批量填写表单数据,发送请求本案例, 通过从文件中批量读取一些名字, 作为请求参数, 通过POST请求发送进行姓名评分获取姓名评分数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import reimport requestsfrom bs4 import BeautifulSoupdef get_name_score(xing, ming): &quot;&quot;&quot; 根据输入的姓名,返回评分,和点评信息 @param xing: @param ming: @return: 字典, 包含评分和点评信息 &quot;&quot;&quot; url = &quot;http://m.life.httpcn.com/m/xingming/&quot; data = &#123; &quot;act&quot;: &quot;submit&quot;, &quot;xing&quot;: xing, &quot;ming&quot;: ming, &quot;sex&quot;: 1, &quot;xiyong&quot;: 0, &quot;isbz&quot;: 0, &#125; try: resp = requests.post(url, data=data) if resp.status_code != 200: print(&quot;请求失败:&quot;, resp.status_code) except Exception as e: print(&quot;请求出现异常:&quot;, e) else: resp.encoding = &quot;utf-8&quot; soup = BeautifulSoup(resp.text, &quot;html.parser&quot;) score = soup.find(&quot;div&quot;, class_=&quot;progress-bar&quot;).get_text() msg = soup.find(string=re.compile(r&quot;.*点评.+&quot;)).get_text() return &#123; &quot;score&quot;: score, &quot;msg&quot;: msg &#125; return Nonewith open(&quot;names_girls_double.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as finput: for line in finput.readlines(): xing = &quot;贾&quot; ming = line.rstrip(&quot;\\n&quot;) res = get_name_score(xing, ming) print(&quot;%s 评分:%s, %s\\n&quot; % (xing+ming, res.get(&quot;score&quot;), res.get(&quot;msg&quot;))) names_girls_double.txt 1234567891011121314雅惠又琴中颖胜霞施诗盼夏明煦春兰晴瑶家卫欣冉忻莹晨文.... 模拟登陆,爬取登陆状态信息本案例将通过携带cookie和 token 来实现模拟人工登陆, 随后获取登陆后才能查看的 “职业”板块评论信息 12345678910111213141516171819202122232425import requestsurl = &quot;https://maimai.cn/sdk/web/content/get_list&quot;params = &#123; &quot;api&quot;: &quot;gossip/v3/square&quot;, &quot;u&quot;: &quot;231728152&quot;, &quot;page&quot;: 1, &quot;before_id&quot;: 0,&#125;headers = &#123; &quot;cookie&quot;: &quot;seid=s1674273265641==...&quot; , &quot;x-csrf-token&quot;: &quot;qlgHEtoipBSaVxw...&quot;, # &quot;referer&quot;: &quot;https://maimai.cn/gossip_list&quot;, # 防盗链,对登陆没影响 # &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.55&quot;&#125;# 登陆主要是要携带 cookie 或者 tokenresp = requests.get(url, params=params, headers=headers)print(resp.status_code)data = resp.json()for obj in data[&quot;list&quot;]: print(obj[&quot;text&quot;], end=&quot;\\n====\\n&quot;) 定位请求程序代码,深入分析有些请求的参数并不是直接传递, 而是通过转换成json字符串进行传递,如下将通过爬取博客园分页文章来作为示例: 分析请求接口和参数: 参数: 编写测试代码: 1234567891011121314url = &quot;https://www.cnblogs.com/AggSite/AggSitePostList&quot;data = &#123; &quot;CategoryType&quot;: &quot;SiteHome&quot;, &quot;ParentCategoryId&quot;: 0, &quot;CategoryId&quot;: 808, &quot;PageIndex&quot;: 3, &quot;TotalPostCount&quot;: 4000, &quot;ItemListActionName&quot;: &quot;AggSitePostList&quot;&#125;resp = requests.post(url, data=data)print(resp.status_code)print(resp.text) 结果发现状态码为415, 可能是请求头的原因, 加上请求头,参考: HTTP响应的状态码415解决 1234567# 如下是经过逐步筛查发现有用的请求头headers = &#123; &quot;content-type&quot;: &quot;application/json; charset=UTF-8&quot;, &quot;referer&quot;: &quot;https://www.cnblogs.com/&quot;, &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.55&quot;, &quot;x-requested-with&quot;: &quot;XMLHttpRequest&quot;&#125; 状态码变成了400, 这个原因是参数与服务器要求的参考不一样,例如: 参数名名称不一样,或后端要求json字符串,而前端传递了一个对象 ==我们检查发起请求的程序代码:== 我们点击loadPostList()进入分析: 最后, 改进程序,将参数也转换成json字符串, 就可以获取成功了 123456789101112131415161718192021import jsonimport requestsurl = &quot;https://www.cnblogs.com/AggSite/AggSitePostList&quot;data = &#123; &quot;CategoryType&quot;: &quot;SiteHome&quot;, &quot;ParentCategoryId&quot;: 0, &quot;CategoryId&quot;: 808, &quot;PageIndex&quot;: 3, &quot;TotalPostCount&quot;: 4000, &quot;ItemListActionName&quot;: &quot;AggSitePostList&quot;&#125;headers = &#123; &quot;content-type&quot;: &quot;application/json; charset=UTF-8&quot;,&#125;resp = requests.post(url, data=json.dumps(data), headers=headers)print(resp.status_code)print(resp.text) 爬虫框架Scrapy入门Scrapy是基于Python的非常流行的网络爬虫框架,用来抓取web站点并从页面总提取结构化数据, 结构如下: 其流程可以描述如下： 爬虫中起始的url构造成request对象–&gt;爬虫中间件–&gt;引擎–&gt;调度器 调度器把request–&gt;引擎–&gt;下载中间件—&gt;下载器 下载器发送请求，获取response响应—-&gt;下载中间件—-&gt;引擎—&gt;爬虫中间件—&gt;爬虫 爬虫提取url地址，组装成request对象—-&gt;爬虫中间件—&gt;引擎—&gt;调度器，重复步骤2 爬虫提取数据—&gt;引擎—&gt;管道处理和保存数据 scrapy的三个内置对象: request请求对象：由url method post_data headers等构成 response响应对象：由url body status headers等构成 item数据对象：本质是个字典 每个模块的具体作用: 自动化Selenium-浏览器自动化 中文文档:https://python-selenium-zh.readthedocs.io/zh_CN/latest/ Selenium 是一个可以模拟浏览器行为的第三方库, 通常用于自动化测试和网络爬虫,Selenium Python提供了一个很方便的接口来驱动 Selenium WebDriver 工作原理: 从上图可以看出： 我们写的自动化程序 需要使用 客户端库。我们程序的自动化请求都是通过这个库里面的编程接口发送给浏览器。 比如，我们要模拟用户点击界面按钮， 自动化程序里面就应该 调用客户端库相应的函数， 就会发送 点击元素 的请求给 下方的 浏览器驱动。 然后，浏览器驱动再转发这个请求给浏览器。 这个自动化程序发送给浏览器驱动的请求 是HTTP请求。 Selenium组织提供了多种编程语言的Selenium客户端库， 包括 java，python，js， ruby等，方便不同编程语言的开发者使用。我们只需要安装好客户端库，调用这些库，就可以发出自动化请求给浏览器咯。 浏览器驱动 也是一个独立的程序，是由浏览器厂商提供的， 不同的浏览器需要不同的浏览器驱动。 比如 Chrome浏览器和 火狐浏览器有 各自不同的驱动程序。浏览器驱动接收到我们的自动化程序发送的界面操作请求后，会转发请求给浏览器， 让浏览器去执行对应的自动化操作。 浏览器执行完操作后，会将自动化的结果返回给浏览器驱动， 浏览器驱动再通过HTTP响应的消息返回给我们的自动化程序的客户端库。自动化程序的客户端库 接收到响应后，将结果转化为 数据对象 返回给 我们的代码。 安装1pip install Selenium 注意: 我们不仅需要安装Selenium, 还需要安装浏览器驱动 浏览器驱动 是和 浏览器对应的。 不同的浏览器 需要选择不同的浏览器驱动。目前主流的浏览器中，谷歌 Chrome 浏览器对 Selenium自动化的支持更加成熟一些。推荐大家使用 Chrome浏览器 。 驱动版本尽量和本地安装的浏览器版本相同或接近 谷歌浏览器驱动下载地址:https://chromedriver.storage.googleapis.com/index.html 下载好之后解压, 也可以下载Edge浏览器驱动 Microsoft Edge WebDriver - Microsoft Edge Developer 快速入门随后编写如下代码将会自动开打对应浏览器并且跳转至百度 1234567from selenium import webdriverfrom selenium.webdriver.chrome.service import Service# # 创建 WebDriver 对象，指明使用浏览器驱动wd = webdriver.Edge(service=Service(r&#x27;E:\\Code\\python\\自动化与数据处理\\edgedriver_win64\\msedgedriver.exe&#x27;))# # 调用WebDriver 对象的get方法 可以让浏览器打开指定网址wd.get(&#x27;https://www.baidu.com&#x27;) 通过上述例子可以发现, 我们需要指定驱动程序的路径, 但我们可以将驱动程序所在目录添加到系统环境变量Path中,就不再需要指定路径 12wd = webdriver.Edge()wd.get(&#x27;https://www.baidu.com&#x27;) 选择元素根据html的id属性值选择元素: 1234567891011from selenium import webdriverfrom selenium.webdriver.chrome.service import Servicefrom selenium.webdriver.common.by import Bywd = webdriver.Edge()wd.get(&#x27;https://www.baidu.com&#x27;)# 百度首页的搜索框 id 属性值为 kwelement = wd.find_element(By.ID, &quot;kw&quot;)# 在浏览器输入 王昭君并且回车element.send_keys(&quot;王昭君&quot;)input() WebElement对象浏览器 找到id为kw的元素后，将结果通过 浏览器驱动 返回给 自动化程序， 所以 find_element 方法会 返回一个 WebElement 类型的对象。我们通过这个WebElement对象，就可以操控对应的界面元素。 调用这个对象的 send_keys() 方法就可以在对应的元素中输入字符串， 调用这个对象的 click()方法就可以 点击 该元素。 通过WebElement对象的text属性可以获取标签的文本内容 1234wd = webdriver.Edge()wd.get(&#x27;https://cdn2.byhy.net/files/selenium/sample1.html&#x27;)element = wd.find_element(By.TAG_NAME, &quot;span&quot;)print(element.text) 选择元素方式:此外,我们还有很多方式选择元素: 根据标签名选择元素: 1wd.find_element(By.TAG_NAME, &#x27;input&#x27;).send_keys(&#x27;sdfsdf&#x27;) 根据class属性值选择元素: 1wd.find_element(By.CLASS_NAME, &#x27;class属性值&#x27;) 也可以使用CSS选择器来定位: 1wd.find_element(By.CSS_SELECTOR,&#x27;button[type=submit]&#x27;) 还可以根据Xpath来定位: 1wd.find_element(By.XPATH,&quot;XPath表达式&quot;) 选择多个元素与选择单个元素类似, 使用find_elements() , 注意element后面多了个s ind_elements 返回的是找到的符合条件的 所有 元素 (这里有3个元素)， 放在一个 列表 中返回。而如果我们使用 wd.find_element() (注意少了一个s) 方法， 就只会返回第一个元素。 1234wd.get(&#x27;https://cdn2.byhy.net/files/selenium/sample1.html&#x27;)elements = wd.find_elements(By.TAG_NAME, &quot;span&quot;)for element in elements: print(element.text) 嵌套选择WebElement对象同WebDriver对象也可以调用 find_elements(), find_element() 之类的方法来选择自己的子孙元素 WebDriver 对象选择元素的范围是整个 web页面(即使整个html标签的内容) WebElement 对象选择元素的范围是该元素的内部。 轮询选择元素在我们进行网页操作的时候， 有的元素内容不是可以立即出现的， 可能会等待一段时间。(例如我们点击查询按钮后需要操作查询结果,但由于网络原因查询结果可能会加载比较慢,而我们代码就找不到查询结果) 即: 我们的代码执行的速度比 网站响应的速度 快。网站还没有来得及 返回搜索结果，我们就执行了操作搜索结果的代码 有两种解决方案: 一种是通过time.sleep()暂停当前线程来等待 (不推荐) Selenium提供了一个更合理的解决方案: 当发现元素没有找到的时候， 并不立即返回 找不到元素的错误。而是周期性（每隔半秒钟）重新寻找该元素，直到该元素找到，或者超出指定最大等待时长，这时才 抛出异常（如果是 find_elements 之类的方法， 则是返回空列表）。 ==Selenium 的 Webdriver 对象 有个方法叫 implicitly_wait() ，可以称之为 隐式等待 ，或者 全局等待 。该方法接受一个参数， 用来指定 最大等待时长。== 1wd.implicitly_wait(second) 那么后续所有的 find_element 或者 find_elements 之类的方法调用 都会采用上面的策略： 如果找不到元素， 每隔 半秒钟 再去界面上查看一次， 直到找到该元素， 或者 过了10秒 最大时长。 技巧:冻结界面(debugger)有些网站上面的元素， 我们鼠标放在上面，会动态弹出一些内容。比如上述例子，百度首页的右上角，有个 更多产品 选项，如下图所示: 如果我们把鼠标放在上边，就会显示一些图标。如果我们要用 selenium 自动化 点击某个图标，就需要 F12 查看这个元素的特征。但是 当我们的鼠标从某个图标 移开， 这个 栏目就整个消失了， 就没法 查看 其对应的 HTML。 这是我们可以通过执行 js 代码的debugger来卡住页面达到冻结页面的效果, debug状态有个特性， 界面被冻住， 不管我们怎么点击界面都不会触发事件。这时候我们就可以通过开发者工具来查看隐藏元素特征了 实例: 其实,我们也可以不获取隐藏元素的特征,而是继续操作鼠标下移点击选择进行操作也可. 操作元素:选择到元素之后，我们的代码会返回元素对应的 WebElement对象，通过这个对象，我们就可以 操控 元素了。 操控元素通常包括 点击元素 在元素中输入字符串，通常是对输入框这样的元素 获取元素包含的信息，比如文本内容，元素的属性 关闭浏览器窗口可以调用WebDriver对象的 quit 方法 点击:点击元素 非常简单，就是调用元素WebElement对象的 click()方法。 当我们调用 WebElement 对象的 click 方法去点击 元素的时候， 浏览器接收到自动化命令，点击的是该元素的 中心点 位置 。 输入框输入字符串 也非常简单，就是调用元素WebElement对象的send_keys()方法。 如果我们要 把输入框中已经有的内容清除掉，可以使用WebElement对象的clear()方法 获取元素信息:获取文本(隐藏)内容:通过WebElement对象的 text 属性，可以获取元素 展示在界面上的 文本内容。但是，有时候，元素的文本内容没有展示在界面上，或者没有完全完全展示在界面上。 这时，用WebElement对象的text属性，获取文本内容，就会有问题。出现这种情况，可以尝试使用 element.get_attribute(&#39;innerText&#39;) ，或者 element.get_attribute(&#39;textContent&#39;) 使用 innerText 和 textContent 的区别是，前者只显示元素可见文本内容，后者显示所有内容（包括display属性为none的部分） 注: get_attribute 调用本质上就是调用 HTMLElement 对像的属性, 比如 element.get_attribute(‘value’) 等价于js里面的 element.value element.get_attribute(‘innerText’) 等价于js里面的 element.innerText 特殊的: 获取网页的标题内容, 即&lt;title&gt;&lt;/title&gt;标签的内容,要通过wb对象的title属性 123wd = webdriver.Edge()wd.get(&#x27;https://www.baidu.com&#x27;)title = wd.title 获取元素属性通过WebElement对象的 get_attribute 方法来获取元素的属性值 , 比如要获取元素属性class的值，就可以使用 element.get_attribute(&#39;class&#39;) 获取html文本要获取整个元素对应的HTML文本内容，可以使用 element.get_attribute(&#39;outerHTML&#39;) 如果，只是想获取某个元素 内部 的HTML文本内容，可以使用 element.get_attribute(&#39;innerHTML&#39;) 获取输入框里面的文字对于input输入框的元素，要获取里面的输入文本，用text属性是不行的，这时可以使用 element.get_attribute(&#39;value&#39;) frame切换/窗口切换切换frame窗口在html语法中，frame 元素 或者iframe元素的内部 会包含一个 被嵌入的 另一份html文档。这个 iframe 元素非常的特殊, 在我们使用selenium打开一个网页是， 我们的操作范围默认是当前的 html ， 并不包含被嵌入的html文档里面的内容。==意味着有时候通过当前的html范围并不能选择到frame标签内部的元素== 如果我们需要选择frame标签内部的元素, 则通过wd.switch_to.frame(frame_reference)方法进行切换 其中， frame_reference 参数可以是 frame 元素的属性 name 或者 ID 。例如: 1234# 切换到 id属性为frame1 的 frame标签窗口wd.switch_to.frame(&#x27;frame1&#x27;)# 切换到name属性值 ‘innerFrame’ 的标签窗口wd.switch_to.frame(&#x27;innerFrame&#x27;) 需要注意的是: 如果已经切换到某个iframe里面进行操作，后续选择和操作界面元素 就都是在这个frame里面进行的。 如果需要切换回原来的主html(最外部的html称之为主html) , 可以使用如下方法: 1wd.switch_to.default_content() 实例: 123456789101112131415161718wd = webdriver.Edge()wd.get(&#x27;https://cdn2.byhy.net/files/selenium/sample2.html&#x27;)# 先根据name属性值 &#x27;innerFrame&#x27;，切换到iframe中wd.switch_to.frame(&#x27;innerFrame&#x27;)# 根据 class name 选择元素，返回的是 一个列表elements = wd.find_elements(By.CLASS_NAME, &#x27;plant&#x27;)for element in elements: print(element.text)# 切换回 最外部的 HTML 中wd.switch_to.default_content()# 然后再 选择操作 外部的 HTML 中 的元素wd.find_element(By.ID,&#x27;outerbutton&#x27;).click()time.sleep(5)# 关闭浏览器当前窗口wd.quit() 切换窗口(标签页)在网页上操作的时候，我们经常遇到，点击一个链接 或者 按钮，就会打开一个 窗口(标签页) 。 用Selenium写自动化程序时在当前窗口里点击一个连接打开了一个新的窗口, WebDriver对象默认对应的还是老窗口, 之后的操作也还是在老窗口进行 要到新的窗口里面操作可以使用Webdriver对象的switch_to属性的 window()方法: 1wd.switch_to.window(handle) WebDriver对象有window_handles 属性，这是一个列表对象， 里面包括了当前浏览器里面**所有的窗口句柄(窗口句柄也就是窗口实例的标识,可以当成窗口id)**。 我们可以通过遍历wd对象的所有窗口句柄, 找到想要操作的句柄来进行操作: 1234567for handle in wd.window_handles: # 先切换到该窗口 wd.switch_to.window(handle) # 得到该窗口的标题栏字符串，判断是不是我们要操作的那个窗口 if &#x27;Bing&#x27; in wd.title: # 如果是，那么这时候WebDriver对象就是对应的该该窗口，正好，跳出循环， break **如果需要切换回最开始的窗口, 可以参考如下做法:**使用临时遍历保存当前窗口的句柄 1234567# mainWindow变量保存当前窗口的句柄mainWindow = wd.current_window_handle# 切换窗口以及后续操作...#通过前面保存的老窗口的句柄，自己切换到老窗口wd.switch_to.window(mainWindow) 关闭窗口: wd.close(): 关闭当前窗口 wd.quit(): 退出驱动并关闭所有关联的窗口 复杂元素操作-选择框html的input标签有三种选择框, 分别是单选框, 复选框, 下拉框, 根据不同的选择框我们要执行不同的操作 radio 单选框radio框选择选项，直接用WebElement的click()方法，模拟用户点击就可以了。 实例: 12345678910wb = webdriver.Edge()wb.get(&quot;https://cdn2.byhy.net/files/selenium/test2.html&quot;)wb.implicitly_wait(10)# 获取默认勾选的元素element = wb.find_element(By.CSS_SELECTOR, &quot;#s_radio input[name=&#x27;teacher&#x27;]:checked&quot;)print(&quot;当前选择的是:&quot;, element.get_attribute(&quot;value&quot;))time.sleep(2)# 选择其他选项wb.find_element(By.CSS_SELECTOR, &quot;#s_radio input[value=&#x27;小江老师&#x27;]&quot;).click() 其中 #s_radio input[name=&quot;teacher&quot;]:checked 里面的 :checked 是CSS伪类选择 , 表示选择 checked 状态的元素，对 radio 和 checkbox 类型的input有效 checkbox 多选框对checkbox进行选择，也是直接用 WebElement 的 click 方法，模拟用户点击选择。 需要注意的是，要选中checkbox的一个选项，必须 先获取当前该复选框的状态 ，如果该选项已经勾选了，就不能再点击。否则反而会取消选择。 所以在处理此类选择框时, 通常先把经选中的选项全部点击一下, 确保都是未选状态, 随后在进行勾选 12345678910# 先把 已经选中的选项全部点击一下elements = wd.find_elements(By.CSS_SELECTOR, &#x27;#s_checkbox input[name=&quot;teacher&quot;]:checked&#x27;)for element in elements: element.click()# 再点击 小雷老师wd.find_element(By.CSS_SELECTOR, &quot;#s_checkbox input[value=&#x27;小雷老师&#x27;]&quot;).click() select 下拉框radio框及checkbox框都是input元素, 只是里面的type不同而已。select框则是一个新的select标签 对于Select 选择框， Selenium 专门提供了一个 Select类 进行操作。Select类 提供了如下的方法: select_by_value() 比如，下面的HTML， 1&lt;option value=&quot;foo&quot;&gt;Bar&lt;/option&gt; 就可以根据 foo 这个值选择该选项， 1s.select_by_value(&#x27;foo&#x27;) select_by_index() 根据选项的 次序 （从1开始），选择元素 select_by_visible_text() 根据选项的 可见文本 ，选择元素。比如，下面的HTML， 1&lt;option value=&quot;foo&quot;&gt;Bar&lt;/option&gt; 就可以根据 Bar 这个内容，选择该选项 1s.select_by_visible_text(&#x27;Bar&#x27;) deselect_by_value() 根据选项的value属性值， 去除 选中元素 deselect_by_index() 根据选项的次序(Selenium4索引从0开始,以前从1 开始)，去除 选中元素 deselect_by_visible_text() 根据选项的可见文本，去除 选中元素 deselect_all() 去除 选中所有元素 实例: 12345678# 导入Select类from selenium.webdriver.support.ui import Select# 创建Select对象select = Select(wd.find_element(By.ID, &quot;ss_single&quot;))# 通过 Select 对象选中小雷老师select.select_by_visible_text(&quot;小雷老师&quot;) **补充:**对于select标签实现的单选框和多选框, 均适用上述方法 元素更多操作之前我们对web元素做的操作主要是：选择元素，然后 点击元素 或者 输入 字符串。显然,这些操作已经能满足大部分需求, 但是有些时候, 我们还需要一些其他的操作: 比如：比如 鼠标右键点击、双击、移动鼠标到某个元素、鼠标拖拽等。 这些操作，可以通过 Selenium 提供的 ActionChains 类来实现。ActionChains 类 里面提供了 一些特殊的动作的模拟，我们可以通过 ActionChains 类的代码查看到，如下所示 我们以移动鼠标到某个元素为例。 百度首页的右上角，有个 更多产品 选项，如下图所示 如果我们把鼠标放在上边，就会显示一些图标。下面我们将使用使用 ActionChains 来 模拟鼠标移动 操作的代码如下： 1234567wb = webdriver.Edge()wb.get(&quot;https://www.baidu.com/&quot;)wb.implicitly_wait(5)ac = ActionChains(wb)ac.move_to_element(wb.find_element(By.CSS_SELECTOR, &quot;a[name=&#x27;tj_briicon&#x27;]&quot;))# 注意, 在给ActionChains对象设定好操作动作后, 调用perform()方法才会执行ac.perform() 更多技巧上传文件:有时候，网站操作需要上传文件, 比如，著名的在线图片压缩网站： https://tinypng.com/ 注:通常，网站页面上传文件的功能，是通过 type 属性 为 file 的 HTML input 元素实现的。 使用selenium自动化上传文件，我们只需要定位到该input元素，然后通过 send_keys() 方法传入要上传的文件路径即可。 示例: 12345# 先定位到上传文件的 input 元素ele = wd.find_element(By.CSS_SELECTOR, &#x27;input[type=file]&#x27;)# 再调用 WebElement 对象的 send_keys 方法ele.send_keys(r&#x27;h:\\g02.png&#x27;) 如果需要上传多个文件，可以多次调用send_keys，如下 123ele = wd.find_element(By.CSS_SELECTOR, &#x27;input[type=file]&#x27;)ele.send_keys(r&#x27;h:\\g01.png&#x27;)ele.send_keys(r&#x27;h:\\g02.png&#x27;) 但是，有的网页上传，是没有 file 类型 的 input 元素的。如果是Windows上的自动化，可以采用 Windows 平台专用的方法： 需要确保 pywin32 已经安装: 1pip install pypiwin32 示例: 12345678910111213# 找到点击上传的元素，点击driver.find_element(By.CSS_SELECTOR, &#x27;.dropzone&#x27;).click()sleep(2) # 等待上传选择文件对话框打开# 直接发送键盘消息给 当前应用程序，# 前提是浏览器必须是当前应用import win32com.clientshell = win32com.client.Dispatch(&quot;WScript.Shell&quot;)# 输入文件路径，最后的&#x27;\\n&#x27;，表示回车确定，也可能时 &#x27;\\r&#x27; 或者 &#x27;\\r\\n&#x27;shell.Sendkeys(r&quot;h:\\a2.png&quot; + &#x27;\\n&#x27;)sleep(1) 截屏有的时候，我们需要把浏览器屏幕内容保存为图片文件。比如，做自动化测试时，一个测试用例检查点发现错误，我们可以截屏为文件，以便测试结束时进行人工核查。 12345678from selenium import webdriverdriver = webdriver.Edge()# 打开网站driver.get(&#x27;https://www.baidu.com/&#x27;)# 截屏保存为图片文件driver.get_screenshot_as_file(&#x27;1.png&#x27;) 窗口大小有时候我们需要获取窗口的属性和相应的信息，并对窗口进行控制 (注: 此处窗口指的是浏览器的一个标签页) 获取窗口大小 1WebDriver.get_window_size() 改变窗口大小 1WebDriver.set_window_size(x, y) 获取网页URL及标题12345678910driver = webdriver.Edge()# 打开网站driver.get(&#x27;https://www.163.com&#x27;)# 获取网站标题栏文本print(driver.title) # 获取网站地址栏文本print(driver.current_url) 手机模式我们可以通过 desired_capabilities 参数，指定以手机模式打开chrome浏览器( Edge同理) 123456789mobile_emulation = &#123; &quot;deviceName&quot;: &quot;Nexus 5&quot; &#125;chrome_options = webdriver.ChromeOptions()chrome_options.add_experimental_option(&quot;mobileEmulation&quot;, mobile_emulation)driver = webdriver.Chrome( desired_capabilities = chrome_options.to_capabilities())driver.get(&#x27;http://www.baidu.com&#x27;) 执行JavaScript我们可以通过WebDriver对象的execute_script()方法让浏览器运行一段javascript代码，并且得到返回值，如下: 1234567891011# 直接执行 javascript，里面可以直接用return返回我们需要的数据nextPageButtonDisabled = driver.execute_script( &#x27;&#x27;&#x27; ele = document.querySelector(&#x27;.soupager &gt; button:last-of-type&#x27;); return ele.getAttribute(&#x27;disabled&#x27;) &#x27;&#x27;&#x27;)# 返回的数据转化为Python中的数据对象进行后续处理if nextPageButtonDisabled == &#x27;disabled&#x27;: # 是最后一页 return Trueelse: # 不是最后一页 return False 有时，自动化的网页内容很长，或者很宽，超过一屏显示，如果我们要点击的元素不在窗口可见区内，新版本的selenium协议， 浏览器发现要操作（比如点击操作）的元素，不在可见区内，往往会操作失败，出现类似下面的提示 123element click intercepted: Element &lt;span&gt;这里是元素html&lt;/span&gt; is not clickable at point (119, 10). Other element would receive the click: &lt;div&gt;...&lt;/div&gt; 这时，可以调用 execute_script 直接执行js代码，让该元素出现在窗口可见区正中 1driver.execute_script(&quot;arguments[0].scrollIntoView(&#123;block:&#x27;center&#x27;,inline:&#x27;center&#x27;&#125;)&quot;, job) 其中 arguments[0] 就指代了后面的第一个参数 job 对应的js对象， js对象的 scrollIntoView 方法，就是让元素滚动到可见部分 block:&#39;center&#39; 指定垂直方向居中 inline:&#39;center&#39; 指定水平方向居中 浏览器对话框处理有的时候，我们经常会在操作界面的时候，出现一些弹出的对话框。这些对话框是浏览器本身自带的,不是html的dom元素, 弹出的对话框有三种类型，分别是 Alert（警告信息）、confirm（确认信息）和prompt（提示输入） 比如这个网站: 请点击打开这个网址 按钮操作:我们可以使用wd对象的switch_to.alert属性的如下的一些方法来对其进行操作处理 1WebDriver.switch_to.alert.accept() 相当于三种框点击确定按钮 1WebDriver.switch_to.alert.dismiss() 相当于confirm框和prompt框的取消按钮 1WebDriver.switch_to.alert.send_keys(&quot;输入内容&quot;) 相当于prompt框输入内容 获取对话框内容:1WebDriver.switch_to.alert.text Appium-手机自动化 appium selenium区别 官方文档: 简介 - Appium 简介Appium 是一个移动 App （手机应用）自动化工具。Appium 自动化方案的特点： 开源免费 支持多个平台 iOS （苹果）、安卓 App 的自动化都支持。 支持多种类型的自动化 支持 苹果、安卓 应用 原生界面 的自动化 支持 应用 内嵌 WebView 的自动化 支持 手机浏览器 中的 web网站自动化 支持 flutter 应用的自动化 支持多种编程语言 像 Selenium 一样， 可以用多种编程语言 调用它 开发自动化程序 工作原理:简单来说appium充当一个中间服务器的功能，接收来自我们代码的请求，然后发送到手机上进行执行。 appium是基于webdriver协议添加对移动设备自动化api扩展而成的，所以具有和webdriver一样的特性, webdriver是基于http协议的，第一连接会建立一个session会话，并通过post发送一个json告知服务端相关测试信息 对于android来说，4.2以后是基于uiautomator框架实现查找注入事件的，4.2以前则是instrumentation框架的，并封装成一个叫Selendroid提供服务 Appium启动时会创建一个http：127.0.0.1:4723/wd/hub服务端（相当于一个中转站），脚本会告诉服务器我要做什么，服务端再去跟设备打交道，服务端完成了脚本交给他的任务之后 原理图: 和Selenium 原理图很像。因为 Appium自动化架构就是借鉴的Selenium。大家看看这幅图， 包含了 3个主体部分 ： 自动化程序、Appium Server、移动设备 自动化程序 自动化程序是由我们来开发的，实现具体的 手机自动化 功能。 要发出具体的指令控制手机，也需要使用 客户端库。 和Selenium一样，Appium 组织 也提供了多种编程语言的客户端库，包括 java，python，js， ruby等，方便不同编程语言的开发者使用。 我们需要安装好客户端库，调用这些库，就可以发出自动化指令给手机。 Appium Server Appium Server 是 Appium 组织开发的程序，它负责管理手机自动化环境，并且转发 自动化程序的控制指令 给 移动端设备，并且转发 移动端设备给 自动化程序的响应消息。 手机设备为什么能 接收并且处理自动化指令呢？ 因为，Appium Server 会在手机上 安装一个 自动化代理程序， 代理程序会等待自动化指令，并且执行自动化指令 比如：要模拟用户点击界面按钮，Appium 自动化系统的流程是这样的： 自动化程序 调用客户端库相应的函数， 发送 点击元素 的指令（封装在HTTP消息里）给 Appium Server Appium Server 再转发这个指令给 手机上的自动化代理 手机上的自动化代理 接收到 指令后，调用手机平台的自动化库，执行点击操作，返回点击成功的结果给 Appium Server Appium Server 转发给 自动化程序 自动化程序了解到本操作成功后，继续后面的自动化流程 其中，自动化代理控制，使用的什么库来实现自动化的呢？ 如果测试的是苹果手机， 用的是苹果的 XCUITest 框架 （IOS9.3版本以后） 如果测试的是安卓手机，用的是安卓的 UIAutomator 框架 (Android4.2以后) 这些自动化框架提供了在手机设备上运行的库，可以让程序调用这些库，像人一样自动化操控设备和APP，比如：点击、滑动，模拟各种按键消息等。 环境搭建本例中主要以安卓为例. 安装client编程库根据原理图， 我们知道自动化程序需要调用客户端库和 Appium Server 进行通信。Python语言开发，所以用pip安装 1pip install appium-python-client 安装Appium ServerAppium Server 是用 nodejs 运行的，基于js开发出来的。Appium组织为了方便大家安装使用，制作了一个可执行程序 Appium Desktop，把 nodejs 运行环境、Appium Server 和一些工具 打包在里面了，只需要简单的下载安装就可以了。 下载地址: Release v1.22.3-4 · appium/appium-desktop · GitHub , 本文中使用的版本为: Appium-windows-1.15.1.exe 安装JDK安卓APP的自动化，必须要安装安卓SDK（后面会讲到），而安卓SDK需要 JDK 环境。本文中以jdk1.8为例, 安装好后还需要配置好jdk的系统环境变量 安装 Android SDK对于安卓APP的自动化，Appium Server 是需要 Android SDK的。因为要用到里面的一些工具，比如 要执行命令设置手机、传送文件、安装应用、查看手机界面等。 下载地址: 安卓软件开发工具包 - 下载 (softonic.com) 下载安装好解压后, 推荐配置一下环境变量: 添加ANDROID_HOME , 设置值为sdk包解压目录 修改添加环境变量PATH , 加入 adb所在目录 , 值为 %ANDROID_HOME%\\platform-tools 连接手机真机连接上述的软件环境都准备好以后，要自动化手机APP，需要： 在你运行程序的电脑上 用 USB线 连接上 你的安卓手机 进入 手机设置 -&gt; 关于手机 ，不断点击 版本号 菜单（7次以上）， 退出到上级菜单，在开发者模式中，启动USB调试 如果手机连接USB线后，手机界面弹出 是否允许调试 提示。选择允许 注意： 有的手机系统，可能需要一些额外的选项需要设置好。 比如，有的手机，开发者选项里 需要打开 允许通过USB安装应用 等。 总之，给USB开发调试 尽可能方便的控制手机。 连接好以后，打开命令行窗口， 执行 adb devices -l 命令来列出连接在电脑上的安卓设备。如果输出 类似如下的内容： 12List of devices attached4d0035dc767a50bb device product:t03gxx model:GT_N7100 device:t03g 表示电脑上可以查看到 连接的设备，就可以运行自动化程序了。 模拟器 各种模拟器介绍以及连接方法: Android开发者必备工具-常见Android模拟器(MuMu、夜神、蓝叠、逍遥、雷电、Genymotion…)_ 下面以夜神模拟器为例: 在模拟器中打开开发者模式和允许设备调试以后, 在电脑上执行: 1adb connect 127.0.0.1:62001 夜神模拟器默认端口是: 62001 查看是否连接成功: 1adb devices -l 随后像真机一样正常连接即可 可能会出现的问题: 解决方案: appium找不 到夜神模拟器could not find a connected Android device的解决办法 - 潇洒然 - 博客园 (cnblogs.com) 1报错: Could not find a connected Android device. 快速入门下面是一段使用 Appium 自动化的打开 B站 应用，搜索 白月黑羽 发布的教程视频，并且打印视频标题的示例。 **注意! 运行代码前，要先 运行 Appium Desktop ** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from appium import webdriverfrom selenium.webdriver.common.by import Byfrom appium.webdriver.extensions.android.nativekey import AndroidKey# 调试设备信息desired_caps = &#123; &#x27;platformName&#x27;: &#x27;Android&#x27;, # 被测手机是安卓 &#x27;platformVersion&#x27;: &#x27;8&#x27;, # 手机安卓版本 &#x27;deviceName&#x27;: &#x27;xxx&#x27;, # 设备名，安卓手机可以随意填写 &#x27;appPackage&#x27;: &#x27;tv.danmaku.bili&#x27;, # 启动APP Package名称 &#x27;appActivity&#x27;: &#x27;.ui.splash.SplashActivity&#x27;, # 启动Activity名称 &#x27;unicodeKeyboard&#x27;: True, # 使用自带输入法，输入中文时填True &#x27;resetKeyboard&#x27;: True, # 执行完程序恢复原来输入法 &#x27;noReset&#x27;: True, # 不要重置App &#x27;newCommandTimeout&#x27;: 6000, &#x27;automationName&#x27;: &#x27;UiAutomator2&#x27; # &#x27;app&#x27;: r&#x27;d:\\apk\\bili.apk&#x27;,&#125;# 连接Appium Server，初始化自动化环境driver = webdriver.Remote(&#x27;http://localhost:4723/wd/hub&#x27;, desired_caps)# 设置缺省等待时间driver.implicitly_wait(5)# 如果有`青少年保护`界面，点击`我知道了`iknow = driver.find_elements(By.ID, &quot;text3&quot;)if iknow: iknow.click()# 根据id定位搜索位置框，点击driver.find_element(By.ID, &#x27;expand_search&#x27;).click()# 根据id定位搜索输入框，点击sbox = driver.find_element(By.ID, &#x27;search_src_text&#x27;)sbox.send_keys(&#x27;白月黑羽&#x27;)# 输入回车键，确定搜索driver.press_keycode(AndroidKey.ENTER)# 选择（定位）所有视频标题eles = driver.find_elements(By.ID, &#x27;title&#x27;)for ele in eles: # 打印标题 print(ele.text)input(&#x27;**** Press to quit..&#x27;)driver.quit() 提示: Appium Python 现在已经升级到 2.x 大版本，依赖 Selenium 4 以后， 下面这种 find_element_by* 方法都作为过期不赞成的写法 1driver.find_element_by_id(&#x27;username&#x27;).send_keys(&#x27;byhy&#x27;) 运行会有告警，都要写成下面这种格式 1wd.find_element(By.ID, &#x27;username&#x27;).send_keys(&#x27;byhy&#x27;) Package和Activity在上面的例子, 我们可以发现, 除了需要配置一些关于手机系统的一些信息外, 还需要其他的一些配置信息,例如: 启动APP Package名称appPackage , 启动Activity名称appActivity等, 我们可以通过 abd shell 脚本命令来获取信息 已安装假如需要获取的应用是已经安装好的, 我们使用手机打开应用,在电脑上执行下面的命令: 1adb shell dumpsys activity recents | find &quot;intent=&#123;&quot; 会显示如下，最近的 几个 activity 信息， 1234intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=tv.danmaku.bili/.ui.splash.SplashActivity&#125;intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10000300cmp=com.huawei.android.launcher/.unihome.UniHomeLauncher&#125;intent=&#123;flg=0x10804000 cmp=com.android.systemui/.recents.RecentsActivity bnds=[48,1378][10322746]&#125;intent=&#123;flg=0x10000000 cmp=com.tencent.mm/.ui.LauncherUI&#125; 其中第一行就是当前的应用，我们特别关注最后 1cmp=tv.danmaku.bili/.ui.splash.SplashActivity 应用的package名称就是 tv.danmaku.bili 应用的启动Activity就是 .ui.splash.SplashActivity 未安装,有apk假如我们已经有需要调试的app的apk文件,在电脑端执行如下命令 1androidsdk安装解压目录\\build-tools\\29.0.3\\aapt.exe dump badging apk文件全路径 | find &quot;package: name=&quot; 输出信息中，就有应用的package名称 1package: name=&#x27;tv.danmaku.bili&#x27; versionCode=&#x27;5531000&#x27; versionName=&#x27;5.53.1&#x27; platformBuildVersionName=&#x27;5.53.1&#x27; compileSdkVersion=&#x27;28&#x27; compileSdkVersionCodename=&#x27;9&#x27; 再执行如下命令: 1androidsdk安装解压目录\\build-tools\\29.0.3\\aapt.exe dump badging apk文件全路径 | find &quot;launchable-activity&quot; 输出信息中，就有应用的启动Activity 1launchable-activity: name=&#x27;tv.danmaku.bili.ui.splash.SplashActivity&#x27; label=&#x27;&#x27; icon=&#x27;&#x27; adb 命令 Android 调试桥 (adb) | Android 开发者 | Android Developers (google.cn) adb 全程 Android Debug Bridge，这个adb 使用非常广泛。可以与 Android 手机设备进行通信，它可进行各种设备操作。比如： 安装应用和调试应用，传输文件，甚至登录到手机设备上shell的进行访问，就像远程登录一样 , 这个adb 在 sdk的 platform-tools 目录下面， 请大家确保路径在path环境变量中。 Appium 对anroid的自动化就非常依赖这个adb工具。 执行自动化过程中，有很多内部操作，比如获取设备信息，传送文件到手机，安装apk，启动某些程序等，都是通常这个adb实现的。 ==tips: 我们可以通过os.system()==或subprocess来通过python代码执行操作系统批处理脚本shell 所以我们也可以通过python来执行adb命令来完成一些代码实现不了的操作 比如，我们自动化过程中，可能需要截屏手机，并且下载到指定目录中，就可以在我们的Python程序中这样写: 123import osshell_code = &#x27;adb shell screencap /sdcard/screen3.png &amp;&amp; adb pull /sdcard/screen3.png&#x27;os.system(shell_code) 特别是，还可以通过adb 使用 am(activity manager) 和pm (package manager) 两个工具， 可以启动 Activity、强行停止进程、广播 intent、修改设备屏幕属性、列出应用、卸载应用等。 查看连接的设备: 1adb devices -l 列出文件和传输文件: 123456# 查看目录adb shell ls /sdcard# 上传adb push wv.apk /sdcard/wv.apk# 下载adb pull /sdcard/new.txt shell: 登录到手机设备上shell的进行访问，就像远程登录一样，可用来在连接的设备上运行各种命令。 大家可以 执行一下 adb shell 然后执行各种 安卓支持的 Linux命令，比如 ps、netstat、netstat -an|grep 4724、 pwd、 ls 、cd 、rm 等。执行quit退出 shell 检查元素工具从示例代码，大家就可以发现，和Selenium Web自动化一样，要操作界面元素，必须先 定位（选择）元素。从示例代码，大家就可以发现，和Selenium Web自动化一样，要操作界面元素，必须先 定位（选择）元素。 find_element_by_XXX 方法，返回符合条件的第一个元素，找不到抛出异常 find_elements_by_XXX 方法，返回符合条件的所有元素的列表，找不到返回空列表 通过 WebDriver 对象调用这样的方法，查找范围是整个界面 通过 WebElement 对象调用这样的方法，查找范围是该节点的子节点 界面元素查看工具: 做 Selenium Web 自动化的时候，要找到元素，我们是通过浏览器的开发者工具栏来查看元素的特性，根据这些特性（属性和位置），来定位元素 . Appium 要自动化手机应用，同样需要工具查看界面元素的特征。 常用的查看工具是： Android Sdk包中的 uiautomateviewer 和 Appium Desktop 中的 Appium Inspector **两款工具配合使用比较好, ** Appium Inspector: 优点是可以更具有多种元素特征查找元素的功能, 功能比较丰富,缺点是运行速度比较慢,需要进行一些配置 uiautomateviewer: 优点是运行速度快, 但是功能单一, 只能通过鼠标定位获取指定元素信息, 不能通过其他方式查找元素信息,无法确定元素的唯一性 Appium InspectorAppium Desktop 中自带的工具 Appium Inspector 可以查看元素。打开Appium后,启动Appium Server 连接好手机后 随后填写配置信息, 包括操作系统版本信息,App包名,和活动名等配置: 随后便可以看到对应元素的特征: uiautomatevieweruiautomatorviewer是android SDK自带的一个元素定位Java工具。通过截屏并分析XML布局文件的方式，为用户提供控件信息查看服务。使用uiautomatorviewer，你可以检查一个应用的UI来查看应用的布局和组件以及相关的属性。该工具位于android SDK目录下的tools\\bin子目录下。在该目录下双击uiautomatorviewer.bat就可以启动 UI界面介绍:上方区域 : 4个按钮从左至右功能分别是：打开已经保存的布局，获取详细布局，获取简洁布局，保存布局。 定位元素由于Appium是基于Selenium实现, 所以在操作元素之前需要定位元素 , 移动端定位元素除了有Web端元素特征外,还可以有自己的元素特征: 根据ID在Selenium Web自动化中, 我们知道,如果能根据ID选择定位元素，最好根据ID，因为通常来说ID是唯一的，所以根据ID选择 效率高。在安卓应用自动化的时候，同样可以根据ID查找。但是这个ID ，是安卓应用元素的 resource-id 属性 123from appium.webdriver.common.appiumby import AppiumBydriver.find_element(AppiumBy.ID, &#x27;expand_search&#x27;) 根据class name安卓界面元素的 class属性 其实就是根据元素的类型，类似web里面的tagname， 所以通常不是唯一的, 通常，我们根据class 属性来选择元素， 是要选择多个而不是一个。当然如果你确定 要查找的 界面元素的类型 在当前界面中只有一个，就可以根据class 来唯一选择。 12345from appium.webdriver.common.appiumby import AppiumBydriver.find_element( AppiumBy.CLASS_NAME, &#x27;android.widget.TextView&#x27;) 根据ACCESSIBILITY ID元素的 content-desc 属性是用来描述该元素的作用的如果要查询的界面元素有 content-desc属性，我们可以通过它来定位选择元素。 123from appium.webdriver.common.appiumby import AppiumBydriver.find_element(AppiumBy.ACCESSIBILITY_ID, &#x27;找人&#x27;) 根据XpathAppium 也支持通过 Xpath选择元素。但是其可靠性和性能不如 Selenium Web自动化。因为Web自动化对Xpath的支持是由浏览器实现的，而Appium Xpath的支持是 Appium Server实现的。但Xpath是标准语法，所以这里表达式的语法规则和 以前学习的Selenium里面Xpath的语法是一样的，学习成本会有所降低 123from appium.webdriver.common.appiumby import AppiumBydriver.find_element(AppiumBy.XPATH, &#x27;//ele1/ele2[@attr=&quot;value&quot;]&#x27;) 注意： selenium自动化中， xpath表达式中每个节点名是html的tagname。 但是在appium中， xpath表达式中 每个节点名 是元素的class属性值。 比如：要选择所有的文本节点，就使用如下代码 1driver.find_element(AppiumBy.XPATH, &#x27;//android.widget.TextView&#x27;) 安卓UIAutomator根据id，classname， accessibilityid，xpath，这些方法选择元素，其实底层都是利用了安卓 uiautomator框架的API功能实现的。 官方文档: https://developer.android.google.cn/training/testing/ui-automator 也就是说，程序的这些定位请求，被Appium server转发给手机自动化代理程序，就转化为为uiautomator里面相应的定位函数调用。 其实，我们的自动化程序，==可以直接告诉 手机上的自动化代理程序，让它 调用UI Automator API的java代码，实现最为直接的自动化控制。== 主要是通过 UiSelector 这个类里面的方法实现元素定位的，比如 123456rom appium.webdriver.common.appiumby import AppiumByjava_code = &#x27;new UiSelector().text(&quot;热门&quot;).className(&quot;android.widget.TextView&quot;)&#x27;driver.find_element(AppiumBy.ANDROID_UIAUTOMATOR, java_code)ele.click() 就是通过 text 属性 和 className的属性 两个条件 来定位元素。UiSelector里面有些元素选择的方法 可以解决 前面解决不了的问题。 比如 text 方法 可以根据元素的文本属性查找元素 textContains 根据文本包含什么字符串 textStartsWith 根据文本以什么字符串开头 textmartch 方法 可以使用正则表达式 选择一些元素，如下 1code = &#x27;new UiSelector().textMatches(&quot;^我的.*&quot;)&#x27; UiSelector 的 instance 和 index 也可以用来定位元素，都是从0开始计数， 他们的区别： instance是匹配的结果所有元素里面 的第几个元素 index则是其父元素的几个节点，类似xpath 里面的*[n] UiSelector 的 childSelector 可以选择后代元素，比如 123code = &#x27;new UiSelector().resourceId(&quot;tv.danmaku.bili:id/recycler_view&quot;).childSelector(new UiSelector().className(&quot;android.widget.TextView&quot;))&#x27;ele = driver.find_element(AppiumBy.ANDROID_UIAUTOMATOR, code) 注意： childSelector后面的引号要框住整个 子 uiSelector 的表达式 目前有个bug：只能找到符合条件的第一个元素，参考appium 在github上的 issues：https://github.com/appium/java-client/issues/150 动作行为click点击1element.click() tap点按WebElement 对象的 tap 方法和 click 类似，都是点击界面。但是最大的区别是， tap是 针对坐标 而不是针对找到的元素。为了保证自动化代码在所有分辨率的手机上都能正常执行，我们通常应该使用click方法。但有的时候，我们难以用通常的方法定位元素， 可以用这个tap方法，根据坐标来点击 , 大家还记得用inspect 查看该元素注: 元素的bounds 属性它就是表示元素的左上角，右下角坐标的 坐标。我们还可以使用 UIAutomatorviewer 直接光标移动，看右边的属性提示。tap 方法可以像这样进行调用 1driver.tap([(850,1080)],300) 它 有 两个参数： 第一个参数是个列表，表示点击的坐标。 注意最多可以有5个元素，代表5根手指点击5个坐标。所以是list类型。 如果我们只要模拟一根手指点击屏幕，list中只要一个元素就可以了 第二个参数 表示 tap点按屏幕后 停留的时间。 如果点按时间过长，就变成了长按操作了。 文本输入1element.send_keys(&#x27;文本内容&#x27;) 滑动我们做移动app测试的时候，经常需要滑动界面。怎么模拟滑动呢？ WebDriver对象的 swipe()方法，就提供了这个功能 1driver.swipe(start_x=x, start_y=y1, end_x=x, end_y=y2, duration=800) 前面4个参数 是 滑动起点 和 终点 的x、y坐标。第5个参数 duration是滑动从起点到终点坐标所耗费的时间。 注意这个时间非常重要，在屏幕上滑动同样的距离，如果时间设置的很短，就是快速的滑动。 比如：一个翻动新闻的界面，快速的滑动，就会是扫动的动作，会导致内容 惯性 滚动很多。 按键 按键定义:https://github.com/appium/python-client/blob/master/appium/webdriver/extensions/android/nativekey.py 前面的示例代码中已经使用过 调用 press_keycode 方法，就能模拟 按键动作，包括安卓手机的实体按键和 键盘按钮。 1234from appium.webdriver.extensions.android.nativekey import AndroidKey# 输入回车键，确定搜索driver.press_keycode(AndroidKey.ENTER) 长按、双击、移动 参考源代码注释: https://github.com/appium/python-client/blob/master/appium/webdriver/common/touch_action.py Appium的 TouchAction 类提供了更多的手机操作方法，比如：长按、双击、移动 12345from appium.webdriver.common.touch_action import TouchAction# ...actions = TouchAction(driver)actions.long_press(element)actions.perform( 打开通知栏:我们可以通过滑动方法来打开通知栏,但是我们有更简便的方法直接打开通知栏: 1driver.open_notifications() 收起通知栏: 可以使用前面介绍的模拟按键， 发出返回按键 的方法。 APP切换与关闭我们知道Appium应用启动时自带的caps可以先行启动某个应用（基于appPackage和appActivity），那么如何用其连续启动多个应用呢？ 这里就需要用到start_activity()方法来启动其它应用，格式如下： 1start_activity(self, app_package, app_activity, **opts) 实例: 连续启动Calculator，FM radio，Music三个应用，代码如下 12345678910111213141516171819202122232425262728293031from appium import webdriverimport time#首先用cap3进入到手机hone界面caps = &#123; &quot;platformName&quot;:&quot;Android&quot;, &quot;platformVersion&quot;:&quot;8.0.0&quot;, &quot;deviceName&quot;:&quot;Phone&quot;, &quot;appPackage&quot;:&quot;home&quot;, &quot;appActivity&quot;:&quot;HomeActivity&quot;&#125;driver webdriver.Remote(&quot;http://localhost:4723/wd/hub&quot;,caps)# 先启动Calculatorl应用driver.start activity(com.calculator&#x27;,&#x27;.Calculator&#x27;)time.sleep(2)# 按home键返回主界面driver.press_keycode(&#x27;3&#x27;) #再启动FM radio应用driver.start activity(comfmradio&#x27;.FmRadioActivity&#x27;)time.sleep(2)# 按home键返回主界面driver.press_keycode(&#x27;3&#x27;)#最后启动Mu3ic应用driver.start activity(com.smusic&#x27;,&#x27;.MusicActivity&#x27;)time.sleep(2)driver.press_keycode (&#x27;3&#x27;) driver.quit() 关闭正在运行的App:示例: 1driver.terminate_app(&quot;tv.danmaku.bili&quot;) 其中: tv.danmaku.bili 是需要关闭的App的包名 内嵌网页自动化不感兴趣,以后有需要再深入学习 参考:内嵌网页自动化 | 白月黑羽 (byhy.net) 很多移动App 都是 Hybrid（混合） 应用。混合应用主要是指 它的一部分是原生界面和代码，而另一部分是内嵌网页 。微信的sms界面是原生代码实现的，而打开某个朋友圈，或者别人发来的的链接部分则是 web部分。 App中的内嵌的展示网页内容的模块，我们称之为 webview 。现在基本上需要打开网页浏览的app都是 混合app，比如微信、支付宝等。 办公自动化pywin32操作Word:“在Windows平台上，从原来使用C/C++编写原生EXE程序，到使用python编写一些常用脚本程序，成熟的模块的使用使得编程效率大大提高了。不过，python模块虽多，也不可能满足开发者的所有需求。而且，模块为了便于使用，通常都封装过度，有些功能无法灵活使用，必须直接调用Vindows API.来实现。要完成这一目标，有两种办法，一种是使用C编写Python扩展模块，或者就是编写普通的DLL通过oython的ctypes.来调用，但是这样就部分牺牲掉了Python的快速开发、免编译特性。还好，有一个模块oywin.32可以解决这个问题，它直接包装了几乎所有的Windows API，可以方便地从Python直接调用，该模块另一大主要功能是通过Python进行COM编程。 下面的办公自动化实际调用了pywin32的子库: python32com **优点:**功能全面,效果完善,功能完善 缺点: 消耗电脑资源, 运行速度慢 (因为pywin32实际上通过调用vbs的api进行操作) 安装: pip install pywin32 导包: 123from win32com.client import Dispatchfrom win32com.client.gencache import EnsureDispatchfrom win32com.client import constants 快速上手-学习方法:查询官方文档:我们可以参考微软的api文档来学习使用 微软api文档:Microsoft.Office.Interop.Word 命名空间 | Microsoft Learn 启动: 12345# 启动 word应用程序 (注意 wps可能不行)word_app = EnsureDispatch(&quot;Word.Application&quot;)word_app.Visible = True# 新建文档文件word_doc = word_app.Documents.Add() 通过Range接口(Range 接口 (Microsoft.Office.Interop.Word) | Microsoft Learn)的属性和方法可以进行一些文字的基本操作: 如: 添加文字, 设置文字样式等 123456# 添加文本word_doc.Range().Text = &quot;Hello World!&quot;# 设置样式word_doc.Range().Bold = Trueword_doc.Range().Font.size = 20word_doc.Range().Font.Name = &quot;宋体&quot; 通过Selection接口(Selection 接口 (Microsoft.Office.Interop.Word) | Microsoft Learn), 可以进行范围部分选中操作 1234567891011121314# 获取`选择区域`对象selection = word_app.Selection# 全选selection.WholeStory()# 获取 选择区域 对象的 范围对象select_range = selection.Range# 查找 选择区域 为 `Hello` 的 范围 (即此时select_range是指`Hello`这个范围)select_range.Find.Execute(&quot;Hello&quot;)# 给 指定范围 设置样式select_range.Bold = Trueselect_range.Font.size = 20select_range.Font.Name = &quot;宋体&quot;select_range.Font.Color = 16711680 设置段落对齐: 需要设置段落对齐方式需要通过 **ParagraphFormat**实现, , Range.Paragraphs属性可以进行多个段落操作 1select_range.ParagraphFormat.Alignment = constants.wdAlignParagraphCenter 注: 如果需要设置的样式值为 内置常量, 则需要通过constants.常量字段来引用 , 有些可以通过常量值设置,也可以通过指定值设置,比如颜色设置: 123# 两行代码等效selection.Font.Color = constants.wdColorAquaselect_range.Font.Color = 13421619 并且用 constants 下变量，word 必须通过 EnsureDispatch 启动，不能通过 Dispatch 启动。 Word录制宏通过Word自带的 录制宏 功能, 可以根据我们手动执行的操作生成对应的vbs脚本, 然后我们可以通过参考官方文档将生成的vbs脚本转换成对应的python脚本 , 从而大大提供我们的效率,而不是盲目的翻阅文档 我们点击录制宏: ,随后在word中进行一些操作,随便输入一些样式, 随后 停止录制宏: 然后查看 我们录制的宏, 选择编辑 随后便可以看到对应操作的vbs脚本: 随后我们根据此脚本去官方文档里搜索查询相关api , 想办法转通过python调用对应的api即可 12345selection = word_app.Selectionselection.Font.UnderlineColor = constants.wdColorAutomaticselection.Font.Underline = constants.wdUnderlineSingleselection.TypeText(&quot;你好哇&quot;) **注意: **如果我们是先 输入了文本在设置样式就不会对文本生效了, (因为此时的光标已经在输入的文本末尾了) 所以我们要想先输入文本在设置样式, 就需要调整光标的位置 1234selection.TypeText(&quot;你好哇&quot;)selection.Start = word_doc.Range().Start # 调整光标位置selection.Font.UnderlineColor = constants.wdColorAutomaticselection.Font.Underline = constants.wdUnderlineSingle 此外,录制宏只是作为参考而已, 因为生成的vbs脚本可能会有大量代码冗余, 且有些操作是无法被记录到的, 比如光标移动操作等 文档打开,新建,保存,转换我们在对文档进行操作前,启动先启动Word程序. 可以通过如下三个类的构造器启动: Dispatch(&quot;Word.Application&quot;): 最基本的启动方式, 如果某个 Word 文档进程被占用，Dispatch 会报错 DispatchEx(&quot;Word.Application&quot;): DispatchEx 可以另开一个 进程避免进程被占用报错 EnsureDispatch(&quot;Word.Application&quot;) : 调用 constants类 下的内置值常量, 需要 EnsureDispatch 启动 启动word程序: 123456word_app = EnsureDispatch(&quot;Word.Application&quot;)# 设置程序界面可见性,默认不可见(即以内核形式在后台运行,占用资源会少一些)word_app.Visible = True# 关闭程序word_app.Quit() 打开文档: 通过word程序对象的Documents.Open(url)方法可以打开word文档文件 如果参数只写文件名不写绝对路径,则会默认从C:\\windows\\system32\\路径下搜索文件 12file_url = r&quot;E:\\Code\\python\\自动化与数据处理\\办公自动化pywin32\\操作word\\word_file\\论文.doc&quot;document1 = word_app.Documents.Open(file_url) 文档的保存,关闭,另存为 通过文档对象的Save()可以进行保存 1docment1.Save() 文档对象的Close()方法可以关闭该文档 (注: 关闭文档并不意味着退出程序) , 该方法可以传入一个参数: SaveChanges, 值可以为: 0 不保存 -1自动保存，-2提示用户 12doc1.Save()doc1.Close(SaveChanges = 0) 文档对象的SaveAs()方法可以实现另存为功能,默认情况下是另存为docx格式,我们可以通过FileFormat参数来指定另存为的格式(即使格式转换) 123456file_url = r&quot;E:\\Code\\python\\自动化与数据处理\\办公自动化pywin32\\操作word\\word_file&quot;doc1 = word_app.Documents.Open(file_url+&quot;\\\\论文.doc&quot;)doc1.Save()# doc1.SaveAs(file_url+&quot;\\\\论文2.doc&quot;)# 另存为PDF格式doc1.SaveAs(file_url+&quot;\\\\论文PDF.pdf&quot;, FileFormat=17) WdSaveFormat保存文件类型: WdSaveFormat 枚举 (Microsoft.Office.Interop.Word) | Microsoft Learn 新建文档: word程序对象的Documents.Add()方法可以新建一个文档,同时返回该文档对象, 不过需要注意: 如果我们新建文档后直接保存(如调用Save())会弹出提示框让我们输入文件名, 但是Add()方法并没有提供设置文件名的参数,所以我们在新建文档时可以通过 另存为 来进行文件命名 12345doc2 = word_app.Documents.Add()# 不推荐, 会弹出对话框影堵塞后续程序运行# doc2.Save()doc2.Range().Text = &quot;这是python创建的一个空白文档!&quot;doc2.SaveAs(file_url+&quot;\\\\新建空白文档.doc&quot;) 文字处理-范围操作,光标操作Word时, 有两种最基本的单位，一个是选区/范围 Range，另一个是光标 Selection。两个都是 万金油属性，属性和方法很多。其他方法和属性如果能够返回或者连接这两种单位，后续的操作将变得容易。比如表格、段落、图片都可以接 Range 属性返回 Range，也可以通过 Selection、 Select()等属性或方法返回 Selection。 Range一个文档可以有很多个 Range，所以操作更灵活 基本操作: 123all_rang = doc.Range() # 获取整个文档的全部范围print(all_rang) # 会打印出该范围的内容all_rang.Text = &quot;你好\\n&quot; # 替换范围内容 在指定范围前后插入: 12all_rang.InsertBefore(&quot;InsertBefore&quot;)all_rang.InsertAfter(&quot;InsertAfter&quot;) 删除指定范围内容: 12all_rang.Delete()all_rang.Text = &quot;&quot; 注意: 如果这样all_rang.Text = &quot;&quot;替换所有内容为空串, 则还是会有一个空串占位 (即all_ange.End的值为1 ,而使用all_range.Delete()则值才会变成0) 理解Range的起始位置 Range的范围有点类似python的含头不含尾, 但是并不完全一致 , 例如在python里Range(0,0) , Range(1,1) 是会报错的, 但在此处则是表示插入位置的意思 1234567891011all_range = doc.Range() # 打开一个存在的文档all_range.Delete()print(all_range.Start, all_range.End) # 范围是0,0all_range.Text = &quot;ABCD&quot;print(all_range.Start, all_range.End) # 范围是0,4,类似python的含头不含尾print(&quot;=&quot; * 10)print(doc.Range(0, 2)) # 返回 ABprint(doc.Range(1, 2)) # 返回 Bprint(doc.Range(0, 0)) # 返回空白,表示定位在最开头print(doc.Range(1, 1)) # 返回空白,表示定位在AB之间 起始位置理解为插入位 1234# 在AB之间插入Ldoc.Range(1, 1).Text = &quot;L&quot;# 通过覆盖A的位置插入F,即将A替换为Fdoc.Range(0, 1).Text = &quot;F&quot; 如果Range() , 中只写一个参数,则该参数表示起始位置,到结尾位置 12# 将文档内容 ABCD 替换为 AQdoc.Range(1).Text = &quot;Q&quot; 复制粘贴: 通过 范围对象Range() 的 Copy() ,和 Paste()可实现对应范围的复制粘贴 12doc.Range(0, 2).Copy()doc.Range(3, 4).Paste() Selection相比而言，由于几乎 word 任何操作都要借助光标，所以 Selection 能应付的场景更多, 不过需要注意一个Word程序只有一个, 而 Range是可以有多个的 获取光标: 1234567# 启动程序word_app = EnsureDispatch(&quot;Word.Application&quot;)word_app.Visible = True# 添加文档doc = word_app.Documents.Add()# 获取光标, 注意是 word 程序的对象，不是文档对象，且不会和“指定范围”关联selection = word_app.Selection 光标位置 光标对象的Start 和 End属性 可以返回光标的起止位置, 类似Range 光标输入操作: 使用TypeText()方法输入: 相当于光标输入(正常光标输入每次输入一个字都会往后移动一个位置), 方法会返回光标最后移动的位置 使用Text属性赋值输入, 输入完内容后,光标是处于选中 输入的内容的状态的 实例1: 通过 Text输入后,此时光标处于是选中了 文档内容的状态,所以此时再通过TypeText()输入会将其覆盖掉 123selection.Text = &quot;Text属性输入值&quot;selection.TypeText(&quot;TypeText()输入值&quot;)print(selection.Start, selection.End) # 13 13 文档内容最终为: TypeText()输入值 实例2: 1234selection = word_app.Selectionselection.TypeText(&quot;TypeText()输入值&quot;) # 相当于直接打字输入,selection.Text = &quot;Text属性输入值&quot;print(selection.Start, selection.End) # 13 22 文档最终内容为: TypeText()输入值Text属性输入值 ,效果如下所示: 为了避免覆盖, 我们除了可以调换顺序外, 还通过设置 光标 末尾坐标, 使其 取消选中状态 123selection.Text = &quot;Text属性输入值&quot;selection.End = 0 # 取消 选中状态selection.TypeText(&quot;TypeText()输入值&quot;) # 相当于直接打字输入, 光标全选操作 通过光标对象的WholeStory()方法可以全选文档内容 (包括 整个页眉页脚) 光标移动: 通过 MoveLeft(Unit, Count)，MoveRight(Unit, Count)，MoveUp(Unit, Count)，MoveDown(Unit, Count) 可对光标进行左右,上下移动 这些方法需要传入两个int类型参数: Unit , Count Unit 设置移动的单位类型, 比如 字符, 段落等 , Count 表示移动的单位数 1234selection.MoveRight(1, 3) # 光标向左移动2个字符# 注意上下移动时不能以字符为单位,可以 以段落为单位# selection.MoveDown(1, 2) selection.MoveDown(4, 2) Range与Selection的选择Range 可以有很多个，但 Selection 只有一个 , 推荐选择更多用 Range Range 索引方便，可以嵌套在各种属性和方法中，而 Selection 要单独两条命令 Range 有多个，相互独立更方便，代码也显得更直观 Selection 可以接 Range，相当于可以通过 Range 的属性和方法实现部分的 Selection 功能， 那可以少学习 一点 Selection 属性和方法 当然，还有不少情况下，我们没有权利选择。譬如复杂的页码设计需要借助 Selection 文字处理-查找替换直接用数字索引修改文字，虽然方便，但大多数情况下没有实用性：因为我们很难知道 我们要编辑的文字的具体索引位置。通常我们知道的，是我们要编辑的文字的内容。 如果用一般的 python 方法，可以先将全文本提取，并用 replace 函数替换，在重新赋值 但这样的问题是：格式就全没了。 所以，还是需要用到 pywin32 的所提供的查找替换功能。 Find查找范围对象的Find.Execute()方法可执行查找功能, 需要传入一个 搜索值 作为参数, 若重复执行此方法, 则表示查找下一个 不过需要注意: ==当范围对象执行了查找功能后, 若查找成功, 他的起止位置会变成查找内容的起止位置== 1234567891011121314# 启动程序并打开文档...all_rang = doc.Range()print(all_rang.Start, all_rang.End)# 查找 全文范围 中 &quot;回应&quot; 文字, 注意: 此操作印象 all_range的起止位置is_find = all_rang.Find.Execute(&quot;回应&quot;)print(is_find, all_rang.Start, all_rang.End)# 再次执行相当于: 相当于界面操作在查找框按&quot;下一个”is_find = all_rang.Find.Execute(&quot;回应&quot;)print(is_find, all_rang.Start, all_rang.End)# Forward设置向前还是向后搜索all_rang.Find.Forward = Falseis_find = all_rang.Find.Execute(&quot;回应&quot;)print(is_find, all_rang.Start, all_rang.End) 运行结果: 12340 2974True 1482 1484True 1544 1546True 1482 1484 我们也可以用光标查找, 效果也类似 123selection = word_app.Selectionwhile selection.Find.Execute(&quot;回应&quot;): print(光标.Start,光标.End) 替换12345678910# 将搜索到的第一个 &quot;回应&quot; 替换成 &quot;答复&quot;# print(all_rang.Find.Execute(FindText=&quot;回应&quot;, ReplaceWith=&quot;答复&quot;))# 批量替换并且设置样式while all_rang.Find.Execute(FindText=&quot;回应&quot;, ReplaceWith=&quot;答复&quot;): all_rang.Font.Bold = True # 斜体加粗 all_rang.Font.Name = &#x27;楷体&#x27; # 字体 all_rang.Font.Color = 65280 # 颜色 all_rang.Font.Size = 20 # 大小 all_rang.Font.Italic = True # 斜体 段落处理:通过文档对象的Paragraphs 属性,可以对段落进行处理, Paragraphs文档所有段落的迭代器, 可以通过构造器传入索引参数获取到一个Paragraph对象 , 不过需要注意的是: 索引是从1开始的 同时需要注意: Paragraphs()只能传递一个参数,不能像Range()一样传递两个参数截取范围 123456doc = word_app.Documents.Open(file_url+&quot;\\\\论文2.doc&quot;)paragraphs = doc.Paragraphsprint(paragraphs(1)) # 打印第一段的简略内容# 遍历每一个自然段的完整内容for p in paragraphs: print(p) Paragraphs没有Range和Text属性，无法一下完整显示所有段落。当然实际上也没有必要，因为有Range()方法和Range属性 注意: 段落的Range()会返回一个字符串,所以没有Text属性, Range属性才有Text属性 1234567p3 = paragraphs(7)print(p3)print(p3.Range.Text) # 完整内容print(type(doc.Range())) # Object:Rangeprint(type(p3.Range)) # Object:Rangeprint(type(p3.Range())) # str 通过Paragraph对象的Next(int n)和 Previous(int n)可获取Paragraps表示的段落向前n段和向后n段段落对象 12p1 = p3.Previous(2)p6 = p3.Next(3) 添加段落范围对象的InsertParagraph(): 将指定范围替换为空段落 (相当于按了回车) 123doc = word_app.Documents.Open(file_url+&quot;\\\\论文2.doc&quot;)r1 = doc.Range(3,8)r1.InsertParagrap() 范围对象的InsertParagraphBefore(), InsertParagraphAfter() , 在范围前后插入空段(相当于按了回车) 注意:调用这两个方法会导致Range对象表示的范围改变,范围会扩展到新增的段落 1234r1 = doc.Range(3, 8)print(r1.Start, r1.End)r1.InsertParagraphAfter()print(r1.Start, r1.End) 运行结果: 123 83 9 文档对象的Paragraphs.Add(): 可以传入一个Range对象参数,在指定范围前面 插入一个空段(相当于按了回车) , 该方法的返回值是 回车前的段落Paragraph对象 , 不会改变传入的Range对象 推荐使用 123print(r1.Start, r1.End)print(doc.Paragraphs.Add(Range=r1))print(r1.Start, r1.End) 运行结果: 1233 9段落内容....3 10 段落查找范围对象同样拥有Paragraphs属性,因此我们先查找到对应的范围, 在通过range.Paragraphs即可实现查找段落的功能 123456r2 = doc.Range()# 从全文范围中查找 &quot;回应&quot;r2.Find.Execute(&quot;回应&quot;)find_p1 = r2.Paragraphs(1) # 含有查找内容的第一段print(find_p1) 此外我们还可以遍历文档的Paragraphs来进行样式查找: 12345# 通过段落属性做判断筛选段落,将大纲级别为1的段落筛选出来paragraphs = doc.Paragrahsfor p in paragraphs: if p.OutlineLevel ==1: print(p) 段落样式设置批量将含有指定内容的段落设置样式 1234567891011r2 = doc.Range()# 从全文范围中查找 &quot;回应&quot;while r2.Find.Execute(&quot;回应&quot;): find_p1 = r2.Paragraphs(1) # 含有查找内容的第一段 find_p1.Range.Font.Name = &quot;楷体&quot; # 由于字体这些不是段落的方法，所以如果要整段改字体这些， find_p1.Alignment = 1 # 对齐方式 find_p1.CharacterUnitFirstLineIndent = -2 # 正数是首行缩进，负数是悬挂缩进 find_p1.LineUnitAfter = 3 # 段后间距 find_p1.LineUnitBefore = 5 # 段前间距 find_p1.LineSpacingRule = 2 # 设置行距规则，另有LineSpacing可设置行距的磅数 find_p1.OutlineLevel = 1 # 设置大纲级别 样式处理Paragraph对象和Range对象等都有Style属性,,代表该段落的样式信息。Styles是document对象下的属性, 表示文档可以设置的样式，Styles的索引对应不同的样式，-2代表标题1，详见内置值,索引也可以写名称:例如: Style(&quot;标题一&quot;) 123# 将第一段设置样式为 标题1doc.Paragraphs(1).Style = doc.Styles(-2)doc.Paragraphs(4).Range.Style = doc.Styles(-2) 我们可以修改内置样式, 但是需要注意: 我们修改了内置样式后, 所有引用了我们修改过的内置样式的地方都会变成我们修改的样子 1234567# 获取内置样式引用my_style = doc.Styles(-2)# 修改内置样式my_style.Font.Name = &quot;仿宋&quot;my_style.Font.Color = 65280# 注意! 不仅段落5变成了我们设置的样式, 前面的段落也变成了我们所设置的样式doc.Paragraphs(5).Style = my_style 效果如下: 添加新样式Styles.Add()完全新建一个样式，第一个参数是样式的名字，第二个参数控制样式类型，1代表段落样式，2代表正文字符样式。建议选1，否则无法设置段落格式#然而，选1的话，默认会链接标题类第一个的样式，我的是“标题”。 123456doc.Styles.Add(&#x27;样式2022&#x27;,1)my_style = doc.Styles(&#x27;样式2022&#x27;) my_style.Font.Name = &quot;楷体&quot; #通过Font属性设置字体样式my_style.ParagraphFormat.LineSpacing = 40 #通过ParagraphFormat属性设置段落样式doc.Paragraphs(5).Style = my_style 格式刷:这里逐渐细化的方式实现格式刷的功能: 12345678# 复制全部格式doc.Paragraphs(6).Style = doc.Paragraphs(5).Style # 只复制字体(包括字体颜色,大小等)doc.Paragraphs(10).Range.Font = doc.Paragraphs(5).Range.Font# 复制段落格式doc.Paragraphs(10).Range.ParagraphFormat = doc.Paragraphs(5).Range.ParagraphFormat# 复制段落格式另一种实现doc.Paragraphs(13).Format = doc.Paragraphs(5).Format 图片处理图片处理用到是的属性 范围对象range的InlineShapes 和 InlineShape 。 InlineShapes 代表文档、区域或所选内容中的所有内嵌形状的对象的集合。InlineShapes(i)可定位第i张图片 插入图片:InlineShapes的 AddPicture()，第一个参数输入图片绝对路径，其余参数： LinkToFile 图片链接到创建它的文件，默认 False； SaveWithDocument 随文档一 起保存的链接的图片,默认 False； Range 图片置于文本中的位置，默认自动放置，在范围前插入。 1234567891011word_app = EnsureDispatch(&quot;Word.Application&quot;)word_app.Visible = Truefile_url = r&quot;E:\\Code\\python\\自动化与数据处理\\办公自动化pywin32\\操作word\\word_file\\\\&quot;doc = word_app.Documents.Open(file_url+&quot;图片例子.docx&quot;)r1 = doc.Range()r1.Find.Execute(&quot;第一张图片&quot;)r1.InlineShapes.AddPicture(file_url+&quot;图片1.jpeg&quot;)# 将InlineSHapes的范围改成范围的结尾，就可以在结尾插入图片了，但发觉文字拉开了，这是因为没有回车doc.Range(r1.End, r1.End).InlineShapes.AddPicture(file_url+&quot;图片2.jpeg&quot;) 在插入范围添加回车(即在后面插入一个段落),再插入图片文字就不会被拉大了 1234r2 = doc.Range()r2.Find.Execute(&quot;第二张图片&quot;)r2.InsertParagraphAfter() # 相当于在后面按下一个回车doc.Range(r2.End, r2.End).InlineShapes.AddPicture(file_url+&quot;图片2.jpeg&quot;) 设置图片调整图片大小: 选中通过右键“大小和位置”可查看和绝对大小和比例 123456# 设置图片 绝对值大小doc.InlineShapes(3).Height = 100 doc.InlineShapes(3).Width = 100# 设置图片 比例大小doc.InlineShapes(2).ScaleHeight = 10doc.InlineShapes(2).ScaleWidth = 10 裁剪图片 通过InlineShape对象的PictureFormat属性下的CropBottom()、CropLeft()、CropRight()、CropTop() , 可实现下,左,右,上方向的剪裁, 不过需要注意: 即使插入的图片调整了大小, 裁剪也是以相对于图片的原始尺寸计算, 例如，如果插入的图片最初为100磅，将其高度调整为200磅，然后将CropBottom属性设置为50，100磅（而不是50）将从图片底部裁剪 123# 剪裁的单位是: 磅数, 不是百分比doc.InlineShapes(3).PictureFormat.CropBottom = 50doc.InlineShapes(3).PictureFormat.CropRight = 1000 图片对齐 由于InlineShape没有对齐属性，所以通过Range.ParagraphFormat.Alignment设置 12# 将第三个图片设置为居中对齐doc.InlineShapes(3).Range.ParagraphFormat.Alignment=1 图片提取如何将 word 中的图片提取/另存到本地？ 在 pywin32 没有找到直接的方法。（在 word 中直接选中图片-右键-另存为图片）。 下面介绍两个间接方法， SaveAs：用于保存提取所有图片 ExportFragment：用于保存提取部分图片 **原理:**通过将文档另存为html, 在另存为html时, 会将图片和内容拆分到一个文件夹里, 在从该文件夹获取图片文件 提取所有图片通过 SaveAs() 保存为 html 格式提取所有图片, 随后通过python的os模块即可操作文件拿到图片文件了 提取部分图片通过 ExportFragment 将选中区域(选中我们想要获取的图片区域即可)另存为 html 格式提取部分图片 如下例子提供了一个封装好的方法: 12345678def ExportImage(ImageShape,SavePath): ImageShape.Range.ExportFragment(SavePath,Format = 8) os.remove(SavePath) for f in os.listdir(SavePath[:-4]+ &#x27;files&#x27;): if &#x27;.jpeg&#x27; in f or &#x27;.jpg&#x27; in f or &#x27;.png&#x27; in f: pass else: os.remove(os.path.join(SavePath[:-4]+ &#x27;files&#x27;,f)) 表格处理表格处理用到的是文档对象的属性 Tables 和 Table。 处理行、列、单元格则分别用到：Row/Rows, Column/ Columns，Cell/Cell 添加表格:文档对象的Tables.Add(range, rows, colums)方法可在指定范围插入一个rows行colums列的表格,需要注意的是若range有内容则会将其覆盖 1234567word_app = EnsureDispatch(&quot;Word.Application&quot;)word_app.Visible = Truefile_url = r&quot;E:\\Code\\python\\自动化与数据处理\\办公自动化pywin32\\操作word\\word_file\\\\&quot;doc = word_app.Documents.Open(file_url+&quot;表格例子.docx&quot;)r1 = doc.Range(1, 3)table = doc.Tables.Add(r1,3,2) # 将 r1 范围的内容替换为一个3行2列的表格 改写上述列子,使其在选定范围后插入表格 1234r1 = doc.Range(1, 3)p = doc.Paragraphs.Add(r1) #先一个回车p = doc.Paragraphs.Add(p.Next().Range) #Next()定位到下一段，再回车一下，段落定位在空行table2 = doc.Tables.Add(p.Range,10,10) 设置表格样式:设置预设表格样式，这个关联的是设计-表格样式，之用调用样式名字作为参数 1table.ApplyStyleDirectFormatting(&quot;网格型&quot;) 处理行列表格对象的Rows和Columns属性可对行列进行处理: 设置行高: 123456print(table.Rows.Count,table.Columns.Count) #返回行数列数# 设置行高table.Rows.HeightRule = 2 # 必须先设置行高规则# 1：行高至少是最小的指定值。0：调整行高以适应该行中的最大高度值。2：行高是固定值。table.Rows.Height = 30 # Rows 复数设置全部行高table.Rows(3).SetHeight(10, 2) # 设置指定行的: Rows(3)，返回 Row，可以单独设置，SetHeight()是另一种设置行高的方法，第一个参数是行高，第二个参数行高规则 设置垂直对齐方式: Row 没有垂直对齐方式，要到 Cells 才有。 注意一行有很多 Cell，所以是 Cells, VerticalAlignment属性值: 3：文字与单元格底边框线对齐。1：文字与单元格中心对齐。0：文字与单元格上框线对齐。 1table.Rows(5).Cells.VerticalAlignment = 3 添加行: 1table.Rows.Add() #添加行，在位置在最后添加 列的处理和行处理基本类似,除了特有的属性操作方式略有不同外 设置列宽: 1table.Columns.Width=30 #设置列宽 处理单元格注意: 直接Cell(i,j)无法赋值,必须获取Cell对象的range才可以进行操作 单元格插入值: 123456k = 1for i in range(1,表格.Rows.Count+1): for j in range(1,表格.Columns.Count+1): 表格.Cell(i,j).Range = k #直接Cell(i,j)无法赋值，必须转成万能的range，然后就可以为所欲为了 表格.Cell(i,j).Range.Font.Name = &quot;Forte&quot; k+=1 操作单元格中的内容 1234for table in 文档.Tables: #将表格遍历出来 for e in table.Range.Cells: #再将单个表格单元格遍历出来 if &quot;42&quot; in e.Range.Text: #用if e.Range.Text ==&#x27;42&#x27;判断不出来，因为单元格处理42可能还有其他东西，譬如回车，TAB之类 e.Range.Font.Color = 128 #Cell没有Font属性，必须用Range过渡 设置表格属性:123doc.Tables(2).Rows.Alignment = 1 #注意区分两种对齐，这是全表居中（吐槽一下这个居然在Rows下，而不是Talbe的属性）doc.Tables(2).Range.ParagraphFormat.Alignment = 2 #这个相当于对表格里的各个数据对齐doc.Tables(2).Rows.WrapAroundText = True #设置文字环绕 设置表格边框,底纹: 12345for r in 文档.Tables(2).Rows: r.Shading.ForegroundPatternColor = 10092543 # Shading设置底纹，ForegroundPatternColor设置颜色 r.Borders(-3).LineStyle = 5 # 行列有边框属性Borders(-3)表示下边框，具体索引见笔记；LineStyle是边框样式，5是虚线，具体见笔记doc.Tables(2).Borders(-3).LineStyle = 7 # table也有边框属性，当然其实用cell也有边框属性 定位表格:12345r1 = 文档.Range()r1.Find.Execute(&quot;湖人&quot;) #通过定位表格中的其中一个元素，可以定位这个表格print(r1.Parent)for c in r1.Tables(1).Range.Cells: #逐行输出 print(c) 页眉页脚页码设置页眉主要用到 Headers 对象，页脚主要用到 Footers 对象。Headers、 Footers 下有 Range 属性，就可以通过 Range 自由编辑了。 页眉页脚以节为单位，所以必须先定位节，再定位页眉页角 , 反映到代码上，Headers、 Footers 是Sections/Section 的属性, 节（Section）的定位同样通过索引（i）获得, 注意: Headers(), Footers()没有单数，（i）的参数，不是指页数，而是内置值：1是节中的所有页，2是第一页，3是偶数页。 添加页眉页脚1234567891011word_app = EnsureDispatch(&quot;Word.Application&quot;)word_app.Visible = Truefile_url = r&quot;E:\\Code\\python\\自动化与数据处理\\办公自动化pywin32\\操作word\\word_file\\\\&quot;doc = word_app.Documents.Open(file_url+&quot;论文.doc&quot;)# 添加页眉, 页脚doc.Sections(1).Headers(1).Range.Text = &quot;这是页眉&quot;doc.Sections(1).Footers(1).Range.Text = &quot;这是页脚&quot;# 设置页眉页脚样式doc.Sections(1).Headers(1).Range.Font.Size = 30doc.Sections(1).Footers(1).Range.ParagraphFormat.Alignment = 1 添加页码页码的添加主要使用Footers或者Headers的 PageNumbers 属性得Add(PageNumberAlignment,FirstPage)方法 , 参数: PageNumberAlignment : 控制页码对齐方式, 为 int类型 FirstPage: 设置是否关联第一页的页眉页脚设置, 为 Boolean类型 1234# 设置 页码样式doc.Sections(1).Footers(1).PageNumbers.NumberStyle = 1# 添加 页码doc.Sections(1).Footers(1).PageNumbers.Add(PageNumberAlignment=1,FirstPage = True) 不同节编辑页码:Sections.Add会在Range前面添加分节符(即图形界面-&gt;布局-&gt;分割符)，第二个参数控制分页符的类型，详见文档 123r1 = doc.Range()r1.Find.Execute(&quot;五、垄断行业&quot;)section = doc.Sections.Add(r1, 1) 设置页眉页脚与上一节不关联，否则设置新节会影响上一节 , 看着没有效果，是因为没有重新设置，默认沿用旧的 12section.Footers(1).LinkToPrevious = False section.Headers(1).LinkToPrevious = False 在新节添加页码: 注意: 即使取消了关联，默认也是接着上一节排页码，所以必须设定重新开始页码 12section.Footers(1).PageNumbers.RestartNumberingAtSection = True section.Footers(1).PageNumbers.StartingNumber = 1 # 设置起始页码 不同节编辑页眉页脚123doc.Footers(1).Range.ParagraphFormat.Alignment = 2doc.Headers(1).Range.Text = &quot;新节的页眉&quot;doc.Headers(1).Range.ParagraphFormat.Alignment = 0 奇偶页编辑设置奇偶页码不同, 偶数页的页眉页脚将消失，需要重新设置 1doc.PageSetup.OddAndEvenPagesHeaderFooter = True 如果设置了奇偶页不同，则需要偶数页（3）也取消关联 12section.Footers(3).LinkToPrevious = Falsesection.Headers(3).LinkToPrevious = False 重新设置第一节的偶数页的页眉页脚 12345 # Headers(3)和Footers(3)为偶数页页眉页脚section.Sections(1).Headers(3).Range.Text = &quot;这是偶数页眉&quot; section.Sections(1).Footers(3).Range.Text = &quot;这是偶数页脚&quot;section.Sections(1).Headers(3).Range.Font.Size = 10section.Sections(1).Footers(3).Range.ParagraphFormat.Alignment = 1 重新设置新节的偶数页的页眉页脚 12345section.Footers(3).Range.Text = &quot;新节偶数页脚&quot;section.Footers(3).Range.ParagraphFormat.Alignment = 2section.Headers(3).Range.Text = &quot;新节偶数页眉&quot;section.Headers(3).Range.ParagraphFormat.Alignment =2section.Headers(3).Range.Font.Size = 10 这时，偶数页的页码不见了。所以重新添加一下 12doc.Sections(1).Footers(3).PageNumbers.Add(PageNumberAlignment=2)section. Footers(3).PageNumbers.Add(PageNumberAlignment=1) 然而，我们发觉设置偶数页会影响奇数页的页码…… pandas操作excel简介 官方文档: API reference — pandas 1.5.3 documentation pandas是⼀个开源的、BSD许可的库 为Python编程语⾔提供⾼性能、易于使⽤的数据结构和数据分析⼯具 pandas 库是基于numpy库 的软件库，因此安装Pandas 之前需要先安装numpy库。默认的pandas不能直接读写excel文件，需要安装读、写库即xlrd、xlwt才可以实现xls后缀的excel文件的读写，要想正常读写xlsx后缀的excel文件，还需要安装openpyxl库 。 安装: pip install pandas pandas数据结构pandas有两个两个数据结构 Series &amp; DataFrame , 非常重要 DataFrame, 表示一个二维表 Series 表示一个一维数据列 Series与DataFrame创建Series:通过构造器创建: Series( data = None, index = None, dtype = None, name = None), 参数说明: data: 数组、可迭代、字典或标量值, 表示存储在“列”中的数据。如果数据是字典，则参数顺序为保持一致。 index: 表示列中数据的索引 , 值必须是可哈希的，并且与数据具有相同的长度。 允许使用非唯一索引值。将默认为 范围索引 （0， 1， 2， …， n） 如果未提供。如果数据类似字典 索引为 None，则数据中的键用作索引。如果 index 不是 None，生成的序列将使用索引值重新编制索引。 dtype: 输出列的数据类型。如果未指定，这将是 从数据推断。 name: 要为系列指定的名称。 1234from pandas import Seriess = pandas.Series([1, 2, 3])print(s) 运行结果: 12340 11 22 3dtype: int64 我们输入全部参数看看: 12s = Series([1, 2, 3], index=list(&#x27;abc&#x27;), dtype=&#x27;int64&#x27;, name=&#x27;num&#x27;)print(s) 运行结果: 1234a 1b 2c 3Name: num, dtype: int64 若data传入一个字典: 123d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;s = Series(d)print(s) 运行结果: 会将字典的键当成列索引 1234a 1b 2c 3dtype: int64 创建DataFrameDataFrame类用于表示一个二维表 有三种方法: 通过2维的list-like创建 通过字典创建 通过读取Excel表 通过类构造器DataFrame(data=None, index=None, columns=None, dtype=None, copy=None)创建, 参数说明: data: 二维表的数据, 类型可以是可迭代对象,二维列表, 字典 或者 DataFrame对象等二维数据, 如果数据是一个字典，列顺序遵循插入顺序。如果字典包含系列 定义了索引，则按其索引对齐。 columns:指定列索引, list类型 index: 指定行索引, list类型 若不指定索引,则默认为 0, 1, 2, 3….. 通过二维列表创建: 123list_2d = [[1, 2], [3, 4]]df = DataFrame(list_2d)print(df) 运行结果: 123 0 10 1 21 3 4 通过列表指定行索引和列索引 12df = DataFrame(list_2d, columns=[&#x27;A&#x27;, &#x27;B&#x27;], index=[&#x27;x&#x27;, &#x27;y&#x27;])print(df) 运行结果: 123 A Bx 1 2y 3 4 通过字典创建, 字典的键会自动转换为列索引 123d = &#123;&#x27;A&#x27;: [1, 3], &#x27;B&#x27;: [2, 4]&#125;df = DataFrame(d, index=[&#x27;x&#x27;, &#x27;y&#x27;])print(df) 运行结果: 123 A B0 1 21 3 4 读取excel文件创建 12df = read_excel(r&quot;data_file\\goods_base.xlsx&quot;)print(df) 查看数据信息: 数据类型 &amp; 处理DataFrame可以看作多个Series组成, 而Series对象有一个dtype属性,用来表示该列的单元格的数据类型, DataFrame对象的dtypes属性表示每一列dtype,数据类型的对应关系如下表所示: 类型 说明 int8/int16/int32/int64(默认) 整型 float16/float32/float64(默认) 浮点型 str/string: 字符串 bool: 布尔 category: 分类 datetime64[ns] 时间戳(纳秒) object python对象混合类型 ==通过convert_dtypes()方法可以进行数据清洗,返回清洗后的数据,建议每次读取到数据时都调用次方法进行数据清洗==, 该方法的作用是:根据单元格的值自动推导并切换成对应的数据类型, 例如 假设 A列的值全部为字符或者文本,就会被推导为string, 若全为数字,就推导为int64 ,全为时间格式就推导为datatime64[ns] 如果既有字符,又有数字或时间, 则会被推导为object(说明数据不干净,需要手动进行数据清洗) **tips:**通过检查dtype属性,可以判断该列的数据是否“干净” , 不干净即列中单元格的值存在多种数据类型, 不利于后续处理和运算 12345678910111213141516171819df = pd.DataFrame([ [&#x27;a&#x27;, &#x27;b&#x27;], [&#x27;c&#x27;, 1],], columns=[&#x27;X&#x27;, &#x27;Y&#x27;])print(df.dtypes)&#x27;&#x27;&#x27;X objectY objectdtype: object&#x27;&#x27;&#x27;# 数据清洗,即自动推导列的数据类型,X列全是字符串,所以会被推导成string,Y是objectdf = df.convert_dtypes()print(df.dtypes)&#x27;&#x27;&#x27;X stringY objectdtype: object&#x27;&#x27;&#x27; 通过astype()系列方法我们可以手动对数据的类型进行强制转换, 接上述例子, 1234567df = df.astype(dtype=&quot;string&quot;) # 讲所有列数据类型转换成 stringprint(df.dtype)&#x27;&#x27;&#x27;X stringY stringdtype: object&#x27;&#x27;&#x27; 关于string类型补充: Accessor 访问器 Series.str可用于以字符串的形式访问Series的值并对其应用一些方法 对于数据类型为string的数据(列) ,注: 这里的string指的是pandas中的数据类型而不是python里的数据类型, 可以应用字符串的常见处理方法如:strip()去除首尾空格或换行符等, split()分割字符串等众多字符串处理函数 示例: 1234567891011121314151617181920212223242526df = pd.DataFrame([ [&#x27;\\na\\n&#x27;, &#x27;\\nd\\n&#x27;, datetime(2020, 1, 1)], [&#x27;\\nb\\n&#x27;, 1, datetime(2020, 1, 2)]], columns=list(&#x27;ABC&#x27;))df = df.convert_dtypes()print(df.dtypes, end=&quot;\\n================\\n&quot;)# 讲A列转换成字符串并且, 去除首尾的 \\nprint(df[&quot;A&quot;], end=&quot;\\n================\\n&quot;)df[&quot;A&quot;] = df[&quot;A&quot;].str.strip() # 去除 A列首尾的 换行符print(df[&quot;A&quot;], end=&quot;\\n================\\n&quot;)# 讲B列转换成字符串并且, 去除首尾的 \\nprint(df[&quot;B&quot;], end=&quot;\\n================\\n&quot;)df[&quot;B&quot;] = df[&quot;B&quot;].astype(&quot;string&quot;).str.strip()print(df[&quot;B&quot;], end=&quot;\\n================\\n&quot;)# 讲C列的时间格式转换成print(df[&quot;C&quot;], end=&quot;\\n================\\n&quot;)df[&quot;C&quot;] = df[&quot;C&quot;].astype(&quot;string&quot;).str.split(&quot;-&quot;)# 注意: C列此时还是object类型是因为 C列虽然不是时间戳格式,但也不是字符串,而是split()返回的一个分割好的字符串列表# df[&quot;C&quot;] = df[&quot;C&quot;].astype(&quot;string&quot;) # 想彻底转成字符串则需要这行代码print(df[&quot;C&quot;], end=&quot;\\n================\\n&quot;)print(df) 运行结果: 12345678910111213141516171819202122232425262728293031323334353637A stringB objectC datetime64[ns]dtype: object================0 a1 bName: A, dtype: string================0 a1 bName: A, dtype: string================0 \\nd\\n1 1Name: B, dtype: object================0 d1 1Name: B, dtype: string================0 2020-01-011 2020-01-02Name: C, dtype: datetime64[ns]================0 [2020, 01, 01]1 [2020, 01, 02]Name: C, dtype: object================ A B C0 a d [2020, 01, 01]1 b 1 [2020, 01, 02] selecting: dtypes通过select_dtypes()方法可以根据列的数据类型进行列的投影运算 12345678910111213141516171819df = pd.DataFrame([ [&#x27;a&#x27;, &#x27;b&#x27;], [&#x27;c&#x27;, 1],], columns=[&#x27;X&#x27;, &#x27;Y&#x27;])print(df)&#x27;&#x27;&#x27; X Y0 a b1 c 1&#x27;&#x27;&#x27;df = df.convert_dtypes() # 数据清洗,即自动推导列的数据类型,X列全是字符串,所以会被推导成string,Y是object# 投影出里类型为 string 的列, print(df.select_dtypes(include=&quot;string&quot;))&#x27;&#x27;&#x27; X0 a1 c&#x27;&#x27;&#x27; selecting:dict-likeSeries &amp; DataFrame 是dict-like, 即有着类似字典的取值操作 Series可以像字典一样根据key 来取值, 其中key就相当于行索引 12345s = pd.Series( &#123;&#x27;A&#x27;: 1, &#x27;B&#x27;: 2, &#x27;C&#x27;: 3&#125;)print(s[&#x27;B&#x27;]) # 2print(s[1]) # 2 Series若要多选取值, 则将键设置为一个列表,如下所示, 在[]是一个列表时, 则会返回一个Series对象 1234print(s[[&#x27;B&#x27;, &#x27;C&#x27;]]) # 即 s.get([&#x27;B&#x27;, &#x27;C&#x27;])# 即 s.get([True, False, True]]), 此种方式布尔值元素要和行数对应print(s[[True, False, True]]) 运行结果: 123456B 2C 3dtype: int64A 1C 3dtype: int64 tips: 键为list,list的元素可以是布尔类型,因此可以通过此方式来定义规则筛选出需要的行 Series重载了逻辑运算符, 当Series对象进行逻辑运行时, 运算的结果是一个新的Series对象, 只不过这个对象的数据是经过运算后的布尔值, 以上述例子为例: s &gt;1 得到的结果是 Series( {A:False, ‘B’: True, ‘C’: True} ) 例如: 1print(s[[s&gt;1]]) # 筛选出 值 大于 1 的行 DataFrame: DataFrame 也同理 , 不过若DataFrame的列不为int,则不能使用int作为索引,这点与Series不同 12345678df = pd.DataFrame(&#123; &#x27;A&#x27;: [1, 4, 7], &#x27;B&#x27;: [2, 5, 8], &#x27;C&#x27;: [3, 6, 9],&#125;, index=list(&#x27;XYZ&#x27;))print(df[&#x27;B&#x27;]) # 返回符合的 Series 对象# print(df[1]) # error 运行结果: 1234X 2Y 5Z 8Name: B, dtype: int64 同理, DataFrame若要多选取值, 则将键设置为一个列表,如下所示, 在[]里是一个列表时, 会返回一个DataFrame对象 , 12print(df[[&#x27;B&#x27;, &#x27;C&#x27;]]) # df.get([&#x27;B&#x27;, &#x27;C&#x27;])print(df[[True, False, True]]) # df.get([True, False, True]) 运行结果: 1234567 B CX 2 3Y 5 6Z 8 9 A B CX 1 2 3Z 7 8 9 tips: 键为list,list的元素可以是布尔类型,因此可以通过此方式来定义规则筛选出需要的行 (注意此种方式筛选的是行而不是列) 相当于将DataFrame的列当成了Series进行逻辑运行, 例如: df[‘B’] &gt; 2的结果是: Series( {‘X’: False, ‘Y’: True, ‘Z’: True} ) 例如: 12df[df[&#x27;B&#x27;] &gt; 2] # 相当于sql语句的: select * from df where B &gt; 2df[(df[&#x27;B&#x27;] &gt; 2) &amp; (df[&#x27;B&#x27;] &lt; 6)] # sql: select * from df where B&gt;2 and B&lt;6 selecting: list-likeSeries &amp; DataFrame 同样有着类似数组的取值方式 需要注意的是: 使用数字索引取值是含头不含尾, 使用名称索引取值时含头又含尾, 语法规则与python的列表规则一致 Series 示例: 12345s = pd.Series( &#123;&#x27;A&#x27;: 1, &#x27;B&#x27;: 2, &#x27;C&#x27;: 3&#125; )print(s[0:2]) # 返回一个Series对象,整数索引,从0开始print(s[0:-1]) # -1 代表最后一个, 倒数第二个为 -2print(s[::-1]) # 步长为负数, 倒序取值print(s[&#x27;A&#x27;:&#x27;B&#x27;]) # 含头含尾 运行结果: 12345678910111213141516A 1B 2dtype: int64A 1B 2dtype: int64C 3B 2A 1dtype: int64A 1B 2dtype: int64 DataFrame 示例: 注意是行筛选,填的索引是行索引(名称) 12345678df = pd.DataFrame(&#123; &#x27;A&#x27;: [1, 4, 7], &#x27;B&#x27;: [2, 5, 8], &#x27;C&#x27;: [3, 6, 9],&#125;, index=list(&#x27;XYZ&#x27;))print(df[0:2])print(df[&#x27;X&#x27;:&#x27;Z&#x27;]) 运行结果: 12345678 A B CX 1 2 3Y 4 5 6 A B CX 1 2 3Y 4 5 6Z 3, 6, 9 selecting: locloc即location , 定位的缩写, 通过指定行或者指定行列来选择数据, 值为一个经过数据筛选的DataFrame对象 1df.loc[row_indexer, column_indexer] 其中column_indexer 是可选项 ,以下图举例: 123456789101112131415161718df = pd.DataFrame([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], columns=list(&#x27;ABCD&#x27;), index=list(&#x27;XYZ&#x27;))df.loc[&#x27;X&#x27;] # 选中 x 行, 注意: 若填入行索引, 返回的是一个Series对象df.loc[&#x27;X&#x27;, &#x27;B&#x27;] # 选中x行, B列 的交集df.loc[[&#x27;X&#x27;, &#x27;Y&#x27;], [&#x27;B&#x27;, &#x27;D&#x27;]] # 选中 x,y两行,B,D两列 的交集df.loc[&#x27;X&#x27;:&#x27;Y&#x27;, [&#x27;B&#x27;, &#x27;D&#x27;]] # 也可以多种选中方式混合使用, 选中, x到y行, B,D两列的交集 df.loc[[True, False, True], [True, True, True, False]] # X,Y行,A,B,C列的交集df.loc[callable1, callable2] # 传入两个函数或lambda表达式,自定义筛选规则 selecting: iloc与 loc类似,唯一区别是iloc是通过整数索引来取值, 注意切片(如 [0:3]) 时,整数索引含头不含尾, 数据的赋值修改通过上述几种selecting选择方式,选择对应的区域后 , 除了可以拿到对应区域的值以外, 还可以对选择的区域进行赋值, 1234567s.loc[&#x27;C&#x27;:&#x27;D&#x27;] = 30 # 将C到D行都赋值为30df[&#x27;A&#x27;] = 100 # 将A列整列所有内容全部修改为100 df[&#x27;B&#x27;] = df[&#x27;B&#x27;] * 10 # 将B列所有内容扩到为原来的10倍df[&#x27;E&#x27;] = df[&#x27;C&#x27;] + df[&#x27;D&#x27;] # 设置E列的值为C列+D列,若不存在E列则新建E列df.loc[df[&#x27;E&#x27;]&gt;10, &#x27;E&#x27;] = 200 # 选择 E列大于10的行和E列的交集, 然后将这些区域赋值为200 运算_缺失值填充 pandas库依赖于numpy库, 所以其NaN实际上是 numpy.NaN 对于Series和DataFrame的加减乘除运算,其运算规则是: 根据索引匹配单元格的进行运算,没匹配的当作NaN,并且对行列进行取补集 此外, 在python里, 0 作为除数会抛出异常, 但是在pandas中对0作为除数做了特殊处理: 即任何数除以0的结果都是无穷大 1231 / 0 == inf-1 /0 == -inf # 注: pandasz中 inf 视为无穷大常量, 为单词infinity的简写 我们可以将无穷也设置为当作NaN处理,只需要添加下面这行代码: 1pandas.options.mode.use_inf_as_na = True Series运算示例: 加减乘除同理 1234s1 = pd.Series(&#123; &quot;A&quot;: 1, &quot;B&quot;: 2, &quot;C&quot;: 3&#125;)s2 = pd.Series(&#123;&quot;B&quot;: 4,&quot;C&quot;: 5,&quot;D&quot;: 6&#125;)print(s1.add(s2)) # 等同于 s1 + s2 DataFrame运算示例: 12345678910111213141516171819df1 = pd.DataFrame( &#123; &quot;A&quot;: [1, 4], &quot;B&quot;: [2, 5], &quot;C&quot;: [3, 6] &#125;, index=[&#x27;x&#x27;, &#x27;y&#x27;])df2 = pd.DataFrame( &#123; &quot;B&quot;: [10, 40], &quot;C&quot;: [20, 50], &quot;D&quot;: [30, 60] &#125;, index=[&#x27;y&#x27;, &#x27;z&#x27;])print(df1.add(df2)) # 等同于 df1 + df2 通过上述例子不难发现,pandas对于含有NaN的运算默认情况下这样处理的:任意数对NaN进行加减乘除的运算结果均为NaN , 这很显然有时候并不符合我们的需求, 可以通过运算方法的关键参数fill_value来对缺失值进行填充处理 将上述例子改写: 123456789101112131415161718print( s1.add(s2, fill_value=0) ) # 运行结果:&#x27;&#x27;&#x27;A 1.0B 6.0C 8.0D 6.0dtype: float64&#x27;&#x27;&#x27;print( pd.DataFrame.add(df1, df2, fill_value=0) )&#x27;&#x27;&#x27;运行结果: A B C Dx 1.0 2.0 3.0 NaNy 4.0 15.0 26.0 30.0z NaN 40.0 50.0 60.0&#x27;&#x27;&#x27; 注: ==此方法能解决NaN与任意实数进行运算,但观察上述例子可以发现对于NaN与NaN之间的运算还是无法解决==, 如: zA , xD MultiIndex 复合索引复合索引指的是多层列索引,对应excel表格结构如下图所示: 从Excel文件中读取含有复合索引的表格, 只需要设置参数header为列表即可, 例如: 1df = pd.read_excel(r&quot;data_file\\jd_tb.xlsx&quot;, header=[0, 1]) DataFrame创建复合索引有两种方式: index或columns属性传入二维list-like ​ 例如: 1234567df = pd.DataFrame(data,columns=[ [&#x27;京东&#x27;, &#x27;京东&#x27;, &#x27;淘宝&#x27;, &#x27;淘宝&#x27;], [&#x27;销量&#x27;, &#x27;售价&#x27;, &#x27;销量&#x27;, &#x27;售价&#x27;], ]) 调用pandas.MultiIndex的相关方法进行创建: , 常用的有如下几种方法: 1234pd.MultiIndex.from_product() # 笛卡尔积pd.MultiIndex.from_arrays() # 数组pd.MultiIndex.from_tuples() # 元组pd.MultiIndex.from_frame() # DataFrame 例如将上述表格进行汇总,并连接汇总表,实现代码如下: 123456789101112131415161718192021222324252627df = pd.read_excel(r&quot;data_file\\jd_tb.xlsx&quot;, header=[0, 1])sum_df = df[&quot;京东&quot;] + df[&quot;淘宝&quot;] # 汇总表# 给汇总表增加 复合列索引# 通过元组生成复合索引# sum_df.columns = pd.MultiIndex.from_tuples(# [# (&quot;汇总&quot;, &quot;销量&quot;),# (&quot;汇总&quot;, &quot;售价&quot;),# ]# )# 通过笛卡尔积生成复合索引, 两者效果一致,笛卡尔积因为灵活更常用,sum_df.columns = pd.MultiIndex.from_product( [ [&quot;汇总&quot;], sum_df.columns ])print(df.join(sum_df))&#x27;&#x27;&#x27;运行结果: 京东 淘宝 汇总 销量 售价 销量 售价 销量 售价0 0 1 2 3 2 41 4 5 6 7 10 12&#x27;&#x27;&#x27; 列连接与行连接列连接:即表格的连接, 类似sql中的join, 在pandas中同样是调用join()方法返回连接后的结果(两个表本身不会改变),此外还可以根据参数选择左连接和右连接,详情参考官方文档, 例如上节例子中: 12345678910111213141516171819202122print(df)&#x27;&#x27;&#x27; 京东 淘宝 销量 售价 销量 售价0 0 1 2 31 4 5 6 7&#x27;&#x27;&#x27;print(sum_df)&#x27;&#x27;&#x27; 汇总 销量 售价0 2 41 10 12&#x27;&#x27;&#x27;# join 默认右连接print(df.join(sum_df))&#x27;&#x27;&#x27; 京东 淘宝 汇总 销量 售价 销量 售价 销量 售价0 0 1 2 3 2 41 4 5 6 7 10 12&#x27;&#x27;&#x27; **行连接:**即将两个表的数据行进行合并, 调用pandas.concat()函数实现, 默认情况是从后追加拼接, 该函数必须入一个数组,会把数组元素进进行 行连接, 默认情况下会保留原来的行索引, 可通过设置参数忽略, 例如: 123456789101112131415161718192021222324252627282930313233343536df1 = pd.DataFrame( &#123; &quot;A&quot;: [1, 2], &quot;B&quot;: [3, 4] &#125;)print(df1)&#x27;&#x27;&#x27; A B0 1 31 2 4&#x27;&#x27;&#x27;df2 = pd.DataFrame( &#123; &quot;A&quot;: [5, 6], &quot;B&quot;: [7, 8] &#125;)print(df2)&#x27;&#x27;&#x27; A B0 5 71 6 8&#x27;&#x27;&#x27;# print(df1.append(df2)) # 此方法也可实现,但已经弃用,将在未来版本删除print(pd.concat([df1, df2], ignore_index=True))&#x27;&#x27;&#x27;若不设置ignore_index为True,则行索引index = [0, 1, 0, 1] A B0 1 31 2 42 5 73 6 8&#x27;&#x27;&#x27; 读取excel文件:通过read_excel()函数可以读取excel文件, 该函数有很多参数,参数如下: io : excel文件路径或者文件输出流 选择子表sheetsheet_name: 一个excel文件中有很多子表sheet,也叫工作表, 这个参数用于指定子表, , 参数支持的类型有: str, int,list, 默认为0, 即读取第一个子表 , 值为None时全选所有子表 设置表头,行索引header: 指定作为表头的行数即列索引, 索引从0开始,默认为 0 names: 列表类型,自定义表头, 注意, 如果自定义表头, 需要指定header=None , 否则数据会错误 index_col: 指定index(行标签)使用哪些列,即行索引 筛选列usecols: 指定只读取哪些列, 支持以下几种类型: None: 全部(默认) int-list: [0, 2] , 若参数类型为列表,并且列表元素均为int , 根据列表元素的值作为选中列的索引, str-list: [‘AAA’, ‘CCC’]: 若参数类型为列表,并且列表元素均为str , 选择列内容与列表元素匹配的列, 本例中[&#39;AAA&#39;, &#39;CCC&#39;]表示选中下图的 A列 和 C列, 因为只有两列内容匹配参数列表, ==(推荐: 这种形式可读性和可拓展性较高)== str: ‘A,C’或 ‘A,C:E’: 参数类型为字符串序列,根据字符串系列元素匹配的列标识, 本例中‘A,C’或A,C:E选中的f分别是: A列C列, 或 A, C, D, E列 函数: lambda x: x == ‘CCC’: 此外还可以**传入一个函数表达式,进行自定义筛选逻辑,根据返回的布尔值进行判断, 本例子中是选中了列内容为‘CCC’ , 即为CCC列 跳过行, 指定范围行skiprows: 参数类型可以为 int 或者 list, 若为int, 则表示读取文件是跳过指定哪一行(索引从0开始) , 如果为list, 则要求元素类型均为int, 将列表元素作为跳过行的索引 nrows: int, 默认 None , 要解析的行数 , 从上往下数,不包括表头(行索引)。 设置列的数据类型dtypes: 此参数为字典类型 ,默认为None,自动推导 1dtype = &#123;&#x27;a&#x27;: &#x27;float64&#x27;, &#x27;b&#x27;: &#x27;int32&#x27;&#125; pandas的数据类型对应关系如下表所示: 类型 说明 int8/int16/int32/int64(默认) 整型 float16/float32/float64(默认) 浮点型 str/string: 字符串 bool: 布尔 category: 分类 datetime64[ns] 时间戳(纳秒) object python对象混合类型 注意: str, string: 并不等同 日期格式处理parse_dates: 此参数可指定需要解析日期格式的列, 将其转换为datetime64[ns]类型便于后续处理 , 默认为Flase,当参数为不同类型时有不同的处理形式: True: 试用内置的解析方法自动解析所有可能为日期格式的列 [0, 1] 或 [‘a’, ‘b’] 指定需要转为日期格式的列, 此例中指定的是 第一列和第二列(根据0,1索引) 或 转换列内容含有列名为 ‘a’ 和 ‘b’的列 [[0, 1, 2]] : 结合多列解析为单个日期列, 将 前三列合并为一列转换为日期格式, {‘日期’: [0, 1, 2]} : 同上, 结果的列名改为’日期’ date_parser: 与上面的参数配合使用, 自定义日期格式解析器 , 接收一个lambda表达式, 可调用pandas.to_datetime()方法来自定义解析解析日期格式的规则, 例如 将表格中 2002年10⽉03⽇这种解析 1date_parser=lambda x: pd.to_datetime(x, format=&#x27;%Y年%m⽉%d⽇&#x27;) 缺失值处理excel中当数据发生错误时, 会产生’#N/A’ 这种, 这叫我们就叫做缺失值, 在pandas中用NaN表示, na_values : 此参数可以设置读取文件时缺失值的处理, 根据参数类型不同处理方式如下: 值为一个 任意数据 如 0, ‘a’ 这种标量时, 会将表中的此标量替换为 NaN 进行处理 类型为列表时, 表中存在有列表中任意一个元素都将替换为NaN 类型为字典时,指定需要解析的列,默认情况下是解析全局的, 视字典的键为列名, 将该列中值与字典的值相同的替换为NaN 例: 1234na_values=0 # 将 0 解析为 NaN na_values=&#x27; &#x27; # 将 空格 解析为 NaNna_values=[&#x27; &#x27;, 0] #将 空格和 0 解析为 NaNna_values=&#123;&#x27;价格&#x27;: [&#x27; &#x27;, 0]&#125; # 将 &quot;价格&quot; 列 中的 空格和0解析为NaN 布尔值处理true_values: 参数类型为list, 将表格中含有list元素的值替换为True false_values: 参数类型为list, 将表格中含有list元素的值替换为False 注意: 上述参数以列为原子单位进行解析转换, 也就是说如果一个列中存在无法转换成True或者False的值,那么这整个列都不会转换 任意值处理converters: dict, 默认 None , 用于值转换, 字典的值可以是一个lambda表达式 例如: 1234converters=&#123;&quot;a&quot;: lambda x: x +1, # &quot;a&quot; -&gt; 0&quot;b&quot;: lambda x: x * 2, # &quot;b&quot; -&gt; 1&#125; 此外, 还可以用来进行数据清洗, 去除列名的空格 1234converters=&#123; # &#x27;货号&#x27;: lambda x: x.strip(), &#x27;货号&#x27;: str.strip&#125; 千位分隔符 浮点数取整处理 重复行处理:mangle_dupe_cols: 参数类型为bool , 是否重命名重复列名 , 默认True 写入excel文件通过如下方法可对excel文件的单个sheet表进行写入 1234567DataFrame.to_excel( excel_writer, # ⽂件路径/ExcelWriter sheet_name=&#x27;Sheet1&#x27;, # sheet名字,如需写入多个sheet,需要用到ExcelWriter对象 index=True, # 是否输出index,即行索引 float_format=None, # 浮点数输出格式, 如: &quot;%.2f&quot; na_rep=&#x27;&#x27;, # 缺失值输出的表示形式) ExcelWriter类ExcelWriter类可以使我们更方便的批量写入excel文件数据 123456class pandas.ExcelWriter( path, # xls/xlsx ⽂件路径, mode, # 追加或重写模式 值为 &#x27;a&#x27; 或者 &#x27;w&#x27; ,默认 &#x27;w&#x27; if_sheet_exists, # 当试图写入一个已经存在的表时的行为(仅限追加模式可用) datetime_format=None, # datatime输出格式,默认: &#x27;YYYY-MM-DD HH:MM:SS&#x27;) 此外, 使用ExcelWriter类可以配合with语句使用, 可以大大提高我们的写入效率 1234567891011121314151617181920212223import pandas as pdfrom datetime import datetime, datedf1 = pd.DataFrame( &#123;&#x27;日期&#x27;: [date(2020, 1, 1), date(2020, 1, 2)], &#x27;销量&#x27;: [10, 20], &#125;,)df2 = pd.DataFrame( &#123;&#x27;日期&#x27;: [date(2020, 2, 1), date(2020, 2, 2)], &#x27;销量&#x27;: [15, 25]&#125;,)print(df1)print(df2)with pd.ExcelWriter(&#x27;tb.xlsx&#x27;, date_format=&#x27;YYYY/MM/DD&#x27; ) as writer: df1.to_excel(writer, sheet_name=&#x27;1月&#x27;, index=False) df2.to_excel(writer, sheet_name=&#x27;2月&#x27;, index=False) 注: 经测试,时间日期格式仅能转换为: YYYY/MM/DD , YYYY/MM/DD HH:MM:SS 或YYYY-MM-DD , YYYY-MM-DD HH:MM:SS CSV文件读写通过DataFrame对象的read_csv() 和 to_csv()可以对CSV文件进行读写 , 两个方法常用参数大致相同, 除此之外, 很多筛选行列的参数例如usecols等和read_excel()类似, 详情查询文档使用 1234567891011DataFrame.to_csv(path_or_buf, # 路径sep=&#x27;,&#x27;, # 分隔符encoding=&#x27;utf8&#x27; # gbk, gb2312, gb18030) DataFrame.read_csv(filepath, # 路径sep=&#x27;,&#x27;, # 分隔符encoding=&#x27;utf8&#x27; # gbk, gb2312, gb18030) group by 分组类似sql的 group by 分组, 详情参考官方文档 图像识别ddddocr 验证码识别 项目地址： 点我传送 , 国内地址 简介: ddddocr是由sml2h3开发的专为验证码厂商进行对自家新版本验证码难易强度进行验证的一个python库，其由作者与kerlomz共同合作完成，通过大批量生成随机数据后进行深度网络训练，本身并非针对任何一家验证码厂商而制作，本库使用效果完全靠玄学，可能可以识别，可能不能识别。 ddddocr奉行着开箱即用、最简依赖的理念，尽量减少用户的配置和使用成本，希望给每一位测试者带来舒适的体验 环境支持: python &lt;= 3.9Windows/Linux/Macos.. 暂时不支持Macbook M1(X)，M1(X)用户需要自己编译onnxruntime才可以使用 安装: 1pip install ddddocr 无法安装尝试更新pip 文字识别验证在1.2.0开始，ddddocr的识别部分进行了一次beta更新，主要更新在于网络结构主体的升级，其训练数据并没有发生过多的改变，所以理论上在识别结果上，原先可能识别效果的很好的图形在1.2.0上有一小部分概率会有一定程度的下降，也有可能原本识别不好的图形在1.2.0之后效果却变得特别好。 classification()函数, 除了ocr外, 还能用于图片验证码,识别率高 测试代码： 123456789import ddddocr as docrocr = docr.DdddOcr()with open(r&quot;test_imges\\af6y.png&quot;, &#x27;rb&#x27;) as f: image = f.read()res = ocr.classification(image)print(res) 点击文字验证目标检测部分同样也是由大量随机合成数据训练而成，对于现在已有的点选验证码图片或者未知的验证码图片都有可能具备一定的识别能力，适用于文字点选和图标点选。 简单来说，对于点选类的验证码，可以快速的检测出图片上的文字或者图标。 123456789101112131415161718192021import ddddocrimport cv2det = ddddocr.DdddOcr(det=True)with open(r&quot;test_imges\\click_img.png&quot;, &#x27;rb&#x27;) as f: image = f.read()poses = det.detection(image)print(poses)# cv2的图片读写方法, 图片路径不支持中文!!!im = cv2.imread(&quot;test_imges\\click_img.png&quot;)for box in poses: x1, y1, x2, y2 = box print(box) im = cv2.rectangle(im, (x1, y1), (x2, y2), color=(0, 0, 255), thickness=2)cv2.imwrite(&quot;result.jpg&quot;, im) 滑块验证更多详情参考文档 文字,文章扫描 百度云: 百度智能云-管理中心 (baidu.com) 经过测试, 百度云的ocr在线api对图片文本的扫描结果最好, 详情查看百度官网: 步骤参考: Python教程：利用百度API进行批量图片OCR识别_ 虚拟环境参考链接 ： pycharm的virtualenv、pipenv、conda详解_pycharm virtualenv_任识算法的博客-CSDN博客 项目打包,发布Python是一个脚本语言，被解释器解释执行。它的发布方式： .py文件：对于开源项目或者源码没那么重要的，直接提供源码，需要使用者自行安装Python并且安装依赖的各种库。（Python官方的各种安装包就是这样做的） .pyc文件：有些公司或个人因为机密或者各种原因，不愿意源码被运行者看到，可以使用pyc文件发布，pyc文件是Python解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的Python和依赖库。 可执行文件：对于非码农用户或者一些小白用户，你让他装个Python同时还要折腾一堆依赖库，那简直是个灾难。对于此类用户，最简单的方式就是提供一个可执行文件，只需要把用法告诉Ta即可。比较麻烦的是需要针对不同平台需要打包不同的可执行文件（Windows,Linux,Mac,…）。 打包成可执行文件需要用到一个三方库: pyinstaller ,安装: pip install pyinstaller PyInstaller是一个十分有用的第三方库，它能够在Windows、Linux、 Mac OS X 等操作系统下将 Python 源文件打包，通过对源文件打包， Python 程序可以在没有安装 Python 的环境中运行，也可以作为一个 独立文件方便传递和管理。 pyinstaller工作原理 先生成一个spec文件（手动或自动均可），该文件决定了实际编译规则 再自动生成一个build文件夹，所有自动编译的中间产物都放在其中 最后生成dist文件夹，存放编译输出 单文件打包: pyinstaller xxx.py 多文件打包: 先自动生成spec文件： pyi-makespec xxx.py 再根据自己的实际需求手动修改spec文件 最后统一installer： pyinstaller xxx.spec spec文件解析: 123456789Analysis: [&#x27;Console.py&#x27;,&#x27;xxx.py&#x27;...] &lt;- 此处列出的脚本生成exe后会按顺序依次执行！ pathex &lt;- 此处为搜索路径 binaries &lt;- 非python的库文件 datas &lt;- ini文件，字体，图片，icon什么的 pure &lt;- python模块PYZ: &lt;- 不用管EXE: &lt;- 输出配置COLLECT: &lt;- 不用管 pyinstaller重要命令参数F 生成一个单一可执行文件【常用】 w 禁止弹出控制台【常用】,如果调用了input()则会报错 i 修改exe生成的图标【常用】 h 打印帮助信息 v 打印版本信息 d 生成带各种依赖的文件夹，包含exe，dll,以及其他文件 p 指定搜索路径 常见问题打包后的文件太大了: 最好的办法是：在一个虚拟环境中单独打包，只打包该程序执行所必备的依赖库, 例如在pycharm的终端中新建虚拟终端: 无法正常使用: 路径问题。 依赖包的问题。 依赖包问题可以通过清除缓存重新打包解决 ==python脚本执行的默认路径和exe打包后的路径是不一样的，如果软件中存在文件读取等操作，很有可能导致exe找不到资源而运行出错。== https://blog.csdn.net/weixin_39879122/article/details/110754872 路径问题补充:pyinstaller打包好一个exe后，运行此exe，会把此文件解压缩到C:\\Users\\xxxx\\AppData\\Local\\Temp\\ 目录下，然后运行。而配置文件一般放置在exe同级别目录下。提供几个解决思路: 12345# 获取 程序文件的文件夹路径os.path.dirname(os.path.realpath(__file__))# 通过相对路径获取 程序文件的文件的父级路径的父级路径print(path.realpath(r&quot;..\\..\\.&quot;)) 来获取目录，会定位到解压缩后的地址。 附各种获取文件目录的方法，可以对比尝试下： 12345678910import os, sys print(&#x27;__file__:&#x27;, __file__) # 当前运行的绝对路径全脚本文件名print(&#x27;realpath of __file__:&#x27;, os.path.realpath(__file__))print(&#x27;sys.executable:&#x27;, sys.executable) # 执行程序所在路径print(&#x27;realpath of sys.executable:&#x27;, os.path.realpath(sys.executable))print(&#x27;sys.argv[0]:&#x27;, sys.argv[0])print(&#x27;realpath of sys.argv[0]:&#x27;, os.path.realpath(sys.argv[0]))print(&#x27;sys.path[0]:&#x27;, sys.path[0])print(&#x27;realpath of sys.path[0]:&#x27;, os.path.realpath(sys.path[0])) 源码打包首先，创建一个 setup.py 文件，其内容如下： 123456789101112from distutils.core import setupsetup( name=&#x27;your_package_name&#x27;, version=&#x27;0.1&#x27;, packages=[&#x27;your_package_name&#x27;], install_requires=[ &#x27;dependency1&#x27;, &#x27;dependency2&#x27;, # ... ]) 其中，替换 your_package_name 为你的包名称，dependency1、dependency2 等为你的依赖包。 最后，运行命令： python setup.py sdist 这将在当前目录下创建一个 dist 目录，其中包含了打包的源代码和依赖包的 tar.gz 文件。您可以将此文件发送给您的用户，让他们安装依赖包: 1pip install your_package_name-0.1.tar.gz 查看项目所需依赖包通过pipreqs工具可以生成项目所有依赖包的清单 **首先安装: **pip install pipreqs 进入到python项目主目录: 1pipreqs ./ --encoding=utf8 完成上面命令会生成requirements.txt , 在需要的安装依赖的主机执行安装: 1pip install -r requirements.txt","categories":[{"name":"python系列","slug":"python系列","permalink":"https://lqy679.github.io/categories/python%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"开发随笔1","slug":"开发随笔1","date":"2020-01-01T00:00:00.000Z","updated":"2023-02-23T12:59:03.539Z","comments":true,"path":"2020/01/01/开发随笔1/","link":"","permalink":"https://lqy679.github.io/2020/01/01/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%941/","excerpt":"关于mysql存储时间类型数据只精确到秒最近在对自己编写的接口进行单元测试时, 发现一个问题: 将Java的Date对象存入mysql时, 在通过Data对象来查询,发现查询不到! 代码如下:","text":"关于mysql存储时间类型数据只精确到秒最近在对自己编写的接口进行单元测试时, 发现一个问题: 将Java的Date对象存入mysql时, 在通过Data对象来查询,发现查询不到! 代码如下: 实体类结构 1234567891011121314151617181920@Data@NoArgsConstructor@AllArgsConstructorpublic class Order &#123; public static final String BeIng = &quot;Be_Ing&quot;; public static final String WaitPay = &quot;Wait_Pay&quot;; public static final String Finished = &quot;Finished&quot;; public static final String Close = &quot;Close&quot;;// 订单编号, 由用户id,车辆编号和时间戳三者用 - 连接 private String order_id;// 第三方交易号 private String trade_no;// 交易类型 private String trade_type; private double amount; private String order_status; private Date start_time; private Date end_time;&#125; 通过如下方法进行插入数据: 12345678910111213141516171819@Autowired OrderMapper orderMapper; @Test public void testAdd()&#123; for (int i=1; i&lt;5; i++)&#123; Date date = new Date(); String s = &quot;&quot; + i; Order order = new Order( &quot;u100&quot;+s+&quot;-b100&quot;+s+&quot;-&quot;+date.getTime(), &quot;888888&quot;, Order.AliPay, 0, Order.BeIng, date, date ); orderMapper.addOrder(order); &#125; &#125; 上述方法向数据库中插入数据, order_id同时也记录了时间戳信息, 注意: order_id后缀的时间戳,是和start_time表示的时间对应的时间戳应该是一致的 这时我尝试测试根据start_time查询数据 12345678910111213@Test public void test_getOrderByStart_time()&#123; // 参数的时间戳 是我从数据表中找了一个 order_id后缀的时间戳 List&lt;Order&gt; list = orderMapper.getOrderByStart_time(new Date(1677138162002L)); if (list.isEmpty())&#123; System.err.println(&quot;查询为空!!!&quot;); &#125; else &#123; for (Order order : list) &#123; System.out.println(order); &#125; &#125; &#125; 运行之后发现居然查询不到, 这让我表示很困惑, 明明是一样的时间戳存入的时间类型数据, 居然找不到 解决与总结:后来我询问老师, 经过讲解后知道 mysql在存入时间类型数据时,只会精确到秒(时间戳是按毫秒算的) 实践检验我们尝试通过order_id来查询到该数据的start_time,并将其转换成时间戳来与order_id后缀时间戳来进行对比 1234@Test public void test_getOrderByOrder_id()&#123; System.out.println(orderMapper.getOrderByOrder_id(&quot;u1001-b1001-1677138162002&quot;).getStart_time().getTime()); &#125; 运行后发现打印结果为: 11677138162000 果然,后面全是0,说明是将毫秒数去除了,只会将时间精确到秒","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://lqy679.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[]}],"categories":[{"name":"时记杂谈","slug":"时记杂谈","permalink":"https://lqy679.github.io/categories/%E6%97%B6%E8%AE%B0%E6%9D%82%E8%B0%88/"},{"name":"Java系列","slug":"Java系列","permalink":"https://lqy679.github.io/categories/Java%E7%B3%BB%E5%88%97/"},{"name":"运维","slug":"运维","permalink":"https://lqy679.github.io/categories/%E8%BF%90%E7%BB%B4/"},{"name":"大前端","slug":"大前端","permalink":"https://lqy679.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"常用知识笔记","slug":"常用知识笔记","permalink":"https://lqy679.github.io/categories/%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"https://lqy679.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机基础理论","slug":"计算机基础理论","permalink":"https://lqy679.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"},{"name":"第三方服务接口调用","slug":"第三方服务接口调用","permalink":"https://lqy679.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"},{"name":"python系列","slug":"python系列","permalink":"https://lqy679.github.io/categories/python%E7%B3%BB%E5%88%97/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://lqy679.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[]}