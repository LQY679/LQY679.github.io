<!DOCTYPE html>
<html lang="zh-CN">
<head>

  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lqy679.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="文件类与IO流File类构造方法(并不真正创建文件):File(Stirng filename): 其中的参数是文件名,默认放在当前程序同一目录File(Stirng 路径, String filename):Fiel(String dir ,Stirng filemane): 其dir指目录注意: 注意区别相对路径(相对于src)和绝对路径(磁盘目录)">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE进阶">
<meta property="og:url" content="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="南城记录倌">
<meta property="og:description" content="文件类与IO流File类构造方法(并不真正创建文件):File(Stirng filename): 其中的参数是文件名,默认放在当前程序同一目录File(Stirng 路径, String filename):Fiel(String dir ,Stirng filemane): 其dir指目录注意: 注意区别相对路径(相对于src)和绝对路径(磁盘目录)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/1628918777119660-16472196645138.png">
<meta property="og:image" content="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/1627282677584841.png">
<meta property="og:image" content="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/1627284534340532.png">
<meta property="og:image" content="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/1627474551819780.png">
<meta property="og:image" content="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/1625803842920030.png">
<meta property="og:image" content="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/1625920196785255.png">
<meta property="og:image" content="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/1628121629422875.png">
<meta property="article:published_time" content="2020-01-01T10:57:32.000Z">
<meta property="article:modified_time" content="2023-02-22T08:03:37.555Z">
<meta property="article:author" content="Luo Qianyou">
<meta property="article:tag" content="Java,Python,web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/1628918777119660-16472196645138.png">


<link rel="canonical" href="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/","path":"2020/01/01/javaSE进阶/","title":"JavaSE进阶"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JavaSE进阶 | 南城记录倌</title>
  








  <!--
    引用自作者
    <script src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
  -->
  <script src="/live2d-widget/autoload.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">
      <img class="custom-logo-image" src="/site_images/logo.jpg" alt="南城记录倌">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">南城记录倌</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">往昔皆为过眼云烟,一切尽随风而逝;此刻之行终将化未来的救赎之刃</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">33</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E4%B8%8EIO%E6%B5%81"><span class="nav-number">1.</span> <span class="nav-text">文件类与IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#File%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">File类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E5%B9%B6%E4%B8%8D%E7%9C%9F%E6%AD%A3%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">构造方法(并不真正创建文件):</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">常用方法:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputStream-OutputStream-%E5%AD%97%E8%8A%82%E6%B5%81IO%E6%B5%81"><span class="nav-number">1.2.</span> <span class="nav-text">InputStream,OutputStream,字节流IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">文件字节输入输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">常用方法:</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%B5%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.2.1.</span> <span class="nav-text">输入流方法:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%B5%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.2.2.</span> <span class="nav-text">输出流方法:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InputStreamReader-InputStreamWriter-%E5%AD%97%E7%AC%A6IO%E6%B5%81"><span class="nav-number">1.2.2.</span> <span class="nav-text">InputStreamReader,InputStreamWriter,字符IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">文件字符输入输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">1.2.2.1.1.1.</span> <span class="nav-text">字符输入流:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.2.2.1.1.2.</span> <span class="nav-text">字符输出流:</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81ButteredReader%E5%92%8CButteredWriter"><span class="nav-number">1.2.3.</span> <span class="nav-text">缓冲流ButteredReader和ButteredWriter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">常用方法:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%8F%B7%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.3.</span> <span class="nav-text">序号化和反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96-%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">序列化:将对象转换成字节流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E5%B0%86%E5%AD%97%E8%8A%82%E6%B5%81%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">反序列化: 将字节流转换成对象</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="nav-number">1.3.0.2.0.1.</span> <span class="nav-text">构造方法:</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="nav-number">1.3.1.</span> <span class="nav-text">常用方法:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serializble%E6%8E%A5%E5%8F%A3-%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Serializble接口 (可序列化接口)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E4%B9%8BPropertest%E7%B1%BB%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="nav-number">1.4.</span> <span class="nav-text">IO之Propertest类与配置文件读取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#properties%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.4.1.</span> <span class="nav-text">properties文件介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">Properties类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Properties%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Properties类的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-4"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">常用方法:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="nav-number">1.4.3.</span> <span class="nav-text">Properties文件读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="nav-number">1.4.4.</span> <span class="nav-text">Properties文件写入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB"><span class="nav-number">2.1.</span> <span class="nav-text">Collection集合体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-5"><span class="nav-number">2.1.1.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">迭代器的使用以及方法:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.</span> <span class="nav-text">List接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E9%99%A4%E4%BA%86Collection%E5%8E%9F%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%96"><span class="nav-number">2.2.1.</span> <span class="nav-text">常用方法(除了Collection原有的方法外)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ListIterator%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E7%9B%B8%E6%AF%94%E8%BE%83%E4%BA%8EIterator%E6%96%B0%E5%A2%9E"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">ListIterator常用方法(相比较于Iterator新增):</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">2.2.2.</span> <span class="nav-text">ArrayList数组列表实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">2.2.3.</span> <span class="nav-text">LinkedList链表实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector%E5%90%91%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%B1%BB-%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%94%A8"><span class="nav-number">2.2.4.</span> <span class="nav-text">Vector向量实现类(不推荐用)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.3.</span> <span class="nav-text">Set接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E4%B8%8ECollection%E5%9F%BA%E6%9C%AC%E4%B8%80%E8%87%B4"><span class="nav-number">2.3.1.</span> <span class="nav-text">常用方法(与Collection基本一致)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-%E6%B2%A1%E6%9C%89ListIterator%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">迭代器(没有ListIterator迭代器)的使用以及方法:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">2.3.2.</span> <span class="nav-text">HashSet哈希集合实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeSet%E6%A0%91%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">2.3.3.</span> <span class="nav-text">TreeSet树集合实现类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-lt-K-V-gt-%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB"><span class="nav-number">2.4.</span> <span class="nav-text">Map&lt;K,V&gt;集合体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-6"><span class="nav-number">2.4.1.</span> <span class="nav-text">常用方法:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%81%8D%E5%8E%86"><span class="nav-number">2.4.2.</span> <span class="nav-text">重要嵌套接口和遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E9%9B%86%E5%90%88"><span class="nav-number">2.4.3.</span> <span class="nav-text">HashMap集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hashtable%E9%9B%86%E5%90%88"><span class="nav-number">2.4.4.</span> <span class="nav-text">Hashtable集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap%E9%9B%86%E5%90%88"><span class="nav-number">2.4.5.</span> <span class="nav-text">TreeMap集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap%E4%B8%8ETreeSet%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.4.6.</span> <span class="nav-text">TreeMap与TreeSet的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">2.5.</span> <span class="nav-text">Collections工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-7"><span class="nav-number">2.5.1.</span> <span class="nav-text">常用方法:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E6%89%A9%E5%B1%95"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">补充扩展:</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">线程概述:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-4"><span class="nav-number">3.2.1.</span> <span class="nav-text">构造方法:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-8"><span class="nav-number">3.2.2.</span> <span class="nav-text">常用方法:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7-Priority"><span class="nav-number">3.3.</span> <span class="nav-text">线程的优先级(Priority):</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%BA1-10-%E9%BB%98%E8%AE%A4%E4%B8%BA5-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B6%8A%E9%AB%98-%E8%A1%A8%E7%A4%BA%E8%8E%B7%E5%BE%97CPU%E7%9A%84%E6%9C%BA%E4%BC%9A%E8%B6%8A%E5%A4%9A"><span class="nav-number">3.3.0.1.</span> <span class="nav-text">线程的优先级为1-10,默认为5,优先级越高,表示获得CPU的机会越多</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E6%96%B9%E6%B3%95-%E7%BA%BF%E7%A8%8B%E5%AF%B9%E5%83%8F-setPriority-int-newPriority-%E5%85%B6%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA%E8%AE%BE%E7%BD%AE%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">3.3.0.2.</span> <span class="nav-text">设置优先级的方法:线程对像.setPriority(int newPriority),其中的参数表示设置的优先级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%844-6-%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">3.4.</span> <span class="nav-text">线程的4(6)种状态:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-9"><span class="nav-number">3.4.1.</span> <span class="nav-text">常用方法:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%90%AF%E5%8A%A8"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">(1)启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-sheep%E4%BC%91%E7%9C%A0-%E7%BA%BF%E7%A8%8B%E6%97%B6%E9%97%B4%E7%89%87%E7%94%A8%E5%AE%8C%E5%90%8E%E5%B0%B1%E4%BC%91%E6%81%AF-%E7%AD%89%E5%BE%85-%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%86%8D%E4%BA%89%E5%8F%96"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">(2)sheep休眠:线程时间片用完后就休息(等待)一段时间再争取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-yield%E6%94%BE%E5%BC%83-%E9%81%BF%E8%AE%A9-%E4%B8%BB%E5%8A%A8%E6%94%BE%E5%BC%83%E4%BA%89%E5%8F%96%E6%9C%AC%E6%AC%A1%E6%97%B6%E9%97%B4%E7%89%87%E8%AE%A9%E7%BB%99%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E6%9C%BA%E4%BC%9A-%E5%9B%9E%E5%88%B0%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%E8%BF%9B%E8%A1%8C%E4%B8%8B%E4%B8%80%E6%AC%A1%E7%9A%84%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E4%BA%89%E5%8F%96"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">(3)yield放弃(避让):主动放弃争取本次时间片让给其他线程机会,回到就绪状态进行下一次的时间片的争取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-join%E5%8A%A0%E5%85%A5-%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8E-%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%BC%9A%E8%BF%9B%E5%85%A5%E5%A0%B5%E5%A1%9E%E7%8A%B6%E6%80%81-%E7%AD%89%E5%BE%85%E5%8A%A0%E5%85%A5%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%BB%A5%E5%90%8E%E5%86%8D%E6%89%A7%E8%A1%8C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">(4)join加入:在一个线程中加入另一个线程后,当前线程会进入堵塞状态,等待加入的线程执行完以后再执行当前线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">3.5.</span> <span class="nav-text">线程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.5.1.</span> <span class="nav-text">前台线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B-%E5%8D%B3%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.5.2.</span> <span class="nav-text">守护线程(即后台线程)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">3.5.3.</span> <span class="nav-text">方法:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">3.6.</span> <span class="nav-text">线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB-%E5%A6%82StringButter-Hashtble-Vector%E7%AD%89"><span class="nav-number">3.6.0.1.</span> <span class="nav-text">常见的Java线程安全类:如StringButter,Hashtble,Vector等</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.6.1.</span> <span class="nav-text">synchronized 关键字的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-%E5%A0%B5%E5%A1%9E%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%94%A4%E9%86%92%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.7.</span> <span class="nav-text">线程通信(堵塞线程以及唤醒线程)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-10"><span class="nav-number">3.7.1.</span> <span class="nav-text">常用方法:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">3.7.2.</span> <span class="nav-text">常见问题:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.8.</span> <span class="nav-text">高级线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">3.8.1.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8API"><span class="nav-number">3.8.2.</span> <span class="nav-text">常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ExecutorService%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.8.2.1.</span> <span class="nav-text">ExecutorService的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Executors%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.8.2.2.</span> <span class="nav-text">Executors的常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable%E6%8E%A5%E5%8F%A3%E5%92%8CFuture%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.8.3.</span> <span class="nav-text">Callable接口和Future接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.8.3.1.</span> <span class="nav-text">Callable接口:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Future%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.8.3.2.</span> <span class="nav-text">Future接口:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">3.8.4.</span> <span class="nav-text">线程的同步和异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.8.5.</span> <span class="nav-text">Lock接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock-%E5%AE%9E%E7%8E%B0%E7%B1%BB-%E5%8D%B3%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">3.8.5.1.</span> <span class="nav-text">ReentrantLock(实现类,即重入锁)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantReadWriteLock-%E8%AF%BB%E5%86%99%E9%94%81-%E5%8F%AF%E5%88%86%E5%88%AB%E5%88%86%E9%85%8D%E8%AF%BB%E9%94%81%E5%92%8C%E5%86%99%E9%94%81"><span class="nav-number">3.8.5.2.</span> <span class="nav-text">ReentrantReadWriteLock(读写锁):可分别分配读锁和写锁</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="nav-number">4.</span> <span class="nav-text">注解与反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3Annotation"><span class="nav-number">4.1.</span> <span class="nav-text">注解Annotation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Annotation%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.1.0.1.</span> <span class="nav-text">Annotation的作用:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Annotation%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.1.0.2.</span> <span class="nav-text">Annotation的格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.1.1.</span> <span class="nav-text">内置注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.1.2.</span> <span class="nav-text">元注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.1.3.</span> <span class="nav-text">自定义注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reflection%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">4.2.</span> <span class="nav-text">Reflection反射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81VS%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80"><span class="nav-number">4.2.1.</span> <span class="nav-text">动态VS静态语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">4.2.2.</span> <span class="nav-text">反射机制提供的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.2.3.</span> <span class="nav-text">反射的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-%E7%B1%BB"><span class="nav-number">4.2.4.</span> <span class="nav-text">Class 类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">创建对象的方式:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-11"><span class="nav-number">4.2.4.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">4.2.5.</span> <span class="nav-text">类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Load-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E5%B0%86%E7%B1%BB%E7%9A%84Class%E6%96%87%E4%BB%B6%E8%AF%BB%E5%85%A5%E5%86%85%E5%AD%98-%E5%B9%B6%E4%B8%BA%E4%B9%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAClass%E6%96%87%E4%BB%B6-%E6%AD%A4%E8%BF%87%E7%A8%8B%E7%94%B1%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%8C%E6%88%90"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">(1)Load:类的加载:将类的Class文件读入内存,并为之创建一个Class文件,此过程由类加载器完成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Link-%E7%B1%BB%E7%9A%84%E9%93%BE%E6%8E%A5-%E5%B0%86%E7%B1%BB%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6%E5%88%B0JRE%E4%B8%AD"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">(2)Link:类的链接:将类的二进制数据合并到JRE中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Initialize-%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-JVM%E8%B4%9F%E8%B4%A3%E5%AF%B9%E7%B1%BB%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.2.5.3.</span> <span class="nav-text">(3)Initialize:类的初始化:JVM负责对类进行初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.2.5.3.1.</span> <span class="nav-text">什么时候会发生类的初始化?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">4.2.6.</span> <span class="nav-text">类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.7.</span> <span class="nav-text">获取类的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E5%8A%A8%E4%BD%9C"><span class="nav-number">4.2.8.</span> <span class="nav-text">反射动作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.2.8.0.1.</span> <span class="nav-text">(1)构造对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%B0%83%E7%94%A8%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.8.0.2.</span> <span class="nav-text">(2)调用普通方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%93%8D%E4%BD%9C%E5%B1%9E%E6%80%A7"><span class="nav-number">4.2.8.0.3.</span> <span class="nav-text">(3) 操作属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">4.2.9.</span> <span class="nav-text">设置可访问权限</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="nav-number">4.2.9.1.</span> <span class="nav-text">性能对比:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%B8%8EORM-%E5%AF%B9%E5%83%8F%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84"><span class="nav-number">4.2.10.</span> <span class="nav-text">反射获取注解与ORM(对像关系映射)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E7%82%B9-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.2.11.</span> <span class="nav-text">(重点)反射获取注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%9B%E5%9E%8B"><span class="nav-number">4.2.12.</span> <span class="nav-text">反射操作泛型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-number">5.1.</span> <span class="nav-text">1. Lambda表达式的简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.2.</span> <span class="nav-text">1.1. Lambda表达式的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.3.</span> <span class="nav-text">1.2. Lambda表达式的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">5.4.</span> <span class="nav-text">1.3. Lambda表达式对接口的要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.5.</span> <span class="nav-text">1.4. 函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">5.5.1.</span> <span class="nav-text">1.4.1. 基础概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-FunctionalInterface"><span class="nav-number">5.5.2.</span> <span class="nav-text">1.4.2. @FunctionalInterface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-%E7%B3%BB%E7%BB%9F%E5%86%85%E7%BD%AE%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.5.3.</span> <span class="nav-text">1.4.3. 系统内置的若干函数式接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number">5.6.</span> <span class="nav-text">2. Lambda表达式的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">5.6.1.</span> <span class="nav-text">2.1. Lambda表达式的基础语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E8%BF%9B%E9%98%B6"><span class="nav-number">5.6.2.</span> <span class="nav-text">2.2. Lambda表达式的语法进阶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E5%8F%82%E6%95%B0%E9%83%A8%E5%88%86%E7%9A%84%E7%B2%BE%E7%AE%80"><span class="nav-number">5.6.3.</span> <span class="nav-text">2.2.1. 参数部分的精简</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.6.3.1.</span> <span class="nav-text">参数的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E5%B0%8F%E6%8B%AC%E5%8F%B7"><span class="nav-number">5.6.3.2.</span> <span class="nav-text">参数的小括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F-%E6%9C%89%E4%B8%94%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA-%EF%BC%8C%E6%AD%A4%E6%97%B6%EF%BC%8C%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%9A%84%E5%B0%8F%E6%8B%AC%E5%8F%B7%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%E4%B8%8D%E5%86%99"><span class="nav-number">5.6.3.3.</span> <span class="nav-text">如果方法的参数列表中的参数数量 有且只有一个 ，此时，参数列表的小括号是可以省略不写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9A%84%E3%80%82"><span class="nav-number">5.6.3.4.</span> <span class="nav-text">的。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.6.3.5.</span> <span class="nav-text">注意事项:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E6%9C%89%E5%BD%93%E5%8F%82%E6%95%B0%E7%9A%84%E6%95%B0%E9%87%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C-%E5%A4%9A%E4%BA%86%E3%80%81%E5%B0%91%E4%BA%86%E9%83%BD%E4%B8%8D%E8%83%BD%E7%9C%81%E7%95%A5%E3%80%82"><span class="nav-number">5.6.3.6.</span> <span class="nav-text">只有当参数的数量是一个的时候， 多了、少了都不能省略。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9C%81%E7%95%A5%E6%8E%89%E5%B0%8F%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%8C%E6%97%B6%EF%BC%8C-%E5%BF%85%E9%A1%BB%E8%A6%81%E7%9C%81%E7%95%A5%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="nav-number">5.6.3.7.</span> <span class="nav-text">省略掉小括号的同时， 必须要省略参数的类型。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E6%96%B9%E6%B3%95%E4%BD%93%E9%83%A8%E5%88%86%E7%9A%84%E7%B2%BE%E7%AE%80"><span class="nav-number">5.6.4.</span> <span class="nav-text">2.2.2. 方法体部分的精简</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BD%93%E5%A4%A7%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%B2%BE%E7%AE%80"><span class="nav-number">5.6.4.1.</span> <span class="nav-text">方法体大括号的精简</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E4%BD%93%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%8C-%E6%9C%89%E4%B8%94%E5%8F%AA%E6%9C%89%E4%B8%80%E5%8F%A5%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C-%E5%A4%A7%E6%8B%AC%E5%8F%B7%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%E3%80%82"><span class="nav-number">5.6.4.2.</span> <span class="nav-text">当一个方法体中的逻辑， 有且只有一句的情况下， 大括号可以省略。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8"><span class="nav-number">5.7.</span> <span class="nav-text">3. 函数引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">5.7.1.</span> <span class="nav-text">3.1. 静态方法的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">5.7.2.</span> <span class="nav-text">3.2. 非静态方法的引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.7.2.1.</span> <span class="nav-text">示例:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">5.7.3.</span> <span class="nav-text">3.3. 构造方法的引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.7.3.1.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E6%AE%8A%E5%BC%95%E7%94%A8"><span class="nav-number">5.7.4.</span> <span class="nav-text">3.4. 对象方法的特殊引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">5.8.</span> <span class="nav-text">4. Lambda表达式需要注意的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Lamb-da%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">5.9.</span> <span class="nav-text">5. Lamb da表达式的实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">5.9.1.</span> <span class="nav-text">5.1. 线程的实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="nav-number">5.9.2.</span> <span class="nav-text">5.2. 集合的常见方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E9%9B%86%E5%90%88%E7%9A%84%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">5.9.3.</span> <span class="nav-text">5.3. 集合的流式编程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E6%A6%82%E8%BF%B0"><span class="nav-number">6.0.1.</span> <span class="nav-text">1.1概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">6.0.1.0.1.</span> <span class="nav-text">计算机网络:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">6.0.1.0.2.</span> <span class="nav-text">网络编程的目的:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">6.0.1.0.3.</span> <span class="nav-text">需要做什么:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E8%A6%81%E7%B4%A0"><span class="nav-number">6.0.2.</span> <span class="nav-text">1.2网络通信的要素</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">6.0.2.0.1.</span> <span class="nav-text">如何实现网络的通信?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%84%E5%88%99-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.0.2.0.2.</span> <span class="nav-text">规则:网络通信的协议</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">6.0.2.0.2.1.</span> <span class="nav-text">小结:</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP"><span class="nav-number">6.1.</span> <span class="nav-text">IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3-Prot"><span class="nav-number">6.2.</span> <span class="nav-text">端口(Prot)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.3.</span> <span class="nav-text">通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE-%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E4%B8%80%E7%BB%84%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.3.1.</span> <span class="nav-text">TCP&#x2F;IP协议:实际上是一组协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E5%AF%B9%E6%AF%94"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">TCP和UDP对比</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%89%93%E7%94%B5%E8%AF%9D"><span class="nav-number">6.3.1.1.1.</span> <span class="nav-text">TCP:相当于打电话</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UDP-%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%8F%91%E7%9F%AD%E6%81%AF"><span class="nav-number">6.3.1.1.2.</span> <span class="nav-text">UDP:相当于发短息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP"><span class="nav-number">6.3.2.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP"><span class="nav-number">6.3.3.</span> <span class="nav-text">UDP</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Luo Qianyou"
      src="/site_images/logo.jpg">
  <p class="site-author-name" itemprop="name">Luo Qianyou</p>
  <div class="site-description" itemprop="description">清醒,知趣 明得失,知进退</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LQY679" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LQY679" rel="noopener me" target="_blank"><i class="fa-brands fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/QianyouLuo" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;QianyouLuo" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://example.com/" title="https:&#x2F;&#x2F;example.com" rel="noopener" target="_blank">Title</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/site_images/logo.jpg">
      <meta itemprop="name" content="Luo Qianyou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南城记录倌">
      <meta itemprop="description" content="清醒,知趣 明得失,知进退">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JavaSE进阶 | 南城记录倌">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaSE进阶
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-01 18:57:32" itemprop="dateCreated datePublished" datetime="2020-01-01T18:57:32+08:00">2020-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-22 16:03:37" itemprop="dateModified" datetime="2023-02-22T16:03:37+08:00">2023-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Java系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="文件类与IO流"><a href="#文件类与IO流" class="headerlink" title="文件类与IO流"></a>文件类与IO流</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="构造方法-并不真正创建文件"><a href="#构造方法-并不真正创建文件" class="headerlink" title="构造方法(并不真正创建文件):"></a>构造方法(并不真正创建文件):</h3><p><strong>File(Stirng filename):</strong> 其中的参数是文件名,默认放在当前程序同一目录<br><strong>File(Stirng 路径, String filename):</strong><br><strong>Fiel(String dir ,Stirng filemane):</strong> 其dir指目录<br><strong>注意:</strong> 注意区别相对路径(相对于src)和绝对路径(磁盘目录)</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法:"></a>常用方法:</h3><p><strong>1.boolean createNewFile() 创建一个文件</strong>  此方法返回true，如果指定的文件不存在，并已成功创建。如果该文件存在，该方法返回false。</p>
<p>2.long length() 测量文件长度(单位是字节)<br>3.boolean isFile() 判断文件是否是文件而不是目录<br><strong>4.boolean exists() 判断文件是否存在</strong><br>5.String getParent() 获取文件的父目录<br>6.String getAbsolutePath() 获取文件的绝对路径<br>7.boolean delete() 删除文件</p>
<p><strong>创建文件</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 文件类与IO流.creat_file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Create_file</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src\\&quot;</span>, <span class="string">&quot;aa.txt&quot;</span>);  <span class="comment">//只创建文件对象不能创建文件,需要调用方法</span></span><br><span class="line">		<span class="comment">//文件构造方法,第一个参数是路径(绝对路径或者相对路径如相对路径),第二个参数是文件名(需加后缀)</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">/* 运行可执行文件</span></span><br><span class="line"><span class="comment">		 * Runtime 类 </span></span><br><span class="line"><span class="comment">		 * 用此类的静态方法创建一个对象</span></span><br><span class="line"><span class="comment">		 * 调用 exec (String 命令或者可执行文件路径)</span></span><br><span class="line"><span class="comment">		 *  */</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">note</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\1.txt&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;文件是否创建成功&quot;</span>+file.createNewFile());</span><br><span class="line">			System.out.println(<span class="string">&quot;文件是否删除成功&quot;</span>+note.delete());</span><br><span class="line">			System.out.println(note.getAbsolutePath());</span><br><span class="line">			System.out.println(note.getParent());		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="InputStream-OutputStream-字节流IO流"><a href="#InputStream-OutputStream-字节流IO流" class="headerlink" title="InputStream,OutputStream,字节流IO流"></a>InputStream,OutputStream,字节流IO流</h2><p>字节流主要是用于处理文件(如图片,视频音乐等),因为这些文件都采用二进制来存储</p>
<h3 id="文件字节输入输出流"><a href="#文件字节输入输出流" class="headerlink" title="文件字节输入输出流"></a>文件字节输入输出流</h3><p>1.输入输出都是相对与<strong>程序</strong>来说的:即输入流是从外部获取数据到程序,输出流是程序输出数据到外部<br>2.输入输出流在使用后都要关闭,先用的后关,后用的先关 </p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><em><strong>将文件字节流绑定到文件</strong></em>   1.<strong>FileInputStream(String 文件名):</strong><br>2.<strong>FileInputStream(File 文件对象):</strong><br>1.<strong>FileOutputStream(File 文件对象):</strong>  将文件字节输出流绑定到文件<br>2.<strong>FileOutputStream(String 文件名):</strong><br>3.<strong>FileOutputStream(File 文件对象, boolean append):</strong> 第二个参数<strong>设置是否追加,默认是重写</strong><br>4.<strong>FileOutputStream(File 文件对象, boolean append):</strong></p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法:"></a>常用方法:</h4><h5 id="输入流方法"><a href="#输入流方法" class="headerlink" title="输入流方法:"></a>输入流方法:</h5><p>1.int read() <strong>从源中每次读取一个字节的数据,并返回字节(0~255), 读到文件末尾返回-1</strong><br>2.int read(byte[] b) 从源中读取<strong>b.length个字符到b字节数组中,返回实际读取的字节数</strong> ,读到文件末尾返回-1<br>3.int read(byte[] int off, int len) 从源中读取 <strong>len个字节到字节数组b中,并返回实际读取的字节数</strong>, 参<strong>数off指定从数组的某个位置开始</strong>存放读取的数组<br>4.void close() 关闭流,如果不关闭,有可能绑定的资源不允许另一个程序操作绑定的资源</p>
<h5 id="输出流方法"><a href="#输出流方法" class="headerlink" title="输出流方法:"></a>输出流方法:</h5><p>1.void write(int n) 每次向绑定的资源中写入<strong>一个字节n</strong><br>2.void write(byte b[]) 每次向绑定的资源中写入<strong>一个字节数组</strong><br>3.void write(byte[] b , int, off ,int len) 每次向从字节数组中<strong>的off位置开始</strong>向绑定资源中<strong>写入len个字节</strong><br>4.void close()<br><strong>总结:</strong> 由于字节流是以字节为单位进行数据处理,但汉字是以多个字节储存的,所以用字节流处理中文就会出现乱码现象,所以在<strong>处理汉字时用字符流</strong>进行处理</p>
<h3 id="InputStreamReader-InputStreamWriter-字符IO流"><a href="#InputStreamReader-InputStreamWriter-字符IO流" class="headerlink" title="InputStreamReader,InputStreamWriter,字符IO流"></a>InputStreamReader,InputStreamWriter,字符IO流</h3><p>字符流主要用于<strong>处理汉字时出现乱码问题的</strong></p>
<p>1.构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream in, String charsetName) ;  <span class="comment">//创建一个指定字符集的输入流,常用来解决中文乱码问题</span></span><br><span class="line">OutputStreamWriter(OutputStream out, String charsetName) <span class="comment">//创建一个指定字符集的输出流</span></span><br></pre></td></tr></table></figure>

<h4 id="文件字符输入输出流"><a href="#文件字符输入输出流" class="headerlink" title="文件字符输入输出流"></a>文件字符输入输出流</h4><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><h6 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流:"></a>字符输入流:</h6><p><strong>FileReader(Stirng 文件名);</strong> <strong>FileReader(File 文件对象);</strong> </p>
<h6 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流:"></a>字符输出流:</h6><p><strong>FileWriter(String 文件名);</strong> <strong>FileWriter(File 文件对象);</strong><br><strong>FielWriter(Sring 文件名, boolean append):</strong> <strong>FileWriter(File 文件名, boolean append);</strong><br>常用的方法和<strong>字节流基本一致</strong>,<br><strong>注意!!! <strong>但对于Writer 的write() 方法将数据</strong>首先写入缓冲区,每当缓冲区溢出时内容才会被自动写入绑定资源,如果关闭流缓冲区内容也会被立刻写入,==也可以调用flush()方法立刻写入==</strong><br><strong>总结: 字节流</strong>主要用于<strong>图片，视频等二进制的文件</strong>,<strong>字符流</strong>用于<strong>文本文件</strong></p>
<p><strong>读写文件:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 串实验;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_String</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 绑定文件对象,注意: 此文件已经存在</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/串实验/readme.txt&quot;</span>);</span><br><span class="line">		 <span class="comment">// 获取文件字符输入流</span></span><br><span class="line">		 <span class="type">FileReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">		 <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">         <span class="comment">// 将读取的内容放入字符数组</span></span><br><span class="line">		 in.read(chars);</span><br><span class="line">		 in.close();</span><br><span class="line">		 <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">		 System.out.println(<span class="string">&quot;读取到的文件内容为:&quot;</span>+str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定文件输出流</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">true</span>);  <span class="comment">// 设置为追加模式的文件输出流</span></span><br><span class="line">		 out.write(<span class="string">&quot;\n这是追加内容呀!&quot;</span>);   <span class="comment">// 以追加的方式想文件输出内容</span></span><br><span class="line">		 out.flush();  <span class="comment">// 立即刷新缓存区, 刷新的话输出流不关闭之前是不会</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="缓冲流ButteredReader和ButteredWriter"><a href="#缓冲流ButteredReader和ButteredWriter" class="headerlink" title="缓冲流ButteredReader和ButteredWriter"></a>缓冲流ButteredReader和ButteredWriter</h3><p><strong>用于增强流的读写能力</strong></p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><p><strong>ButteredReader(Reader in);</strong><br><strong>ButteredWriter(Writer out);</strong> </p>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法:"></a>常用方法:</h4><p>1.<strong>String readLine():</strong> 一次读取一行数据<br>2.<strong>void writeLine():</strong> 一次写入一行数据</p>
<h2 id="序号化和反序列化"><a href="#序号化和反序列化" class="headerlink" title="序号化和反序列化"></a>序号化和反序列化</h2><h4 id="序列化-将对象转换成字节流"><a href="#序列化-将对象转换成字节流" class="headerlink" title="序列化:将对象转换成字节流"></a>序列化:将对象转换成字节流</h4><h4 id="反序列化-将字节流转换成对象"><a href="#反序列化-将字节流转换成对象" class="headerlink" title="反序列化: 将字节流转换成对象"></a>反序列化: 将字节流转换成对象</h4><h6 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法:"></a>构造方法:</h6><p><strong>ObjectInputStream(InoutStream in):</strong> 创建一个输入对象的字节流,参数 in 是要绑定的字节流或者是字节流的子类 **ObjectOutputStream(OutputSream out):**创建一个输出对象的字节流,其中参数out是要绑定的字节流或者是其子类</p>
<h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法:"></a>常用方法:</h3><p>1.void writeObject(Object object): 将对象写入对象所绑定的输出流中<br>2.Object readObject() 将输入流中的对象读取出来并且返回</p>
<h4 id="Serializble接口-可序列化接口"><a href="#Serializble接口-可序列化接口" class="headerlink" title="Serializble接口 (可序列化接口)"></a>Serializble接口 (可序列化接口)</h4><p><strong>在使用writeObject(Object object)方法将对象序列化时,要序列化的对象必须实现Serializble接口将对象设置成可序列化状态</strong>,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建文件输出流,为写入对象做准备</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">file_out</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(E:\\<span class="number">1.</span>txt));</span><br><span class="line">    <span class="comment">//创建对象流将文件流file_out绑定</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">o_out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(file_out);</span><br><span class="line">    <span class="comment">//将猫对象序列化写入文件</span></span><br><span class="line">        o_out.writeObject(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//猫对象,注意要实现接口Serializble</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Serializble</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO之Propertest类与配置文件读取"><a href="#IO之Propertest类与配置文件读取" class="headerlink" title="IO之Propertest类与配置文件读取"></a>IO之Propertest类与配置文件读取</h2><h3 id="properties文件介绍"><a href="#properties文件介绍" class="headerlink" title="properties文件介绍"></a>properties文件介绍</h3><hr>
<p>在开发项目时,项目通常会依赖一些中间件,这些中间件的配置不是硬编码写在代码中,而是使用配置文件方式存储<br><strong>常用配置文件有以下几种:</strong></p>
<ul>
<li>properties文件: SpringBoot应用都有应用此配置文件</li>
<li>xml文件: 如MyBattis的配置文件</li>
<li>JSON文件</li>
</ul>
<p>properties文件通常采用键值对存储,key=value</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">order-api</span></span><br></pre></td></tr></table></figure>

<h3 id="Properties类的使用"><a href="#Properties类的使用" class="headerlink" title="Properties类的使用"></a>Properties类的使用</h3><hr>
<h4 id="Properties类的介绍"><a href="#Properties类的介绍" class="headerlink" title="Properties类的介绍"></a>Properties类的介绍</h4><p>Properties类表示一组持久存储的属性,属性由属性名和属性值组成.<strong>Properties可以保存到流(以流的方式写入)或者从流中加载</strong>,属性列表中每个键及其对应的值都是<strong>字符串</strong><br>Properties可以当成Map集合使用,但是一般不会这样做</p>
<h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法:"></a>常用方法:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">properties.getProperty(String key)  <span class="comment">//根据键值获取属性</span></span><br><span class="line">properties.load(InputStream inStream)   <span class="comment">//根据输入流(一般是properties文件的输入流)加载文件内容</span></span><br><span class="line">properties.propertyNames() <span class="comment">//获取 key的集合</span></span><br><span class="line">properties.store(OutputStream out, String comments)   <span class="comment">//向文件中写入内容</span></span><br></pre></td></tr></table></figure>

<h3 id="Properties文件读取"><a href="#Properties文件读取" class="headerlink" title="Properties文件读取"></a>Properties文件读取</h3><p>当Properties文件放在项目下时,properties文件会随着java程序在编译生成字节码时一起打包在同一个目录下,<strong>故可以通过类加载器来获取文件流进而读取文件内容</strong><br><img src="1628918777119660-16472196645138.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从类加载器加载加载文件,由于在生成字节码时Properties文件会随着java文件编译被一起打包到同一目录下,故可以通过类加载器读取到文件</span></span><br><span class="line"> <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span>PropertiesDemo01.class.getClassLoader().getResourceAsStream(<span class="string">&quot;application.properties&quot;</span>);</span><br><span class="line"> <span class="comment">//创建properties对象通过加载properties文件的输入流来加载文件内容</span></span><br><span class="line"> <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"> <span class="comment">//Properties对象加载的文件流</span></span><br><span class="line"> properties.load(in);</span><br><span class="line"> <span class="comment">//取出所有的属性名(key)集合</span></span><br><span class="line"> Set&lt;String&gt; propertySet = properties.stringPropertyNames();</span><br><span class="line"> <span class="keyword">for</span>(String key:propertySet)&#123;   <span class="comment">//遍历集合中的key</span></span><br><span class="line">	System.out.println(key+<span class="string">&quot;:&quot;</span>+properties.getProperty(key));  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>如文件中含有中文,出现乱码问题则改为字符流</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(PropertiesDemo01.class.getClassLoader().getResourceAsStream(<span class="string">&quot;application.properties&quot;</span>),<span class="string">&quot;utf8&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Properties文件写入"><a href="#Properties文件写入" class="headerlink" title="Properties文件写入"></a>Properties文件写入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/test.properties&quot;</span>));</span><br><span class="line">properties.store(out,<span class="string">&quot;注释&quot;</span>);</span><br></pre></td></tr></table></figure>



<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li><strong>概念:</strong> 对象的容器,定义了对多个对象进行操作的常用方法,可实现数组的功能</li>
<li><strong>与数组的区别:</strong></li>
<li>(1) 数组长度固定,集合长度不固定</li>
<li>(2) 数组可以存储基本数据类型和引用类型,集合只能存储引用类型(但是基本数据类型可以装箱转换)</li>
</ul>
<h2 id="Collection集合体系"><a href="#Collection集合体系" class="headerlink" title="Collection集合体系"></a>Collection集合体系</h2><p><img src="1627282677584841.png">(<em>并非实际结构,只表示大致关系</em>)</p>
<h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><strong>boolean add(Object obj)</strong> 在集合尾部添加一个对象</li>
<li><strong>boolean addAll(Collection c)</strong> 将一个集合的所有对象添加到此集合中</li>
<li><strong>void clear()</strong>  清空此集合中所有对象</li>
<li><strong>boolean remove(Object o)</strong> 移除此集合中的o对象</li>
<li><strong>Object[] toArray()</strong> 将集合中的所有元素以数组形式返回</li>
<li><strong>boolean isEmpty()</strong>  判断此集合是否为空</li>
<li><strong>boolean contains(Object o)</strong>  判断此集合中是否包含o对象</li>
<li><strong>boolean equals(Object o)</strong>  判断此集合是否与o对象具有相同的引用</li>
<li><strong>int size()</strong>  返回此集合中元素个数</li>
<li><strong>Iterator<V> iterator()方法:</V></strong> 获取当前集合的迭代器</li>
</ul>
<h4 id="迭代器的使用以及方法"><a href="#迭代器的使用以及方法" class="headerlink" title="迭代器的使用以及方法:"></a><strong>迭代器的使用以及方法:</strong></h4><ul>
<li>boolean hasNext()方法:当迭代器的下一位置不为null时,返回true,否则返回false (即判断下一次集合中是否还有元素)</li>
<li>Object next()方法: 获得迭代器位置下移,返回下移后的元素</li>
<li>void remove()方法:删除迭代器所指向的元素(<strong>注意:在迭代过程中只能用此方法删除元素</strong>)</li>
</ul>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>**特点:**有序,有下标,元素可重复</p>
<h3 id="常用方法-除了Collection原有的方法外"><a href="#常用方法-除了Collection原有的方法外" class="headerlink" title="常用方法(除了Collection原有的方法外)"></a>常用方法(除了Collection原有的方法外)</h3><ul>
<li>void add(int index,Object obj): 在列表的指定位置添加元素(<em>第一个元素的下标为0</em>)</li>
<li>void addAll(int index, Collection c) :从指定位置开始将c中所有元素添加到列表中</li>
<li>Object get(int index):放回指定下表的元素</li>
<li>int indexOf(Object o):放回指定元素的索引,不存在返回-1</li>
<li>Objcet remove(int index):移除指定下标的元素</li>
<li>void removeRange(int fromIndex,int toIndex):含头不含尾的移除指定下标到指定下标的元素</li>
<li>Object set(int index,Object o):将指定索引位置的对象替换为o</li>
<li>Object[] toArray():按照列表中元素的顺序返回包含列表所有元素的数组</li>
<li>ListIterator ListIterator():返回列表的列表迭代器</li>
</ul>
<h4 id="ListIterator常用方法-相比较于Iterator新增"><a href="#ListIterator常用方法-相比较于Iterator新增" class="headerlink" title="ListIterator常用方法(相比较于Iterator新增):"></a><strong>ListIterator常用方法(相比较于Iterator新增):</strong></h4><p>(1)boolean hasPrevious():逆向遍历,如果前一个有元素则返回true,否则返回false<br>(2)Object previous():迭代器指针前移,返回前移后的元素<br>(3)int NextIndex():返回对next()调用后返回元素的索引<br>(4)int PreviousIndex():返回对previous()调用后的返回元素的索引<br>(5)void set(Object o):将迭代器指针所指向的位置的元素替换为o<br>(6)void add(Object)</p>
<h3 id="ArrayList数组列表实现类"><a href="#ArrayList数组列表实现类" class="headerlink" title="ArrayList数组列表实现类"></a>ArrayList数组列表实现类</h3><ul>
<li>实现结构:<strong>使用数组结构实现</strong></li>
<li>特点: <strong>查询快,修改慢</strong></li>
</ul>
<h3 id="LinkedList链表实现类"><a href="#LinkedList链表实现类" class="headerlink" title="LinkedList链表实现类"></a>LinkedList链表实现类</h3><ul>
<li>实现结构:<strong>双向链表实现</strong></li>
<li>特点:<strong>查询慢,修改快</strong></li>
</ul>
<h3 id="Vector向量实现类-不推荐用"><a href="#Vector向量实现类-不推荐用" class="headerlink" title="Vector向量实现类(不推荐用)"></a><em>Vector向量实现类(不推荐用)</em></h3><ul>
<li>特点: 线程安全,但是运行效率低,有更好的代替</li>
</ul>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p><strong>特点:无序,无下标,不可重复元素</strong></p>
<h3 id="常用方法-与Collection基本一致"><a href="#常用方法-与Collection基本一致" class="headerlink" title="常用方法(与Collection基本一致)"></a>常用方法(与Collection基本一致)</h3><ul>
<li>**int HashCode()*<em>获取哈希码值<br>关于哈希码:</em> <strong>如果两个对象具有相同的引用(即equals的返回值为true),则哈希码一定相同,但哈希码相同,对象不一定具有相同的引用</strong> *</li>
<li><strong>boolean equals(Object o)</strong>,判断是否是同一个对象(如果该类没有重写此方法的的话)</li>
</ul>
<h4 id="迭代器-没有ListIterator迭代器-的使用以及方法"><a href="#迭代器-没有ListIterator迭代器-的使用以及方法" class="headerlink" title="迭代器(没有ListIterator迭代器)的使用以及方法:"></a><strong>迭代器(没有ListIterator迭代器)的使用以及方法:</strong></h4><ul>
<li>boolean hasNext()方法:当迭代器的下一位置不为null时,返回true,否则返回false (即判断下一次集合中是否还有元素)</li>
<li>Object next()方法: 获得迭代器位置下移,返回下移后的元素</li>
<li>void remove()方法:删除迭代器所指向的元素(<strong>注意:在迭代过程中只能用此方法删除元素</strong>)</li>
</ul>
<h3 id="HashSet哈希集合实现类"><a href="#HashSet哈希集合实现类" class="headerlink" title="HashSet哈希集合实现类"></a>HashSet哈希集合实现类</h3><ul>
<li>实现结构:<strong>采用数组+链表+(JDK1.8之后加入红黑树)</strong><br><img src="1627284534340532.png"></li>
<li>特点:元素唯一,根据哈希码HashCode和equals()方法和equals()方法来去重</li>
</ul>
<h3 id="TreeSet树集合实现类"><a href="#TreeSet树集合实现类" class="headerlink" title="TreeSet树集合实现类"></a>TreeSet树集合实现类</h3><ul>
<li>实现结构:<strong>红黑树</strong></li>
<li>特点:<br>(1) <strong>基于排序来去重按顺序存储</strong><br>(2) <strong>实现了SortedSet接口,对集合元素自动排序</strong><br>(3) <strong>元素对象的类型必须实现Comparable接口,指定排序规则</strong><br>(4) <strong>通过CompareTo()方法来确定是否为重复元素</strong></li>
<li>要求:<br><strong>元素必须是可以比较的,即实现Comparable接口<br>或使用TreeSet<?>(Comparator<?> com)构造器来创建集合为集合添加比较器</strong><br>ps:<br>(1)Compareable<E>接口:只有一个int ComparaTo<E>(E o)方法,调用对象和参数比较,一般来说,调用者大于参数则返回正数,小于则返回负数,等于返回0<br>(2)Comparator<E>接口: 只有一个int compara(E o1,E o2)方法</E></E></E></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line"> <span class="comment">//实现接口的所有抽象方法</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">comparaTo</span><span class="params">(Student o)</span>&#123;</span><br><span class="line">      <span class="comment">//比较规则</span></span><br><span class="line">      reutrn 整数;</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建自定义比较器的树集合</span></span><br><span class="line">TreeSet&lt;Student&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">        <span class="comment">//实现接口的所有抽象方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compara</span><span class="params">(Student o1,Student o2)</span>&#123;</span><br><span class="line">          <span class="comment">//自定义的比较规则</span></span><br><span class="line">          <span class="keyword">return</span> 整数;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<h2 id="Map-lt-K-V-gt-集合体系"><a href="#Map-lt-K-V-gt-集合体系" class="headerlink" title="Map&lt;K,V&gt;集合体系"></a>Map&lt;K,V&gt;集合体系</h2><p><img src="1627474551819780.png"></p>
<h3 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法:"></a>常用方法:</h3><ul>
<li>**V get(Object key):**根据参数的键值返回对用的Value</li>
<li>**V put(K key,V  value)**向集合中加入键值对</li>
<li>**void putAll(Map&lt;K,V&gt;)**将参数中的Map集合添加</li>
<li><strong>Set<K> keySet():将Map集合中的键以Set<K>的形式返回</K></K></strong></li>
<li><strong>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():   将Map集合中的键值对整体以Set集合的形式返回</strong></li>
<li><strong>Collection<V> values():将Map集合中的Value以Collection集合的形式返回</V></strong></li>
<li>V remove(Object key)</li>
<li>boolean containsKey()</li>
<li>boolean containsValue()</li>
<li>int size()</li>
<li>boolean isEmpty()</li>
</ul>
<h3 id="重要嵌套接口和遍历"><a href="#重要嵌套接口和遍历" class="headerlink" title="重要嵌套接口和遍历"></a>重要嵌套接口和遍历</h3><ul>
<li><strong>遍历方式:</strong><br>(1) <strong>遍历Map可通过keySet()转化成键的Set集合遍历</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Set&lt;V&gt; key:map.entrySet())&#123;</span><br><span class="line"><span class="comment">//打印Key以及对应的Value</span></span><br><span class="line">        System.out.println(key+<span class="string">&quot;----&quot;</span>+map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) <strong>通过entrySet()转化成键值对(Map.Entry)Set集合对来遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得map的Entry 集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;K,V&gt; entry:entrySet)&#123;</span><br><span class="line"><span class="comment">//打印键值对</span></span><br><span class="line">        System.out.println(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中通过键值对来遍历效率要更高</strong>,<em>因为通过键集合来遍历需要遍历两次</em></p>
<ul>
<li><strong>Map嵌套接口Entry&lt;K,V&gt;</strong>:<br>该类是Map集合的一个内部接口,表示Map的一个键值对,该接口提供了一些方法可以得到对应map集合的一下key或者value,以及修改Key对应的Value<br>如: V **setValue(V value)**方法,将此键对应下的值替换为参数的Value</li>
</ul>
<h3 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h3><ul>
<li>特点:<br>(1) JDk1.2版本,线程不安全(不同步),运行效率高,允许null作为Key或Value的值<br>(2) <strong>存储结构:哈希表(数组+链表+JDK1.8加入红黑树),去重依据:根据Key的equals()和HasCode()</strong></li>
<li><strong>源码分析:</strong><br>(1)<strong>属性:</strong> <em>初始容量,扩容因子(*<em>指的当集合内元素个数&gt;集合的容量</em>扩容因子 的时候,集合的的容量会扩大至原来的2倍*</em>)* </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 当添加一个元素时,初始容量为1&lt;&lt;4即16,不存在元素容量为0,便于节省空间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;   <span class="comment">//集合的最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;  <span class="comment">//默认的扩容因子为0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;  <span class="comment">//JDK1.8 , 当链表的长度大于8时,调整为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>; <span class="comment">//JDk1.8,当链表的长度大于8时,并且元素个数大于64时,调整为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;  <span class="comment">//JDK1.8 ,当链表的长度小于6时,调整为链表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="comment">//哈希表中的(链表)数组</span></span><br></pre></td></tr></table></figure>

<p>(2) <strong>构造器:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造:默认扩容因子为0.75,不过刚创建好时 table是null,size是0</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指定初始容量和扩容因子的构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>(3) <strong>方法:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put(K key,V value)方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);<span class="comment">//hash方法用来确定位置</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//put方法中调用的putVal方法</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) </span><br><span class="line"><span class="comment">//如果集合中还未添加元素,则调用调用resize()方法重置,为集合分配初始容量(即16)</span></span><br><span class="line">            n = (tab = resize()).length; </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//如果集合为空,则为创建一个Node加入数组中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"><span class="comment">//如果集合的元素个数已经超过了扩容阈值(扩容因子*集合容量),则重新分配集合容量,为原来的2倍</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>HashSet与HashMap的关系的</strong><br><strong>通过查看源码可发现,HashSet实际上就是使用了HashMap的结构,只不过Value为null</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">       map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hashtable集合"><a href="#Hashtable集合" class="headerlink" title="Hashtable集合"></a>Hashtable集合</h3><p>特点: JDK1.0版本,线程安全,运行效率低,不允许null作为Key或者Value<br><strong>重要子类:Properties:要求key,value都是String,通常用于配置文件的读取</strong></p>
<h3 id="TreeMap集合"><a href="#TreeMap集合" class="headerlink" title="TreeMap集合"></a>TreeMap集合</h3><ul>
<li>特点:实现了SortedMap接口,可以对key自动排序</li>
<li><strong>存储结构:采用红黑树,去重规则是根据compara(Objcect o1,Object o2)即元素自身的比较器或元素的ComparaTo(Object o)方法即使元素实现了comparabale接口</strong> </li>
</ul>
<h3 id="TreeMap与TreeSet的关系"><a href="#TreeMap与TreeSet的关系" class="headerlink" title="TreeMap与TreeSet的关系"></a>TreeMap与TreeSet的关系</h3><p><strong>通过查看源码,可发现TreeSet实际上是调用了TreeHap来实现的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;());</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><ul>
<li>概念:集合工具类,定义了除了存取以外的集合常用方法</li>
</ul>
<h3 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法:"></a>常用方法:</h3><ul>
<li>public static void sort(List<T> list)//升序排列(元素必须实现Comparable接口)</T></li>
<li>public static void reverse(List<T> list) //反转元素集合顺序</T></li>
<li>public static void shuffle(List<T> list) //随机重置集合元素的顺序</T></li>
<li>public static int binarySearch(List<T> list , T object)//二分查找(前提元素已经是排序好的),返回索引值</T></li>
<li>public static void copy(List copy_list,List list)//复制,不过两个参数的元素个数必须相同</li>
</ul>
<h4 id="补充扩展"><a href="#补充扩展" class="headerlink" title="补充扩展:"></a>补充扩展:</h4><p>(1) <strong>当把数组转换成集合时,该转化的集合是一个受限集合,不能添加或者删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;zhan&quot;</span>,<span class="string">&quot;wenwen&quot;</span>&#125;;</span><br><span class="line">List&lt;Stirng&gt; list = Arrays.asList(names);  <span class="comment">//此集合不能添加或者删除元素</span></span><br></pre></td></tr></table></figure>

<p>(2) <strong>把基本类型数组转化成集合时,需要注意</strong>由于基本类型数组也是引用类型数据,故转化后的集合只有一个元素(即该基本数据类型数组)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] nums = &#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(nums);  <span class="comment">//错误!!!! int[] 并不等同于Integer</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; list = Arrays.asList(nums);<span class="comment">//此集合只要一个元素,该元素是一个数组,nums</span></span><br><span class="line"><span class="comment">/*********或者修改为如下所示*****************/</span></span><br><span class="line">Integer[] nums = &#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(nums);  <span class="comment">//此集合包含三个元素,都是Integer对象</span></span><br></pre></td></tr></table></figure>



<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述:"></a>线程概述:</h2><ol>
<li><p><strong>线程是CPU的基本调度单位,进程是操作系统的基本调度的单位,一个进程由一个或者多个线程组成</strong></p>
</li>
<li><p><strong>在同一个进程中的线程资源共享,但是进程之间相互独立</strong></p>
</li>
<li><p><strong>线程抢占式执行</strong></p>
</li>
<li><p><strong>线程的组成:</strong></p>
</li>
</ol>
<p>(1)<strong>时间片:</strong> 操作系统(OS)会为每个线程分配执行时间<br>(2)<strong>运行数据:</strong> </p>
<ul>
<li>堆空间:存储线程中使用的对象,多个线程可以共享堆中的对象</li>
<li>栈空间:存储线程中使用的局部变量,每个线程都有拥有独立的栈<br><img src="1625803842920030.png" alt="关系示意图"></li>
</ul>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>1.<strong>继承Thread类创建线程,并且重写run()方法:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//这里写该线程要执行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>实现接口runnable</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myrunnable</span> implement Runnable&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//需要执行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//使用Thread的有参构造器来创建线程</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Myrunnable</span>());</span><br><span class="line">    <span class="comment">//也可不实现Runnable,直接使用匿名内部类</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">tread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        run()&#123;</span><br><span class="line">        <span class="comment">//匿名类创建的线程的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法:"></a>构造方法:</h3><p>1.**Thread():**无参构造<br>2.**Thread(Runnable run):**有参构造,**绑定的接口Runnable的线程,执行方法由Runnble提供,**<strong>降低耦合性</strong><br>3.**Thread(String name):**参数代表创建线程时将其命名<br>4.**Thread(Runnable run,String name):**绑定接口,并且将其线程命名</p>
<h3 id="常用方法-8"><a href="#常用方法-8" class="headerlink" title="常用方法:"></a>常用方法:</h3><p> 1.<strong>void start():启动线程</strong>,注意!thread.start()与thread.run()有本质区别,虽然有时候执行结果是一样的<br> 2.<strong>static Thread currentThread():</strong> 获得当前线程<br> 3.Stirng getId():获得线程ID,<strong>每个线程ID是唯一的且由OS提供,不能更改</strong><br> 3.Srting getName(): 获得线程的名称,线程名称可以自定义</p>
<h2 id="线程的优先级-Priority"><a href="#线程的优先级-Priority" class="headerlink" title="线程的优先级(Priority):"></a>线程的优先级(Priority):</h2><h4 id="线程的优先级为1-10-默认为5-优先级越高-表示获得CPU的机会越多"><a href="#线程的优先级为1-10-默认为5-优先级越高-表示获得CPU的机会越多" class="headerlink" title="线程的优先级为1-10,默认为5,优先级越高,表示获得CPU的机会越多"></a>线程的优先级为1-10,默认为5,优先级越高,表示获得CPU的机会越多</h4><h4 id="设置优先级的方法-线程对像-setPriority-int-newPriority-其中的参数表示设置的优先级"><a href="#设置优先级的方法-线程对像-setPriority-int-newPriority-其中的参数表示设置的优先级" class="headerlink" title="设置优先级的方法:线程对像.setPriority(int newPriority),其中的参数表示设置的优先级"></a>设置优先级的方法:线程对像.setPriority(int newPriority),其中的参数表示设置的优先级</h4><h2 id="线程的4-6-种状态"><a href="#线程的4-6-种状态" class="headerlink" title="线程的4(6)种状态:"></a>线程的4(6)种状态:</h2><p><img src="1625920196785255.png"><br><em>注:线程的运行结束时间片到期不代表线程销毁,run()方法执行完毕线程才真正销毁;<br>某个线程的run()方法还没结束但是时间片到期了,其他线程也能抢占CPU进而执行</em></p>
<h3 id="常用方法-9"><a href="#常用方法-9" class="headerlink" title="常用方法:"></a>常用方法:</h3><h4 id="1-启动"><a href="#1-启动" class="headerlink" title="(1)启动"></a>(1)启动</h4><p><strong>void start():启动线程</strong>,注意!thread.start()与thread.run()有本质区别,虽然有时候执行结果是一样的</p>
<h4 id="2-sheep休眠-线程时间片用完后就休息-等待-一段时间再争取"><a href="#2-sheep休眠-线程时间片用完后就休息-等待-一段时间再争取" class="headerlink" title="(2)sheep休眠:线程时间片用完后就休息(等待)一段时间再争取"></a>(2)sheep休眠:线程时间片用完后就休息(等待)一段时间再争取</h4><p><strong>static void sleep(long 等待毫秒数):</strong>,时间片每用完一次就休息一会</p>
<h4 id="3-yield放弃-避让-主动放弃争取本次时间片让给其他线程机会-回到就绪状态进行下一次的时间片的争取"><a href="#3-yield放弃-避让-主动放弃争取本次时间片让给其他线程机会-回到就绪状态进行下一次的时间片的争取" class="headerlink" title="(3)yield放弃(避让):主动放弃争取本次时间片让给其他线程机会,回到就绪状态进行下一次的时间片的争取"></a>(3)yield放弃(避让):主动放弃争取本次时间片让给其他线程机会,回到就绪状态进行下一次的时间片的争取</h4><p>**static void yield():**主动将当前线程放弃</p>
<h4 id="4-join加入-在一个线程中加入另一个线程后-当前线程会进入堵塞状态-等待加入的线程执行完以后再执行当前线程"><a href="#4-join加入-在一个线程中加入另一个线程后-当前线程会进入堵塞状态-等待加入的线程执行完以后再执行当前线程" class="headerlink" title="(4)join加入:在一个线程中加入另一个线程后,当前线程会进入堵塞状态,等待加入的线程执行完以后再执行当前线程"></a>(4)join加入:在一个线程中加入另一个线程后,当前线程会进入堵塞状态,等待加入的线程执行完以后再执行当前线程</h4><p><strong>final void join():</strong>,如addThread.join(),代表在当前线程中加入addThread线程</p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><h3 id="前台线程"><a href="#前台线程" class="headerlink" title="前台线程"></a><strong>前台线程</strong></h3><h3 id="守护线程-即后台线程"><a href="#守护线程-即后台线程" class="headerlink" title="守护线程(即后台线程)"></a>守护线程(即后台线程)</h3><p>守护线程即为前台线程服务的线程</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h3><p><strong>void setDaemon(true):</strong>,前台线程<br><strong>注意:当前台线程结束后,守护线程无论是否执行完毕都会自动结束,java中的垃圾回收器就算一个守护线程</strong></p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p><strong>描述:多个线程共同操作同一空间,会出现数据丢失的情况<br>当多个线程并发访问临界资源,如果破坏原子操作,可能会出现数据不一致</strong></p>
<ul>
<li>共享资源: 即共享资源,<strong>一次仅允许一个线程使用才能保证其正确性</strong></li>
<li>原子操作: 不可分割的多部操作,被视为一个整体,其顺序和步骤不可打乱或者缺省<br>例子:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Thread_safe</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//共享资源</span></span><br><span class="line">        String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//线程a</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        	<span class="meta">@Override</span></span><br><span class="line">        	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//原子操作</span></span><br><span class="line">            s[index++] = <span class="string">&quot;hello&quot;</span>;    </span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="comment">//线程b</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//原子操作</span></span><br><span class="line">                s[index++] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        <span class="comment">/*加入线程是保证a,b,线程完毕执行完毕在执行主线程的打印语句 */</span></span><br><span class="line">        a.join();</span><br><span class="line">        b.join();</span><br><span class="line">        System.out.println(Arrays.toString(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在没有发生安全问题时的输出结果应该为:<br>[world, hello, null, null, null]或<br>[hello, world, null, null, null],发生安全问题后则结果为:[world, null, null, null, null]或[world, null, null, null, null]</strong></p>
<h4 id="常见的Java线程安全类-如StringButter-Hashtble-Vector等"><a href="#常见的Java线程安全类-如StringButter-Hashtble-Vector等" class="headerlink" title="常见的Java线程安全类:如StringButter,Hashtble,Vector等"></a>常见的Java线程安全类:如StringButter,Hashtble,Vector等</h4><h3 id="synchronized-关键字的使用"><a href="#synchronized-关键字的使用" class="headerlink" title="synchronized 关键字的使用"></a>synchronized 关键字的使用</h3><p><strong>在使用synchronized添加锁时一定要注意是否是同一个对象锁,不可使用new 创建一个对象锁</strong>如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注意!这样的锁没意义,每次都会创建一个新的锁对象*/</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">new</span> <span class="title class_">Object</span>())&#123;</span><br><span class="line"><span class="comment">//原子操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(1)synchronized(){代码块}:</strong>,同步代码块,给代码块添加锁<br>**(2)synchronized 方法(){}:**修饰为同步方法(<strong>注意:当同步方法为非静态方法时,锁对象是this,当是静态方法时锁对象是类即 类.class</strong>)</p>
<h2 id="线程通信-堵塞线程以及唤醒线程"><a href="#线程通信-堵塞线程以及唤醒线程" class="headerlink" title="线程通信(堵塞线程以及唤醒线程)"></a>线程通信(堵塞线程以及唤醒线程)</h2><p><strong>通过synchronized可以对方法和代码块上锁,同样的也可以通过锁对象调用waitin()方法来将线程加入等待队列(加入等待队列的线程无法抢夺CPU,直到使用notify()方法将其唤醒)<br>从而释放该线程锁占用的锁,使得其他线程有机会抢夺CPU</strong></p>
<h3 id="常用方法-10"><a href="#常用方法-10" class="headerlink" title="常用方法:"></a>常用方法:</h3><p><em>注意:调用这几个方法的对象都是锁</em><br><strong>1.锁对象.wait():将线程持有的锁释放,线程加入等待队列,等待队列的线程不能参与CPU的争夺</strong><br><strong>2.notify():<br>(1)随机唤醒等待队列的一个线程,唤醒的线程不一定只是有争夺CPU的机会并不一定能夺得CPU;<br>(2)唤醒的线程执行时将从wait()处开始执行</strong><br><strong>3.notifyAll():唤醒等待队列的全部线程</strong></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题:"></a>常见问题:</h3><p><em>假设有四个线程:两个存钱线程(晨晨,明明),两个取钱线程(冰冰,莉莉),要求有银行卡里没钱时不能取钱,银行卡里有钱时不能存钱</em></p>
<ul>
<li><strong>问题1:标记没进行二次判断</strong><br>加入在判断时使用如下代码进行存钱的操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">subMonney</span><span class="params">(<span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="comment">//如果没钱</span></span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">this</span>.monney -= m;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取出&quot;</span>+m+<span class="string">&quot;剩余:&quot;</span>+<span class="built_in">this</span>.monney);</span><br><span class="line">         <span class="comment">//修改标记</span></span><br><span class="line">         flag = <span class="literal">false</span>;</span><br><span class="line">         <span class="comment">//唤醒线程</span></span><br><span class="line">         <span class="built_in">this</span>.notifyAll();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>例如:<br>当两个取钱线程处于等待队列时,晨晨执行成功,修改了余额标记,唤醒莉莉<br>接着莉莉开始执行,执行成功后,<strong>唤醒了冰冰,即使已经修改了标记,但是方法中的if语句已经执行完毕,不会再次判断,而是直接从this.wait()语句之后开始执行,于是导致再次进行了取钱操作</strong>导致余额变成了负数导致程序与预期不一样<br><strong>解决方案:将if换成while可以多次判断</strong></p>
<ul>
<li><strong>问题2: 全部陷入等待队列导致死锁</strong><br>例如:<br>前两次执行了取钱操作均失败,都进入等待队列<br>第三次晨晨存钱成功,修改标记,唤醒冰冰<br>第四次明明存钱失败,释放锁,进入等待队列<br>第五次晨晨存钱失败,释放锁,进入等待队列<br>第六次冰冰取钱成功,修改标记,唤醒莉莉**(问题所在,当唤醒的是功能相同的线程时,最终都两个取钱线程操作失败都进入等待队列形成死锁)**<br>第七次莉莉取钱失败,释放锁进入等待队列<br>第八次冰冰也取钱失败释放锁进入等待队列<br><strong>解决方案:将notify()方法替换成notifyAll()唤醒全部线程</strong></li>
</ul>
<h2 id="高级线程"><a href="#高级线程" class="headerlink" title="高级线程"></a>高级线程</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>线程池:即线程的容器</strong></p>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p><strong>Executor:线程池的顶级接口</strong><br><strong>ExecutorService:线程池服务接口,用于管理线程池</strong><br><strong>Executos,线程池工厂类,用于创建线程池</strong></p>
<h4 id="ExecutorService的常用方法"><a href="#ExecutorService的常用方法" class="headerlink" title="ExecutorService的常用方法"></a>ExecutorService的常用方法</h4><p><strong>submit(Runnable task):向线程池提交任务</strong><br><strong>shutdown():关闭线程池,如果不关闭程序不会停止</strong></p>
<h4 id="Executors的常用方法"><a href="#Executors的常用方法" class="headerlink" title="Executors的常用方法"></a>Executors的常用方法</h4><p>(1)创建固定大小的线程池: <strong>staitc newFixedThreadPool(int 个数)</strong><br>(2)创建缓存线程池:<strong>static newCachedThreadPool()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*常见的创建线程池并使用的格式如下*/</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(n); <span class="comment">//n为线程个数</span></span><br><span class="line"><span class="comment">//创建缓存线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">es2</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="type">Runnablme</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//线程执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//提交任务</span></span><br><span class="line">es.submit(task);</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">es.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="Callable接口和Future接口"><a href="#Callable接口和Future接口" class="headerlink" title="Callable接口和Future接口"></a>Callable接口和Future<T>接口</T></h3><h4 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口:"></a>Callable接口:</h4><p>使用方法和Runable接口类似,其实现方法是call()方法,<strong>与run()方法的区别:call()方法可以抛出异常声明和拥有返回值,而run()方法都不可以<br>但由于Thread的构造方法中没有Callable接口的参数,故没法直接绑定到线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用匿名内部类创建callable上转型对象</span></span><br><span class="line">Callable&lt;V&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;()&#123;</span><br><span class="line">        &lt;V&gt; call()&#123;</span><br><span class="line">        <span class="comment">//执行语句</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*无法直接添加线程</span></span><br><span class="line"><span class="comment">故需要使用FutureTask&lt;V&gt;类(此类实现了Runnable接口和Future接口)进行转换*/</span></span><br><span class="line">FutureTask&lt;V&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;V&gt;(callable);</span><br><span class="line"><span class="comment">/* 由于FutureTask&lt;T&gt;实现了Runnable接口故可以添加到线程中*/</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br></pre></td></tr></table></figure>

<p><em>注:</em> <strong>不过线程池的submit()方法可以直接添加Callable接口对象</strong></p>
<h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口:"></a>Future<T>接口:</T></h4><p><strong>Future<T>接口表示执行任务的结果,如ExecutorSerVice中的submit()方法的返回类型就是Future<V></V></T></strong><br><strong>常见方法:<T>get():获取future对象的结果</T></strong><br>故常见写法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//创建Future&lt;V&gt;对象接收线程池的接收结果</span></span><br><span class="line">Future&lt;Integer&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">                <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">                    sum+=i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//打印获取结果</span></span><br><span class="line">        System.out.println(future.get());</span><br></pre></td></tr></table></figure>

<h3 id="线程的同步和异步"><a href="#线程的同步和异步" class="headerlink" title="线程的同步和异步"></a>线程的同步和异步</h3><p>**同步(有等待):**形容一次方法的调用,同步一旦开始,必须等待该方法返回才能继续.<br>**异步(无等待):**形容一次方法调用,异步一旦开始,像是一次消息传递,调用者告知后立刻返回.两者竞争时间片,并发执行.</p>
<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><h4 id="ReentrantLock-实现类-即重入锁"><a href="#ReentrantLock-实现类-即重入锁" class="headerlink" title="ReentrantLock(实现类,即重入锁)"></a>ReentrantLock(实现类,即重入锁)</h4><p><strong>功能与synchronized类似</strong><br>JDK5加入与synchronized比较,<strong>显示定义,需要手动释放,结构更灵活,功能更强大,性能更优越</strong><br><em>区别:synchronized采用悲观锁,而Lock采用乐观锁(乐观锁通俗说就是不堵塞其他线程假设不会冲突,如果冲突就不断重试)</em></p>
<h4 id="ReentrantReadWriteLock-读写锁-可分别分配读锁和写锁"><a href="#ReentrantReadWriteLock-读写锁-可分别分配读锁和写锁" class="headerlink" title="ReentrantReadWriteLock(读写锁):可分别分配读锁和写锁"></a>ReentrantReadWriteLock(读写锁):可分别分配读锁和写锁</h4><p><strong>互斥规则:</strong></p>
<ul>
<li>写-写,互斥堵塞</li>
<li>读-写,互斥,读堵塞写,写堵塞读</li>
<li>读-读,不互斥,不堵塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建读写锁</span></span><br><span class="line"><span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="comment">//分配读锁</span></span><br><span class="line"><span class="type">ReadLock</span> <span class="variable">readlock</span> <span class="operator">=</span> rwl.ReadLock();</span><br><span class="line"><span class="comment">//分配写锁</span></span><br><span class="line"><span class="type">WriteLock</span> <span class="variable">writelock</span> <span class="operator">=</span> rwl.WriteLock();</span><br><span class="line"><span class="comment">/*读写锁的获取锁的方式和释放锁的方式和重入锁一致 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ReentrantReadLock</strong> 读锁<br><strong>可并发</strong>执行,即允许多个线程同时拿到读锁</li>
<li><strong>ReentantWriteLock</strong> 写锁<br><strong>不可并发</strong>执行,一次只允许一个线程获得写锁</li>
</ul>
<h1 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h1><h2 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h2><p>如: @Override</p>
<h4 id="Annotation的作用"><a href="#Annotation的作用" class="headerlink" title="Annotation的作用:"></a>Annotation的作用:</h4><ul>
<li>不是程序本身,对程序做出解释</li>
<li>可以被其他程序读取</li>
</ul>
<h4 id="Annotation的格式"><a href="#Annotation的格式" class="headerlink" title="Annotation的格式"></a>Annotation的格式</h4><ul>
<li>以@注解名在代码中存在,可以有参数值,例如:@SuppressWarmings(value=”unchecked”)</li>
<li>Annotation可以作用在method,fleld(字段),TYPE(类型),package,class,上面,相当于给他们添加了额外的辅助信息,我们可以通过反射机制编程实现对这些元数据的访问</li>
</ul>
<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul>
<li>@Override:定义在java,.lang.Override中,此注解用于修饰方法中,表示这个方法是要覆盖父类方法的</li>
<li>Deprecated: 此注解可以修饰方法,类,属性,表示已经过时,不推荐使用,通常是危险的或者是有更好的替代</li>
<li>@SuppressWarmings:用于抑制编译器的警告信息,与前两个注解不同,此注解必须要有参数,参数是已经定义好的</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解用于对其他注解的定义修饰</p>
<ul>
<li>@Target:用于描述注解的使用范围</li>
<li>@Retention:表示需要在什么级别保留该注解信息,用于描述注解的声明周期(source&lt;class&lt;runntime)</li>
<li>@Document:说明该注解被包含在javadoc中</li>
<li>@Inherited:说明子类可以<strong>继承</strong>父类的中的该注解<br>JDk中@Override注解的源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义此注解的使用范围</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="comment">//定义此注解的生命周期</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul>
<li>自定义注解的格式:public @注解名{定义内容}</li>
<li>其中每一个(抽象)方法实际上是声明了一个配置参数</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只要一个参数成员,一般参数名为value,因为只有一个参数且名为value时使用可隐式赋值参数</li>
<li>注解元素必须要有值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义注解</span></span><br><span class="line"><span class="meta">@Target(Element.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@myAnnotation</span>&#123;</span><br><span class="line">    <span class="comment">//注解参数: 参数类型+参数名();</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="comment">//如果参数没有默认值,就必须给参数赋值</span></span><br><span class="line">    <span class="meta">@myAnnotation(&quot;自定义的注解&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型只能是参数的类型(返回值只能是Class,String,enum)</li>
</ul>
<h2 id="Reflection反射机制"><a href="#Reflection反射机制" class="headerlink" title="Reflection反射机制"></a>Reflection反射机制</h2><h3 id="动态VS静态语言"><a href="#动态VS静态语言" class="headerlink" title="动态VS静态语言"></a>动态VS静态语言</h3><ul>
<li>动态语言:是指在运行是可以改变其结构的语言,像新的函数,对象,甚至代码可以被引进.如JavaScript,PHP,Python,C#等</li>
<li>静态语言:与动态语言相对应,运行时结构不能改变的语言,如: C C++,Java(但是java也有一定的动态性,可利用反射机制获得类似动态语言的特性)</li>
</ul>
<h3 id="反射机制提供的功能"><a href="#反射机制提供的功能" class="headerlink" title="反射机制提供的功能"></a>反射机制提供的功能</h3><ul>
<li>在运行时判断一个对象所属的类</li>
<li>在运行时构造一个任意类的对象</li>
<li>在运行时判断一个类具有的属性和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的属性和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><ul>
<li>优点:可以实现动态创建对象和编译,具有很大的灵活性</li>
<li>缺点:对性能有影响,使用反射基本上是一种解释操作,我们可以告诉JVM,我们希望做什么并且他满足我们的要求,这类操作总是慢于我们相同的操作</li>
</ul>
<h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><p><strong>一个类只有一个Class对象,并且类在加载后由系统创建,类的结构信息会封装在Class对象中</strong></p>
<p>在加载完类之后,在堆内存区中就产生了一个Class类型的对象(一个类中只有一个Class对象),这个对象包含了完整的类结构信息,<strong>我们可以通过这个Class对象看到类的结构</strong>,这个对象就像一面镜子,通过这个镜子看到类的结构,我们形象的称之为:反射</p>
<h4 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式:"></a><strong>创建对象的方式:</strong></h4><ul>
<li>正常方式: (1)引入包类名称 (2)通过new 实例化 (取得实例化对象)</li>
<li>反射方式 (1)实例化对象 (2) getClass()方法 (3)得到完整的”包类名称”(即获得一个Class 对象)<br>获得Class对象的几种常用方式:<br>方式一:通过对象.getClass()<br>方式二:通过Class.forName(“包类名”)<br>方式三:通过类名.class</li>
</ul>
<h4 id="常用方法-11"><a href="#常用方法-11" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>static Class forName(String name) 返回指定类名的Class对象</li>
<li>Class newInstance() 调用构造器返回Class对象的实例</li>
<li>Class getSuperClass() 返回当前Class对象的父类的Class对象</li>
<li>Class[] getInterface()</li>
<li>ClassLoader getClassLoader() 返回该类的类加载器</li>
</ul>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h4 id="1-Load-类的加载-将类的Class文件读入内存-并为之创建一个Class文件-此过程由类加载器完成"><a href="#1-Load-类的加载-将类的Class文件读入内存-并为之创建一个Class文件-此过程由类加载器完成" class="headerlink" title="(1)Load:类的加载:将类的Class文件读入内存,并为之创建一个Class文件,此过程由类加载器完成"></a>(1)Load:类的加载:将类的Class文件读入内存,并为之创建一个Class文件,此过程由类加载器完成</h4><h4 id="2-Link-类的链接-将类的二进制数据合并到JRE中"><a href="#2-Link-类的链接-将类的二进制数据合并到JRE中" class="headerlink" title="(2)Link:类的链接:将类的二进制数据合并到JRE中"></a>(2)Link:类的链接:将类的二进制数据合并到JRE中</h4><ul>
<li>**验证:**确保加载的类的信息符合JVM规范,没有安全问题</li>
<li><strong>准备:</strong> <strong>正式为静态变量分配内存并设置初始值</strong>,这些内存都在方法区中分配</li>
<li>**解析:**虚拟机常量池的符号引用(常量名)替换为直接引用(地址)的过程</li>
</ul>
<h4 id="3-Initialize-类的初始化-JVM负责对类进行初始化"><a href="#3-Initialize-类的初始化-JVM负责对类进行初始化" class="headerlink" title="(3)Initialize:类的初始化:JVM负责对类进行初始化"></a>(3)Initialize:类的初始化:JVM负责对类进行初始化</h4><ul>
<li>执行类构造器<clinit>()方法的过程,<strong>类构造器<clinit>()方法是由编译期自动收集所有类变量的赋值动作和静态代码块的语句合并产生的</clinit></strong>(此类构造器与对象的构造器即构造方法不是同一个东西)</clinit></li>
<li>当初始化一个类时,如果返现其父类还未初始化会先初始化父类</li>
<li>JVM会保证一个类的构造器的<clinit>()方法在多线程环境中被正确加锁和同步<br>如:</clinit></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;m=&quot;</span>+A.m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="comment">/*(2)在类的链接完毕后JVM会将类进行初始化,自动将所有的类变量和静态代码块按代码顺序收集整合,故按顺序执行赋值语句, m=100,m=200*/</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*(1)实际上下面这条语句的执行在两个过程,首先在类的链接过程中执行 static int m=0,即正式为m分配内存,并且为其设置初始值0 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">200</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类的无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:<br>A类静态代码块<br>A类的无参构造<br>m=200</p>
<h5 id="什么时候会发生类的初始化"><a href="#什么时候会发生类的初始化" class="headerlink" title="什么时候会发生类的初始化?"></a>什么时候会发生类的初始化?</h5><ul>
<li><strong>类的主动引用(一定会发生类的初始化):</strong><br>-&gt; 当虚拟机启动,先初始化main()方法所在的类<br>-&gt; new 一个类的对象<br>-&gt; 调用类的静态成员和静态方法(除了final常量)<br>-&gt; 使用java.lang.reflect包的方法对类进行反射调用<br>-&gt; 当初始化一个类,如果其类的父类没有被初始化,则会先初始化他的父类</li>
<li><strong>类的被动引用(不会发生类的初始化):</strong><br>-&gt; 当访问一个静态域时,只有真正声明这个域的类才会被初始化,如:当通过子类引用父类的静态变量,不会导致子类初始化<br><code>Son.m  //其中m为父类的类变量,但是父类初始化</code><br>-&gt; 通过数组定义类引用,不会触发此类的初始化<br>-&gt; 引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器作用是用来把类装载进内存.JVM规定了如下类型的加载器</p>
<ul>
<li>引导类加载器:用C++编写,是JVM自带的加载器,<strong>负责java平台核心库的装载,该类无法直接获取</strong></li>
<li>扩展类加载器:负责jre/lib/ext目录下的jar包或者指定目录下的jar包装装入工作库</li>
<li>系统类加载器: 负责java-classpath或者-D java.class.path所指的目录下的类与jar包装入工作,<strong>是最常用的加载器</strong><br>测试代码:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//获取系统类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(systemClassLoader);</span><br><span class="line"><span class="comment">//获取系统类加载器的父类加载器--&gt;拓展类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">System.out.println(parent);</span><br><span class="line"><span class="comment">//获取扩展类的父类加载器--&gt;根加载器(用C++编写)</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">root</span> <span class="operator">=</span> parent.getParent();</span><br><span class="line">System.out.println(root);</span><br><span class="line"><span class="comment">//测试当前类的加载器是哪个加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> TestLoader.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line"><span class="comment">//获取JDK内置类的加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">jdkLoader</span> <span class="operator">=</span>Object.class.getClassLoader(); </span><br><span class="line">System.out.println(jdkLoader);</span><br></pre></td></tr></table></figure>

<p>运行结果:<br>jdk.internal.loader.ClassLoaders$AppClassLoader@2077d4de   系统类加载器<br>jdk.internal.loader.ClassLoaders$PlatformClassLoader@3830f1c0  扩展类加载器<br>null    由于是根加载器,即引导类加载器,无法获取,所以为空<br>jdk.internal.loader.ClassLoaders$AppClassLoader@2077d4de 用户自定义的类也是由系统类加载器加载<br>null   JDK内置类的加载器也是根加载器</p>
<h3 id="获取类的结构"><a href="#获取类的结构" class="headerlink" title="获取类的结构"></a>获取类的结构</h3><p>通过反射能获取到类的结构有:</p>
<ul>
<li><strong>Field(属性)</strong></li>
<li><strong>Method</strong></li>
<li><strong>Constructor(构造方法)</strong></li>
<li><strong>Annotation</strong></li>
<li><strong>SuperClass</strong></li>
<li><strong>Interface</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = c1.getFields();   <span class="comment">//获得public 的属性</span></span><br><span class="line">Field[] fields2 = c1.getDeclaredFields();  <span class="comment">//获的全部属性</span></span><br><span class="line">Field[] fields = c1.getFields();   <span class="comment">//获得public 的属性</span></span><br><span class="line">Field[] fields2 = c1.getDeclaredFields();  <span class="comment">//获的全部属性</span></span><br><span class="line"><span class="comment">//获得指定属性的值</span></span><br><span class="line"><span class="comment">//Field name = c1.getField(&quot;name&quot;); //获得public 的属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>); <span class="comment">//获得全部</span></span><br><span class="line"><span class="comment">//获得方法</span></span><br><span class="line">Method[] methods = c1.getMethods();  <span class="comment">//获取所所有的public方法,包括父类的</span></span><br><span class="line">Method[] methods2 = c1.getDeclaredMethods(); <span class="comment">//只获得自己的全部方法</span></span><br><span class="line"><span class="comment">//获得指定方法,提供方法名和参数</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">met</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;getName&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">met2</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors(); <span class="comment">//获得所有的public 构造器</span></span><br><span class="line">Constructor&lt;?&gt; constrcutor = c1.getConstructor(String.class,String.class); <span class="comment">//获得指定的构造器</span></span><br></pre></td></tr></table></figure>

<p><em>即不带有Declared的只能获取public 的,带有Declared自己所拥有的(不包括父类)</em></p>
<h3 id="反射动作"><a href="#反射动作" class="headerlink" title="反射动作"></a>反射动作</h3><p>有了类的Class对象,就可以:</p>
<h5 id="1-构造对象"><a href="#1-构造对象" class="headerlink" title="(1)构造对象"></a>(1)构造对象</h5><ul>
<li>有无参数构造: 调用Class对象的newInstance()方法<br>-&gt; 类必须有无参构造方法<br>-&gt; 无参构造方法的访问权限必须足够</li>
<li>没有无参构造:<br>步骤如下: (1)通过Class类的getDeclareConstructot(Class …paremeterTypes)取得指定<strong>Constructor对象, (2)Constrcutor对象调用new Instance()方法</strong></li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//获得Class对象</span></span><br><span class="line"> Class&lt;User&gt; c1 = User.class;</span><br><span class="line"><span class="comment">//构造一个对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> c1.getDeclaredConstructor().newInstance();<span class="comment">//newInstance()方法过时,本质是调用了无参构造</span></span><br><span class="line"><span class="comment">//调用有参构造</span></span><br><span class="line">Constructor&lt;User&gt; constructors = c1.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) constructors.newInstance(<span class="string">&quot;雯雯&quot;</span>,<span class="number">1234</span>);</span><br></pre></td></tr></table></figure>

<h5 id="2-调用普通方法"><a href="#2-调用普通方法" class="headerlink" title="(2)调用普通方法"></a>(2)调用普通方法</h5><p> 首先获取通过Class对象获取到<strong>Method对象,然后Method调用invoke(方法所在的对象,实参列表)方法</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;User&gt; constructors = c1.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) constructors.newInstance(<span class="string">&quot;雯雯&quot;</span>,<span class="number">1234</span>);</span><br><span class="line"> <span class="comment">//通过反射调用普通方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">               System.out.println(getName.invoke(user2));</span><br><span class="line">        <span class="type">Method</span> <span class="variable">setName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">               setName.invoke(user2, <span class="string">&quot;丽丽&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="3-操作属性"><a href="#3-操作属性" class="headerlink" title="(3) 操作属性"></a>(3) 操作属性</h5><p> 首先通过Class对象获取<strong>Field对象,Field对象调用Set(字段所在属性类的对象,字段的值)方法</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射操作属性</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span>(User) c1.getDeclaredConstructor().newInstance();  <span class="comment">//创建对象</span></span><br><span class="line">      <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>); </span><br><span class="line">            <span class="comment">//不能直接访问,需要设置访问权限开放</span></span><br><span class="line">            name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            name.set(user3, <span class="string">&quot;潇潇&quot;</span>);</span><br><span class="line">            System.out.println(user3.getName());</span><br></pre></td></tr></table></figure>

<h3 id="设置可访问权限"><a href="#设置可访问权限" class="headerlink" title="设置可访问权限"></a>设置可访问权限</h3><p> Constructor Method Field 都有一个setAccessible(boolean flage)方法,<strong>默认情况下是false,即使访问权限不开放,private修饰的成员是不可见的,但设置为true之后,将开放访问权限,使得哪怕是private成员也可见</strong>(频繁使用反射建议开放)</p>
<h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比:"></a>性能对比:</h4><p><strong>普通方式&gt;反射(开放权限)&gt;反射(不开放权限)</strong></p>
<h3 id="反射获取注解与ORM-对像关系映射"><a href="#反射获取注解与ORM-对像关系映射" class="headerlink" title="反射获取注解与ORM(对像关系映射)"></a>反射获取注解与ORM(对像关系映射)</h3><p>**对象关系映射:**将实体类映射成一个表,其中</p>
<ul>
<li>类和表结构对应</li>
<li>属性和字段对应</li>
<li>对象和记录对应</li>
</ul>
<h3 id="重点-反射获取注解"><a href="#重点-反射获取注解" class="headerlink" title="(重点)反射获取注解"></a>(重点)反射获取注解</h3><p>注解的做<strong>作用域对象调用getAnnotation(Class Element)方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类名的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Table&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义属性的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> TableField&#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">type</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="meta">@Table(value = &quot;db_student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@TableField(columnName = &quot;db_No&quot;,type = &quot;int&quot;, length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> stuNo;</span><br><span class="line">    <span class="meta">@TableField(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;, length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@TableField(columnName = &quot;db_age&quot;,type = &quot;int&quot;, length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/********************************************************/</span></span><br><span class="line">Class&lt;Student&gt; c1 = Student.class;</span><br><span class="line">        <span class="comment">//获得类的注解</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span>(Table) c1.getAnnotation(Table.class);</span><br><span class="line">        <span class="comment">//获得name属性的注解</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f1</span> <span class="operator">=</span> c1.getDeclaredField();  <span class="comment">//先获得字段对象</span></span><br><span class="line">        <span class="type">TableField</span> <span class="variable">name</span> <span class="operator">=</span> f1.getAnnotation(TableField.class);  <span class="comment">//通过字段对象获取注解</span></span><br><span class="line">        <span class="comment">//获得注解的值</span></span><br><span class="line">        name.columnName();</span><br><span class="line">        name.type();</span><br><span class="line">        name.length();</span><br></pre></td></tr></table></figure>

<h3 id="反射操作泛型"><a href="#反射操作泛型" class="headerlink" title="反射操作泛型"></a>反射操作泛型</h3><p>(1) java采用泛型擦除的机制来引入泛型,Java中泛型仅仅是给编译器javac使用的,确保数据的安全性和免去强制转换类型的机制,但是,<strong>一旦编译完成,所有和泛型有关的类型全部擦除</strong><br>如: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">System.out.println(list1.getClass()==list2.getClass());  <span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure>

<p>(2) 通过反射操作这些类型,java新增了<strong>ParamerterizedType,GenericArrayType,TypeVariable和WildcardType几种类型代表不能被归一到Class类中的类型但是又和原始类型齐名的类型</strong></p>
<ul>
<li><strong>ParamerterizedType: 表示参数化类型,即泛型</strong></li>
<li><strong>GenericArrayType: 表示泛型或者引用类型变量的数组</strong></li>
<li>TypeVariable:是各种类型变量的公共父接口</li>
<li>WildcardType:代表一种通配符的类型表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得Class对象方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> Test.class.getMethod(<span class="string">&quot;test01&quot;</span>,Map.class,List.class);</span><br><span class="line">        <span class="comment">//Class[] parameterTypes = m1.getParameterTypes();  //获得参数类型数组,元素为形参的类型(无类型参数)</span></span><br><span class="line">        Type[] parameterTypes= m1.getGenericParameterTypes();  <span class="comment">//获得通用的参数类型数组,元素为形参的类型(有类型参数)</span></span><br><span class="line">        <span class="keyword">for</span> (Type parameterType : parameterTypes) &#123;<span class="comment">//遍历方法的每个参数类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;#方法的参数类型为:&quot;</span>+parameterType);</span><br><span class="line">            <span class="keyword">if</span>(parameterType <span class="keyword">instanceof</span> ParameterizedType) &#123;  <span class="comment">//如果参数为泛型参数</span></span><br><span class="line">                <span class="comment">//获得真实参数类型</span></span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) parameterType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type type : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;*参数的类型参数为:&quot;</span>+type);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="1-Lambda表达式的简介"><a href="#1-Lambda表达式的简介" class="headerlink" title="1. Lambda表达式的简介"></a>1. Lambda表达式的简介</h2><h2 id="1-1-Lambda表达式的概念"><a href="#1-1-Lambda表达式的概念" class="headerlink" title="1.1. Lambda表达式的概念"></a>1.1. Lambda表达式的概念</h2><p>lambda表达式， 是Java8的一个新特性， 也是Java8中最值得学习的新特性之一。</p>
<p>lambda表达式， 从本质来讲， 是一个匿名函数。 可以使用使用这个匿名函数， 实现接口中的方法。<br>对接口进行非常简洁的实现， 从而简化代码。</p>
<h2 id="1-2-Lambda表达式的使用场景"><a href="#1-2-Lambda表达式的使用场景" class="headerlink" title="1.2. Lambda表达式的使用场景"></a>1.2. Lambda表达式的使用场景</h2><p>通常来讲， 使用lambda表达式， 是为了简化接口实现的。</p>
<p>关于接口实现， 可以有很多种方式来实现。 例如： 设计接口的实现类、 使用匿名内部类。 但是<br>lambda表达式， 比这两种方式都简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> 千锋大数据教学团队</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Company</span> 千锋好程序员大数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 2020/4/</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 无参、无返回值的函数式接口</span></span><br><span class="line"> interfaceImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">interfaceImpl</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 1. 使用显式的实现类对象</span></span><br><span class="line"> <span class="type">SingleReturnSingleParameter</span> <span class="variable">parameter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Impl</span>();</span><br><span class="line"> <span class="comment">// 2. 使用匿名内部类实现</span></span><br><span class="line"> <span class="type">SingleReturnSingleParameter</span> <span class="variable">parameter2</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">SingleReturnSingleParameter</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-Lambda表达式对接口的要求"><a href="#1-3-Lambda表达式对接口的要求" class="headerlink" title="1.3. Lambda表达式对接口的要求"></a>1.3. Lambda表达式对接口的要求</h2><p>虽然说， lambda表达式可以在一定程度上简化接口的实现。 但是， 并不是所有的接口都可以使用<br>lambda表达式来简洁实现的。</p>
<p>lambda表达式毕竟只是一个匿名方法。 当实现的接口中的方法过多或者多少的时候， lambda表达式<br>都是不适用的。</p>
<p>lambda表达式，只能实现 <strong>函数式接口</strong> 。</p>
<h2 id="1-4-函数式接口"><a href="#1-4-函数式接口" class="headerlink" title="1.4. 函数式接口"></a>1.4. 函数式接口</h2><h3 id="1-4-1-基础概念"><a href="#1-4-1-基础概念" class="headerlink" title="1.4.1. 基础概念"></a>1.4.1. 基础概念</h3><p>如果说， 一个接口中， 要求实现类 必须 实现的抽象方法， 有且只有一个！ 这样的接口， 就是函数式接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//使用lambda表达式实现</span></span><br><span class="line"> <span class="type">SingleReturnSingleParameter</span> <span class="variable">parameter3</span> <span class="operator">=</span> a -&gt; a * a;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个接口中， 有且只有一个方法， 是实现类必须实现的， 因此是一个函数式接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个接口中， 实现类必须要实现的方法， 有两个！ 因此不是一个函数式接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个接口中， 实现类必须要实现的方法， 有零个！ 因此不是一个函数式接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个接口中， 虽然没有定义任何的方法， 但是可以从父接口中继承到一个抽象方法的。 是一个函数式</span></span><br><span class="line">接口</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Test4</span> <span class="keyword">extends</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个接口， 虽然里面定义了两个方法， 但是defualt方法子类不是必须实现的。</span></span><br><span class="line"><span class="comment">// 因此， 实现类实现这个接口的时候， 必须实现的方法只有一个! 是一个函数式接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>;</span><br><span class="line"> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个接口中的 toString 方法， 是Object类中定义的方法。</span></span><br><span class="line"><span class="comment">// 此时， 实现类在实现接口的时候， toString可以不重写的！ 因为可以从父类Object中继承到！</span></span><br><span class="line"><span class="comment">// 此时， 实现类在实现接口的时候， 有且只有一个方法是必须要重写的。 是一个函数式接口！</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>;</span><br><span class="line"> String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FunctionalInterfaceTest</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-FunctionalInterface"><a href="#1-4-2-FunctionalInterface" class="headerlink" title="1.4.2. @FunctionalInterface"></a>1.4.2. @FunctionalInterface</h3><p>是一个注解 , 用在接口之前 ,判断这个接口是否是一个函数式接口。 如果是函数式接口， 没有任何问题。如果不是函数式接口，则会报错。 功能类似于 @Override。</p>
<h3 id="1-4-3-系统内置的若干函数式接口"><a href="#1-4-3-系统内置的若干函数式接口" class="headerlink" title="1.4.3. 系统内置的若干函数式接口"></a>1.4.3. 系统内置的若干函数式接口</h3><p>Predicate<T> T boolean</T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntPredicate: 参数<span class="type">int</span>， 返回值 <span class="type">boolean</span></span><br><span class="line">LongPredicate: 参数 <span class="type">long</span>， 返回值 <span class="type">boolean</span></span><br><span class="line">DoublePredicate: 参数 <span class="type">double</span>， 返回值 <span class="type">boolean</span></span><br></pre></td></tr></table></figure>

<p>Consumer<T> T void</T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntConsumer: 参数<span class="type">int</span>， 返回值 <span class="keyword">void</span></span><br><span class="line">LongConsumer: 参数 <span class="type">long</span>， 返回值 <span class="keyword">void</span></span><br><span class="line">DoubleConsumer: 参数 <span class="type">double</span>， 返回值 <span class="keyword">void</span></span><br></pre></td></tr></table></figure>

<p>Function&lt;T, R&gt; T R</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;R&gt;: 参数 <span class="type">int</span>， 返回值 R</span><br><span class="line">IntToDoubleFunction: 参数 <span class="type">int</span>， 返回值 <span class="type">double</span></span><br><span class="line">IntToLongFunction: 参数 <span class="type">int</span>， 返回值 <span class="type">long</span></span><br><span class="line">LongFunction&lt;R&gt;: 参数 <span class="type">long</span>， 返回值 R</span><br><span class="line">LongToIntFunction: 参数 <span class="type">long</span>， 返回值 <span class="type">int</span></span><br><span class="line">LongToDoubleFunction: 参数 <span class="type">long</span>， 返回值<span class="type">double</span></span><br><span class="line">DoubleFunction&lt;R&gt;: 参数 <span class="type">double</span>， 返回值 R</span><br><span class="line">DoubleToIntFunction: 参数 <span class="type">double</span>， 返回值 <span class="type">int</span></span><br><span class="line">DoubleToLongFunction: 参数 <span class="type">double</span>， 返回值<span class="type">long</span></span><br></pre></td></tr></table></figure>

<p>Supplier<T> 无 T</T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BooleanSupplier: 参数无， 返回值 <span class="type">boolean</span></span><br><span class="line">IntSupplier: 参数无， 返回值 <span class="type">int</span></span><br><span class="line">LongSupplier: 参数无， 返回值 <span class="type">long</span></span><br><span class="line">DoubleSupplier: 参数无， 返回值 <span class="type">double</span></span><br></pre></td></tr></table></figure>

<p>UnaryOperator<T> T T</T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntUnaryOperator: 参数 <span class="type">int</span>， 返回值 <span class="type">int</span></span><br><span class="line">LongUnaryOperator: 参数 <span class="type">long</span>, 返回值 <span class="type">long</span></span><br><span class="line">DoubleUnaryOperator: 参数 <span class="type">double</span>, 返回值 <span class="type">double</span></span><br></pre></td></tr></table></figure>

<p>BinaryOperator<T></T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntBinaryOperator: 参数 <span class="type">int</span>, <span class="type">int</span>， 返回值 <span class="type">int</span></span><br><span class="line">LongBinaryOperator: 参数 <span class="type">long</span>, <span class="type">long</span>， 返回值</span><br><span class="line"><span class="type">long</span></span><br><span class="line">DoubleBinaryOperator: 参数 <span class="type">double</span>, <span class="type">double</span>， 返</span><br><span class="line">回值 <span class="type">double</span></span><br></pre></td></tr></table></figure>

<p>BiPredicate&lt;L, R&gt; L,R</p>
<p>BiConsumer&lt;T, U&gt;</p>
<p>BiFunction&lt;T, U, R&gt;</p>
<h2 id="2-Lambda表达式的语法"><a href="#2-Lambda表达式的语法" class="headerlink" title="2. Lambda表达式的语法"></a>2. Lambda表达式的语法</h2><h3 id="2-1-Lambda表达式的基础语法"><a href="#2-1-Lambda表达式的基础语法" class="headerlink" title="2.1. Lambda表达式的基础语法"></a>2.1. Lambda表达式的基础语法</h3><p>lambda表达式， 其实本质来讲， 就是一个匿名函数。 因此在写lambda表达式的时候， 不需要关心方法名是什么。实际上， 我们在写lambda表达式的时候， 也不需要关心返回值类型。我们在写lambda表达式的时候， 只需要关注两部分内容即可： <strong>参数列表</strong> 和 <strong>方法体</strong></p>
<p><strong>lambda表达式的基础语法：</strong></p>
<p>参数部分： 方法的参数列表， 要求和实现的接口中的方法参数部分一致， 包括参数的数量和类型。</p>
<p>方法体部分： 方法的实现部分， 如果接口中定义的方法有返回值， 则在实现的时候， 注意返回值的返回。</p>
<p>-&gt;: 分隔参数部分和方法体部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数)-&gt; &#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Syntax</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 1. 无参、无返回值的方法实现</span></span><br><span class="line"> <span class="type">NoneReturnNoneParameter</span> <span class="variable">lambda1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;无参、无返回值方法的实现&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"> lambda1.test();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 2. 有参、无返回值的方法实现</span></span><br><span class="line"> <span class="type">NoneReturnSingleParameter</span> <span class="variable">lambda2</span> <span class="operator">=</span> (<span class="type">int</span> a) -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;一个参数、无返回值方法的实现: 参数是 &quot;</span> + a);</span><br><span class="line">&#125;;</span><br><span class="line"> lambda2.test(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 3. 多个参数、无返回值方法的实现</span></span><br><span class="line"> <span class="type">NoneReturnMutipleParameter</span> <span class="variable">lambda3</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;多个参数、无返回值方法的实现: 参数a是 &quot;</span> + a + <span class="string">&quot;, 参数b</span></span><br><span class="line"><span class="string">是 &quot;</span> + b);</span><br><span class="line">&#125;;</span><br><span class="line"> lambda3.test(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Lambda表达式的语法进阶"><a href="#2-2-Lambda表达式的语法进阶" class="headerlink" title="2.2. Lambda表达式的语法进阶"></a>2.2. Lambda表达式的语法进阶</h3><p>在上述代码中， 的确可以使用lambda表达式实现接口， 但是依然不够简洁， 有简化的空间。</p>
<h3 id="2-2-1-参数部分的精简"><a href="#2-2-1-参数部分的精简" class="headerlink" title="2.2.1. 参数部分的精简"></a>2.2.1. 参数部分的精简</h3><h4 id="参数的类型"><a href="#参数的类型" class="headerlink" title="参数的类型"></a>参数的类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由于在接口的方法中，已经定义了每一个参数的类型是什么。 而且在使用lambda表达式实</span><br><span class="line">现接口的时候， 必须要保证参数的数量和类型需要和接口中的方法保持一致。 因此， 此时</span><br><span class="line">lambda表达式中的参数的类型可以省略不写。</span><br><span class="line">注意事项：</span><br><span class="line">如果需要省略参数的类型， 要保证： 要省略， 每一个参数的类型都必须省略不写。 绝</span><br><span class="line">对不能出现， 有的参数类型省略了， 有的参数类型没有省略。</span><br></pre></td></tr></table></figure>

<h4 id="参数的小括号"><a href="#参数的小括号" class="headerlink" title="参数的小括号"></a>参数的小括号</h4><h4 id="如果方法的参数列表中的参数数量-有且只有一个-，此时，参数列表的小括号是可以省略不写"><a href="#如果方法的参数列表中的参数数量-有且只有一个-，此时，参数列表的小括号是可以省略不写" class="headerlink" title="如果方法的参数列表中的参数数量 有且只有一个 ，此时，参数列表的小括号是可以省略不写"></a>如果方法的参数列表中的参数数量 有且只有一个 ，此时，参数列表的小括号是可以省略不写</h4><h4 id="的。"><a href="#的。" class="headerlink" title="的。"></a>的。</h4><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h4><h4 id="只有当参数的数量是一个的时候，-多了、少了都不能省略。"><a href="#只有当参数的数量是一个的时候，-多了、少了都不能省略。" class="headerlink" title="只有当参数的数量是一个的时候， 多了、少了都不能省略。"></a>只有当参数的数量是一个的时候， 多了、少了都不能省略。</h4><h4 id="省略掉小括号的同时，-必须要省略参数的类型。"><a href="#省略掉小括号的同时，-必须要省略参数的类型。" class="headerlink" title="省略掉小括号的同时， 必须要省略参数的类型。"></a>省略掉小括号的同时， 必须要省略参数的类型。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 4. 无参、有返回值的方法的实现</span></span><br><span class="line"> <span class="type">SingleReturnNoneParameter</span> <span class="variable">lambda4</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;无参、有返回值方法的实现&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> System.out.println(lambda4.test());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 5. 一个参数、有返回值的方法实现</span></span><br><span class="line"> <span class="type">SingleReturnSingleParameter</span> <span class="variable">lambda5</span> <span class="operator">=</span> (<span class="type">int</span> a) -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;一个参数、有返回值的方法实现: 参数是 &quot;</span> + a);</span><br><span class="line"> <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;;</span><br><span class="line"> System.out.println(lambda5.test(<span class="number">9</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 6. 多个参数、有返回值的方法实现</span></span><br><span class="line"> <span class="type">SingleReturnMutipleParameter</span> <span class="variable">lambda6</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;多个参数、有返回值的方法实现: 参数a是 &quot;</span> + a + <span class="string">&quot;, 参数b</span></span><br><span class="line"><span class="string">是 &quot;</span> + b);</span><br><span class="line"> <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"> System.out.println(lambda6.test(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个参数、无返回值的方法实现</span></span><br><span class="line"><span class="type">NoneReturnMutipleParameter</span> <span class="variable">lambda1</span> <span class="operator">=</span> (a, b) -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;多个参数、无返回值方法的实现: 参数a是 &quot;</span> + a + <span class="string">&quot;, 参数</span></span><br><span class="line"><span class="string">b是 &quot;</span> + b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-方法体部分的精简"><a href="#2-2-2-方法体部分的精简" class="headerlink" title="2.2.2. 方法体部分的精简"></a>2.2.2. 方法体部分的精简</h3><h4 id="方法体大括号的精简"><a href="#方法体大括号的精简" class="headerlink" title="方法体大括号的精简"></a>方法体大括号的精简</h4><h4 id="当一个方法体中的逻辑，-有且只有一句的情况下，-大括号可以省略。"><a href="#当一个方法体中的逻辑，-有且只有一句的情况下，-大括号可以省略。" class="headerlink" title="当一个方法体中的逻辑， 有且只有一句的情况下， 大括号可以省略。"></a>当一个方法体中的逻辑， 有且只有一句的情况下， 大括号可以省略。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>的精简</span><br><span class="line">如果一个方法中唯一的一条语句是一个返回语句， 此时在省略掉大括号的同时， 也必须省略</span><br><span class="line">掉<span class="keyword">return</span>。</span><br></pre></td></tr></table></figure>

<h2 id="3-函数引用"><a href="#3-函数引用" class="headerlink" title="3. 函数引用"></a>3. 函数引用</h2><p><strong>函数引用：</strong> 引用一个已经存在的方法， 使其替代lambda表达式完成接口的实现。</p>
<p>lambda表达式是为了简化接口的实现的。 在lambda表达式中， 不应该出现比较复杂的逻辑。 如果在<br>lambda表达式中出现了过于复杂的逻辑， 会对程序的可读性造成非常大的影响。 如果在lambda表达<br>式中需要处理的逻辑比较复杂， 一般情况会单独的写一个方法。 在lambda表达式中直接引用这个方法<br>即可。或者， 在有些情况下， 我们需要在lambda表达式中实现的逻辑， 在另外一个地方已经写好了。<br>此时我们就不需要再单独写一遍， 只需要直接引用这个已经存在的方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个参、无返回值的方法实现</span></span><br><span class="line"><span class="type">NoneReturnSingleParameter</span> <span class="variable">lambda2</span> <span class="operator">=</span> a -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;一个参数、无返回值方法的实现: 参数是 &quot;</span> + a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 有多个参数、无返回值的方法实现</span></span><br><span class="line"><span class="type">NoneReturnSingleParameter</span> <span class="variable">lambda2</span> <span class="operator">=</span> a -&gt; System.out.println(<span class="string">&quot;一个参数、无返回值方法的实现: 参数是 &quot;</span> + a);</span><br><span class="line"><span class="type">SingleReturnMutipleParameter</span> <span class="variable">lambda3</span> <span class="operator">=</span> (a, b) -&gt; a + b; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-1-静态方法的引用"><a href="#3-1-静态方法的引用" class="headerlink" title="3.1. 静态方法的引用"></a>3.1. 静态方法的引用</h3><p>语法： 类::静态方法</p>
<p><strong>注意事项</strong>: <strong>在引用的方法后面，不要添加小括号。引用的这个方法,参数（数量、类型） 和 返回值，必须要跟接口中定义的一致。</strong></p>
<h3 id="3-2-非静态方法的引用"><a href="#3-2-非静态方法的引用" class="headerlink" title="3.2. 非静态方法的引用"></a>3.2. 非静态方法的引用</h3><p>语法：对象::非静态方法</p>
<p>注意事项:在引用的方法后面， 不要添加小括号。引用的这个方法， 参数（数量、类型） 和 返回值， 必须要跟接口中定义的一致。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Syntax1</span> &#123;</span><br><span class="line"> <span class="comment">// 静态方法的引用</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 实现一个多个参数的、一个返回值的接口</span></span><br><span class="line"> <span class="comment">// 对一个静态方法的引用</span></span><br><span class="line"> <span class="comment">// 类::静态方法</span></span><br><span class="line"> <span class="type">SingleReturnMutipleParameter</span> <span class="variable">lambda1</span> <span class="operator">=</span> Calculator::calculate;</span><br><span class="line"> System.out.println(lambda1.test(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"> <span class="comment">// 稍微复杂的逻辑：计算a和b的差值的绝对值</span></span><br><span class="line"> <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line"> <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Syntax2</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 对非静态方法的引用，需要使用对象来完成</span></span><br><span class="line"> <span class="type">SingleReturnMutipleParameter</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">Calculator</span>()::calculate;</span><br><span class="line"> System.out.println(lambda.test(<span class="number">10</span>, <span class="number">30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> private static class Calculator &#123;</span><br><span class="line"> public int calculate(int a, int b) &#123;</span><br><span class="line"> return a &gt; b? a - b : b - a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-构造方法的引用"><a href="#3-3-构造方法的引用" class="headerlink" title="3.3. 构造方法的引用"></a>3.3. 构造方法的引用</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p> 如果某一个函数式接口中定义的方法， 仅仅是为了得到一个类的对象。 此时我们就可以使用构造方法的引用， 简化这个方法的实现。</p>
<p>语法: 类名::new<br>注意事项:可以通过接口中的方法的参数,区分引用不同的构造方法。示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Syntax3</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> String name;</span><br><span class="line"> <span class="type">int</span> age;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;一个Person对象被实例化了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;一个Person对象被有参的实例化了&quot;</span>);</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@FunctionalInterface</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">interface</span> <span class="title class_">GetPerson</span> &#123;</span><br><span class="line"> <span class="comment">// 仅仅是希望获取到一个Person对象作为返回值</span></span><br><span class="line"> Person <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> private interface GetPersonWithParameter &#123;</span><br><span class="line"> Person test(String name, int age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// lambda表达式实现接口</span></span><br><span class="line"> <span class="type">GetPerson</span> <span class="variable">lambda</span> <span class="operator">=</span> Person::<span class="keyword">new</span>; <span class="comment">// 引用到Person类中的无参构造方</span></span><br><span class="line">法，获取到一个Person对象</span><br><span class="line"> <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> lambda.test();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">GetPersonWithParameter</span> <span class="variable">lambda2</span> <span class="operator">=</span> Person::<span class="keyword">new</span>;  <span class="comment">// 引用到Person类</span></span><br><span class="line">中的有参构造方法，获取到一个Person对象</span><br><span class="line"> lambda2.test(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-对象方法的特殊引用"><a href="#3-4-对象方法的特殊引用" class="headerlink" title="3.4. 对象方法的特殊引用"></a>3.4. 对象方法的特殊引用</h3><p>如果在使用lambda表达式，实现某些接口的时候。 lambda表达式中包含了某一个对象， 此时方法体<br>中， 直接使用这个对象调用它的某一个方法就可以完成整体的逻辑。 其他的参数， 可以作为调用方法<br>的参数。 此时， 可以对这种实现进行简化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Syntax</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 如果对于这个方法的实现逻辑，是为了获取到对象的名字</span></span><br><span class="line"> <span class="type">GetField</span> <span class="variable">field</span> <span class="operator">=</span> person -&gt; person.getName();</span><br><span class="line"> <span class="comment">// 对于对象方法的特殊引用</span></span><br><span class="line"> <span class="type">GetField</span> <span class="variable">field</span> <span class="operator">=</span> Person::getName;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果对于这个方法的实现逻辑，是为了给对象的某些属性进行赋值</span></span><br><span class="line"><span class="type">SetField</span> <span class="variable">lambda</span> <span class="operator">=</span> (person, name) -&gt; person.setName(name);</span><br><span class="line"><span class="type">SetField</span> <span class="variable">lambda</span> <span class="operator">=</span> Person::setName;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 如果对于这个方法的实现逻辑，正好是参数对象的某一个方法</span></span><br><span class="line"> <span class="type">ShowTest</span> <span class="variable">lambda2</span> <span class="operator">=</span> person -&gt; person.show();</span><br><span class="line"> <span class="type">ShowTest</span> <span class="variable">lambda2</span> <span class="operator">=</span> Person::show;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ShowTest</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SetField</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Person person, String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GetField</span> &#123;</span><br><span class="line"> String <span class="title function_">get</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-Lambda表达式需要注意的问题"><a href="#4-Lambda表达式需要注意的问题" class="headerlink" title="4. Lambda表达式需要注意的问题"></a>4. Lambda表达式需要注意的问题</h2><p>这里类似于局部内部类、匿名内部类，依然存在闭包的问题。<strong>如果在lambda表达式中，使用到了局部变量，那么这个局部变量会被隐式的声明为 final。 是一个常量， ==不能修改值。==</strong></p>
<h2 id="5-Lamb-da表达式的实例"><a href="#5-Lamb-da表达式的实例" class="headerlink" title="5. Lamb da表达式的实例"></a>5. Lamb da表达式的实例</h2><h3 id="5-1-线程的实例化"><a href="#5-1-线程的实例化" class="headerlink" title="5.1. 线程的实例化"></a>5.1. 线程的实例化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> <span class="comment">// run()方法体</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="5-2-集合的常见方法"><a href="#5-2-集合的常见方法" class="headerlink" title="5.2. 集合的常见方法"></a>5.2. 集合的常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="string">&quot;千锋&quot;</span>, <span class="string">&quot;大数据&quot;</span>, <span class="string">&quot;好程序员&quot;</span>, <span class="string">&quot;严选&quot;</span>, <span class="string">&quot;高薪&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="5-3-集合的流式编程"><a href="#5-3-集合的流式编程" class="headerlink" title="5.3. 集合的流式编程"></a>5.3. 集合的流式编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照条件进行删除</span></span><br><span class="line">list.removeIf(ele -&gt; ele.endsWith(<span class="string">&quot;.m&quot;</span>));</span><br><span class="line"><span class="comment">// 批量替换</span></span><br><span class="line">list.replaceAll(ele -&gt; ele.concat(<span class="string">&quot;!&quot;</span>));</span><br><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line">list.sort((e1, e2) -&gt; e2.compareTo(e1));</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="string">&quot;千锋&quot;</span>, <span class="string">&quot;大数据&quot;</span>, <span class="string">&quot;好程序员&quot;</span>, <span class="string">&quot;严选&quot;</span>, <span class="string">&quot;高薪&quot;</span>);</span><br></pre></td></tr></table></figure>





<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><h5 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络:"></a>计算机网络:</h5><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>
<h5 id="网络编程的目的"><a href="#网络编程的目的" class="headerlink" title="网络编程的目的:"></a>网络编程的目的:</h5><p>无线电台,传播交流信息,数据交换,通信</p>
<h5 id="需要做什么"><a href="#需要做什么" class="headerlink" title="需要做什么:"></a>需要做什么:</h5><ol>
<li>如何准确定位网络上的一台主机 192.168.16.124:端口</li>
<li>找到了这个主机,如何传传输数据<br>Java web: 网页编程 B/S<br>网络编程: TCP/IP C/S</li>
</ol>
<h3 id="1-2网络通信的要素"><a href="#1-2网络通信的要素" class="headerlink" title="1.2网络通信的要素"></a>1.2网络通信的要素</h3><h5 id="如何实现网络的通信"><a href="#如何实现网络的通信" class="headerlink" title="如何实现网络的通信?"></a>如何实现网络的通信?</h5><p>通信的地址:</p>
<ul>
<li>IP</li>
<li>端口</li>
</ul>
<h5 id="规则-网络通信的协议"><a href="#规则-网络通信的协议" class="headerlink" title="规则:网络通信的协议"></a>规则:网络通信的协议</h5><p>TCP/IP参考模型<br><img src="1628121629422875.png"></p>
<h6 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h6><ol>
<li>网络编程的有两个主要问题<ul>
<li>如何准确的定位网络上的一台或者多态计算机</li>
<li>找到主机后如何进行通信</li>
</ul>
</li>
<li>网络编程中的要素<ul>
<li>IP和端口号</li>
<li>网络通信协议:TCP UDP</li>
</ul>
</li>
</ol>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>ip地址:InteAddress</p>
<ul>
<li>唯一定位一台网络上的计算机</li>
<li>127.0.0.1 :本机localhost</li>
<li>ip地址的分类<ul>
<li>ipv4/ipv6<ul>
<li>**IPV4 **: 127.0.0.1,由4个字节组成,0-255</li>
<li><strong>IPV6:</strong> 2409:8a5c:4027:bd50:4168:a92e:8054:524b ,128位,8个16进制数的4位数整数</li>
</ul>
</li>
<li>公网(互联网)-私网(局域网)<br>如：192.168.xxx.xxx</li>
</ul>
</li>
<li>域名,为了方便记忆,实际上就是ip地址</li>
</ul>
<h2 id="端口-Prot"><a href="#端口-Prot" class="headerlink" title="端口(Prot)"></a>端口(Prot)</h2><p>端口表示计算机上的一个程序的进程</p>
<ul>
<li>不同的进程有不同的端口号!用来区分软件</li>
<li>端口被规定 0-65535</li>
<li><strong>单个协议下</strong>端口号不能冲突</li>
<li><strong>端口分类:</strong></li>
</ul>
<ul>
<li>公用端口 0-1024<ul>
<li>http:80</li>
<li>https:443</li>
<li>ftp: 21</li>
<li>Telent:23</li>
</ul>
</li>
<li>程序注册端口<ul>
<li>Tomcat: 8080</li>
<li>MySQL: 3306</li>
<li>Oracle : 1521</li>
</ul>
</li>
<li>动态,私有端口<br>查看所有端口  [cmd命令]<br>查看指定端口所被占用的进程id(PID) [cmd命令]</li>
</ul>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p><strong>网络通信协议:</strong> 速率,传输码率,代码结构,传输控制<br>问题: 太繁杂,于是有了分层的概念<br><strong>套接字Socket = 端口Prot + IP地址</strong><br>其中,IP地址用来标识网络上的唯一的一台计算机,而端口是用来唯一标识程序的进程</p>
<h3 id="TCP-IP协议-实际上是一组协议"><a href="#TCP-IP协议-实际上是一组协议" class="headerlink" title="TCP/IP协议:实际上是一组协议"></a>TCP/IP协议:实际上是一组协议</h3><p>两个重要的协议</p>
<ul>
<li>TCP:用户传输协议</li>
<li>UDP:用户输出报协议</li>
</ul>
<h4 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h4><h5 id="TCP-相当于打电话"><a href="#TCP-相当于打电话" class="headerlink" title="TCP:相当于打电话"></a>TCP:相当于打电话</h5><ul>
<li><p>链接,稳定</p>
</li>
<li><p>三次握手,四次挥手</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最少需要三次握手,保证稳定链接!</span><br><span class="line">A : 滴滴</span><br><span class="line">B : 在</span><br><span class="line">A : 在干嘛?</span><br><span class="line">四次挥手</span><br><span class="line">A : 我要断开了</span><br><span class="line">B : 我知道你要断开了</span><br><span class="line">B : 你确定要断开了嘛</span><br><span class="line">A : 我真的要断开!</span><br></pre></td></tr></table></figure></li>
<li><p>客户端,服务端</p>
</li>
<li><p>传输完成,释放链接,效率低</p>
</li>
</ul>
<h5 id="UDP-相当于发短息"><a href="#UDP-相当于发短息" class="headerlink" title="UDP:相当于发短息"></a>UDP:相当于发短息</h5><ul>
<li>不连接,不稳定</li>
<li>客户端,服务端:没有明确的界限</li>
<li>不管对方是否接受,都能发送</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>实现简单通信</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个程序端口服务</span></span><br><span class="line">            server = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">4444</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//创建一个接受server 服务的链接socket</span></span><br><span class="line">                socket = server.accept();</span><br><span class="line">                <span class="comment">// 建立服务链接的输入流</span></span><br><span class="line">                in = socket.getInputStream();</span><br><span class="line">                <span class="comment">//字节数组输出流</span></span><br><span class="line">                out = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                <span class="comment">//缓冲数组</span></span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="comment">//输入流的数据读取,即服务链接的数据,放入buffer中</span></span><br><span class="line">                <span class="keyword">while</span>((len = in.read(buffer))!=-<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//输出流写入buffer的数据</span></span><br><span class="line">                    out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//打印输出流中的数据</span></span><br><span class="line">                System.out.println(out.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">            in.close();</span><br><span class="line">            socket.close();</span><br><span class="line">            server.close();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//建立一个端口服务链接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4444</span>);</span><br><span class="line">             <span class="comment">//创建一个服务链接的输出流</span></span><br><span class="line">             out = socket.getOutputStream();</span><br><span class="line">             <span class="comment">//向服务链接中输出信息</span></span><br><span class="line">             out.write(<span class="string">&quot;你好,Tcp!&quot;</span>.getBytes());</span><br><span class="line">             <span class="comment">//关闭流</span></span><br><span class="line">            out.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>发短信,只需要知道地址,不需要建立链接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receive</span> &#123;  <span class="comment">//接收端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;     </span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"><span class="comment">//        DatagramSocket socket = new DatagramSocket(9090,ip);</span></span><br><span class="line">        <span class="comment">//注意:用于接收的套接字也不要加IP,有IP地址的是用于发送的</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//DatagramPacket packet = new DatagramPacket(buf, buf.length, InetAddress.getLocalHost(), 9090);</span></span><br><span class="line">        <span class="comment">//创建用于接收的数据包,注意! 不要端口和IP</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">        </span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;发送者的地址为:&quot;</span>+packet.getSocketAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;接受到的信息为:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">        </span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;  <span class="comment">//发送端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">//注意:发送端的套接字不要和接受端端口一致,否则会造成端口占用</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建用于用于发送的数据包,需要提供发送的地址和端口号    </span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="string">&quot;你好!udp&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf,buf.length,ip,<span class="number">9090</span>);</span><br><span class="line">        </span><br><span class="line">        socket.send(packet);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Luo Qianyou
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://lqy679.github.io/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/" title="JavaSE进阶">https://lqy679.github.io/2020/01/01/javaSE进阶/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/01/01/Spring/" rel="prev" title="Spring">
                  <i class="fa fa-chevron-left"></i> Spring
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/01/01/mysql/" rel="next" title="mysql">
                  mysql <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="" aria-label="选择语言">
      
        <option value="zh-CN" data-href="/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/2020/01/01/javaSE%E8%BF%9B%E9%98%B6/" selected="">
          English
        </option>
      
    </select>
  </div>


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luo Qianyou</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/LQY679" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





<!-- hexo injector body_end start -->
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script>
<meting-js server="tencent" type="playlist" id="8809238545" fixed="true"  autoplay="false" loop="all" order="list" list-folded="ture" list-max-height="500px" ><!-- hexo injector body_end end --></body>
</html>
